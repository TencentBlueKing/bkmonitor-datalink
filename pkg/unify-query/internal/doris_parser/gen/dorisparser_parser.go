// Code generated from DorisParser.g4 by ANTLR 4.13.2. DO NOT EDIT.

package gen // DorisParser
import (
	"fmt"
	"strconv"
	"sync"

	"github.com/antlr4-go/antlr/v4"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type DorisParserParser struct {
	*antlr.BaseParser
}

var DorisParserParserStaticData struct {
	once                   sync.Once
	serializedATN          []int32
	LiteralNames           []string
	SymbolicNames          []string
	RuleNames              []string
	PredictionContextCache *antlr.PredictionContextCache
	atn                    *antlr.ATN
	decisionToDFA          []*antlr.DFA
}

func dorisparserParserInit() {
	staticData := &DorisParserParserStaticData
	staticData.LiteralNames = []string{
		"", "';'", "'('", "')'", "','", "'.'", "'...'", "'['", "']'", "'{'",
		"'}'", "'ACCOUNT_LOCK'", "'ACCOUNT_UNLOCK'", "'ACTIONS'", "'ADD'", "'ADMIN'",
		"'AFTER'", "'AGG_STATE'", "'AGGREGATE'", "'ALIAS'", "'ALL'", "'ALTER'",
		"'ANALYZE'", "'ANALYZED'", "'ANALYZER'", "'AND'", "'ANTI'", "'APPEND'",
		"'ARRAY'", "'AS'", "'ASC'", "'AT'", "'AUTHORS'", "'AUTO'", "'AUTO_INCREMENT'",
		"'ALWAYS'", "'BACKEND'", "'BACKENDS'", "'BACKUP'", "'BEGIN'", "'BELONG'",
		"'BETWEEN'", "'BIGINT'", "'BIN'", "'BINARY'", "'BINLOG'", "'BITAND'",
		"'BITMAP'", "'BITMAP_EMPTY'", "'BITMAP_UNION'", "'BITOR'", "'BITXOR'",
		"'BLOB'", "'BOOLEAN'", "'BRANCH'", "'BRIEF'", "'BROKER'", "'BUCKETS'",
		"'BUILD'", "'BUILTIN'", "'BULK'", "'BY'", "'CACHE'", "'CACHED'", "'CALL'",
		"'CANCEL'", "'CASE'", "'CAST'", "'CATALOG'", "'CATALOGS'", "'CHAIN'",
		"", "'CHARSET'", "'CHECK'", "'CLEAN'", "'CLUSTER'", "'CLUSTERS'", "'COLLATE'",
		"'COLLATION'", "'COLLECT'", "'COLOCATE'", "'COLUMN'", "'COLUMNS'", "'COMMENT'",
		"'COMMIT'", "'COMMITTED'", "'COMPACT'", "'COMPLETE'", "'COMPRESS_TYPE'",
		"'COMPUTE'", "'CONDITIONS'", "'CONFIG'", "'CONNECTION'", "'CONNECTION_ID'",
		"'CONSISTENT'", "'CONSTRAINT'", "'CONSTRAINTS'", "'CONVERT'", "'CONVERT_LIGHT_SCHEMA_CHANGE_PROCESS'",
		"'COPY'", "'COUNT'", "'CREATE'", "'CREATION'", "'CRON'", "'CROSS'",
		"'CUBE'", "'CURRENT'", "'CURRENT_CATALOG'", "'CURRENT_DATE'", "'CURRENT_TIME'",
		"'CURRENT_TIMESTAMP'", "'CURRENT_USER'", "'DATA'", "'DATABASE'", "'DATABASES'",
		"'DATE'", "'DATETIME'", "'DATETIMEV2'", "'DATEV2'", "'DATETIMEV1'",
		"'DATEV1'", "'DAY'", "'DAYS'", "'DECIMAL'", "'DECIMALV2'", "'DECIMALV3'",
		"'DECOMMISSION'", "'DEFAULT'", "'DEFERRED'", "'DELETE'", "'DEMAND'",
		"'DESC'", "'DESCRIBE'", "'DIAGNOSE'", "'DIAGNOSIS'", "'DICTIONARIES'",
		"'DICTIONARY'", "'DISK'", "'DISTINCT'", "'DISTINCTPC'", "'DISTINCTPCSA'",
		"'DISTRIBUTED'", "'DISTRIBUTION'", "'DIV'", "'DO'", "'DORIS_INTERNAL_TABLE_ID'",
		"'DOUBLE'", "'DROP'", "'DROPP'", "'DUAL'", "'DUMP'", "'DUPLICATE'",
		"'DYNAMIC'", "'E'", "'ELSE'", "'ENABLE'", "'ENCRYPTKEY'", "'ENCRYPTKEYS'",
		"'END'", "'ENDS'", "'ENGINE'", "'ENGINES'", "'ENTER'", "'ERRORS'", "'ESCAPE'",
		"'EVENTS'", "'EVERY'", "'EXCEPT'", "'EXCLUDE'", "'EXECUTE'", "'EXISTS'",
		"'EXPIRED'", "'EXPLAIN'", "'EXPORT'", "'EXTENDED'", "'EXTERNAL'", "'EXTRACT'",
		"'FAILED_LOGIN_ATTEMPTS'", "'FALSE'", "'FAST'", "'FEATURE'", "'FIELDS'",
		"'FILE'", "'FILTER'", "'FIRST'", "'FLOAT'", "'FOLLOWER'", "'FOLLOWING'",
		"'FOR'", "'FOREIGN'", "'FORCE'", "'FORMAT'", "'FREE'", "'FROM'", "'FRONTEND'",
		"'FRONTENDS'", "'FULL'", "'FUNCTION'", "'FUNCTIONS'", "'GENERATED'",
		"'GENERIC'", "'GLOBAL'", "'GRANT'", "'GRANTS'", "'GRAPH'", "'GROUP'",
		"'GROUPING'", "'GROUPS'", "'HASH'", "'HASH_MAP'", "'HAVING'", "'HDFS'",
		"'HELP'", "'HISTOGRAM'", "'HLL'", "'HLL_UNION'", "'HOSTNAME'", "'HOTSPOT'",
		"'HOUR'", "'HOURS'", "'HUB'", "'IDENTIFIED'", "'IF'", "'IGNORE'", "'IMMEDIATE'",
		"'IN'", "'INCREMENTAL'", "'INDEX'", "'INDEXES'", "'INFILE'", "'INNER'",
		"'INSERT'", "'INSTALL'", "'INT'", "'INTEGER'", "'INTERMEDIATE'", "'INTERSECT'",
		"'INTERVAL'", "'INTO'", "'INVERTED'", "'IP_TRIE'", "'IPV4'", "'IPV6'",
		"'IS'", "'IS_NOT_NULL_PRED'", "'IS_NULL_PRED'", "'ISNULL'", "'ISOLATION'",
		"'JOB'", "'JOBS'", "'JOIN'", "'JSON'", "'JSONB'", "'KEY'", "'KEYS'",
		"'KILL'", "'LABEL'", "'LARGEINT'", "'LAYOUT'", "'LAST'", "'LATERAL'",
		"'LDAP'", "'LDAP_ADMIN_PASSWORD'", "'LEFT'", "'LESS'", "'LEVEL'", "'LIKE'",
		"'LIMIT'", "'LINES'", "'LINK'", "'LIST'", "'LOAD'", "'LOCAL'", "'LOCALTIME'",
		"'LOCALTIMESTAMP'", "'LOCATION'", "'LOCK'", "'LOGICAL'", "'LOW_PRIORITY'",
		"'MANUAL'", "'MAP'", "'MATCH'", "'MATCH_ALL'", "'MATCH_ANY'", "'MATCH_PHRASE'",
		"'MATCH_PHRASE_EDGE'", "'MATCH_PHRASE_PREFIX'", "'MATCH_REGEXP'", "'MATERIALIZED'",
		"'MAX'", "'MAXVALUE'", "'MEMO'", "'MERGE'", "'MIGRATE'", "'MIGRATIONS'",
		"'MIN'", "'MINUS'", "'MINUTE'", "'MINUTES'", "'MODIFY'", "'MONTH'",
		"'MTMV'", "'NAME'", "'NAMES'", "'NATURAL'", "'NEGATIVE'", "'NEVER'",
		"'NEXT'", "'NGRAM_BF'", "'NO'", "'NO_USE_MV'", "'NON_NULLABLE'", "'NOT'",
		"'NULL'", "'NULLS'", "'OBSERVER'", "'OF'", "'OFFSET'", "'ON'", "'ONLY'",
		"'OPEN'", "'OPTIMIZED'", "'OR'", "'ORDER'", "'OUTER'", "'OUTFILE'",
		"'OVER'", "'OVERWRITE'", "'PARAMETER'", "'PARSED'", "'PARTITION'", "'PARTITIONS'",
		"'PASSWORD'", "'PASSWORD_EXPIRE'", "'PASSWORD_HISTORY'", "'PASSWORD_LOCK_TIME'",
		"'PASSWORD_REUSE'", "'PATH'", "'PAUSE'", "'PERCENT'", "'PERIOD'", "'PERMISSIVE'",
		"'PHYSICAL'", "'PI'", "'?'", "'PLAN'", "'PLAY'", "'PRIVILEGES'", "'PROCESS'",
		"'PLUGIN'", "'PLUGINS'", "'POLICY'", "'PRECEDING'", "'PREPARE'", "'PRIMARY'",
		"'PROC'", "'PROCEDURE'", "'PROCESSLIST'", "'PROFILE'", "'PROPERTIES'",
		"'PROPERTY'", "'QUANTILE_STATE'", "'QUANTILE_UNION'", "'QUERY'", "'QUEUED'",
		"'QUOTA'", "'QUALIFY'", "'QUARTER'", "'RANDOM'", "'RANGE'", "'READ'",
		"'REAL'", "'REBALANCE'", "'RECENT'", "'RECOVER'", "'RECYCLE'", "'REFRESH'",
		"'REFERENCES'", "'REGEXP'", "'RELEASE'", "'RENAME'", "'REPAIR'", "'REPEATABLE'",
		"'REPLACE'", "'REPLACE_IF_NOT_NULL'", "'REPLAYER'", "'REPLICA'", "'REPOSITORIES'",
		"'REPOSITORY'", "'RESOURCE'", "'RESOURCES'", "'RESTORE'", "'RESTRICTIVE'",
		"'RESUME'", "'RETAIN'", "'RETENTION'", "'RETURNS'", "'REVOKE'", "'REWRITTEN'",
		"'RIGHT'", "'RLIKE'", "'ROLE'", "'ROLES'", "'ROLLBACK'", "'ROLLUP'",
		"'ROUTINE'", "'ROW'", "'ROWS'", "'S3'", "'SAMPLE'", "'SCHEDULE'", "'SCHEDULER'",
		"'SCHEMA'", "'SCHEMAS'", "'SECOND'", "'SELECT'", "'SEMI'", "'SERIALIZABLE'",
		"'SESSION'", "'SESSION_USER'", "'SET'", "'SETS'", "'SET_SESSION_VARIABLE'",
		"'SHAPE'", "'SHOW'", "'SIGNED'", "'SKEW'", "'SMALLINT'", "'SNAPSHOT'",
		"'SNAPSHOTS'", "'SONAME'", "'SPLIT'", "'SQL'", "'SQL_BLOCK_RULE'", "'STAGE'",
		"'STAGES'", "'START'", "'STARTS'", "'STATS'", "'STATUS'", "'STOP'",
		"'STORAGE'", "'STREAM'", "'STREAMING'", "'STRING'", "'STRUCT'", "'SUM'",
		"'SUPERUSER'", "'SWITCH'", "'SYNC'", "'SYSTEM'", "'TABLE'", "'TABLES'",
		"'TABLESAMPLE'", "'TABLET'", "'TABLETS'", "'TAG'", "'TASK'", "'TASKS'",
		"'TEMPORARY'", "'TERMINATED'", "'TEXT'", "'THAN'", "'THEN'", "'TIME'",
		"'TIMESTAMP'", "'TINYINT'", "'TO'", "'TOKENIZER'", "'TOKEN_FILTER'",
		"'TRANSACTION'", "'TRASH'", "'TREE'", "'TRIGGERS'", "'TRIM'", "'TRUE'",
		"'TRUNCATE'", "'TYPE'", "'TYPE_CAST'", "'TYPES'", "'UNBOUNDED'", "'UNCOMMITTED'",
		"'UNINSTALL'", "'UNION'", "'UNIQUE'", "'UNLOCK'", "'UNSET'", "'UNSIGNED'",
		"'UP'", "'UPDATE'", "'USE'", "'USER'", "'USE_MV'", "'USING'", "'VALUE'",
		"'VALUES'", "'VARCHAR'", "'VARIABLE'", "'VARIABLES'", "'VARIANT'", "'VAULT'",
		"'VAULTS'", "'VERBOSE'", "'VERSION'", "'VIEW'", "'VIEWS'", "'WARM'",
		"'WARNINGS'", "'WEEK'", "'WHEN'", "'WHERE'", "'WHITELIST'", "'WITH'",
		"'WORK'", "'WORKLOAD'", "'WRITE'", "'XOR'", "'YEAR'", "", "'<=>'", "",
		"'<'", "", "'>'", "", "'+'", "'-'", "'*'", "'/'", "'%'", "'~'", "'&'",
		"'&&'", "'!'", "'|'", "'||'", "'^'", "':'", "'->'", "'/*+'", "'*/'",
		"'/*'", "'@'", "'@@'",
	}
	staticData.SymbolicNames = []string{
		"", "SEMICOLON", "LEFT_PAREN", "RIGHT_PAREN", "COMMA", "DOT", "DOTDOTDOT",
		"LEFT_BRACKET", "RIGHT_BRACKET", "LEFT_BRACE", "RIGHT_BRACE", "ACCOUNT_LOCK",
		"ACCOUNT_UNLOCK", "ACTIONS", "ADD", "ADMIN", "AFTER", "AGG_STATE", "AGGREGATE",
		"ALIAS", "ALL", "ALTER", "ANALYZE", "ANALYZED", "ANALYZER", "AND", "ANTI",
		"APPEND", "ARRAY", "AS", "ASC", "AT", "AUTHORS", "AUTO", "AUTO_INCREMENT",
		"ALWAYS", "BACKEND", "BACKENDS", "BACKUP", "BEGIN", "BELONG", "BETWEEN",
		"BIGINT", "BIN", "BINARY", "BINLOG", "BITAND", "BITMAP", "BITMAP_EMPTY",
		"BITMAP_UNION", "BITOR", "BITXOR", "BLOB", "BOOLEAN", "BRANCH", "BRIEF",
		"BROKER", "BUCKETS", "BUILD", "BUILTIN", "BULK", "BY", "CACHE", "CACHED",
		"CALL", "CANCEL", "CASE", "CAST", "CATALOG", "CATALOGS", "CHAIN", "CHAR",
		"CHARSET", "CHECK", "CLEAN", "CLUSTER", "CLUSTERS", "COLLATE", "COLLATION",
		"COLLECT", "COLOCATE", "COLUMN", "COLUMNS", "COMMENT", "COMMIT", "COMMITTED",
		"COMPACT", "COMPLETE", "COMPRESS_TYPE", "COMPUTE", "CONDITIONS", "CONFIG",
		"CONNECTION", "CONNECTION_ID", "CONSISTENT", "CONSTRAINT", "CONSTRAINTS",
		"CONVERT", "CONVERT_LSC", "COPY", "COUNT", "CREATE", "CREATION", "CRON",
		"CROSS", "CUBE", "CURRENT", "CURRENT_CATALOG", "CURRENT_DATE", "CURRENT_TIME",
		"CURRENT_TIMESTAMP", "CURRENT_USER", "DATA", "DATABASE", "DATABASES",
		"DATE", "DATETIME", "DATETIMEV2", "DATEV2", "DATETIMEV1", "DATEV1",
		"DAY", "DAYS", "DECIMAL", "DECIMALV2", "DECIMALV3", "DECOMMISSION",
		"DEFAULT", "DEFERRED", "DELETE", "DEMAND", "DESC", "DESCRIBE", "DIAGNOSE",
		"DIAGNOSIS", "DICTIONARIES", "DICTIONARY", "DISK", "DISTINCT", "DISTINCTPC",
		"DISTINCTPCSA", "DISTRIBUTED", "DISTRIBUTION", "DIV", "DO", "DORIS_INTERNAL_TABLE_ID",
		"DOUBLE", "DROP", "DROPP", "DUAL", "DUMP", "DUPLICATE", "DYNAMIC", "E",
		"ELSE", "ENABLE", "ENCRYPTKEY", "ENCRYPTKEYS", "END", "ENDS", "ENGINE",
		"ENGINES", "ENTER", "ERRORS", "ESCAPE", "EVENTS", "EVERY", "EXCEPT",
		"EXCLUDE", "EXECUTE", "EXISTS", "EXPIRED", "EXPLAIN", "EXPORT", "EXTENDED",
		"EXTERNAL", "EXTRACT", "FAILED_LOGIN_ATTEMPTS", "FALSE", "FAST", "FEATURE",
		"FIELDS", "FILE", "FILTER", "FIRST", "FLOAT", "FOLLOWER", "FOLLOWING",
		"FOR", "FOREIGN", "FORCE", "FORMAT", "FREE", "FROM", "FRONTEND", "FRONTENDS",
		"FULL", "FUNCTION", "FUNCTIONS", "GENERATED", "GENERIC", "GLOBAL", "GRANT",
		"GRANTS", "GRAPH", "GROUP", "GROUPING", "GROUPS", "HASH", "HASH_MAP",
		"HAVING", "HDFS", "HELP", "HISTOGRAM", "HLL", "HLL_UNION", "HOSTNAME",
		"HOTSPOT", "HOUR", "HOURS", "HUB", "IDENTIFIED", "IF", "IGNORE", "IMMEDIATE",
		"IN", "INCREMENTAL", "INDEX", "INDEXES", "INFILE", "INNER", "INSERT",
		"INSTALL", "INT", "INTEGER", "INTERMEDIATE", "INTERSECT", "INTERVAL",
		"INTO", "INVERTED", "IP_TRIE", "IPV4", "IPV6", "IS", "IS_NOT_NULL_PRED",
		"IS_NULL_PRED", "ISNULL", "ISOLATION", "JOB", "JOBS", "JOIN", "JSON",
		"JSONB", "KEY", "KEYS", "KILL", "LABEL", "LARGEINT", "LAYOUT", "LAST",
		"LATERAL", "LDAP", "LDAP_ADMIN_PASSWORD", "LEFT", "LESS", "LEVEL", "LIKE",
		"LIMIT", "LINES", "LINK", "LIST", "LOAD", "LOCAL", "LOCALTIME", "LOCALTIMESTAMP",
		"LOCATION", "LOCK", "LOGICAL", "LOW_PRIORITY", "MANUAL", "MAP", "MATCH",
		"MATCH_ALL", "MATCH_ANY", "MATCH_PHRASE", "MATCH_PHRASE_EDGE", "MATCH_PHRASE_PREFIX",
		"MATCH_REGEXP", "MATERIALIZED", "MAX", "MAXVALUE", "MEMO", "MERGE",
		"MIGRATE", "MIGRATIONS", "MIN", "MINUS", "MINUTE", "MINUTES", "MODIFY",
		"MONTH", "MTMV", "NAME", "NAMES", "NATURAL", "NEGATIVE", "NEVER", "NEXT",
		"NGRAM_BF", "NO", "NO_USE_MV", "NON_NULLABLE", "NOT", "NULL", "NULLS",
		"OBSERVER", "OF", "OFFSET", "ON", "ONLY", "OPEN", "OPTIMIZED", "OR",
		"ORDER", "OUTER", "OUTFILE", "OVER", "OVERWRITE", "PARAMETER", "PARSED",
		"PARTITION", "PARTITIONS", "PASSWORD", "PASSWORD_EXPIRE", "PASSWORD_HISTORY",
		"PASSWORD_LOCK_TIME", "PASSWORD_REUSE", "PATH", "PAUSE", "PERCENT",
		"PERIOD", "PERMISSIVE", "PHYSICAL", "PI", "PLACEHOLDER", "PLAN", "PLAY",
		"PRIVILEGES", "PROCESS", "PLUGIN", "PLUGINS", "POLICY", "PRECEDING",
		"PREPARE", "PRIMARY", "PROC", "PROCEDURE", "PROCESSLIST", "PROFILE",
		"PROPERTIES", "PROPERTY", "QUANTILE_STATE", "QUANTILE_UNION", "QUERY",
		"QUEUED", "QUOTA", "QUALIFY", "QUARTER", "RANDOM", "RANGE", "READ",
		"REAL", "REBALANCE", "RECENT", "RECOVER", "RECYCLE", "REFRESH", "REFERENCES",
		"REGEXP", "RELEASE", "RENAME", "REPAIR", "REPEATABLE", "REPLACE", "REPLACE_IF_NOT_NULL",
		"REPLAYER", "REPLICA", "REPOSITORIES", "REPOSITORY", "RESOURCE", "RESOURCES",
		"RESTORE", "RESTRICTIVE", "RESUME", "RETAIN", "RETENTION", "RETURNS",
		"REVOKE", "REWRITTEN", "RIGHT", "RLIKE", "ROLE", "ROLES", "ROLLBACK",
		"ROLLUP", "ROUTINE", "ROW", "ROWS", "S3", "SAMPLE", "SCHEDULE", "SCHEDULER",
		"SCHEMA", "SCHEMAS", "SECOND", "SELECT", "SEMI", "SERIALIZABLE", "SESSION",
		"SESSION_USER", "SET", "SETS", "SET_SESSION_VARIABLE", "SHAPE", "SHOW",
		"SIGNED", "SKEW", "SMALLINT", "SNAPSHOT", "SNAPSHOTS", "SONAME", "SPLIT",
		"SQL", "SQL_BLOCK_RULE", "STAGE", "STAGES", "START", "STARTS", "STATS",
		"STATUS", "STOP", "STORAGE", "STREAM", "STREAMING", "STRING", "STRUCT",
		"SUM", "SUPERUSER", "SWITCH", "SYNC", "SYSTEM", "TABLE", "TABLES", "TABLESAMPLE",
		"TABLET", "TABLETS", "TAG", "TASK", "TASKS", "TEMPORARY", "TERMINATED",
		"TEXT", "THAN", "THEN", "TIME", "TIMESTAMP", "TINYINT", "TO", "TOKENIZER",
		"TOKEN_FILTER", "TRANSACTION", "TRASH", "TREE", "TRIGGERS", "TRIM",
		"TRUE", "TRUNCATE", "TYPE", "TYPECAST", "TYPES", "UNBOUNDED", "UNCOMMITTED",
		"UNINSTALL", "UNION", "UNIQUE", "UNLOCK", "UNSET", "UNSIGNED", "UP",
		"UPDATE", "USE", "USER", "USE_MV", "USING", "VALUE", "VALUES", "VARCHAR",
		"VARIABLE", "VARIABLES", "VARIANT", "VAULT", "VAULTS", "VERBOSE", "VERSION",
		"VIEW", "VIEWS", "WARM", "WARNINGS", "WEEK", "WHEN", "WHERE", "WHITELIST",
		"WITH", "WORK", "WORKLOAD", "WRITE", "XOR", "YEAR", "EQ", "NSEQ", "NEQ",
		"LT", "LTE", "GT", "GTE", "PLUS", "SUBTRACT", "ASTERISK", "SLASH", "MOD",
		"TILDE", "AMPERSAND", "LOGICALAND", "LOGICALNOT", "PIPE", "DOUBLEPIPES",
		"HAT", "COLON", "ARROW", "HINT_START", "HINT_END", "COMMENT_START",
		"ATSIGN", "DOUBLEATSIGN", "STRING_LITERAL", "LEADING_STRING", "BIGINT_LITERAL",
		"SMALLINT_LITERAL", "TINYINT_LITERAL", "INTEGER_VALUE", "EXPONENT_VALUE",
		"DECIMAL_VALUE", "BIGDECIMAL_LITERAL", "IDENTIFIER", "BACKQUOTED_IDENTIFIER",
		"SIMPLE_COMMENT", "BRACKETED_COMMENT", "FROM_DUAL", "WS", "UNRECOGNIZED",
	}
	staticData.RuleNames = []string{
		"multiStatements", "singleStatement", "statement", "statementBase",
		"unsupportedStatement", "materializedViewStatement", "supportedJobStatement",
		"constraintStatement", "supportedDmlStatement", "supportedCreateStatement",
		"dictionaryColumnDefs", "dictionaryColumnDef", "supportedAlterStatement",
		"supportedDropStatement", "supportedShowStatement", "supportedLoadStatement",
		"supportedKillStatement", "supportedOtherStatement", "unsupportedOtherStatement",
		"warmUpItem", "lockTable", "createRoutineLoad", "unsupportedLoadStatement",
		"loadProperty", "importSequenceStatement", "importDeleteOnStatement",
		"importWhereStatement", "importPrecedingFilterStatement", "importColumnsStatement",
		"importColumnDesc", "supportedRefreshStatement", "supportedCleanStatement",
		"supportedCancelStatement", "supportedAdminStatement", "supportedRecoverStatement",
		"unsupportedAdminStatement", "baseTableRef", "wildWhere", "supportedTransactionStatement",
		"supportedGrantRevokeStatement", "privilege", "privilegeList", "alterSystemClause",
		"dropRollupClause", "addRollupClause", "alterTableClause", "createOrReplaceTagClause",
		"createOrReplaceBranchClause", "tagOptions", "branchOptions", "retainTime",
		"retentionSnapshot", "minSnapshotsToKeep", "timeValueWithUnit", "dropBranchClause",
		"dropTagClause", "columnPosition", "toRollup", "fromRollup", "supportedStatsStatement",
		"unsupportedStatsStatement", "analyzeProperties", "workloadPolicyActions",
		"workloadPolicyAction", "workloadPolicyConditions", "workloadPolicyCondition",
		"storageBackend", "passwordOption", "functionArguments", "dataTypeList",
		"supportedSetStatement", "optionWithType", "optionWithoutType", "variable",
		"transactionAccessMode", "isolationLevel", "supportedUnsetStatement",
		"supportedUseStatement", "stageAndPattern", "supportedDescribeStatement",
		"constraint", "partitionSpec", "partitionTable", "identityOrFunctionList",
		"identityOrFunction", "dataDesc", "statementScope", "buildMode", "refreshTrigger",
		"refreshSchedule", "refreshMethod", "mvPartition", "identifierOrText",
		"identifierOrTextOrAsterisk", "multipartIdentifierOrAsterisk", "identifierOrAsterisk",
		"userIdentify", "grantUserIdentify", "explain", "explainCommand", "planType",
		"replayCommand", "replayType", "mergeType", "preFilterClause", "deleteOnClause",
		"sequenceColClause", "colFromPath", "colMappingList", "mappingExpr",
		"withRemoteStorageSystem", "resourceDesc", "mysqlDataDesc", "skipLines",
		"outFileClause", "query", "queryTerm", "setQuantifier", "queryPrimary",
		"querySpecification", "cte", "aliasQuery", "columnAliases", "selectClause",
		"selectColumnClause", "whereClause", "fromClause", "intoClause", "bulkCollectClause",
		"tableRow", "relations", "relation", "joinRelation", "distributeType",
		"relationHint", "aggClause", "groupingElement", "groupingSet", "havingClause",
		"qualifyClause", "selectHint", "hintStatement", "hintAssignment", "updateAssignment",
		"updateAssignmentSeq", "lateralView", "queryOrganization", "sortClause",
		"sortItem", "limitClause", "partitionClause", "joinType", "joinCriteria",
		"identifierList", "identifierSeq", "optScanParams", "relationPrimary",
		"materializedViewName", "propertyClause", "propertyItemList", "propertyItem",
		"propertyKey", "propertyValue", "tableAlias", "multipartIdentifier",
		"simpleColumnDefs", "simpleColumnDef", "columnDefs", "columnDef", "indexDefs",
		"indexDef", "partitionsDef", "partitionDef", "lessThanPartitionDef",
		"fixedPartitionDef", "stepPartitionDef", "inPartitionDef", "partitionValueList",
		"partitionValueDef", "rollupDefs", "rollupDef", "aggTypeDef", "tabletList",
		"inlineTable", "namedExpression", "namedExpressionSeq", "expression",
		"lambdaExpression", "booleanExpression", "rowConstructor", "rowConstructorItem",
		"predicate", "valueExpression", "primaryExpression", "exceptOrReplace",
		"castDataType", "functionCallExpression", "functionIdentifier", "functionNameIdentifier",
		"windowSpec", "windowFrame", "frameUnits", "frameBoundary", "qualifiedName",
		"specifiedPartition", "constant", "comparisonOperator", "booleanValue",
		"whenClause", "interval", "unitIdentifier", "dataTypeWithNullable",
		"dataType", "primitiveColType", "complexColTypeList", "complexColType",
		"commentSpec", "sample", "sampleMethod", "tableSnapshot", "errorCapturingIdentifier",
		"errorCapturingIdentifierExtra", "identifier", "strictIdentifier", "quotedIdentifier",
		"number", "nonReserved",
	}
	staticData.PredictionContextCache = antlr.NewPredictionContextCache()
	staticData.serializedATN = []int32{
		4, 1, 559, 6318, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4,
		7, 4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10,
		7, 10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7,
		15, 2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20,
		2, 21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2,
		26, 7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31,
		7, 31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7,
		36, 2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41,
		2, 42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2,
		47, 7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52,
		7, 52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7,
		57, 2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 2, 61, 7, 61, 2, 62, 7, 62,
		2, 63, 7, 63, 2, 64, 7, 64, 2, 65, 7, 65, 2, 66, 7, 66, 2, 67, 7, 67, 2,
		68, 7, 68, 2, 69, 7, 69, 2, 70, 7, 70, 2, 71, 7, 71, 2, 72, 7, 72, 2, 73,
		7, 73, 2, 74, 7, 74, 2, 75, 7, 75, 2, 76, 7, 76, 2, 77, 7, 77, 2, 78, 7,
		78, 2, 79, 7, 79, 2, 80, 7, 80, 2, 81, 7, 81, 2, 82, 7, 82, 2, 83, 7, 83,
		2, 84, 7, 84, 2, 85, 7, 85, 2, 86, 7, 86, 2, 87, 7, 87, 2, 88, 7, 88, 2,
		89, 7, 89, 2, 90, 7, 90, 2, 91, 7, 91, 2, 92, 7, 92, 2, 93, 7, 93, 2, 94,
		7, 94, 2, 95, 7, 95, 2, 96, 7, 96, 2, 97, 7, 97, 2, 98, 7, 98, 2, 99, 7,
		99, 2, 100, 7, 100, 2, 101, 7, 101, 2, 102, 7, 102, 2, 103, 7, 103, 2,
		104, 7, 104, 2, 105, 7, 105, 2, 106, 7, 106, 2, 107, 7, 107, 2, 108, 7,
		108, 2, 109, 7, 109, 2, 110, 7, 110, 2, 111, 7, 111, 2, 112, 7, 112, 2,
		113, 7, 113, 2, 114, 7, 114, 2, 115, 7, 115, 2, 116, 7, 116, 2, 117, 7,
		117, 2, 118, 7, 118, 2, 119, 7, 119, 2, 120, 7, 120, 2, 121, 7, 121, 2,
		122, 7, 122, 2, 123, 7, 123, 2, 124, 7, 124, 2, 125, 7, 125, 2, 126, 7,
		126, 2, 127, 7, 127, 2, 128, 7, 128, 2, 129, 7, 129, 2, 130, 7, 130, 2,
		131, 7, 131, 2, 132, 7, 132, 2, 133, 7, 133, 2, 134, 7, 134, 2, 135, 7,
		135, 2, 136, 7, 136, 2, 137, 7, 137, 2, 138, 7, 138, 2, 139, 7, 139, 2,
		140, 7, 140, 2, 141, 7, 141, 2, 142, 7, 142, 2, 143, 7, 143, 2, 144, 7,
		144, 2, 145, 7, 145, 2, 146, 7, 146, 2, 147, 7, 147, 2, 148, 7, 148, 2,
		149, 7, 149, 2, 150, 7, 150, 2, 151, 7, 151, 2, 152, 7, 152, 2, 153, 7,
		153, 2, 154, 7, 154, 2, 155, 7, 155, 2, 156, 7, 156, 2, 157, 7, 157, 2,
		158, 7, 158, 2, 159, 7, 159, 2, 160, 7, 160, 2, 161, 7, 161, 2, 162, 7,
		162, 2, 163, 7, 163, 2, 164, 7, 164, 2, 165, 7, 165, 2, 166, 7, 166, 2,
		167, 7, 167, 2, 168, 7, 168, 2, 169, 7, 169, 2, 170, 7, 170, 2, 171, 7,
		171, 2, 172, 7, 172, 2, 173, 7, 173, 2, 174, 7, 174, 2, 175, 7, 175, 2,
		176, 7, 176, 2, 177, 7, 177, 2, 178, 7, 178, 2, 179, 7, 179, 2, 180, 7,
		180, 2, 181, 7, 181, 2, 182, 7, 182, 2, 183, 7, 183, 2, 184, 7, 184, 2,
		185, 7, 185, 2, 186, 7, 186, 2, 187, 7, 187, 2, 188, 7, 188, 2, 189, 7,
		189, 2, 190, 7, 190, 2, 191, 7, 191, 2, 192, 7, 192, 2, 193, 7, 193, 2,
		194, 7, 194, 2, 195, 7, 195, 2, 196, 7, 196, 2, 197, 7, 197, 2, 198, 7,
		198, 2, 199, 7, 199, 2, 200, 7, 200, 2, 201, 7, 201, 2, 202, 7, 202, 2,
		203, 7, 203, 2, 204, 7, 204, 2, 205, 7, 205, 2, 206, 7, 206, 2, 207, 7,
		207, 2, 208, 7, 208, 2, 209, 7, 209, 2, 210, 7, 210, 2, 211, 7, 211, 2,
		212, 7, 212, 2, 213, 7, 213, 2, 214, 7, 214, 2, 215, 7, 215, 2, 216, 7,
		216, 2, 217, 7, 217, 2, 218, 7, 218, 2, 219, 7, 219, 2, 220, 7, 220, 2,
		221, 7, 221, 2, 222, 7, 222, 2, 223, 7, 223, 2, 224, 7, 224, 2, 225, 7,
		225, 2, 226, 7, 226, 1, 0, 5, 0, 456, 8, 0, 10, 0, 12, 0, 459, 9, 0, 1,
		0, 3, 0, 462, 8, 0, 1, 0, 4, 0, 465, 8, 0, 11, 0, 12, 0, 466, 1, 0, 5,
		0, 470, 8, 0, 10, 0, 12, 0, 473, 9, 0, 1, 0, 5, 0, 476, 8, 0, 10, 0, 12,
		0, 479, 9, 0, 1, 0, 1, 0, 1, 1, 5, 1, 484, 8, 1, 10, 1, 12, 1, 487, 9,
		1, 1, 1, 3, 1, 490, 8, 1, 1, 1, 5, 1, 493, 8, 1, 10, 1, 12, 1, 496, 9,
		1, 1, 1, 1, 1, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 5, 2, 507, 8,
		2, 10, 2, 12, 2, 510, 9, 2, 3, 2, 512, 8, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1,
		2, 1, 2, 3, 2, 520, 8, 2, 1, 2, 3, 2, 523, 8, 2, 1, 2, 1, 2, 1, 2, 1, 2,
		5, 2, 529, 8, 2, 10, 2, 12, 2, 532, 9, 2, 1, 2, 1, 2, 5, 2, 536, 8, 2,
		10, 2, 12, 2, 539, 9, 2, 1, 2, 1, 2, 1, 2, 1, 2, 3, 2, 545, 8, 2, 1, 2,
		1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 3, 2, 554, 8, 2, 1, 2, 1, 2, 1, 2,
		1, 2, 1, 2, 3, 2, 561, 8, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 3, 2, 568, 8,
		2, 1, 2, 1, 2, 3, 2, 572, 8, 2, 3, 2, 574, 8, 2, 1, 3, 3, 3, 577, 8, 3,
		1, 3, 1, 3, 3, 3, 581, 8, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3,
		1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3,
		1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 3, 3, 607, 8, 3, 1, 4, 1, 4, 1, 4, 1, 4,
		3, 4, 613, 8, 4, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 3, 5, 621, 8, 5, 1,
		5, 1, 5, 1, 5, 1, 5, 1, 5, 3, 5, 628, 8, 5, 1, 5, 3, 5, 631, 8, 5, 1, 5,
		1, 5, 3, 5, 635, 8, 5, 1, 5, 3, 5, 638, 8, 5, 3, 5, 640, 8, 5, 1, 5, 3,
		5, 643, 8, 5, 1, 5, 1, 5, 3, 5, 647, 8, 5, 1, 5, 1, 5, 3, 5, 651, 8, 5,
		1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 3, 5, 659, 8, 5, 1, 5, 1, 5, 1, 5,
		1, 5, 1, 5, 3, 5, 666, 8, 5, 1, 5, 1, 5, 3, 5, 670, 8, 5, 3, 5, 672, 8,
		5, 1, 5, 3, 5, 675, 8, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1,
		5, 1, 5, 1, 5, 3, 5, 687, 8, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1,
		5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 3, 5, 701, 8, 5, 1, 5, 1, 5, 1, 5, 1,
		5, 1, 5, 1, 5, 3, 5, 709, 8, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 3, 5, 716,
		8, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 3, 5, 723, 8, 5, 1, 5, 1, 5, 1, 5,
		3, 5, 728, 8, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5,
		1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5,
		1, 5, 1, 5, 1, 5, 3, 5, 754, 8, 5, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6,
		1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 3, 6, 767, 8, 6, 3, 6, 769, 8, 6, 1, 6, 1,
		6, 3, 6, 773, 8, 6, 1, 6, 1, 6, 1, 6, 3, 6, 778, 8, 6, 3, 6, 780, 8, 6,
		1, 6, 3, 6, 783, 8, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6,
		1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 3, 6, 799, 8, 6, 1, 6, 1, 6, 1, 6,
		1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6,
		1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 3, 6, 824, 8, 6, 1, 7,
		1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7,
		1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 3, 7, 845, 8, 7, 1, 8, 3, 8, 848, 8,
		8, 1, 8, 3, 8, 851, 8, 8, 1, 8, 1, 8, 1, 8, 1, 8, 3, 8, 857, 8, 8, 1, 8,
		1, 8, 1, 8, 1, 8, 1, 8, 3, 8, 864, 8, 8, 1, 8, 3, 8, 867, 8, 8, 1, 8, 1,
		8, 1, 8, 3, 8, 872, 8, 8, 1, 8, 3, 8, 875, 8, 8, 1, 8, 1, 8, 1, 8, 1, 8,
		3, 8, 881, 8, 8, 1, 8, 1, 8, 3, 8, 885, 8, 8, 1, 8, 3, 8, 888, 8, 8, 1,
		8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 3, 8, 896, 8, 8, 1, 8, 3, 8, 899, 8, 8,
		1, 8, 3, 8, 902, 8, 8, 1, 8, 3, 8, 905, 8, 8, 1, 8, 1, 8, 1, 8, 1, 8, 3,
		8, 911, 8, 8, 1, 8, 1, 8, 1, 8, 3, 8, 916, 8, 8, 1, 8, 3, 8, 919, 8, 8,
		1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 5, 8, 928, 8, 8, 10, 8, 12, 8,
		931, 9, 8, 1, 8, 1, 8, 3, 8, 935, 8, 8, 1, 8, 3, 8, 938, 8, 8, 1, 8, 3,
		8, 941, 8, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 3, 8, 948, 8, 8, 1, 8, 3, 8,
		951, 8, 8, 1, 8, 1, 8, 1, 8, 3, 8, 956, 8, 8, 1, 8, 3, 8, 959, 8, 8, 1,
		8, 1, 8, 1, 8, 1, 8, 3, 8, 965, 8, 8, 1, 8, 1, 8, 3, 8, 969, 8, 8, 1, 8,
		1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 3, 8, 979, 8, 8, 1, 8, 1, 8,
		3, 8, 983, 8, 8, 1, 8, 3, 8, 986, 8, 8, 1, 8, 1, 8, 1, 8, 1, 8, 3, 8, 992,
		8, 8, 1, 8, 3, 8, 995, 8, 8, 3, 8, 997, 8, 8, 1, 9, 1, 9, 3, 9, 1001, 8,
		9, 1, 9, 1, 9, 1, 9, 1, 9, 3, 9, 1007, 8, 9, 1, 9, 1, 9, 3, 9, 1011, 8,
		9, 1, 9, 1, 9, 1, 9, 1, 9, 3, 9, 1017, 8, 9, 1, 9, 3, 9, 1020, 8, 9, 1,
		9, 1, 9, 3, 9, 1024, 8, 9, 1, 9, 1, 9, 1, 9, 3, 9, 1029, 8, 9, 1, 9, 1,
		9, 1, 9, 1, 9, 1, 9, 1, 9, 3, 9, 1037, 8, 9, 3, 9, 1039, 8, 9, 1, 9, 1,
		9, 3, 9, 1043, 8, 9, 1, 9, 3, 9, 1046, 8, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1,
		9, 3, 9, 1053, 8, 9, 1, 9, 1, 9, 1, 9, 3, 9, 1058, 8, 9, 3, 9, 1060, 8,
		9, 3, 9, 1062, 8, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 3, 9, 1069, 8, 9, 1,
		9, 3, 9, 1072, 8, 9, 1, 9, 1, 9, 3, 9, 1076, 8, 9, 1, 9, 1, 9, 3, 9, 1080,
		8, 9, 1, 9, 1, 9, 1, 9, 3, 9, 1085, 8, 9, 1, 9, 1, 9, 1, 9, 1, 9, 3, 9,
		1091, 8, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 3, 9, 1098, 8, 9, 1, 9, 1, 9,
		3, 9, 1102, 8, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 3, 9,
		1112, 8, 9, 1, 9, 1, 9, 1, 9, 3, 9, 1117, 8, 9, 1, 9, 1, 9, 1, 9, 1, 9,
		3, 9, 1123, 8, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 3, 9, 1131, 8, 9,
		3, 9, 1133, 8, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 3, 9, 1140, 8, 9, 1, 9,
		1, 9, 1, 9, 3, 9, 1145, 8, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 3, 9,
		1153, 8, 9, 1, 9, 1, 9, 1, 9, 3, 9, 1158, 8, 9, 1, 9, 3, 9, 1161, 8, 9,
		1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 3, 9, 1168, 8, 9, 1, 9, 1, 9, 1, 9, 1, 9,
		3, 9, 1174, 8, 9, 1, 9, 1, 9, 3, 9, 1178, 8, 9, 1, 9, 3, 9, 1181, 8, 9,
		1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 3, 9, 1189, 8, 9, 1, 9, 1, 9, 1, 9,
		1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 3, 9, 1200, 8, 9, 1, 9, 1, 9, 1, 9,
		1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 3, 9, 1213, 8, 9, 1, 9,
		1, 9, 3, 9, 1217, 8, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 3, 9, 1225,
		8, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 3, 9, 1232, 8, 9, 1, 9, 1, 9, 1, 9,
		1, 9, 1, 9, 1, 9, 3, 9, 1240, 8, 9, 1, 9, 3, 9, 1243, 8, 9, 1, 9, 1, 9,
		3, 9, 1247, 8, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 3, 9, 1255, 8, 9,
		1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 3, 9, 1263, 8, 9, 1, 9, 1, 9, 1, 9,
		1, 9, 1, 9, 3, 9, 1270, 8, 9, 1, 9, 3, 9, 1273, 8, 9, 1, 9, 1, 9, 1, 9,
		1, 9, 1, 9, 3, 9, 1280, 8, 9, 1, 9, 1, 9, 3, 9, 1284, 8, 9, 1, 9, 1, 9,
		1, 9, 1, 9, 1, 9, 3, 9, 1291, 8, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9,
		3, 9, 1299, 8, 9, 1, 9, 3, 9, 1302, 8, 9, 1, 9, 1, 9, 1, 9, 1, 9, 3, 9,
		1308, 8, 9, 1, 9, 1, 9, 1, 9, 3, 9, 1313, 8, 9, 1, 9, 1, 9, 1, 9, 1, 9,
		1, 9, 3, 9, 1320, 8, 9, 1, 9, 3, 9, 1323, 8, 9, 1, 9, 1, 9, 3, 9, 1327,
		8, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 3, 9, 1334, 8, 9, 1, 9, 1, 9, 1, 9,
		3, 9, 1339, 8, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 3, 9, 1346, 8, 9, 1, 9,
		1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 3, 9, 1357, 8, 9, 1, 9,
		1, 9, 1, 9, 1, 9, 1, 9, 3, 9, 1364, 8, 9, 1, 9, 1, 9, 3, 9, 1368, 8, 9,
		1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 3, 9, 1375, 8, 9, 1, 9, 1, 9, 3, 9, 1379,
		8, 9, 1, 9, 1, 9, 1, 9, 3, 9, 1384, 8, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9,
		1, 9, 1, 9, 3, 9, 1393, 8, 9, 1, 9, 1, 9, 1, 9, 1, 9, 3, 9, 1399, 8, 9,
		1, 9, 1, 9, 3, 9, 1403, 8, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 3, 9, 1410,
		8, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9,
		3, 9, 1423, 8, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 3, 9, 1430, 8, 9, 1, 9,
		1, 9, 3, 9, 1434, 8, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 3, 9, 1442,
		8, 9, 1, 9, 1, 9, 3, 9, 1446, 8, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9,
		1, 9, 3, 9, 1455, 8, 9, 1, 9, 1, 9, 3, 9, 1459, 8, 9, 1, 9, 1, 9, 1, 9,
		1, 9, 1, 9, 1, 9, 1, 9, 3, 9, 1468, 8, 9, 1, 9, 1, 9, 3, 9, 1472, 8, 9,
		1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 3, 9, 1481, 8, 9, 1, 9, 1, 9,
		3, 9, 1485, 8, 9, 3, 9, 1487, 8, 9, 1, 10, 1, 10, 1, 10, 5, 10, 1492, 8,
		10, 10, 10, 12, 10, 1495, 9, 10, 1, 11, 1, 11, 1, 11, 1, 12, 1, 12, 1,
		12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 3, 12,
		1512, 8, 12, 1, 12, 1, 12, 3, 12, 1516, 8, 12, 1, 12, 1, 12, 3, 12, 1520,
		8, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1,
		12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12,
		1, 12, 1, 12, 1, 12, 3, 12, 1545, 8, 12, 1, 12, 3, 12, 1548, 8, 12, 1,
		12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12,
		1, 12, 1, 12, 1, 12, 3, 12, 1564, 8, 12, 1, 12, 1, 12, 1, 12, 1, 12, 3,
		12, 1570, 8, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12,
		1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1,
		12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 5, 12, 1597, 8, 12, 10, 12,
		12, 12, 1600, 9, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1,
		12, 5, 12, 1610, 8, 12, 10, 12, 12, 12, 1613, 9, 12, 1, 12, 1, 12, 1, 12,
		1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 5, 12, 1623, 8, 12, 10, 12, 12, 12,
		1626, 9, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1,
		12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 3, 12, 1644, 8, 12,
		1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1,
		12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12,
		3, 12, 1667, 8, 12, 1, 12, 1, 12, 1, 12, 1, 12, 3, 12, 1673, 8, 12, 1,
		12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 3, 12, 1681, 8, 12, 1, 12, 1, 12,
		1, 12, 1, 12, 1, 12, 1, 12, 3, 12, 1689, 8, 12, 1, 12, 1, 12, 1, 12, 1,
		12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 3, 12,
		1704, 8, 12, 1, 12, 1, 12, 1, 12, 1, 12, 3, 12, 1710, 8, 12, 3, 12, 1712,
		8, 12, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1,
		13, 1, 13, 1, 13, 3, 13, 1726, 8, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13,
		3, 13, 1733, 8, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 3, 13, 1740, 8,
		13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 3, 13, 1747, 8, 13, 1, 13, 1, 13,
		1, 13, 1, 13, 1, 13, 1, 13, 3, 13, 1755, 8, 13, 1, 13, 1, 13, 1, 13, 1,
		13, 1, 13, 1, 13, 3, 13, 1763, 8, 13, 1, 13, 1, 13, 1, 13, 3, 13, 1768,
		8, 13, 1, 13, 1, 13, 1, 13, 1, 13, 3, 13, 1774, 8, 13, 1, 13, 1, 13, 1,
		13, 1, 13, 1, 13, 1, 13, 3, 13, 1782, 8, 13, 1, 13, 1, 13, 1, 13, 1, 13,
		1, 13, 1, 13, 3, 13, 1790, 8, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1,
		13, 1, 13, 1, 13, 3, 13, 1800, 8, 13, 1, 13, 1, 13, 3, 13, 1804, 8, 13,
		1, 13, 1, 13, 1, 13, 1, 13, 3, 13, 1810, 8, 13, 1, 13, 1, 13, 3, 13, 1814,
		8, 13, 1, 13, 1, 13, 3, 13, 1818, 8, 13, 1, 13, 1, 13, 1, 13, 3, 13, 1823,
		8, 13, 1, 13, 1, 13, 1, 13, 3, 13, 1828, 8, 13, 1, 13, 1, 13, 1, 13, 1,
		13, 1, 13, 1, 13, 3, 13, 1836, 8, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13,
		1, 13, 1, 13, 1, 13, 3, 13, 1846, 8, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1,
		13, 1, 13, 3, 13, 1854, 8, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13,
		1, 13, 3, 13, 1863, 8, 13, 3, 13, 1865, 8, 13, 1, 13, 1, 13, 1, 13, 1,
		13, 3, 13, 1871, 8, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 3, 13, 1878,
		8, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 3, 13, 1885, 8, 13, 1, 13, 1,
		13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 3, 13, 1894, 8, 13, 1, 13, 1, 13,
		1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 3, 13, 1903, 8, 13, 1, 13, 1, 13, 1,
		13, 1, 13, 1, 13, 1, 13, 1, 13, 3, 13, 1912, 8, 13, 1, 13, 3, 13, 1915,
		8, 13, 1, 14, 1, 14, 3, 14, 1919, 8, 14, 1, 14, 1, 14, 3, 14, 1923, 8,
		14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 3, 14,
		1934, 8, 14, 1, 14, 1, 14, 3, 14, 1938, 8, 14, 1, 14, 3, 14, 1941, 8, 14,
		1, 14, 3, 14, 1944, 8, 14, 1, 14, 3, 14, 1947, 8, 14, 1, 14, 1, 14, 1,
		14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 3, 14, 1957, 8, 14, 1, 14, 3, 14,
		1960, 8, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 3, 14, 1969,
		8, 14, 1, 14, 3, 14, 1972, 8, 14, 1, 14, 3, 14, 1975, 8, 14, 1, 14, 3,
		14, 1978, 8, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 3, 14, 1986,
		8, 14, 1, 14, 1, 14, 1, 14, 1, 14, 3, 14, 1992, 8, 14, 1, 14, 3, 14, 1995,
		8, 14, 1, 14, 1, 14, 1, 14, 1, 14, 3, 14, 2001, 8, 14, 1, 14, 3, 14, 2004,
		8, 14, 1, 14, 3, 14, 2007, 8, 14, 1, 14, 3, 14, 2010, 8, 14, 1, 14, 1,
		14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 3, 14, 2019, 8, 14, 1, 14, 1, 14,
		1, 14, 1, 14, 3, 14, 2025, 8, 14, 1, 14, 1, 14, 1, 14, 3, 14, 2030, 8,
		14, 1, 14, 1, 14, 1, 14, 1, 14, 3, 14, 2036, 8, 14, 1, 14, 1, 14, 1, 14,
		3, 14, 2041, 8, 14, 1, 14, 1, 14, 3, 14, 2045, 8, 14, 1, 14, 3, 14, 2048,
		8, 14, 1, 14, 1, 14, 1, 14, 3, 14, 2053, 8, 14, 1, 14, 1, 14, 3, 14, 2057,
		8, 14, 1, 14, 1, 14, 1, 14, 3, 14, 2062, 8, 14, 1, 14, 1, 14, 1, 14, 3,
		14, 2067, 8, 14, 1, 14, 1, 14, 3, 14, 2071, 8, 14, 1, 14, 1, 14, 1, 14,
		1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1,
		14, 3, 14, 2087, 8, 14, 1, 14, 1, 14, 1, 14, 1, 14, 3, 14, 2093, 8, 14,
		1, 14, 3, 14, 2096, 8, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1,
		14, 1, 14, 1, 14, 1, 14, 1, 14, 3, 14, 2109, 8, 14, 1, 14, 1, 14, 1, 14,
		1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 3, 14, 2122, 8,
		14, 1, 14, 1, 14, 3, 14, 2126, 8, 14, 1, 14, 1, 14, 3, 14, 2130, 8, 14,
		1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 3, 14, 2137, 8, 14, 1, 14, 1, 14, 1,
		14, 3, 14, 2142, 8, 14, 1, 14, 1, 14, 1, 14, 1, 14, 3, 14, 2148, 8, 14,
		1, 14, 3, 14, 2151, 8, 14, 1, 14, 3, 14, 2154, 8, 14, 1, 14, 1, 14, 3,
		14, 2158, 8, 14, 1, 14, 1, 14, 1, 14, 3, 14, 2163, 8, 14, 1, 14, 3, 14,
		2166, 8, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1,
		14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 3, 14, 2182, 8, 14, 1, 14, 1, 14,
		3, 14, 2186, 8, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1,
		14, 1, 14, 1, 14, 1, 14, 3, 14, 2199, 8, 14, 1, 14, 1, 14, 1, 14, 1, 14,
		3, 14, 2205, 8, 14, 1, 14, 1, 14, 3, 14, 2209, 8, 14, 1, 14, 1, 14, 1,
		14, 1, 14, 1, 14, 3, 14, 2216, 8, 14, 1, 14, 1, 14, 1, 14, 3, 14, 2221,
		8, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 3, 14, 2230, 8,
		14, 3, 14, 2232, 8, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 3, 14,
		2240, 8, 14, 3, 14, 2242, 8, 14, 1, 14, 1, 14, 1, 14, 1, 14, 3, 14, 2248,
		8, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1,
		14, 3, 14, 2260, 8, 14, 1, 14, 1, 14, 3, 14, 2264, 8, 14, 1, 14, 3, 14,
		2267, 8, 14, 1, 14, 3, 14, 2270, 8, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1,
		14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 3, 14, 2283, 8, 14, 1, 14,
		1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1,
		14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 3, 14, 2303, 8, 14, 1, 14,
		3, 14, 2306, 8, 14, 1, 14, 3, 14, 2309, 8, 14, 1, 14, 1, 14, 3, 14, 2313,
		8, 14, 1, 14, 1, 14, 1, 14, 3, 14, 2318, 8, 14, 1, 14, 3, 14, 2321, 8,
		14, 1, 14, 3, 14, 2324, 8, 14, 1, 14, 3, 14, 2327, 8, 14, 1, 14, 1, 14,
		1, 14, 1, 14, 1, 14, 3, 14, 2334, 8, 14, 1, 14, 3, 14, 2337, 8, 14, 1,
		14, 3, 14, 2340, 8, 14, 1, 14, 1, 14, 3, 14, 2344, 8, 14, 1, 14, 1, 14,
		3, 14, 2348, 8, 14, 1, 14, 1, 14, 1, 14, 3, 14, 2353, 8, 14, 1, 14, 3,
		14, 2356, 8, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14,
		1, 14, 3, 14, 2367, 8, 14, 1, 14, 3, 14, 2370, 8, 14, 1, 14, 1, 14, 1,
		14, 3, 14, 2375, 8, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 3, 14, 2382,
		8, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 3, 14, 2389, 8, 14, 1, 14, 3,
		14, 2392, 8, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 3, 14,
		2401, 8, 14, 1, 14, 1, 14, 1, 14, 1, 14, 3, 14, 2407, 8, 14, 1, 14, 1,
		14, 1, 14, 1, 14, 3, 14, 2413, 8, 14, 1, 14, 1, 14, 3, 14, 2417, 8, 14,
		1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 5, 14, 2428,
		8, 14, 10, 14, 12, 14, 2431, 9, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14,
		1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 3, 14, 2443, 8, 14, 1, 14, 1, 14, 3,
		14, 2447, 8, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 3, 14, 2454, 8, 14,
		1, 14, 1, 14, 1, 14, 1, 14, 3, 14, 2460, 8, 14, 1, 14, 3, 14, 2463, 8,
		14, 1, 14, 1, 14, 1, 14, 1, 14, 3, 14, 2469, 8, 14, 1, 14, 1, 14, 3, 14,
		2473, 8, 14, 1, 14, 1, 14, 1, 14, 3, 14, 2478, 8, 14, 1, 14, 3, 14, 2481,
		8, 14, 1, 14, 1, 14, 3, 14, 2485, 8, 14, 1, 14, 1, 14, 1, 14, 3, 14, 2490,
		8, 14, 1, 14, 3, 14, 2493, 8, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 3,
		14, 2500, 8, 14, 1, 14, 3, 14, 2503, 8, 14, 1, 14, 1, 14, 1, 14, 1, 14,
		3, 14, 2509, 8, 14, 1, 14, 3, 14, 2512, 8, 14, 1, 14, 1, 14, 1, 14, 1,
		14, 1, 14, 3, 14, 2519, 8, 14, 1, 14, 3, 14, 2522, 8, 14, 1, 14, 3, 14,
		2525, 8, 14, 1, 14, 3, 14, 2528, 8, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1,
		14, 1, 14, 3, 14, 2536, 8, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14,
		3, 14, 2544, 8, 14, 1, 14, 1, 14, 1, 14, 1, 14, 3, 14, 2550, 8, 14, 1,
		14, 3, 14, 2553, 8, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 3, 14,
		2561, 8, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 3, 14, 2568, 8, 14, 1,
		14, 1, 14, 1, 14, 1, 14, 3, 14, 2574, 8, 14, 1, 14, 3, 14, 2577, 8, 14,
		1, 14, 3, 14, 2580, 8, 14, 1, 14, 3, 14, 2583, 8, 14, 1, 14, 1, 14, 1,
		14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 3, 14, 2594, 8, 14, 3, 14,
		2596, 8, 14, 3, 14, 2598, 8, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1,
		14, 3, 14, 2606, 8, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 3, 14, 2613,
		8, 14, 3, 14, 2615, 8, 14, 1, 15, 1, 15, 1, 15, 1, 15, 3, 15, 2621, 8,
		15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15,
		1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1,
		15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 3, 15,
		2653, 8, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 3, 15, 2661, 8,
		15, 3, 15, 2663, 8, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 3, 15,
		2671, 8, 15, 1, 15, 3, 15, 2674, 8, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1,
		15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 3, 15, 2688, 8, 15,
		1, 16, 1, 16, 3, 16, 2692, 8, 16, 1, 16, 1, 16, 1, 16, 1, 16, 3, 16, 2698,
		8, 16, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 3,
		17, 2709, 8, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17,
		5, 17, 2719, 8, 17, 10, 17, 12, 17, 2722, 9, 17, 3, 17, 2724, 8, 17, 1,
		17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 5, 17,
		2736, 8, 17, 10, 17, 12, 17, 2739, 9, 17, 1, 17, 1, 17, 3, 17, 2743, 8,
		17, 1, 17, 3, 17, 2746, 8, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 3, 17,
		2753, 8, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 3, 17, 2760, 8, 17, 1,
		17, 1, 17, 1, 17, 1, 17, 5, 17, 2766, 8, 17, 10, 17, 12, 17, 2769, 9, 17,
		3, 17, 2771, 8, 17, 1, 17, 3, 17, 2774, 8, 17, 1, 17, 1, 17, 1, 17, 1,
		17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 5, 17, 2786, 8, 17, 10, 17,
		12, 17, 2789, 9, 17, 1, 17, 1, 17, 3, 17, 2793, 8, 17, 1, 17, 3, 17, 2796,
		8, 17, 3, 17, 2798, 8, 17, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 3, 18, 2805,
		8, 18, 1, 19, 1, 19, 1, 19, 1, 19, 3, 19, 2811, 8, 19, 1, 20, 1, 20, 1,
		20, 3, 20, 2816, 8, 20, 1, 20, 1, 20, 3, 20, 2820, 8, 20, 1, 20, 3, 20,
		2823, 8, 20, 1, 20, 3, 20, 2826, 8, 20, 1, 21, 1, 21, 1, 21, 1, 21, 1,
		21, 1, 21, 3, 21, 2834, 8, 21, 1, 21, 1, 21, 3, 21, 2838, 8, 21, 1, 21,
		1, 21, 1, 21, 5, 21, 2843, 8, 21, 10, 21, 12, 21, 2846, 9, 21, 3, 21, 2848,
		8, 21, 1, 21, 3, 21, 2851, 8, 21, 1, 21, 1, 21, 1, 21, 1, 21, 1, 21, 1,
		21, 3, 21, 2859, 8, 21, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22,
		3, 22, 2868, 8, 22, 1, 22, 3, 22, 2871, 8, 22, 1, 22, 1, 22, 1, 22, 1,
		22, 1, 22, 3, 22, 2878, 8, 22, 1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 1, 23,
		1, 23, 1, 23, 1, 23, 1, 23, 3, 23, 2890, 8, 23, 1, 24, 1, 24, 1, 24, 1,
		24, 1, 25, 1, 25, 1, 25, 1, 25, 1, 26, 1, 26, 1, 26, 1, 27, 1, 27, 1, 27,
		1, 27, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 5, 28, 2912, 8, 28, 10, 28, 12,
		28, 2915, 9, 28, 1, 28, 1, 28, 1, 29, 1, 29, 1, 29, 3, 29, 2922, 8, 29,
		1, 29, 1, 29, 1, 29, 1, 29, 3, 29, 2928, 8, 29, 1, 29, 1, 29, 3, 29, 2932,
		8, 29, 1, 30, 1, 30, 1, 30, 1, 30, 3, 30, 2938, 8, 30, 1, 30, 1, 30, 1,
		30, 1, 30, 3, 30, 2944, 8, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30,
		1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 3, 30, 2957, 8, 30, 3, 30, 2959, 8,
		30, 1, 31, 1, 31, 1, 31, 1, 31, 1, 31, 1, 31, 3, 31, 2967, 8, 31, 1, 31,
		1, 31, 1, 31, 1, 31, 1, 31, 1, 31, 1, 31, 1, 31, 1, 31, 3, 31, 2978, 8,
		31, 1, 31, 1, 31, 1, 31, 1, 31, 3, 31, 2984, 8, 31, 1, 32, 1, 32, 1, 32,
		1, 32, 3, 32, 2990, 8, 32, 1, 32, 3, 32, 2993, 8, 32, 1, 32, 1, 32, 1,
		32, 1, 32, 3, 32, 2999, 8, 32, 1, 32, 3, 32, 3002, 8, 32, 1, 32, 1, 32,
		1, 32, 1, 32, 1, 32, 3, 32, 3009, 8, 32, 1, 32, 1, 32, 1, 32, 1, 32, 1,
		32, 1, 32, 5, 32, 3017, 8, 32, 10, 32, 12, 32, 3020, 9, 32, 1, 32, 1, 32,
		1, 32, 1, 32, 3, 32, 3026, 8, 32, 1, 32, 1, 32, 1, 32, 1, 32, 3, 32, 3032,
		8, 32, 1, 32, 1, 32, 1, 32, 1, 32, 1, 32, 1, 32, 1, 32, 1, 32, 1, 32, 5,
		32, 3043, 8, 32, 10, 32, 12, 32, 3046, 9, 32, 1, 32, 3, 32, 3049, 8, 32,
		1, 32, 1, 32, 1, 32, 1, 32, 1, 32, 1, 32, 1, 32, 3, 32, 3058, 8, 32, 1,
		32, 1, 32, 1, 32, 1, 32, 1, 32, 1, 32, 5, 32, 3066, 8, 32, 10, 32, 12,
		32, 3069, 9, 32, 1, 32, 3, 32, 3072, 8, 32, 3, 32, 3074, 8, 32, 1, 33,
		1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 1,
		33, 1, 33, 1, 33, 5, 33, 3090, 8, 33, 10, 33, 12, 33, 3093, 9, 33, 1, 33,
		3, 33, 3096, 8, 33, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 1,
		33, 1, 33, 5, 33, 3107, 8, 33, 10, 33, 12, 33, 3110, 9, 33, 1, 33, 3, 33,
		3113, 8, 33, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 1,
		33, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 3, 33, 3130, 8, 33, 1, 33,
		1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 3, 33, 3140, 8, 33, 1,
		33, 1, 33, 1, 33, 1, 33, 3, 33, 3146, 8, 33, 1, 33, 1, 33, 1, 33, 1, 33,
		1, 33, 1, 33, 3, 33, 3154, 8, 33, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 3,
		33, 3161, 8, 33, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 3, 33, 3168, 8, 33,
		1, 33, 3, 33, 3171, 8, 33, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 1,
		33, 1, 33, 5, 33, 3181, 8, 33, 10, 33, 12, 33, 3184, 9, 33, 1, 33, 3, 33,
		3187, 8, 33, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 1,
		33, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 3, 33, 3204, 8, 33, 1, 33,
		1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 1,
		33, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33,
		1, 33, 3, 33, 3229, 8, 33, 3, 33, 3231, 8, 33, 1, 34, 1, 34, 1, 34, 1,
		34, 3, 34, 3237, 8, 34, 1, 34, 1, 34, 3, 34, 3241, 8, 34, 1, 34, 1, 34,
		1, 34, 1, 34, 3, 34, 3247, 8, 34, 1, 34, 1, 34, 3, 34, 3251, 8, 34, 1,
		34, 1, 34, 1, 34, 1, 34, 3, 34, 3257, 8, 34, 1, 34, 1, 34, 3, 34, 3261,
		8, 34, 1, 34, 1, 34, 1, 34, 3, 34, 3266, 8, 34, 1, 35, 1, 35, 1, 35, 1,
		35, 1, 35, 1, 35, 1, 35, 3, 35, 3275, 8, 35, 1, 36, 1, 36, 3, 36, 3279,
		8, 36, 1, 36, 3, 36, 3282, 8, 36, 1, 36, 3, 36, 3285, 8, 36, 1, 36, 3,
		36, 3288, 8, 36, 1, 36, 1, 36, 3, 36, 3292, 8, 36, 1, 36, 3, 36, 3295,
		8, 36, 1, 37, 1, 37, 1, 37, 1, 37, 3, 37, 3301, 8, 37, 1, 38, 1, 38, 1,
		38, 1, 38, 3, 38, 3307, 8, 38, 3, 38, 3309, 8, 38, 1, 38, 1, 38, 3, 38,
		3313, 8, 38, 1, 38, 1, 38, 3, 38, 3317, 8, 38, 1, 38, 3, 38, 3320, 8, 38,
		1, 38, 3, 38, 3323, 8, 38, 1, 38, 3, 38, 3326, 8, 38, 1, 38, 1, 38, 3,
		38, 3330, 8, 38, 1, 38, 1, 38, 3, 38, 3334, 8, 38, 1, 38, 3, 38, 3337,
		8, 38, 1, 38, 3, 38, 3340, 8, 38, 1, 38, 3, 38, 3343, 8, 38, 3, 38, 3345,
		8, 38, 1, 39, 1, 39, 1, 39, 1, 39, 1, 39, 1, 39, 1, 39, 1, 39, 3, 39, 3355,
		8, 39, 1, 39, 1, 39, 1, 39, 1, 39, 1, 39, 1, 39, 1, 39, 1, 39, 1, 39, 1,
		39, 1, 39, 1, 39, 3, 39, 3369, 8, 39, 1, 39, 1, 39, 1, 39, 1, 39, 1, 39,
		3, 39, 3376, 8, 39, 1, 39, 1, 39, 1, 39, 1, 39, 5, 39, 3382, 8, 39, 10,
		39, 12, 39, 3385, 9, 39, 1, 39, 1, 39, 1, 39, 1, 39, 1, 39, 1, 39, 1, 39,
		5, 39, 3394, 8, 39, 10, 39, 12, 39, 3397, 9, 39, 1, 39, 1, 39, 1, 39, 1,
		39, 1, 39, 1, 39, 1, 39, 1, 39, 1, 39, 1, 39, 1, 39, 1, 39, 1, 39, 1, 39,
		1, 39, 3, 39, 3414, 8, 39, 1, 39, 1, 39, 1, 39, 1, 39, 1, 39, 3, 39, 3421,
		8, 39, 1, 39, 1, 39, 1, 39, 1, 39, 1, 39, 1, 39, 1, 39, 1, 39, 3, 39, 3431,
		8, 39, 3, 39, 3433, 8, 39, 1, 40, 1, 40, 3, 40, 3437, 8, 40, 1, 40, 3,
		40, 3440, 8, 40, 1, 41, 1, 41, 1, 41, 5, 41, 3445, 8, 41, 10, 41, 12, 41,
		3448, 9, 41, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 5, 42, 3455, 8, 42, 10,
		42, 12, 42, 3458, 9, 42, 1, 42, 3, 42, 3461, 8, 42, 1, 42, 1, 42, 1, 42,
		1, 42, 1, 42, 5, 42, 3468, 8, 42, 10, 42, 12, 42, 3471, 9, 42, 1, 42, 1,
		42, 1, 42, 1, 42, 1, 42, 5, 42, 3478, 8, 42, 10, 42, 12, 42, 3481, 9, 42,
		1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1,
		42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 5, 42, 3501, 8, 42,
		10, 42, 12, 42, 3504, 9, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42,
		5, 42, 3512, 8, 42, 10, 42, 12, 42, 3515, 9, 42, 1, 42, 1, 42, 1, 42, 1,
		42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 3, 42, 3526, 8, 42, 1, 42, 1, 42,
		1, 42, 1, 42, 1, 42, 5, 42, 3533, 8, 42, 10, 42, 12, 42, 3536, 9, 42, 1,
		42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 3, 42,
		3548, 8, 42, 1, 43, 1, 43, 3, 43, 3552, 8, 43, 1, 44, 1, 44, 1, 44, 1,
		44, 1, 44, 3, 44, 3559, 8, 44, 1, 44, 3, 44, 3562, 8, 44, 1, 44, 3, 44,
		3565, 8, 44, 1, 45, 1, 45, 1, 45, 1, 45, 3, 45, 3571, 8, 45, 1, 45, 3,
		45, 3574, 8, 45, 1, 45, 3, 45, 3577, 8, 45, 1, 45, 1, 45, 1, 45, 1, 45,
		1, 45, 1, 45, 3, 45, 3585, 8, 45, 1, 45, 3, 45, 3588, 8, 45, 1, 45, 1,
		45, 1, 45, 1, 45, 3, 45, 3594, 8, 45, 1, 45, 3, 45, 3597, 8, 45, 1, 45,
		1, 45, 1, 45, 1, 45, 3, 45, 3603, 8, 45, 1, 45, 3, 45, 3606, 8, 45, 1,
		45, 3, 45, 3609, 8, 45, 1, 45, 1, 45, 1, 45, 1, 45, 3, 45, 3615, 8, 45,
		1, 45, 3, 45, 3618, 8, 45, 1, 45, 1, 45, 3, 45, 3622, 8, 45, 1, 45, 1,
		45, 1, 45, 1, 45, 1, 45, 1, 45, 3, 45, 3630, 8, 45, 1, 45, 1, 45, 1, 45,
		3, 45, 3635, 8, 45, 3, 45, 3637, 8, 45, 3, 45, 3639, 8, 45, 1, 45, 3, 45,
		3642, 8, 45, 1, 45, 1, 45, 3, 45, 3646, 8, 45, 1, 45, 1, 45, 1, 45, 3,
		45, 3651, 8, 45, 1, 45, 1, 45, 3, 45, 3655, 8, 45, 1, 45, 1, 45, 1, 45,
		3, 45, 3660, 8, 45, 1, 45, 1, 45, 3, 45, 3664, 8, 45, 1, 45, 1, 45, 1,
		45, 1, 45, 1, 45, 1, 45, 3, 45, 3672, 8, 45, 1, 45, 1, 45, 1, 45, 1, 45,
		1, 45, 1, 45, 1, 45, 3, 45, 3681, 8, 45, 1, 45, 1, 45, 3, 45, 3685, 8,
		45, 1, 45, 3, 45, 3688, 8, 45, 1, 45, 3, 45, 3691, 8, 45, 1, 45, 1, 45,
		1, 45, 1, 45, 1, 45, 3, 45, 3698, 8, 45, 1, 45, 3, 45, 3701, 8, 45, 1,
		45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45,
		1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1,
		45, 1, 45, 3, 45, 3726, 8, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45,
		3, 45, 3734, 8, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 3,
		45, 3743, 8, 45, 1, 45, 1, 45, 1, 45, 3, 45, 3748, 8, 45, 3, 45, 3750,
		8, 45, 3, 45, 3752, 8, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1,
		45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 3, 45, 3768, 8, 45,
		1, 45, 1, 45, 3, 45, 3772, 8, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1,
		45, 1, 45, 1, 45, 3, 45, 3782, 8, 45, 1, 45, 3, 45, 3785, 8, 45, 1, 45,
		1, 45, 1, 45, 1, 45, 3, 45, 3791, 8, 45, 1, 46, 1, 46, 1, 46, 1, 46, 1,
		46, 3, 46, 3798, 8, 46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 3, 46, 3805,
		8, 46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 3, 46, 3812, 8, 46, 1, 47, 1,
		47, 1, 47, 1, 47, 1, 47, 3, 47, 3819, 8, 47, 1, 47, 1, 47, 1, 47, 1, 47,
		1, 47, 3, 47, 3826, 8, 47, 1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 3, 47, 3833,
		8, 47, 1, 48, 1, 48, 1, 48, 1, 48, 3, 48, 3839, 8, 48, 1, 48, 3, 48, 3842,
		8, 48, 1, 49, 1, 49, 1, 49, 1, 49, 3, 49, 3848, 8, 49, 1, 49, 3, 49, 3851,
		8, 49, 1, 49, 3, 49, 3854, 8, 49, 1, 50, 1, 50, 1, 50, 1, 51, 1, 51, 1,
		51, 1, 51, 1, 51, 1, 51, 1, 51, 1, 51, 1, 51, 1, 51, 1, 51, 1, 51, 1, 51,
		1, 51, 3, 51, 3873, 8, 51, 1, 52, 1, 52, 1, 52, 1, 53, 1, 53, 1, 53, 1,
		54, 1, 54, 1, 54, 1, 54, 3, 54, 3885, 8, 54, 1, 54, 1, 54, 1, 55, 1, 55,
		1, 55, 1, 55, 3, 55, 3893, 8, 55, 1, 55, 1, 55, 1, 56, 1, 56, 1, 56, 3,
		56, 3900, 8, 56, 1, 57, 1, 57, 1, 57, 1, 58, 1, 58, 1, 58, 1, 59, 1, 59,
		3, 59, 3910, 8, 59, 1, 59, 1, 59, 1, 59, 3, 59, 3915, 8, 59, 1, 59, 1,
		59, 1, 59, 1, 59, 1, 59, 3, 59, 3922, 8, 59, 1, 59, 1, 59, 1, 59, 1, 59,
		1, 59, 3, 59, 3929, 8, 59, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 3, 59, 3936,
		8, 59, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 1,
		59, 1, 59, 5, 59, 3949, 8, 59, 10, 59, 12, 59, 3952, 9, 59, 1, 59, 3, 59,
		3955, 8, 59, 1, 59, 1, 59, 1, 59, 1, 59, 3, 59, 3961, 8, 59, 1, 59, 3,
		59, 3964, 8, 59, 1, 59, 1, 59, 5, 59, 3968, 8, 59, 10, 59, 12, 59, 3971,
		9, 59, 1, 59, 3, 59, 3974, 8, 59, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 1,
		59, 1, 59, 1, 59, 1, 59, 3, 59, 3985, 8, 59, 1, 59, 1, 59, 1, 59, 1, 59,
		1, 59, 3, 59, 3992, 8, 59, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 1,
		59, 1, 59, 1, 59, 3, 59, 4003, 8, 59, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59,
		1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 3, 59, 4015, 8, 59, 1, 59, 3, 59, 4018,
		8, 59, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 1,
		59, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 3, 59,
		4039, 8, 59, 1, 59, 3, 59, 4042, 8, 59, 1, 59, 1, 59, 1, 59, 1, 59, 3,
		59, 4048, 8, 59, 1, 60, 1, 60, 1, 60, 3, 60, 4053, 8, 60, 1, 60, 1, 60,
		1, 60, 3, 60, 4058, 8, 60, 1, 60, 3, 60, 4061, 8, 60, 1, 60, 1, 60, 1,
		60, 1, 60, 1, 60, 3, 60, 4068, 8, 60, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61,
		1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 3, 61, 4080, 8, 61, 1, 61, 1, 61, 1,
		61, 1, 61, 1, 61, 1, 61, 3, 61, 4088, 8, 61, 1, 62, 1, 62, 1, 62, 5, 62,
		4093, 8, 62, 10, 62, 12, 62, 4096, 9, 62, 1, 63, 1, 63, 1, 63, 1, 63, 3,
		63, 4102, 8, 63, 3, 63, 4104, 8, 63, 1, 64, 1, 64, 1, 64, 5, 64, 4109,
		8, 64, 10, 64, 12, 64, 4112, 9, 64, 1, 65, 1, 65, 1, 65, 1, 65, 3, 65,
		4118, 8, 65, 1, 66, 1, 66, 3, 66, 4122, 8, 66, 1, 66, 1, 66, 1, 66, 1,
		66, 3, 66, 4128, 8, 66, 1, 67, 1, 67, 1, 67, 3, 67, 4133, 8, 67, 3, 67,
		4135, 8, 67, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 3, 67, 4143, 8,
		67, 3, 67, 4145, 8, 67, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 3, 67, 4152,
		8, 67, 3, 67, 4154, 8, 67, 1, 67, 1, 67, 3, 67, 4158, 8, 67, 1, 67, 1,
		67, 1, 67, 1, 67, 3, 67, 4164, 8, 67, 3, 67, 4166, 8, 67, 1, 67, 3, 67,
		4169, 8, 67, 1, 68, 1, 68, 1, 68, 1, 68, 1, 68, 1, 68, 3, 68, 4177, 8,
		68, 1, 69, 1, 69, 1, 69, 5, 69, 4182, 8, 69, 10, 69, 12, 69, 4185, 9, 69,
		1, 70, 1, 70, 1, 70, 3, 70, 4190, 8, 70, 1, 70, 1, 70, 1, 70, 3, 70, 4195,
		8, 70, 5, 70, 4197, 8, 70, 10, 70, 12, 70, 4200, 9, 70, 1, 70, 1, 70, 1,
		70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 3, 70, 4213,
		8, 70, 1, 70, 1, 70, 1, 70, 3, 70, 4218, 8, 70, 1, 70, 1, 70, 1, 70, 1,
		70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 3, 70, 4231, 8, 70,
		3, 70, 4233, 8, 70, 1, 71, 1, 71, 1, 71, 1, 71, 1, 71, 3, 71, 4240, 8,
		71, 1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 3, 72, 4248, 8, 72, 1, 72,
		1, 72, 3, 72, 4252, 8, 72, 1, 72, 1, 72, 1, 72, 3, 72, 4257, 8, 72, 1,
		72, 1, 72, 1, 72, 3, 72, 4262, 8, 72, 1, 72, 1, 72, 1, 72, 3, 72, 4267,
		8, 72, 1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 3, 72, 4275, 8, 72, 1,
		72, 1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 3, 72, 4284, 8, 72, 1, 72,
		3, 72, 4287, 8, 72, 1, 73, 1, 73, 1, 73, 1, 73, 3, 73, 4293, 8, 73, 3,
		73, 4295, 8, 73, 1, 73, 1, 73, 1, 73, 1, 73, 3, 73, 4301, 8, 73, 1, 73,
		1, 73, 1, 73, 1, 73, 1, 73, 3, 73, 4308, 8, 73, 1, 74, 1, 74, 1, 74, 1,
		75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 3, 75, 4322,
		8, 75, 1, 76, 1, 76, 3, 76, 4326, 8, 76, 1, 76, 1, 76, 1, 76, 3, 76, 4331,
		8, 76, 1, 76, 1, 76, 1, 76, 1, 76, 3, 76, 4337, 8, 76, 1, 77, 1, 77, 1,
		77, 1, 77, 1, 77, 1, 77, 3, 77, 4345, 8, 77, 1, 77, 1, 77, 1, 77, 1, 77,
		1, 77, 3, 77, 4352, 8, 77, 1, 77, 3, 77, 4355, 8, 77, 1, 77, 1, 77, 3,
		77, 4359, 8, 77, 1, 78, 1, 78, 1, 78, 3, 78, 4364, 8, 78, 1, 78, 1, 78,
		1, 78, 3, 78, 4369, 8, 78, 1, 79, 1, 79, 1, 79, 1, 79, 1, 79, 3, 79, 4376,
		8, 79, 1, 79, 1, 79, 1, 79, 1, 79, 1, 79, 1, 79, 1, 79, 1, 79, 1, 79, 1,
		79, 3, 79, 4388, 8, 79, 1, 79, 1, 79, 1, 79, 1, 79, 3, 79, 4394, 8, 79,
		1, 80, 1, 80, 1, 80, 1, 80, 1, 80, 1, 80, 1, 80, 1, 80, 1, 80, 1, 80, 1,
		80, 1, 80, 3, 80, 4408, 8, 80, 1, 81, 3, 81, 4411, 8, 81, 1, 81, 1, 81,
		1, 81, 3, 81, 4416, 8, 81, 1, 81, 1, 81, 1, 81, 1, 81, 1, 81, 1, 81, 3,
		81, 4424, 8, 81, 1, 82, 3, 82, 4427, 8, 82, 1, 82, 1, 82, 1, 82, 3, 82,
		4432, 8, 82, 1, 82, 1, 82, 1, 82, 3, 82, 4437, 8, 82, 1, 82, 1, 82, 1,
		83, 1, 83, 1, 83, 1, 83, 5, 83, 4445, 8, 83, 10, 83, 12, 83, 4448, 9, 83,
		1, 83, 1, 83, 1, 84, 1, 84, 3, 84, 4454, 8, 84, 1, 85, 3, 85, 4457, 8,
		85, 1, 85, 3, 85, 4460, 8, 85, 1, 85, 1, 85, 1, 85, 1, 85, 1, 85, 1, 85,
		5, 85, 4468, 8, 85, 10, 85, 12, 85, 4471, 9, 85, 1, 85, 1, 85, 1, 85, 1,
		85, 1, 85, 3, 85, 4478, 8, 85, 1, 85, 1, 85, 1, 85, 1, 85, 3, 85, 4484,
		8, 85, 1, 85, 1, 85, 1, 85, 1, 85, 3, 85, 4490, 8, 85, 1, 85, 1, 85, 1,
		85, 3, 85, 4495, 8, 85, 1, 85, 1, 85, 1, 85, 3, 85, 4500, 8, 85, 1, 85,
		3, 85, 4503, 8, 85, 1, 85, 3, 85, 4506, 8, 85, 1, 85, 3, 85, 4509, 8, 85,
		1, 85, 3, 85, 4512, 8, 85, 1, 85, 3, 85, 4515, 8, 85, 1, 85, 3, 85, 4518,
		8, 85, 1, 85, 3, 85, 4521, 8, 85, 1, 85, 3, 85, 4524, 8, 85, 1, 85, 3,
		85, 4527, 8, 85, 1, 85, 3, 85, 4530, 8, 85, 1, 85, 1, 85, 1, 85, 1, 85,
		1, 85, 1, 85, 1, 85, 1, 85, 1, 85, 3, 85, 4541, 8, 85, 1, 85, 3, 85, 4544,
		8, 85, 1, 85, 3, 85, 4547, 8, 85, 1, 85, 3, 85, 4550, 8, 85, 1, 85, 3,
		85, 4553, 8, 85, 3, 85, 4555, 8, 85, 1, 86, 1, 86, 1, 87, 1, 87, 1, 87,
		1, 88, 1, 88, 1, 88, 1, 88, 1, 88, 1, 88, 1, 88, 3, 88, 4569, 8, 88, 1,
		89, 1, 89, 1, 89, 1, 89, 1, 89, 3, 89, 4576, 8, 89, 1, 90, 1, 90, 1, 91,
		1, 91, 3, 91, 4582, 8, 91, 1, 92, 1, 92, 3, 92, 4586, 8, 92, 1, 93, 1,
		93, 1, 93, 3, 93, 4591, 8, 93, 1, 94, 1, 94, 1, 94, 5, 94, 4596, 8, 94,
		10, 94, 12, 94, 4599, 9, 94, 1, 95, 1, 95, 3, 95, 4603, 8, 95, 1, 96, 1,
		96, 1, 96, 1, 96, 1, 96, 1, 96, 1, 96, 3, 96, 4612, 8, 96, 3, 96, 4614,
		8, 96, 1, 97, 1, 97, 1, 97, 1, 97, 3, 97, 4620, 8, 97, 1, 97, 3, 97, 4623,
		8, 97, 1, 98, 1, 98, 3, 98, 4627, 8, 98, 1, 98, 3, 98, 4630, 8, 98, 1,
		98, 3, 98, 4633, 8, 98, 1, 99, 1, 99, 1, 100, 1, 100, 1, 101, 1, 101, 1,
		101, 1, 101, 1, 102, 1, 102, 1, 102, 1, 102, 3, 102, 4647, 8, 102, 1, 103,
		1, 103, 1, 104, 1, 104, 1, 104, 1, 104, 1, 105, 1, 105, 1, 105, 1, 105,
		1, 106, 1, 106, 1, 106, 1, 106, 1, 107, 1, 107, 1, 107, 1, 107, 1, 107,
		1, 107, 1, 108, 1, 108, 1, 108, 1, 108, 1, 108, 5, 108, 4674, 8, 108, 10,
		108, 12, 108, 4677, 9, 108, 1, 108, 1, 108, 1, 109, 1, 109, 1, 109, 1,
		109, 1, 110, 1, 110, 1, 110, 1, 110, 1, 110, 1, 110, 1, 110, 1, 110, 1,
		110, 1, 110, 1, 110, 1, 110, 1, 110, 1, 110, 1, 110, 1, 110, 1, 110, 1,
		110, 1, 110, 1, 110, 1, 110, 1, 110, 1, 110, 1, 110, 1, 110, 1, 110, 3,
		110, 4711, 8, 110, 3, 110, 4713, 8, 110, 1, 111, 1, 111, 1, 111, 1, 111,
		1, 111, 1, 111, 1, 111, 3, 111, 4722, 8, 111, 1, 112, 1, 112, 3, 112, 4726,
		8, 112, 1, 112, 1, 112, 1, 112, 1, 112, 1, 112, 1, 112, 1, 112, 3, 112,
		4735, 8, 112, 1, 112, 1, 112, 1, 112, 1, 112, 3, 112, 4741, 8, 112, 1,
		112, 1, 112, 1, 112, 1, 112, 3, 112, 4747, 8, 112, 1, 112, 3, 112, 4750,
		8, 112, 1, 112, 3, 112, 4753, 8, 112, 1, 112, 3, 112, 4756, 8, 112, 1,
		112, 3, 112, 4759, 8, 112, 1, 113, 1, 113, 1, 113, 1, 113, 1, 113, 1, 113,
		3, 113, 4767, 8, 113, 1, 114, 1, 114, 1, 114, 1, 114, 1, 114, 1, 114, 3,
		114, 4775, 8, 114, 1, 114, 3, 114, 4778, 8, 114, 1, 115, 3, 115, 4781,
		8, 115, 1, 115, 1, 115, 1, 115, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116,
		1, 116, 3, 116, 4792, 8, 116, 1, 116, 1, 116, 1, 116, 1, 116, 3, 116, 4798,
		8, 116, 1, 116, 5, 116, 4801, 8, 116, 10, 116, 12, 116, 4804, 9, 116, 1,
		117, 1, 117, 1, 118, 1, 118, 1, 118, 1, 118, 1, 118, 1, 118, 3, 118, 4814,
		8, 118, 1, 119, 1, 119, 3, 119, 4818, 8, 119, 1, 119, 3, 119, 4821, 8,
		119, 1, 119, 3, 119, 4824, 8, 119, 1, 119, 3, 119, 4827, 8, 119, 1, 119,
		3, 119, 4830, 8, 119, 1, 119, 3, 119, 4833, 8, 119, 1, 119, 1, 119, 1,
		119, 3, 119, 4838, 8, 119, 1, 120, 1, 120, 1, 120, 1, 120, 5, 120, 4844,
		8, 120, 10, 120, 12, 120, 4847, 9, 120, 1, 121, 1, 121, 3, 121, 4851, 8,
		121, 1, 121, 1, 121, 1, 121, 1, 121, 1, 121, 1, 122, 1, 122, 1, 122, 1,
		122, 5, 122, 4862, 8, 122, 10, 122, 12, 122, 4865, 9, 122, 1, 122, 1, 122,
		1, 123, 1, 123, 3, 123, 4871, 8, 123, 1, 123, 1, 123, 1, 124, 1, 124, 1,
		125, 1, 125, 1, 125, 1, 126, 1, 126, 1, 126, 1, 127, 3, 127, 4884, 8, 127,
		1, 127, 1, 127, 1, 127, 3, 127, 4889, 8, 127, 1, 127, 1, 127, 1, 127, 3,
		127, 4894, 8, 127, 5, 127, 4896, 8, 127, 10, 127, 12, 127, 4899, 9, 127,
		1, 128, 1, 128, 1, 128, 1, 129, 1, 129, 1, 129, 1, 129, 1, 129, 1, 130,
		1, 130, 1, 130, 5, 130, 4912, 8, 130, 10, 130, 12, 130, 4915, 9, 130, 1,
		131, 1, 131, 5, 131, 4919, 8, 131, 10, 131, 12, 131, 4922, 9, 131, 1, 132,
		1, 132, 1, 132, 3, 132, 4927, 8, 132, 1, 132, 1, 132, 3, 132, 4931, 8,
		132, 1, 133, 1, 133, 1, 133, 1, 133, 1, 133, 1, 133, 1, 133, 1, 133, 3,
		133, 4941, 8, 133, 1, 134, 1, 134, 1, 134, 1, 134, 5, 134, 4947, 8, 134,
		10, 134, 12, 134, 4950, 9, 134, 1, 134, 1, 134, 1, 134, 1, 134, 1, 134,
		1, 134, 5, 134, 4958, 8, 134, 10, 134, 12, 134, 4961, 9, 134, 1, 134, 1,
		134, 3, 134, 4965, 8, 134, 1, 135, 1, 135, 1, 135, 1, 135, 1, 136, 1, 136,
		1, 136, 1, 136, 1, 136, 5, 136, 4976, 8, 136, 10, 136, 12, 136, 4979, 9,
		136, 3, 136, 4981, 8, 136, 1, 136, 1, 136, 1, 136, 1, 136, 1, 136, 1, 136,
		5, 136, 4989, 8, 136, 10, 136, 12, 136, 4992, 9, 136, 3, 136, 4994, 8,
		136, 1, 136, 1, 136, 1, 136, 1, 136, 1, 136, 1, 136, 1, 136, 5, 136, 5003,
		8, 136, 10, 136, 12, 136, 5006, 9, 136, 1, 136, 1, 136, 1, 136, 1, 136,
		1, 136, 5, 136, 5013, 8, 136, 10, 136, 12, 136, 5016, 9, 136, 1, 136, 1,
		136, 3, 136, 5020, 8, 136, 3, 136, 5022, 8, 136, 1, 137, 1, 137, 1, 137,
		1, 137, 5, 137, 5028, 8, 137, 10, 137, 12, 137, 5031, 9, 137, 3, 137, 5033,
		8, 137, 1, 137, 1, 137, 1, 138, 1, 138, 1, 138, 1, 139, 1, 139, 1, 139,
		1, 140, 1, 140, 3, 140, 5045, 8, 140, 1, 140, 5, 140, 5048, 8, 140, 10,
		140, 12, 140, 5051, 9, 140, 1, 140, 1, 140, 1, 141, 1, 141, 1, 141, 1,
		141, 3, 141, 5059, 8, 141, 1, 141, 5, 141, 5062, 8, 141, 10, 141, 12, 141,
		5065, 9, 141, 1, 141, 1, 141, 3, 141, 5069, 8, 141, 1, 141, 1, 141, 1,
		141, 1, 141, 1, 141, 5, 141, 5076, 8, 141, 10, 141, 12, 141, 5079, 9, 141,
		1, 141, 1, 141, 3, 141, 5083, 8, 141, 3, 141, 5085, 8, 141, 1, 142, 1,
		142, 1, 142, 1, 142, 3, 142, 5091, 8, 142, 3, 142, 5093, 8, 142, 1, 142,
		3, 142, 5096, 8, 142, 1, 143, 1, 143, 1, 143, 1, 143, 3, 143, 5102, 8,
		143, 1, 144, 1, 144, 1, 144, 5, 144, 5107, 8, 144, 10, 144, 12, 144, 5110,
		9, 144, 1, 145, 1, 145, 1, 145, 1, 145, 1, 145, 1, 145, 1, 145, 5, 145,
		5119, 8, 145, 10, 145, 12, 145, 5122, 9, 145, 3, 145, 5124, 8, 145, 1,
		145, 1, 145, 1, 145, 1, 145, 1, 145, 1, 145, 5, 145, 5132, 8, 145, 10,
		145, 12, 145, 5135, 9, 145, 1, 146, 3, 146, 5138, 8, 146, 1, 146, 3, 146,
		5141, 8, 146, 1, 147, 1, 147, 1, 147, 1, 147, 1, 147, 5, 147, 5148, 8,
		147, 10, 147, 12, 147, 5151, 9, 147, 1, 148, 1, 148, 3, 148, 5155, 8, 148,
		1, 148, 1, 148, 3, 148, 5159, 8, 148, 1, 149, 1, 149, 1, 149, 1, 149, 1,
		149, 1, 149, 1, 149, 1, 149, 1, 149, 1, 149, 3, 149, 5171, 8, 149, 1, 150,
		1, 150, 1, 150, 1, 150, 1, 150, 5, 150, 5178, 8, 150, 10, 150, 12, 150,
		5181, 9, 150, 1, 151, 3, 151, 5184, 8, 151, 1, 151, 1, 151, 1, 151, 3,
		151, 5189, 8, 151, 1, 151, 1, 151, 3, 151, 5193, 8, 151, 1, 151, 1, 151,
		3, 151, 5197, 8, 151, 1, 151, 1, 151, 1, 151, 1, 151, 1, 151, 1, 151, 1,
		151, 1, 151, 3, 151, 5207, 8, 151, 1, 152, 1, 152, 1, 152, 1, 152, 3, 152,
		5213, 8, 152, 1, 153, 1, 153, 1, 153, 1, 153, 1, 154, 1, 154, 1, 154, 5,
		154, 5222, 8, 154, 10, 154, 12, 154, 5225, 9, 154, 1, 155, 1, 155, 1, 155,
		1, 155, 1, 155, 3, 155, 5232, 8, 155, 1, 155, 1, 155, 1, 156, 1, 156, 3,
		156, 5238, 8, 156, 1, 156, 3, 156, 5241, 8, 156, 1, 156, 3, 156, 5244,
		8, 156, 1, 156, 3, 156, 5247, 8, 156, 1, 156, 3, 156, 5250, 8, 156, 1,
		156, 1, 156, 3, 156, 5254, 8, 156, 1, 156, 3, 156, 5257, 8, 156, 1, 156,
		5, 156, 5260, 8, 156, 10, 156, 12, 156, 5263, 9, 156, 1, 156, 1, 156, 1,
		156, 1, 156, 1, 156, 5, 156, 5270, 8, 156, 10, 156, 12, 156, 5273, 9, 156,
		1, 156, 1, 156, 1, 156, 3, 156, 5278, 8, 156, 1, 156, 1, 156, 1, 156, 1,
		156, 1, 156, 1, 156, 1, 156, 3, 156, 5287, 8, 156, 1, 157, 1, 157, 1, 157,
		1, 158, 1, 158, 1, 158, 1, 158, 1, 158, 1, 159, 1, 159, 1, 159, 5, 159,
		5300, 8, 159, 10, 159, 12, 159, 5303, 9, 159, 1, 160, 1, 160, 1, 160, 1,
		160, 1, 161, 1, 161, 3, 161, 5311, 8, 161, 1, 162, 1, 162, 3, 162, 5315,
		8, 162, 1, 163, 3, 163, 5318, 8, 163, 1, 163, 1, 163, 3, 163, 5322, 8,
		163, 3, 163, 5324, 8, 163, 1, 164, 1, 164, 1, 164, 5, 164, 5329, 8, 164,
		10, 164, 12, 164, 5332, 9, 164, 1, 165, 1, 165, 1, 165, 5, 165, 5337, 8,
		165, 10, 165, 12, 165, 5340, 9, 165, 1, 166, 1, 166, 1, 166, 3, 166, 5345,
		8, 166, 1, 167, 1, 167, 1, 167, 5, 167, 5350, 8, 167, 10, 167, 12, 167,
		5353, 9, 167, 1, 168, 1, 168, 1, 168, 3, 168, 5358, 8, 168, 1, 168, 3,
		168, 5361, 8, 168, 1, 168, 1, 168, 3, 168, 5365, 8, 168, 1, 168, 1, 168,
		1, 168, 1, 168, 1, 168, 3, 168, 5372, 8, 168, 1, 168, 3, 168, 5375, 8,
		168, 1, 168, 3, 168, 5378, 8, 168, 1, 168, 1, 168, 1, 168, 1, 168, 1, 168,
		3, 168, 5385, 8, 168, 3, 168, 5387, 8, 168, 1, 168, 1, 168, 1, 168, 3,
		168, 5392, 8, 168, 1, 168, 1, 168, 3, 168, 5396, 8, 168, 1, 168, 1, 168,
		1, 168, 1, 168, 1, 168, 1, 168, 1, 168, 1, 168, 1, 168, 1, 168, 1, 168,
		3, 168, 5409, 8, 168, 3, 168, 5411, 8, 168, 3, 168, 5413, 8, 168, 1, 168,
		1, 168, 1, 168, 1, 168, 1, 168, 1, 168, 1, 168, 3, 168, 5422, 8, 168, 3,
		168, 5424, 8, 168, 1, 168, 1, 168, 3, 168, 5428, 8, 168, 1, 169, 1, 169,
		1, 169, 5, 169, 5433, 8, 169, 10, 169, 12, 169, 5436, 9, 169, 1, 170, 1,
		170, 1, 170, 1, 170, 3, 170, 5442, 8, 170, 1, 170, 1, 170, 1, 170, 1, 170,
		3, 170, 5448, 8, 170, 1, 170, 1, 170, 1, 170, 1, 170, 1, 170, 3, 170, 5455,
		8, 170, 1, 170, 1, 170, 3, 170, 5459, 8, 170, 1, 171, 1, 171, 1, 171, 5,
		171, 5464, 8, 171, 10, 171, 12, 171, 5467, 9, 171, 1, 172, 1, 172, 1, 172,
		1, 172, 3, 172, 5473, 8, 172, 1, 172, 1, 172, 1, 172, 1, 172, 3, 172, 5479,
		8, 172, 1, 173, 1, 173, 1, 173, 1, 173, 3, 173, 5485, 8, 173, 1, 173, 1,
		173, 1, 173, 1, 173, 1, 173, 1, 173, 3, 173, 5493, 8, 173, 1, 174, 1, 174,
		1, 174, 1, 174, 3, 174, 5499, 8, 174, 1, 174, 1, 174, 1, 174, 1, 174, 1,
		174, 1, 174, 1, 174, 1, 174, 1, 175, 1, 175, 1, 175, 1, 175, 1, 175, 1,
		175, 1, 175, 3, 175, 5516, 8, 175, 1, 176, 1, 176, 1, 176, 1, 176, 3, 176,
		5522, 8, 176, 1, 176, 1, 176, 1, 176, 1, 176, 1, 176, 1, 176, 1, 176, 5,
		176, 5531, 8, 176, 10, 176, 12, 176, 5534, 9, 176, 1, 176, 1, 176, 1, 176,
		3, 176, 5539, 8, 176, 3, 176, 5541, 8, 176, 1, 177, 1, 177, 1, 177, 1,
		177, 5, 177, 5547, 8, 177, 10, 177, 12, 177, 5550, 9, 177, 1, 177, 1, 177,
		1, 178, 3, 178, 5555, 8, 178, 1, 178, 1, 178, 1, 178, 1, 178, 3, 178, 5561,
		8, 178, 1, 179, 1, 179, 1, 179, 5, 179, 5566, 8, 179, 10, 179, 12, 179,
		5569, 9, 179, 1, 180, 1, 180, 1, 180, 1, 180, 1, 180, 3, 180, 5576, 8,
		180, 1, 180, 3, 180, 5579, 8, 180, 1, 181, 1, 181, 1, 182, 1, 182, 1, 182,
		1, 182, 1, 182, 5, 182, 5588, 8, 182, 10, 182, 12, 182, 5591, 9, 182, 1,
		182, 1, 182, 1, 183, 1, 183, 1, 183, 1, 183, 5, 183, 5599, 8, 183, 10,
		183, 12, 183, 5602, 9, 183, 1, 184, 1, 184, 3, 184, 5606, 8, 184, 1, 184,
		3, 184, 5609, 8, 184, 1, 185, 1, 185, 1, 185, 5, 185, 5614, 8, 185, 10,
		185, 12, 185, 5617, 9, 185, 1, 186, 1, 186, 3, 186, 5621, 8, 186, 1, 187,
		1, 187, 1, 187, 1, 187, 1, 187, 1, 187, 1, 187, 1, 187, 4, 187, 5631, 8,
		187, 11, 187, 12, 187, 5632, 1, 187, 1, 187, 1, 187, 1, 187, 3, 187, 5639,
		8, 187, 1, 188, 1, 188, 1, 188, 1, 188, 1, 188, 1, 188, 1, 188, 1, 188,
		1, 188, 1, 188, 1, 188, 1, 188, 1, 188, 1, 188, 1, 188, 1, 188, 1, 188,
		1, 188, 1, 188, 1, 188, 3, 188, 5661, 8, 188, 1, 188, 1, 188, 3, 188, 5665,
		8, 188, 1, 188, 1, 188, 1, 188, 1, 188, 1, 188, 1, 188, 1, 188, 1, 188,
		1, 188, 1, 188, 1, 188, 1, 188, 5, 188, 5679, 8, 188, 10, 188, 12, 188,
		5682, 9, 188, 1, 189, 1, 189, 1, 189, 1, 189, 5, 189, 5688, 8, 189, 10,
		189, 12, 189, 5691, 9, 189, 3, 189, 5693, 8, 189, 1, 189, 1, 189, 1, 190,
		1, 190, 1, 190, 3, 190, 5700, 8, 190, 1, 191, 3, 191, 5703, 8, 191, 1,
		191, 1, 191, 1, 191, 1, 191, 1, 191, 1, 191, 3, 191, 5711, 8, 191, 1, 191,
		1, 191, 1, 191, 3, 191, 5716, 8, 191, 1, 191, 1, 191, 1, 191, 1, 191, 3,
		191, 5722, 8, 191, 1, 191, 3, 191, 5725, 8, 191, 1, 191, 1, 191, 1, 191,
		3, 191, 5730, 8, 191, 1, 191, 1, 191, 1, 191, 1, 191, 1, 191, 1, 191, 3,
		191, 5738, 8, 191, 1, 191, 1, 191, 1, 191, 1, 191, 1, 191, 5, 191, 5745,
		8, 191, 10, 191, 12, 191, 5748, 9, 191, 1, 191, 1, 191, 1, 191, 1, 191,
		3, 191, 5754, 8, 191, 1, 191, 1, 191, 1, 191, 3, 191, 5759, 8, 191, 1,
		191, 3, 191, 5762, 8, 191, 1, 192, 1, 192, 1, 192, 1, 192, 3, 192, 5768,
		8, 192, 1, 192, 1, 192, 1, 192, 1, 192, 1, 192, 1, 192, 1, 192, 1, 192,
		1, 192, 1, 192, 1, 192, 1, 192, 1, 192, 1, 192, 1, 192, 1, 192, 1, 192,
		1, 192, 1, 192, 5, 192, 5789, 8, 192, 10, 192, 12, 192, 5792, 9, 192, 1,
		193, 1, 193, 1, 193, 1, 193, 1, 193, 1, 193, 1, 193, 1, 193, 1, 193, 1,
		193, 4, 193, 5804, 8, 193, 11, 193, 12, 193, 5805, 1, 193, 1, 193, 3, 193,
		5810, 8, 193, 1, 193, 1, 193, 1, 193, 1, 193, 1, 193, 4, 193, 5817, 8,
		193, 11, 193, 12, 193, 5818, 1, 193, 1, 193, 3, 193, 5823, 8, 193, 1, 193,
		1, 193, 1, 193, 1, 193, 1, 193, 1, 193, 1, 193, 1, 193, 1, 193, 1, 193,
		1, 193, 1, 193, 1, 193, 5, 193, 5838, 8, 193, 10, 193, 12, 193, 5841, 9,
		193, 1, 193, 1, 193, 1, 193, 1, 193, 5, 193, 5847, 8, 193, 10, 193, 12,
		193, 5850, 9, 193, 1, 193, 1, 193, 1, 193, 1, 193, 1, 193, 5, 193, 5857,
		8, 193, 10, 193, 12, 193, 5860, 9, 193, 1, 193, 1, 193, 3, 193, 5864, 8,
		193, 1, 193, 1, 193, 1, 193, 1, 193, 1, 193, 1, 193, 1, 193, 1, 193, 1,
		193, 1, 193, 1, 193, 1, 193, 1, 193, 1, 193, 1, 193, 1, 193, 1, 193, 1,
		193, 1, 193, 1, 193, 1, 193, 1, 193, 1, 193, 1, 193, 1, 193, 1, 193, 3,
		193, 5892, 8, 193, 1, 193, 1, 193, 3, 193, 5896, 8, 193, 1, 193, 1, 193,
		1, 193, 1, 193, 1, 193, 1, 193, 1, 193, 1, 193, 1, 193, 3, 193, 5907, 8,
		193, 1, 193, 1, 193, 1, 193, 1, 193, 1, 193, 1, 193, 3, 193, 5915, 8, 193,
		1, 193, 1, 193, 1, 193, 3, 193, 5920, 8, 193, 1, 193, 1, 193, 1, 193, 1,
		193, 1, 193, 1, 193, 1, 193, 1, 193, 1, 193, 1, 193, 3, 193, 5932, 8, 193,
		1, 193, 1, 193, 1, 193, 1, 193, 1, 193, 1, 193, 1, 193, 1, 193, 1, 193,
		1, 193, 3, 193, 5944, 8, 193, 5, 193, 5946, 8, 193, 10, 193, 12, 193, 5949,
		9, 193, 1, 194, 1, 194, 1, 194, 1, 194, 1, 194, 1, 194, 1, 194, 1, 194,
		1, 194, 1, 194, 3, 194, 5961, 8, 194, 1, 195, 1, 195, 1, 195, 3, 195, 5966,
		8, 195, 3, 195, 5968, 8, 195, 1, 196, 1, 196, 1, 196, 3, 196, 5973, 8,
		196, 1, 196, 1, 196, 1, 196, 5, 196, 5978, 8, 196, 10, 196, 12, 196, 5981,
		9, 196, 1, 196, 1, 196, 1, 196, 1, 196, 1, 196, 5, 196, 5988, 8, 196, 10,
		196, 12, 196, 5991, 9, 196, 3, 196, 5993, 8, 196, 3, 196, 5995, 8, 196,
		1, 196, 1, 196, 1, 196, 3, 196, 6000, 8, 196, 1, 197, 1, 197, 1, 197, 3,
		197, 6005, 8, 197, 1, 197, 1, 197, 1, 198, 1, 198, 1, 198, 1, 198, 1, 198,
		1, 198, 1, 198, 1, 198, 1, 198, 1, 198, 1, 198, 1, 198, 1, 198, 1, 198,
		1, 198, 1, 198, 3, 198, 6025, 8, 198, 1, 199, 1, 199, 3, 199, 6029, 8,
		199, 1, 199, 3, 199, 6032, 8, 199, 1, 199, 3, 199, 6035, 8, 199, 1, 199,
		1, 199, 1, 200, 1, 200, 1, 200, 1, 200, 1, 200, 1, 200, 1, 200, 1, 200,
		1, 200, 3, 200, 6048, 8, 200, 1, 201, 1, 201, 1, 202, 1, 202, 1, 202, 1,
		202, 1, 202, 1, 202, 1, 202, 3, 202, 6059, 8, 202, 1, 203, 1, 203, 1, 203,
		5, 203, 6064, 8, 203, 10, 203, 12, 203, 6067, 9, 203, 1, 204, 3, 204, 6070,
		8, 204, 1, 204, 1, 204, 1, 204, 3, 204, 6075, 8, 204, 1, 204, 3, 204, 6078,
		8, 204, 1, 204, 1, 204, 3, 204, 6082, 8, 204, 1, 205, 1, 205, 1, 205, 1,
		205, 1, 205, 1, 205, 3, 205, 6090, 8, 205, 1, 205, 1, 205, 1, 205, 3, 205,
		6095, 8, 205, 1, 205, 1, 205, 5, 205, 6099, 8, 205, 10, 205, 12, 205, 6102,
		9, 205, 1, 205, 1, 205, 1, 205, 1, 205, 1, 205, 1, 205, 3, 205, 6110, 8,
		205, 1, 205, 1, 205, 1, 205, 1, 205, 1, 205, 5, 205, 6117, 8, 205, 10,
		205, 12, 205, 6120, 9, 205, 1, 205, 1, 205, 1, 205, 1, 205, 1, 205, 5,
		205, 6127, 8, 205, 10, 205, 12, 205, 6130, 9, 205, 1, 205, 1, 205, 1, 205,
		3, 205, 6135, 8, 205, 1, 206, 1, 206, 1, 207, 1, 207, 1, 208, 1, 208, 1,
		208, 1, 208, 1, 208, 1, 209, 1, 209, 1, 209, 1, 209, 1, 210, 1, 210, 1,
		211, 1, 211, 3, 211, 6154, 8, 211, 1, 211, 3, 211, 6157, 8, 211, 1, 212,
		1, 212, 1, 212, 1, 212, 1, 212, 1, 212, 1, 212, 1, 212, 1, 212, 1, 212,
		1, 212, 1, 212, 1, 212, 1, 212, 1, 212, 1, 212, 1, 212, 1, 212, 1, 212,
		1, 212, 1, 212, 1, 212, 1, 212, 1, 212, 5, 212, 6183, 8, 212, 10, 212,
		12, 212, 6186, 9, 212, 1, 212, 1, 212, 1, 212, 1, 212, 1, 212, 1, 212,
		1, 212, 1, 212, 5, 212, 6196, 8, 212, 10, 212, 12, 212, 6199, 9, 212, 1,
		212, 3, 212, 6202, 8, 212, 3, 212, 6204, 8, 212, 1, 213, 1, 213, 1, 213,
		1, 213, 1, 213, 1, 213, 1, 213, 1, 213, 1, 213, 1, 213, 1, 213, 1, 213,
		1, 213, 1, 213, 1, 213, 1, 213, 1, 213, 1, 213, 1, 213, 1, 213, 1, 213,
		1, 213, 1, 213, 1, 213, 1, 213, 1, 213, 1, 213, 1, 213, 1, 213, 1, 213,
		1, 213, 1, 213, 3, 213, 6238, 8, 213, 1, 214, 1, 214, 1, 214, 5, 214, 6243,
		8, 214, 10, 214, 12, 214, 6246, 9, 214, 1, 215, 1, 215, 1, 215, 1, 215,
		3, 215, 6252, 8, 215, 1, 216, 1, 216, 1, 216, 1, 217, 1, 217, 1, 217, 3,
		217, 6260, 8, 217, 1, 217, 1, 217, 1, 217, 3, 217, 6265, 8, 217, 1, 218,
		1, 218, 1, 218, 1, 218, 3, 218, 6271, 8, 218, 1, 219, 1, 219, 1, 219, 1,
		219, 1, 219, 1, 219, 1, 219, 1, 219, 1, 219, 1, 219, 3, 219, 6283, 8, 219,
		1, 220, 1, 220, 1, 220, 1, 221, 1, 221, 4, 221, 6290, 8, 221, 11, 221,
		12, 221, 6291, 1, 221, 3, 221, 6295, 8, 221, 1, 222, 1, 222, 1, 223, 1,
		223, 1, 223, 3, 223, 6302, 8, 223, 1, 224, 1, 224, 1, 225, 3, 225, 6307,
		8, 225, 1, 225, 1, 225, 3, 225, 6311, 8, 225, 1, 225, 3, 225, 6314, 8,
		225, 1, 226, 1, 226, 1, 226, 2, 530, 537, 4, 232, 376, 384, 386, 227, 0,
		2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38,
		40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74,
		76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108,
		110, 112, 114, 116, 118, 120, 122, 124, 126, 128, 130, 132, 134, 136, 138,
		140, 142, 144, 146, 148, 150, 152, 154, 156, 158, 160, 162, 164, 166, 168,
		170, 172, 174, 176, 178, 180, 182, 184, 186, 188, 190, 192, 194, 196, 198,
		200, 202, 204, 206, 208, 210, 212, 214, 216, 218, 220, 222, 224, 226, 228,
		230, 232, 234, 236, 238, 240, 242, 244, 246, 248, 250, 252, 254, 256, 258,
		260, 262, 264, 266, 268, 270, 272, 274, 276, 278, 280, 282, 284, 286, 288,
		290, 292, 294, 296, 298, 300, 302, 304, 306, 308, 310, 312, 314, 316, 318,
		320, 322, 324, 326, 328, 330, 332, 334, 336, 338, 340, 342, 344, 346, 348,
		350, 352, 354, 356, 358, 360, 362, 364, 366, 368, 370, 372, 374, 376, 378,
		380, 382, 384, 386, 388, 390, 392, 394, 396, 398, 400, 402, 404, 406, 408,
		410, 412, 414, 416, 418, 420, 422, 424, 426, 428, 430, 432, 434, 436, 438,
		440, 442, 444, 446, 448, 450, 452, 0, 62, 1, 0, 355, 356, 2, 0, 197, 197,
		356, 356, 2, 0, 36, 36, 194, 194, 2, 0, 33, 33, 549, 549, 2, 0, 175, 175,
		459, 459, 3, 0, 18, 18, 151, 151, 484, 484, 2, 0, 193, 193, 225, 225, 2,
		0, 341, 341, 392, 392, 3, 0, 47, 47, 239, 239, 308, 308, 2, 0, 18, 18,
		452, 452, 2, 0, 113, 113, 412, 412, 2, 0, 253, 253, 494, 494, 3, 0, 112,
		112, 386, 386, 470, 470, 1, 0, 500, 501, 2, 0, 163, 163, 507, 507, 2, 0,
		82, 82, 181, 181, 2, 0, 114, 114, 413, 413, 2, 0, 227, 228, 253, 254, 2,
		0, 544, 544, 549, 549, 2, 0, 168, 168, 318, 318, 3, 0, 27, 27, 129, 129,
		292, 292, 1, 0, 147, 148, 3, 0, 122, 122, 219, 219, 298, 298, 2, 0, 225,
		225, 467, 467, 4, 0, 56, 56, 211, 211, 272, 272, 408, 408, 3, 0, 121, 121,
		218, 218, 414, 414, 1, 0, 11, 12, 2, 0, 319, 319, 515, 515, 1, 0, 330,
		331, 2, 0, 270, 270, 369, 369, 3, 0, 201, 201, 272, 272, 418, 418, 2, 0,
		128, 128, 224, 224, 2, 0, 33, 33, 87, 87, 5, 0, 150, 150, 204, 204, 345,
		345, 472, 472, 502, 502, 2, 0, 131, 132, 172, 172, 10, 0, 20, 20, 23, 23,
		141, 141, 277, 277, 291, 291, 321, 321, 329, 329, 342, 342, 398, 398, 423,
		423, 3, 0, 167, 167, 296, 296, 483, 483, 2, 0, 20, 20, 138, 138, 2, 0,
		310, 310, 492, 492, 2, 0, 30, 30, 131, 131, 2, 0, 184, 184, 259, 259, 8,
		0, 49, 49, 200, 200, 215, 215, 289, 289, 295, 295, 362, 362, 383, 384,
		446, 446, 1, 0, 245, 246, 2, 0, 25, 25, 532, 532, 2, 0, 378, 378, 400,
		400, 1, 0, 281, 287, 2, 0, 178, 178, 475, 475, 2, 0, 525, 526, 530, 530,
		2, 0, 143, 143, 527, 529, 1, 0, 525, 526, 2, 0, 201, 201, 418, 418, 2,
		0, 115, 115, 465, 465, 2, 0, 425, 425, 487, 487, 1, 0, 233, 234, 2, 0,
		369, 369, 407, 407, 2, 0, 187, 187, 352, 352, 4, 0, 115, 115, 118, 118,
		120, 120, 465, 465, 1, 0, 518, 524, 8, 0, 121, 121, 218, 218, 297, 297,
		300, 300, 367, 367, 414, 414, 508, 508, 517, 517, 2, 0, 527, 527, 549,
		549, 1, 0, 550, 551, 98, 0, 9, 10, 13, 13, 16, 19, 23, 23, 28, 28, 31,
		32, 34, 35, 37, 40, 43, 43, 46, 60, 62, 64, 68, 73, 75, 76, 78, 80, 82,
		94, 96, 100, 102, 103, 107, 112, 115, 125, 128, 128, 130, 130, 133, 136,
		139, 140, 144, 145, 149, 149, 152, 153, 155, 161, 163, 166, 168, 168, 171,
		171, 175, 175, 177, 177, 179, 184, 191, 192, 195, 195, 197, 197, 199, 201,
		204, 204, 206, 209, 211, 213, 215, 221, 223, 224, 226, 226, 228, 228, 239,
		242, 244, 249, 251, 252, 256, 256, 259, 259, 261, 262, 264, 265, 268, 269,
		272, 277, 279, 280, 282, 289, 291, 295, 297, 303, 305, 309, 311, 311, 314,
		314, 316, 317, 319, 321, 328, 329, 331, 343, 345, 345, 347, 351, 355, 355,
		357, 368, 373, 376, 382, 385, 387, 396, 398, 398, 400, 400, 403, 405, 408,
		412, 414, 414, 417, 419, 422, 423, 426, 426, 428, 432, 434, 446, 452, 452,
		456, 459, 461, 462, 464, 465, 470, 470, 472, 473, 476, 477, 479, 479, 481,
		481, 485, 486, 488, 488, 491, 491, 494, 494, 496, 508, 513, 513, 517, 517,
		539, 541, 7467, 0, 457, 1, 0, 0, 0, 2, 485, 1, 0, 0, 0, 4, 573, 1, 0, 0,
		0, 6, 606, 1, 0, 0, 0, 8, 612, 1, 0, 0, 0, 10, 753, 1, 0, 0, 0, 12, 823,
		1, 0, 0, 0, 14, 844, 1, 0, 0, 0, 16, 996, 1, 0, 0, 0, 18, 1486, 1, 0, 0,
		0, 20, 1488, 1, 0, 0, 0, 22, 1496, 1, 0, 0, 0, 24, 1711, 1, 0, 0, 0, 26,
		1914, 1, 0, 0, 0, 28, 2614, 1, 0, 0, 0, 30, 2687, 1, 0, 0, 0, 32, 2697,
		1, 0, 0, 0, 34, 2797, 1, 0, 0, 0, 36, 2799, 1, 0, 0, 0, 38, 2806, 1, 0,
		0, 0, 40, 2812, 1, 0, 0, 0, 42, 2827, 1, 0, 0, 0, 44, 2877, 1, 0, 0, 0,
		46, 2889, 1, 0, 0, 0, 48, 2891, 1, 0, 0, 0, 50, 2895, 1, 0, 0, 0, 52, 2899,
		1, 0, 0, 0, 54, 2902, 1, 0, 0, 0, 56, 2906, 1, 0, 0, 0, 58, 2931, 1, 0,
		0, 0, 60, 2958, 1, 0, 0, 0, 62, 2983, 1, 0, 0, 0, 64, 3073, 1, 0, 0, 0,
		66, 3230, 1, 0, 0, 0, 68, 3265, 1, 0, 0, 0, 70, 3267, 1, 0, 0, 0, 72, 3276,
		1, 0, 0, 0, 74, 3300, 1, 0, 0, 0, 76, 3344, 1, 0, 0, 0, 78, 3432, 1, 0,
		0, 0, 80, 3439, 1, 0, 0, 0, 82, 3441, 1, 0, 0, 0, 84, 3547, 1, 0, 0, 0,
		86, 3549, 1, 0, 0, 0, 88, 3553, 1, 0, 0, 0, 90, 3790, 1, 0, 0, 0, 92, 3811,
		1, 0, 0, 0, 94, 3832, 1, 0, 0, 0, 96, 3838, 1, 0, 0, 0, 98, 3847, 1, 0,
		0, 0, 100, 3855, 1, 0, 0, 0, 102, 3872, 1, 0, 0, 0, 104, 3874, 1, 0, 0,
		0, 106, 3877, 1, 0, 0, 0, 108, 3880, 1, 0, 0, 0, 110, 3888, 1, 0, 0, 0,
		112, 3899, 1, 0, 0, 0, 114, 3901, 1, 0, 0, 0, 116, 3904, 1, 0, 0, 0, 118,
		4047, 1, 0, 0, 0, 120, 4067, 1, 0, 0, 0, 122, 4087, 1, 0, 0, 0, 124, 4089,
		1, 0, 0, 0, 126, 4103, 1, 0, 0, 0, 128, 4105, 1, 0, 0, 0, 130, 4113, 1,
		0, 0, 0, 132, 4119, 1, 0, 0, 0, 134, 4134, 1, 0, 0, 0, 136, 4176, 1, 0,
		0, 0, 138, 4178, 1, 0, 0, 0, 140, 4232, 1, 0, 0, 0, 142, 4234, 1, 0, 0,
		0, 144, 4286, 1, 0, 0, 0, 146, 4307, 1, 0, 0, 0, 148, 4309, 1, 0, 0, 0,
		150, 4312, 1, 0, 0, 0, 152, 4336, 1, 0, 0, 0, 154, 4358, 1, 0, 0, 0, 156,
		4360, 1, 0, 0, 0, 158, 4393, 1, 0, 0, 0, 160, 4407, 1, 0, 0, 0, 162, 4423,
		1, 0, 0, 0, 164, 4426, 1, 0, 0, 0, 166, 4440, 1, 0, 0, 0, 168, 4453, 1,
		0, 0, 0, 170, 4554, 1, 0, 0, 0, 172, 4556, 1, 0, 0, 0, 174, 4558, 1, 0,
		0, 0, 176, 4568, 1, 0, 0, 0, 178, 4570, 1, 0, 0, 0, 180, 4577, 1, 0, 0,
		0, 182, 4581, 1, 0, 0, 0, 184, 4585, 1, 0, 0, 0, 186, 4590, 1, 0, 0, 0,
		188, 4592, 1, 0, 0, 0, 190, 4602, 1, 0, 0, 0, 192, 4604, 1, 0, 0, 0, 194,
		4615, 1, 0, 0, 0, 196, 4624, 1, 0, 0, 0, 198, 4634, 1, 0, 0, 0, 200, 4636,
		1, 0, 0, 0, 202, 4638, 1, 0, 0, 0, 204, 4646, 1, 0, 0, 0, 206, 4648, 1,
		0, 0, 0, 208, 4650, 1, 0, 0, 0, 210, 4654, 1, 0, 0, 0, 212, 4658, 1, 0,
		0, 0, 214, 4662, 1, 0, 0, 0, 216, 4668, 1, 0, 0, 0, 218, 4680, 1, 0, 0,
		0, 220, 4712, 1, 0, 0, 0, 222, 4714, 1, 0, 0, 0, 224, 4723, 1, 0, 0, 0,
		226, 4766, 1, 0, 0, 0, 228, 4768, 1, 0, 0, 0, 230, 4780, 1, 0, 0, 0, 232,
		4785, 1, 0, 0, 0, 234, 4805, 1, 0, 0, 0, 236, 4813, 1, 0, 0, 0, 238, 4815,
		1, 0, 0, 0, 240, 4839, 1, 0, 0, 0, 242, 4848, 1, 0, 0, 0, 244, 4857, 1,
		0, 0, 0, 246, 4868, 1, 0, 0, 0, 248, 4874, 1, 0, 0, 0, 250, 4876, 1, 0,
		0, 0, 252, 4879, 1, 0, 0, 0, 254, 4883, 1, 0, 0, 0, 256, 4900, 1, 0, 0,
		0, 258, 4903, 1, 0, 0, 0, 260, 4908, 1, 0, 0, 0, 262, 4916, 1, 0, 0, 0,
		264, 4923, 1, 0, 0, 0, 266, 4940, 1, 0, 0, 0, 268, 4964, 1, 0, 0, 0, 270,
		4966, 1, 0, 0, 0, 272, 5021, 1, 0, 0, 0, 274, 5023, 1, 0, 0, 0, 276, 5036,
		1, 0, 0, 0, 278, 5039, 1, 0, 0, 0, 280, 5042, 1, 0, 0, 0, 282, 5084, 1,
		0, 0, 0, 284, 5095, 1, 0, 0, 0, 286, 5097, 1, 0, 0, 0, 288, 5103, 1, 0,
		0, 0, 290, 5111, 1, 0, 0, 0, 292, 5137, 1, 0, 0, 0, 294, 5142, 1, 0, 0,
		0, 296, 5152, 1, 0, 0, 0, 298, 5170, 1, 0, 0, 0, 300, 5172, 1, 0, 0, 0,
		302, 5206, 1, 0, 0, 0, 304, 5212, 1, 0, 0, 0, 306, 5214, 1, 0, 0, 0, 308,
		5218, 1, 0, 0, 0, 310, 5226, 1, 0, 0, 0, 312, 5286, 1, 0, 0, 0, 314, 5288,
		1, 0, 0, 0, 316, 5291, 1, 0, 0, 0, 318, 5296, 1, 0, 0, 0, 320, 5304, 1,
		0, 0, 0, 322, 5310, 1, 0, 0, 0, 324, 5314, 1, 0, 0, 0, 326, 5323, 1, 0,
		0, 0, 328, 5325, 1, 0, 0, 0, 330, 5333, 1, 0, 0, 0, 332, 5341, 1, 0, 0,
		0, 334, 5346, 1, 0, 0, 0, 336, 5354, 1, 0, 0, 0, 338, 5429, 1, 0, 0, 0,
		340, 5437, 1, 0, 0, 0, 342, 5460, 1, 0, 0, 0, 344, 5472, 1, 0, 0, 0, 346,
		5480, 1, 0, 0, 0, 348, 5494, 1, 0, 0, 0, 350, 5508, 1, 0, 0, 0, 352, 5517,
		1, 0, 0, 0, 354, 5542, 1, 0, 0, 0, 356, 5560, 1, 0, 0, 0, 358, 5562, 1,
		0, 0, 0, 360, 5570, 1, 0, 0, 0, 362, 5580, 1, 0, 0, 0, 364, 5582, 1, 0,
		0, 0, 366, 5594, 1, 0, 0, 0, 368, 5603, 1, 0, 0, 0, 370, 5610, 1, 0, 0,
		0, 372, 5620, 1, 0, 0, 0, 374, 5638, 1, 0, 0, 0, 376, 5664, 1, 0, 0, 0,
		378, 5683, 1, 0, 0, 0, 380, 5699, 1, 0, 0, 0, 382, 5761, 1, 0, 0, 0, 384,
		5767, 1, 0, 0, 0, 386, 5919, 1, 0, 0, 0, 388, 5960, 1, 0, 0, 0, 390, 5967,
		1, 0, 0, 0, 392, 5969, 1, 0, 0, 0, 394, 6004, 1, 0, 0, 0, 396, 6024, 1,
		0, 0, 0, 398, 6026, 1, 0, 0, 0, 400, 6047, 1, 0, 0, 0, 402, 6049, 1, 0,
		0, 0, 404, 6058, 1, 0, 0, 0, 406, 6060, 1, 0, 0, 0, 408, 6081, 1, 0, 0,
		0, 410, 6134, 1, 0, 0, 0, 412, 6136, 1, 0, 0, 0, 414, 6138, 1, 0, 0, 0,
		416, 6140, 1, 0, 0, 0, 418, 6145, 1, 0, 0, 0, 420, 6149, 1, 0, 0, 0, 422,
		6151, 1, 0, 0, 0, 424, 6203, 1, 0, 0, 0, 426, 6237, 1, 0, 0, 0, 428, 6239,
		1, 0, 0, 0, 430, 6247, 1, 0, 0, 0, 432, 6253, 1, 0, 0, 0, 434, 6256, 1,
		0, 0, 0, 436, 6270, 1, 0, 0, 0, 438, 6282, 1, 0, 0, 0, 440, 6284, 1, 0,
		0, 0, 442, 6294, 1, 0, 0, 0, 444, 6296, 1, 0, 0, 0, 446, 6301, 1, 0, 0,
		0, 448, 6303, 1, 0, 0, 0, 450, 6313, 1, 0, 0, 0, 452, 6315, 1, 0, 0, 0,
		454, 456, 5, 1, 0, 0, 455, 454, 1, 0, 0, 0, 456, 459, 1, 0, 0, 0, 457,
		455, 1, 0, 0, 0, 457, 458, 1, 0, 0, 0, 458, 461, 1, 0, 0, 0, 459, 457,
		1, 0, 0, 0, 460, 462, 3, 4, 2, 0, 461, 460, 1, 0, 0, 0, 461, 462, 1, 0,
		0, 0, 462, 471, 1, 0, 0, 0, 463, 465, 5, 1, 0, 0, 464, 463, 1, 0, 0, 0,
		465, 466, 1, 0, 0, 0, 466, 464, 1, 0, 0, 0, 466, 467, 1, 0, 0, 0, 467,
		468, 1, 0, 0, 0, 468, 470, 3, 4, 2, 0, 469, 464, 1, 0, 0, 0, 470, 473,
		1, 0, 0, 0, 471, 469, 1, 0, 0, 0, 471, 472, 1, 0, 0, 0, 472, 477, 1, 0,
		0, 0, 473, 471, 1, 0, 0, 0, 474, 476, 5, 1, 0, 0, 475, 474, 1, 0, 0, 0,
		476, 479, 1, 0, 0, 0, 477, 475, 1, 0, 0, 0, 477, 478, 1, 0, 0, 0, 478,
		480, 1, 0, 0, 0, 479, 477, 1, 0, 0, 0, 480, 481, 5, 0, 0, 1, 481, 1, 1,
		0, 0, 0, 482, 484, 5, 1, 0, 0, 483, 482, 1, 0, 0, 0, 484, 487, 1, 0, 0,
		0, 485, 483, 1, 0, 0, 0, 485, 486, 1, 0, 0, 0, 486, 489, 1, 0, 0, 0, 487,
		485, 1, 0, 0, 0, 488, 490, 3, 4, 2, 0, 489, 488, 1, 0, 0, 0, 489, 490,
		1, 0, 0, 0, 490, 494, 1, 0, 0, 0, 491, 493, 5, 1, 0, 0, 492, 491, 1, 0,
		0, 0, 493, 496, 1, 0, 0, 0, 494, 492, 1, 0, 0, 0, 494, 495, 1, 0, 0, 0,
		495, 497, 1, 0, 0, 0, 496, 494, 1, 0, 0, 0, 497, 498, 5, 0, 0, 1, 498,
		3, 1, 0, 0, 0, 499, 574, 3, 6, 3, 0, 500, 501, 5, 64, 0, 0, 501, 502, 3,
		328, 164, 0, 502, 511, 5, 2, 0, 0, 503, 508, 3, 372, 186, 0, 504, 505,
		5, 4, 0, 0, 505, 507, 3, 372, 186, 0, 506, 504, 1, 0, 0, 0, 507, 510, 1,
		0, 0, 0, 508, 506, 1, 0, 0, 0, 508, 509, 1, 0, 0, 0, 509, 512, 1, 0, 0,
		0, 510, 508, 1, 0, 0, 0, 511, 503, 1, 0, 0, 0, 511, 512, 1, 0, 0, 0, 512,
		513, 1, 0, 0, 0, 513, 514, 5, 3, 0, 0, 514, 574, 1, 0, 0, 0, 515, 523,
		5, 21, 0, 0, 516, 519, 5, 101, 0, 0, 517, 518, 5, 322, 0, 0, 518, 520,
		5, 383, 0, 0, 519, 517, 1, 0, 0, 0, 519, 520, 1, 0, 0, 0, 520, 523, 1,
		0, 0, 0, 521, 523, 5, 383, 0, 0, 522, 515, 1, 0, 0, 0, 522, 516, 1, 0,
		0, 0, 522, 521, 1, 0, 0, 0, 523, 524, 1, 0, 0, 0, 524, 525, 7, 0, 0, 0,
		525, 526, 3, 328, 164, 0, 526, 530, 5, 2, 0, 0, 527, 529, 9, 0, 0, 0, 528,
		527, 1, 0, 0, 0, 529, 532, 1, 0, 0, 0, 530, 531, 1, 0, 0, 0, 530, 528,
		1, 0, 0, 0, 531, 533, 1, 0, 0, 0, 532, 530, 1, 0, 0, 0, 533, 537, 5, 3,
		0, 0, 534, 536, 9, 0, 0, 0, 535, 534, 1, 0, 0, 0, 536, 539, 1, 0, 0, 0,
		537, 538, 1, 0, 0, 0, 537, 535, 1, 0, 0, 0, 538, 574, 1, 0, 0, 0, 539,
		537, 1, 0, 0, 0, 540, 541, 5, 147, 0, 0, 541, 544, 7, 0, 0, 0, 542, 543,
		5, 222, 0, 0, 543, 545, 5, 170, 0, 0, 544, 542, 1, 0, 0, 0, 544, 545, 1,
		0, 0, 0, 545, 546, 1, 0, 0, 0, 546, 574, 3, 328, 164, 0, 547, 548, 5, 424,
		0, 0, 548, 549, 7, 1, 0, 0, 549, 553, 5, 439, 0, 0, 550, 551, 5, 266, 0,
		0, 551, 554, 3, 384, 192, 0, 552, 554, 3, 250, 125, 0, 553, 550, 1, 0,
		0, 0, 553, 552, 1, 0, 0, 0, 553, 554, 1, 0, 0, 0, 554, 574, 1, 0, 0, 0,
		555, 556, 5, 424, 0, 0, 556, 557, 5, 101, 0, 0, 557, 558, 5, 356, 0, 0,
		558, 574, 3, 328, 164, 0, 559, 561, 5, 15, 0, 0, 560, 559, 1, 0, 0, 0,
		560, 561, 1, 0, 0, 0, 561, 562, 1, 0, 0, 0, 562, 563, 5, 424, 0, 0, 563,
		564, 7, 2, 0, 0, 564, 567, 5, 91, 0, 0, 565, 566, 5, 266, 0, 0, 566, 568,
		3, 384, 192, 0, 567, 565, 1, 0, 0, 0, 567, 568, 1, 0, 0, 0, 568, 571, 1,
		0, 0, 0, 569, 570, 5, 193, 0, 0, 570, 572, 5, 549, 0, 0, 571, 569, 1, 0,
		0, 0, 571, 572, 1, 0, 0, 0, 572, 574, 1, 0, 0, 0, 573, 499, 1, 0, 0, 0,
		573, 500, 1, 0, 0, 0, 573, 522, 1, 0, 0, 0, 573, 540, 1, 0, 0, 0, 573,
		547, 1, 0, 0, 0, 573, 555, 1, 0, 0, 0, 573, 560, 1, 0, 0, 0, 574, 5, 1,
		0, 0, 0, 575, 577, 3, 196, 98, 0, 576, 575, 1, 0, 0, 0, 576, 577, 1, 0,
		0, 0, 577, 578, 1, 0, 0, 0, 578, 580, 3, 230, 115, 0, 579, 581, 3, 228,
		114, 0, 580, 579, 1, 0, 0, 0, 580, 581, 1, 0, 0, 0, 581, 607, 1, 0, 0,
		0, 582, 607, 3, 16, 8, 0, 583, 607, 3, 18, 9, 0, 584, 607, 3, 24, 12, 0,
		585, 607, 3, 10, 5, 0, 586, 607, 3, 12, 6, 0, 587, 607, 3, 14, 7, 0, 588,
		607, 3, 62, 31, 0, 589, 607, 3, 158, 79, 0, 590, 607, 3, 26, 13, 0, 591,
		607, 3, 140, 70, 0, 592, 607, 3, 152, 76, 0, 593, 607, 3, 60, 30, 0, 594,
		607, 3, 28, 14, 0, 595, 607, 3, 30, 15, 0, 596, 607, 3, 64, 32, 0, 597,
		607, 3, 68, 34, 0, 598, 607, 3, 66, 33, 0, 599, 607, 3, 154, 77, 0, 600,
		607, 3, 34, 17, 0, 601, 607, 3, 32, 16, 0, 602, 607, 3, 118, 59, 0, 603,
		607, 3, 76, 38, 0, 604, 607, 3, 78, 39, 0, 605, 607, 3, 8, 4, 0, 606, 576,
		1, 0, 0, 0, 606, 582, 1, 0, 0, 0, 606, 583, 1, 0, 0, 0, 606, 584, 1, 0,
		0, 0, 606, 585, 1, 0, 0, 0, 606, 586, 1, 0, 0, 0, 606, 587, 1, 0, 0, 0,
		606, 588, 1, 0, 0, 0, 606, 589, 1, 0, 0, 0, 606, 590, 1, 0, 0, 0, 606,
		591, 1, 0, 0, 0, 606, 592, 1, 0, 0, 0, 606, 593, 1, 0, 0, 0, 606, 594,
		1, 0, 0, 0, 606, 595, 1, 0, 0, 0, 606, 596, 1, 0, 0, 0, 606, 597, 1, 0,
		0, 0, 606, 598, 1, 0, 0, 0, 606, 599, 1, 0, 0, 0, 606, 600, 1, 0, 0, 0,
		606, 601, 1, 0, 0, 0, 606, 602, 1, 0, 0, 0, 606, 603, 1, 0, 0, 0, 606,
		604, 1, 0, 0, 0, 606, 605, 1, 0, 0, 0, 607, 7, 1, 0, 0, 0, 608, 613, 3,
		120, 60, 0, 609, 613, 3, 70, 35, 0, 610, 613, 3, 44, 22, 0, 611, 613, 3,
		36, 18, 0, 612, 608, 1, 0, 0, 0, 612, 609, 1, 0, 0, 0, 612, 610, 1, 0,
		0, 0, 612, 611, 1, 0, 0, 0, 613, 9, 1, 0, 0, 0, 614, 615, 5, 101, 0, 0,
		615, 616, 5, 288, 0, 0, 616, 620, 5, 504, 0, 0, 617, 618, 5, 222, 0, 0,
		618, 619, 5, 312, 0, 0, 619, 621, 5, 170, 0, 0, 620, 617, 1, 0, 0, 0, 620,
		621, 1, 0, 0, 0, 621, 622, 1, 0, 0, 0, 622, 627, 3, 328, 164, 0, 623, 624,
		5, 2, 0, 0, 624, 625, 3, 330, 165, 0, 625, 626, 5, 3, 0, 0, 626, 628, 1,
		0, 0, 0, 627, 623, 1, 0, 0, 0, 627, 628, 1, 0, 0, 0, 628, 630, 1, 0, 0,
		0, 629, 631, 3, 174, 87, 0, 630, 629, 1, 0, 0, 0, 630, 631, 1, 0, 0, 0,
		631, 639, 1, 0, 0, 0, 632, 634, 5, 376, 0, 0, 633, 635, 3, 180, 90, 0,
		634, 633, 1, 0, 0, 0, 634, 635, 1, 0, 0, 0, 635, 637, 1, 0, 0, 0, 636,
		638, 3, 176, 88, 0, 637, 636, 1, 0, 0, 0, 637, 638, 1, 0, 0, 0, 638, 640,
		1, 0, 0, 0, 639, 632, 1, 0, 0, 0, 639, 640, 1, 0, 0, 0, 640, 646, 1, 0,
		0, 0, 641, 643, 5, 151, 0, 0, 642, 641, 1, 0, 0, 0, 642, 643, 1, 0, 0,
		0, 643, 644, 1, 0, 0, 0, 644, 645, 5, 253, 0, 0, 645, 647, 3, 306, 153,
		0, 646, 642, 1, 0, 0, 0, 646, 647, 1, 0, 0, 0, 647, 650, 1, 0, 0, 0, 648,
		649, 5, 83, 0, 0, 649, 651, 5, 544, 0, 0, 650, 648, 1, 0, 0, 0, 650, 651,
		1, 0, 0, 0, 651, 658, 1, 0, 0, 0, 652, 653, 5, 330, 0, 0, 653, 654, 5,
		61, 0, 0, 654, 655, 5, 2, 0, 0, 655, 656, 3, 182, 91, 0, 656, 657, 5, 3,
		0, 0, 657, 659, 1, 0, 0, 0, 658, 652, 1, 0, 0, 0, 658, 659, 1, 0, 0, 0,
		659, 671, 1, 0, 0, 0, 660, 661, 5, 141, 0, 0, 661, 665, 5, 61, 0, 0, 662,
		663, 5, 208, 0, 0, 663, 666, 3, 306, 153, 0, 664, 666, 5, 368, 0, 0, 665,
		662, 1, 0, 0, 0, 665, 664, 1, 0, 0, 0, 666, 669, 1, 0, 0, 0, 667, 668,
		5, 57, 0, 0, 668, 670, 7, 3, 0, 0, 669, 667, 1, 0, 0, 0, 669, 670, 1, 0,
		0, 0, 670, 672, 1, 0, 0, 0, 671, 660, 1, 0, 0, 0, 671, 672, 1, 0, 0, 0,
		672, 674, 1, 0, 0, 0, 673, 675, 3, 316, 158, 0, 674, 673, 1, 0, 0, 0, 674,
		675, 1, 0, 0, 0, 675, 676, 1, 0, 0, 0, 676, 677, 5, 29, 0, 0, 677, 678,
		3, 230, 115, 0, 678, 754, 1, 0, 0, 0, 679, 680, 5, 376, 0, 0, 680, 681,
		5, 288, 0, 0, 681, 682, 5, 504, 0, 0, 682, 686, 3, 328, 164, 0, 683, 687,
		3, 162, 81, 0, 684, 687, 5, 87, 0, 0, 685, 687, 5, 33, 0, 0, 686, 683,
		1, 0, 0, 0, 686, 684, 1, 0, 0, 0, 686, 685, 1, 0, 0, 0, 687, 754, 1, 0,
		0, 0, 688, 689, 5, 21, 0, 0, 689, 690, 5, 288, 0, 0, 690, 691, 5, 504,
		0, 0, 691, 715, 3, 328, 164, 0, 692, 693, 5, 380, 0, 0, 693, 716, 3, 444,
		222, 0, 694, 700, 5, 376, 0, 0, 695, 701, 3, 180, 90, 0, 696, 701, 3, 176,
		88, 0, 697, 698, 3, 180, 90, 0, 698, 699, 3, 176, 88, 0, 699, 701, 1, 0,
		0, 0, 700, 695, 1, 0, 0, 0, 700, 696, 1, 0, 0, 0, 700, 697, 1, 0, 0, 0,
		701, 716, 1, 0, 0, 0, 702, 703, 5, 383, 0, 0, 703, 704, 5, 512, 0, 0, 704,
		705, 5, 288, 0, 0, 705, 706, 5, 504, 0, 0, 706, 708, 3, 444, 222, 0, 707,
		709, 3, 316, 158, 0, 708, 707, 1, 0, 0, 0, 708, 709, 1, 0, 0, 0, 709, 716,
		1, 0, 0, 0, 710, 711, 5, 420, 0, 0, 711, 712, 5, 2, 0, 0, 712, 713, 3,
		318, 159, 0, 713, 714, 5, 3, 0, 0, 714, 716, 1, 0, 0, 0, 715, 692, 1, 0,
		0, 0, 715, 694, 1, 0, 0, 0, 715, 702, 1, 0, 0, 0, 715, 710, 1, 0, 0, 0,
		716, 754, 1, 0, 0, 0, 717, 718, 5, 147, 0, 0, 718, 719, 5, 288, 0, 0, 719,
		722, 5, 504, 0, 0, 720, 721, 5, 222, 0, 0, 721, 723, 5, 170, 0, 0, 722,
		720, 1, 0, 0, 0, 722, 723, 1, 0, 0, 0, 723, 724, 1, 0, 0, 0, 724, 727,
		3, 328, 164, 0, 725, 726, 5, 318, 0, 0, 726, 728, 3, 328, 164, 0, 727,
		725, 1, 0, 0, 0, 727, 728, 1, 0, 0, 0, 728, 754, 1, 0, 0, 0, 729, 730,
		5, 338, 0, 0, 730, 731, 5, 288, 0, 0, 731, 732, 5, 504, 0, 0, 732, 733,
		5, 248, 0, 0, 733, 734, 5, 318, 0, 0, 734, 754, 3, 328, 164, 0, 735, 736,
		5, 393, 0, 0, 736, 737, 5, 288, 0, 0, 737, 738, 5, 504, 0, 0, 738, 739,
		5, 248, 0, 0, 739, 740, 5, 318, 0, 0, 740, 754, 3, 328, 164, 0, 741, 742,
		5, 65, 0, 0, 742, 743, 5, 288, 0, 0, 743, 744, 5, 504, 0, 0, 744, 745,
		5, 457, 0, 0, 745, 746, 5, 549, 0, 0, 746, 747, 5, 318, 0, 0, 747, 754,
		3, 328, 164, 0, 748, 749, 5, 424, 0, 0, 749, 750, 5, 101, 0, 0, 750, 751,
		5, 288, 0, 0, 751, 752, 5, 504, 0, 0, 752, 754, 3, 328, 164, 0, 753, 614,
		1, 0, 0, 0, 753, 679, 1, 0, 0, 0, 753, 688, 1, 0, 0, 0, 753, 717, 1, 0,
		0, 0, 753, 729, 1, 0, 0, 0, 753, 735, 1, 0, 0, 0, 753, 741, 1, 0, 0, 0,
		753, 748, 1, 0, 0, 0, 754, 11, 1, 0, 0, 0, 755, 756, 5, 101, 0, 0, 756,
		757, 5, 248, 0, 0, 757, 758, 3, 328, 164, 0, 758, 759, 5, 318, 0, 0, 759,
		779, 5, 410, 0, 0, 760, 761, 5, 166, 0, 0, 761, 762, 5, 549, 0, 0, 762,
		768, 3, 444, 222, 0, 763, 766, 5, 437, 0, 0, 764, 767, 5, 544, 0, 0, 765,
		767, 5, 110, 0, 0, 766, 764, 1, 0, 0, 0, 766, 765, 1, 0, 0, 0, 767, 769,
		1, 0, 0, 0, 768, 763, 1, 0, 0, 0, 768, 769, 1, 0, 0, 0, 769, 772, 1, 0,
		0, 0, 770, 771, 5, 159, 0, 0, 771, 773, 5, 544, 0, 0, 772, 770, 1, 0, 0,
		0, 772, 773, 1, 0, 0, 0, 773, 780, 1, 0, 0, 0, 774, 777, 5, 31, 0, 0, 775,
		778, 5, 544, 0, 0, 776, 778, 5, 110, 0, 0, 777, 775, 1, 0, 0, 0, 777, 776,
		1, 0, 0, 0, 778, 780, 1, 0, 0, 0, 779, 760, 1, 0, 0, 0, 779, 774, 1, 0,
		0, 0, 780, 782, 1, 0, 0, 0, 781, 783, 3, 432, 216, 0, 782, 781, 1, 0, 0,
		0, 782, 783, 1, 0, 0, 0, 783, 784, 1, 0, 0, 0, 784, 785, 5, 144, 0, 0,
		785, 786, 3, 16, 8, 0, 786, 824, 1, 0, 0, 0, 787, 788, 5, 338, 0, 0, 788,
		789, 5, 248, 0, 0, 789, 790, 5, 510, 0, 0, 790, 791, 3, 444, 222, 0, 791,
		792, 5, 518, 0, 0, 792, 793, 5, 544, 0, 0, 793, 824, 1, 0, 0, 0, 794, 795,
		5, 147, 0, 0, 795, 798, 5, 248, 0, 0, 796, 797, 5, 222, 0, 0, 797, 799,
		5, 170, 0, 0, 798, 796, 1, 0, 0, 0, 798, 799, 1, 0, 0, 0, 799, 800, 1,
		0, 0, 0, 800, 801, 5, 510, 0, 0, 801, 802, 3, 444, 222, 0, 802, 803, 5,
		518, 0, 0, 803, 804, 5, 544, 0, 0, 804, 824, 1, 0, 0, 0, 805, 806, 5, 393,
		0, 0, 806, 807, 5, 248, 0, 0, 807, 808, 5, 510, 0, 0, 808, 809, 3, 444,
		222, 0, 809, 810, 5, 518, 0, 0, 810, 811, 5, 544, 0, 0, 811, 824, 1, 0,
		0, 0, 812, 813, 5, 65, 0, 0, 813, 814, 5, 457, 0, 0, 814, 815, 5, 510,
		0, 0, 815, 816, 3, 444, 222, 0, 816, 817, 5, 518, 0, 0, 817, 818, 5, 544,
		0, 0, 818, 819, 5, 25, 0, 0, 819, 820, 3, 444, 222, 0, 820, 821, 5, 518,
		0, 0, 821, 822, 5, 549, 0, 0, 822, 824, 1, 0, 0, 0, 823, 755, 1, 0, 0,
		0, 823, 787, 1, 0, 0, 0, 823, 794, 1, 0, 0, 0, 823, 805, 1, 0, 0, 0, 823,
		812, 1, 0, 0, 0, 824, 13, 1, 0, 0, 0, 825, 826, 5, 21, 0, 0, 826, 827,
		5, 451, 0, 0, 827, 828, 3, 328, 164, 0, 828, 829, 5, 14, 0, 0, 829, 830,
		5, 95, 0, 0, 830, 831, 3, 440, 220, 0, 831, 832, 3, 160, 80, 0, 832, 845,
		1, 0, 0, 0, 833, 834, 5, 21, 0, 0, 834, 835, 5, 451, 0, 0, 835, 836, 3,
		328, 164, 0, 836, 837, 5, 147, 0, 0, 837, 838, 5, 95, 0, 0, 838, 839, 3,
		440, 220, 0, 839, 845, 1, 0, 0, 0, 840, 841, 5, 424, 0, 0, 841, 842, 5,
		96, 0, 0, 842, 843, 5, 193, 0, 0, 843, 845, 3, 328, 164, 0, 844, 825, 1,
		0, 0, 0, 844, 833, 1, 0, 0, 0, 844, 840, 1, 0, 0, 0, 845, 15, 1, 0, 0,
		0, 846, 848, 3, 196, 98, 0, 847, 846, 1, 0, 0, 0, 847, 848, 1, 0, 0, 0,
		848, 850, 1, 0, 0, 0, 849, 851, 3, 240, 120, 0, 850, 849, 1, 0, 0, 0, 850,
		851, 1, 0, 0, 0, 851, 852, 1, 0, 0, 0, 852, 856, 5, 231, 0, 0, 853, 857,
		5, 238, 0, 0, 854, 855, 5, 327, 0, 0, 855, 857, 5, 451, 0, 0, 856, 853,
		1, 0, 0, 0, 856, 854, 1, 0, 0, 0, 857, 863, 1, 0, 0, 0, 858, 864, 3, 328,
		164, 0, 859, 860, 5, 145, 0, 0, 860, 861, 5, 2, 0, 0, 861, 862, 5, 549,
		0, 0, 862, 864, 5, 3, 0, 0, 863, 858, 1, 0, 0, 0, 863, 859, 1, 0, 0, 0,
		864, 866, 1, 0, 0, 0, 865, 867, 3, 162, 81, 0, 866, 865, 1, 0, 0, 0, 866,
		867, 1, 0, 0, 0, 867, 871, 1, 0, 0, 0, 868, 869, 5, 512, 0, 0, 869, 870,
		5, 256, 0, 0, 870, 872, 3, 444, 222, 0, 871, 868, 1, 0, 0, 0, 871, 872,
		1, 0, 0, 0, 872, 874, 1, 0, 0, 0, 873, 875, 3, 306, 153, 0, 874, 873, 1,
		0, 0, 0, 874, 875, 1, 0, 0, 0, 875, 880, 1, 0, 0, 0, 876, 877, 5, 7, 0,
		0, 877, 878, 3, 308, 154, 0, 878, 879, 5, 8, 0, 0, 879, 881, 1, 0, 0, 0,
		880, 876, 1, 0, 0, 0, 880, 881, 1, 0, 0, 0, 881, 882, 1, 0, 0, 0, 882,
		997, 3, 230, 115, 0, 883, 885, 3, 196, 98, 0, 884, 883, 1, 0, 0, 0, 884,
		885, 1, 0, 0, 0, 885, 887, 1, 0, 0, 0, 886, 888, 3, 240, 120, 0, 887, 886,
		1, 0, 0, 0, 887, 888, 1, 0, 0, 0, 888, 889, 1, 0, 0, 0, 889, 890, 5, 489,
		0, 0, 890, 891, 3, 328, 164, 0, 891, 892, 3, 326, 163, 0, 892, 893, 5,
		420, 0, 0, 893, 895, 3, 288, 144, 0, 894, 896, 3, 252, 126, 0, 895, 894,
		1, 0, 0, 0, 895, 896, 1, 0, 0, 0, 896, 898, 1, 0, 0, 0, 897, 899, 3, 250,
		125, 0, 898, 897, 1, 0, 0, 0, 898, 899, 1, 0, 0, 0, 899, 997, 1, 0, 0,
		0, 900, 902, 3, 196, 98, 0, 901, 900, 1, 0, 0, 0, 901, 902, 1, 0, 0, 0,
		902, 904, 1, 0, 0, 0, 903, 905, 3, 240, 120, 0, 904, 903, 1, 0, 0, 0, 904,
		905, 1, 0, 0, 0, 905, 906, 1, 0, 0, 0, 906, 907, 5, 129, 0, 0, 907, 908,
		5, 193, 0, 0, 908, 910, 3, 328, 164, 0, 909, 911, 3, 162, 81, 0, 910, 909,
		1, 0, 0, 0, 910, 911, 1, 0, 0, 0, 911, 912, 1, 0, 0, 0, 912, 915, 3, 326,
		163, 0, 913, 914, 5, 493, 0, 0, 914, 916, 3, 260, 130, 0, 915, 913, 1,
		0, 0, 0, 915, 916, 1, 0, 0, 0, 916, 918, 1, 0, 0, 0, 917, 919, 3, 250,
		125, 0, 918, 917, 1, 0, 0, 0, 918, 919, 1, 0, 0, 0, 919, 997, 1, 0, 0,
		0, 920, 921, 5, 271, 0, 0, 921, 922, 5, 256, 0, 0, 922, 923, 3, 328, 164,
		0, 923, 924, 5, 2, 0, 0, 924, 929, 3, 170, 85, 0, 925, 926, 5, 4, 0, 0,
		926, 928, 3, 170, 85, 0, 927, 925, 1, 0, 0, 0, 928, 931, 1, 0, 0, 0, 929,
		927, 1, 0, 0, 0, 929, 930, 1, 0, 0, 0, 930, 932, 1, 0, 0, 0, 931, 929,
		1, 0, 0, 0, 932, 934, 5, 3, 0, 0, 933, 935, 3, 220, 110, 0, 934, 933, 1,
		0, 0, 0, 934, 935, 1, 0, 0, 0, 935, 937, 1, 0, 0, 0, 936, 938, 3, 316,
		158, 0, 937, 936, 1, 0, 0, 0, 937, 938, 1, 0, 0, 0, 938, 940, 1, 0, 0,
		0, 939, 941, 3, 432, 216, 0, 940, 939, 1, 0, 0, 0, 940, 941, 1, 0, 0, 0,
		941, 997, 1, 0, 0, 0, 942, 943, 5, 173, 0, 0, 943, 944, 5, 451, 0, 0, 944,
		947, 3, 328, 164, 0, 945, 946, 5, 330, 0, 0, 946, 948, 3, 306, 153, 0,
		947, 945, 1, 0, 0, 0, 947, 948, 1, 0, 0, 0, 948, 950, 1, 0, 0, 0, 949,
		951, 3, 250, 125, 0, 950, 949, 1, 0, 0, 0, 950, 951, 1, 0, 0, 0, 951, 952,
		1, 0, 0, 0, 952, 953, 5, 467, 0, 0, 953, 955, 5, 544, 0, 0, 954, 956, 3,
		316, 158, 0, 955, 954, 1, 0, 0, 0, 955, 956, 1, 0, 0, 0, 956, 958, 1, 0,
		0, 0, 957, 959, 3, 220, 110, 0, 958, 957, 1, 0, 0, 0, 958, 959, 1, 0, 0,
		0, 959, 997, 1, 0, 0, 0, 960, 997, 3, 202, 101, 0, 961, 962, 5, 99, 0,
		0, 962, 964, 5, 238, 0, 0, 963, 965, 3, 280, 140, 0, 964, 963, 1, 0, 0,
		0, 964, 965, 1, 0, 0, 0, 965, 966, 1, 0, 0, 0, 966, 968, 3, 328, 164, 0,
		967, 969, 3, 306, 153, 0, 968, 967, 1, 0, 0, 0, 968, 969, 1, 0, 0, 0, 969,
		970, 1, 0, 0, 0, 970, 982, 5, 193, 0, 0, 971, 983, 3, 156, 78, 0, 972,
		973, 5, 2, 0, 0, 973, 974, 5, 415, 0, 0, 974, 975, 3, 248, 124, 0, 975,
		976, 5, 193, 0, 0, 976, 978, 3, 156, 78, 0, 977, 979, 3, 250, 125, 0, 978,
		977, 1, 0, 0, 0, 978, 979, 1, 0, 0, 0, 979, 980, 1, 0, 0, 0, 980, 981,
		5, 3, 0, 0, 981, 983, 1, 0, 0, 0, 982, 971, 1, 0, 0, 0, 982, 972, 1, 0,
		0, 0, 983, 985, 1, 0, 0, 0, 984, 986, 3, 316, 158, 0, 985, 984, 1, 0, 0,
		0, 985, 986, 1, 0, 0, 0, 986, 997, 1, 0, 0, 0, 987, 988, 5, 476, 0, 0,
		988, 989, 5, 451, 0, 0, 989, 991, 3, 328, 164, 0, 990, 992, 3, 408, 204,
		0, 991, 990, 1, 0, 0, 0, 991, 992, 1, 0, 0, 0, 992, 994, 1, 0, 0, 0, 993,
		995, 5, 190, 0, 0, 994, 993, 1, 0, 0, 0, 994, 995, 1, 0, 0, 0, 995, 997,
		1, 0, 0, 0, 996, 847, 1, 0, 0, 0, 996, 884, 1, 0, 0, 0, 996, 901, 1, 0,
		0, 0, 996, 920, 1, 0, 0, 0, 996, 942, 1, 0, 0, 0, 996, 960, 1, 0, 0, 0,
		996, 961, 1, 0, 0, 0, 996, 987, 1, 0, 0, 0, 997, 17, 1, 0, 0, 0, 998, 1000,
		5, 101, 0, 0, 999, 1001, 7, 4, 0, 0, 1000, 999, 1, 0, 0, 0, 1000, 1001,
		1, 0, 0, 0, 1001, 1002, 1, 0, 0, 0, 1002, 1006, 5, 451, 0, 0, 1003, 1004,
		5, 222, 0, 0, 1004, 1005, 5, 312, 0, 0, 1005, 1007, 5, 170, 0, 0, 1006,
		1003, 1, 0, 0, 0, 1006, 1007, 1, 0, 0, 0, 1007, 1008, 1, 0, 0, 0, 1008,
		1023, 3, 328, 164, 0, 1009, 1011, 3, 306, 153, 0, 1010, 1009, 1, 0, 0,
		0, 1010, 1011, 1, 0, 0, 0, 1011, 1024, 1, 0, 0, 0, 1012, 1013, 5, 2, 0,
		0, 1013, 1016, 3, 334, 167, 0, 1014, 1015, 5, 4, 0, 0, 1015, 1017, 3, 338,
		169, 0, 1016, 1014, 1, 0, 0, 0, 1016, 1017, 1, 0, 0, 0, 1017, 1019, 1,
		0, 0, 0, 1018, 1020, 5, 4, 0, 0, 1019, 1018, 1, 0, 0, 0, 1019, 1020, 1,
		0, 0, 0, 1020, 1021, 1, 0, 0, 0, 1021, 1022, 5, 3, 0, 0, 1022, 1024, 1,
		0, 0, 0, 1023, 1010, 1, 0, 0, 0, 1023, 1012, 1, 0, 0, 0, 1024, 1028, 1,
		0, 0, 0, 1025, 1026, 5, 160, 0, 0, 1026, 1027, 5, 518, 0, 0, 1027, 1029,
		3, 444, 222, 0, 1028, 1025, 1, 0, 0, 0, 1028, 1029, 1, 0, 0, 0, 1029, 1038,
		1, 0, 0, 0, 1030, 1031, 7, 5, 0, 0, 1031, 1032, 5, 253, 0, 0, 1032, 1036,
		3, 306, 153, 0, 1033, 1034, 5, 75, 0, 0, 1034, 1035, 5, 61, 0, 0, 1035,
		1037, 3, 306, 153, 0, 1036, 1033, 1, 0, 0, 0, 1036, 1037, 1, 0, 0, 0, 1037,
		1039, 1, 0, 0, 0, 1038, 1030, 1, 0, 0, 0, 1038, 1039, 1, 0, 0, 0, 1039,
		1042, 1, 0, 0, 0, 1040, 1041, 5, 83, 0, 0, 1041, 1043, 5, 544, 0, 0, 1042,
		1040, 1, 0, 0, 0, 1042, 1043, 1, 0, 0, 0, 1043, 1045, 1, 0, 0, 0, 1044,
		1046, 3, 164, 82, 0, 1045, 1044, 1, 0, 0, 0, 1045, 1046, 1, 0, 0, 0, 1046,
		1061, 1, 0, 0, 0, 1047, 1048, 5, 141, 0, 0, 1048, 1052, 5, 61, 0, 0, 1049,
		1050, 5, 208, 0, 0, 1050, 1053, 3, 306, 153, 0, 1051, 1053, 5, 368, 0,
		0, 1052, 1049, 1, 0, 0, 0, 1052, 1051, 1, 0, 0, 0, 1053, 1059, 1, 0, 0,
		0, 1054, 1057, 5, 57, 0, 0, 1055, 1058, 5, 549, 0, 0, 1056, 1058, 5, 33,
		0, 0, 1057, 1055, 1, 0, 0, 0, 1057, 1056, 1, 0, 0, 0, 1058, 1060, 1, 0,
		0, 0, 1059, 1054, 1, 0, 0, 0, 1059, 1060, 1, 0, 0, 0, 1060, 1062, 1, 0,
		0, 0, 1061, 1047, 1, 0, 0, 0, 1061, 1062, 1, 0, 0, 0, 1062, 1068, 1, 0,
		0, 0, 1063, 1064, 5, 404, 0, 0, 1064, 1065, 5, 2, 0, 0, 1065, 1066, 3,
		358, 179, 0, 1066, 1067, 5, 3, 0, 0, 1067, 1069, 1, 0, 0, 0, 1068, 1063,
		1, 0, 0, 0, 1068, 1069, 1, 0, 0, 0, 1069, 1071, 1, 0, 0, 0, 1070, 1072,
		3, 316, 158, 0, 1071, 1070, 1, 0, 0, 0, 1071, 1072, 1, 0, 0, 0, 1072, 1075,
		1, 0, 0, 0, 1073, 1074, 5, 56, 0, 0, 1074, 1076, 3, 316, 158, 0, 1075,
		1073, 1, 0, 0, 0, 1075, 1076, 1, 0, 0, 0, 1076, 1079, 1, 0, 0, 0, 1077,
		1078, 5, 29, 0, 0, 1078, 1080, 3, 230, 115, 0, 1079, 1077, 1, 0, 0, 0,
		1079, 1080, 1, 0, 0, 0, 1080, 1487, 1, 0, 0, 0, 1081, 1084, 5, 101, 0,
		0, 1082, 1083, 5, 322, 0, 0, 1083, 1085, 5, 383, 0, 0, 1084, 1082, 1, 0,
		0, 0, 1084, 1085, 1, 0, 0, 0, 1085, 1086, 1, 0, 0, 0, 1086, 1090, 5, 504,
		0, 0, 1087, 1088, 5, 222, 0, 0, 1088, 1089, 5, 312, 0, 0, 1089, 1091, 5,
		170, 0, 0, 1090, 1087, 1, 0, 0, 0, 1090, 1091, 1, 0, 0, 0, 1091, 1092,
		1, 0, 0, 0, 1092, 1097, 3, 328, 164, 0, 1093, 1094, 5, 2, 0, 0, 1094, 1095,
		3, 330, 165, 0, 1095, 1096, 5, 3, 0, 0, 1096, 1098, 1, 0, 0, 0, 1097, 1093,
		1, 0, 0, 0, 1097, 1098, 1, 0, 0, 0, 1098, 1101, 1, 0, 0, 0, 1099, 1100,
		5, 83, 0, 0, 1100, 1102, 5, 544, 0, 0, 1101, 1099, 1, 0, 0, 0, 1101, 1102,
		1, 0, 0, 0, 1102, 1103, 1, 0, 0, 0, 1103, 1104, 5, 29, 0, 0, 1104, 1105,
		3, 230, 115, 0, 1105, 1487, 1, 0, 0, 0, 1106, 1107, 5, 101, 0, 0, 1107,
		1108, 5, 182, 0, 0, 1108, 1111, 5, 544, 0, 0, 1109, 1110, 7, 6, 0, 0, 1110,
		1112, 3, 444, 222, 0, 1111, 1109, 1, 0, 0, 0, 1111, 1112, 1, 0, 0, 0, 1112,
		1113, 1, 0, 0, 0, 1113, 1487, 3, 316, 158, 0, 1114, 1116, 5, 101, 0, 0,
		1115, 1117, 7, 4, 0, 0, 1116, 1115, 1, 0, 0, 0, 1116, 1117, 1, 0, 0, 0,
		1117, 1118, 1, 0, 0, 0, 1118, 1122, 5, 451, 0, 0, 1119, 1120, 5, 222, 0,
		0, 1120, 1121, 5, 312, 0, 0, 1121, 1123, 5, 170, 0, 0, 1122, 1119, 1, 0,
		0, 0, 1122, 1123, 1, 0, 0, 0, 1123, 1124, 1, 0, 0, 0, 1124, 1125, 3, 328,
		164, 0, 1125, 1126, 5, 266, 0, 0, 1126, 1132, 3, 328, 164, 0, 1127, 1128,
		5, 512, 0, 0, 1128, 1130, 5, 404, 0, 0, 1129, 1131, 3, 306, 153, 0, 1130,
		1129, 1, 0, 0, 0, 1130, 1131, 1, 0, 0, 0, 1131, 1133, 1, 0, 0, 0, 1132,
		1127, 1, 0, 0, 0, 1132, 1133, 1, 0, 0, 0, 1133, 1487, 1, 0, 0, 0, 1134,
		1135, 5, 101, 0, 0, 1135, 1139, 5, 401, 0, 0, 1136, 1137, 5, 222, 0, 0,
		1137, 1138, 5, 312, 0, 0, 1138, 1140, 5, 170, 0, 0, 1139, 1136, 1, 0, 0,
		0, 1139, 1140, 1, 0, 0, 0, 1140, 1141, 1, 0, 0, 0, 1141, 1144, 3, 184,
		92, 0, 1142, 1143, 5, 83, 0, 0, 1143, 1145, 5, 544, 0, 0, 1144, 1142, 1,
		0, 0, 0, 1144, 1145, 1, 0, 0, 0, 1145, 1487, 1, 0, 0, 0, 1146, 1147, 5,
		101, 0, 0, 1147, 1148, 5, 514, 0, 0, 1148, 1152, 5, 205, 0, 0, 1149, 1150,
		5, 222, 0, 0, 1150, 1151, 5, 312, 0, 0, 1151, 1153, 5, 170, 0, 0, 1152,
		1149, 1, 0, 0, 0, 1152, 1153, 1, 0, 0, 0, 1153, 1154, 1, 0, 0, 0, 1154,
		1157, 3, 184, 92, 0, 1155, 1156, 5, 188, 0, 0, 1156, 1158, 3, 184, 92,
		0, 1157, 1155, 1, 0, 0, 0, 1157, 1158, 1, 0, 0, 0, 1158, 1160, 1, 0, 0,
		0, 1159, 1161, 3, 316, 158, 0, 1160, 1159, 1, 0, 0, 0, 1160, 1161, 1, 0,
		0, 0, 1161, 1487, 1, 0, 0, 0, 1162, 1163, 5, 101, 0, 0, 1163, 1167, 5,
		68, 0, 0, 1164, 1165, 5, 222, 0, 0, 1165, 1166, 5, 312, 0, 0, 1166, 1168,
		5, 170, 0, 0, 1167, 1164, 1, 0, 0, 0, 1167, 1168, 1, 0, 0, 0, 1168, 1169,
		1, 0, 0, 0, 1169, 1173, 3, 444, 222, 0, 1170, 1171, 5, 512, 0, 0, 1171,
		1172, 5, 389, 0, 0, 1172, 1174, 3, 444, 222, 0, 1173, 1170, 1, 0, 0, 0,
		1173, 1174, 1, 0, 0, 0, 1174, 1177, 1, 0, 0, 0, 1175, 1176, 5, 83, 0, 0,
		1176, 1178, 5, 544, 0, 0, 1177, 1175, 1, 0, 0, 0, 1177, 1178, 1, 0, 0,
		0, 1178, 1180, 1, 0, 0, 0, 1179, 1181, 3, 316, 158, 0, 1180, 1179, 1, 0,
		0, 0, 1180, 1181, 1, 0, 0, 0, 1181, 1487, 1, 0, 0, 0, 1182, 1183, 5, 101,
		0, 0, 1183, 1184, 5, 406, 0, 0, 1184, 1188, 5, 351, 0, 0, 1185, 1186, 5,
		222, 0, 0, 1186, 1187, 5, 312, 0, 0, 1187, 1189, 5, 170, 0, 0, 1188, 1185,
		1, 0, 0, 0, 1188, 1189, 1, 0, 0, 0, 1189, 1190, 1, 0, 0, 0, 1190, 1191,
		3, 444, 222, 0, 1191, 1192, 5, 318, 0, 0, 1192, 1193, 3, 328, 164, 0, 1193,
		1194, 5, 29, 0, 0, 1194, 1195, 7, 7, 0, 0, 1195, 1199, 5, 467, 0, 0, 1196,
		1200, 3, 192, 96, 0, 1197, 1198, 5, 401, 0, 0, 1198, 1200, 3, 184, 92,
		0, 1199, 1196, 1, 0, 0, 0, 1199, 1197, 1, 0, 0, 0, 1200, 1201, 1, 0, 0,
		0, 1201, 1202, 5, 493, 0, 0, 1202, 1203, 5, 2, 0, 0, 1203, 1204, 3, 376,
		188, 0, 1204, 1205, 5, 3, 0, 0, 1205, 1487, 1, 0, 0, 0, 1206, 1207, 5,
		101, 0, 0, 1207, 1208, 5, 441, 0, 0, 1208, 1212, 5, 351, 0, 0, 1209, 1210,
		5, 222, 0, 0, 1210, 1211, 5, 312, 0, 0, 1211, 1213, 5, 170, 0, 0, 1212,
		1209, 1, 0, 0, 0, 1212, 1213, 1, 0, 0, 0, 1213, 1214, 1, 0, 0, 0, 1214,
		1216, 3, 444, 222, 0, 1215, 1217, 3, 316, 158, 0, 1216, 1215, 1, 0, 0,
		0, 1216, 1217, 1, 0, 0, 0, 1217, 1487, 1, 0, 0, 0, 1218, 1219, 5, 58, 0,
		0, 1219, 1220, 5, 227, 0, 0, 1220, 1221, 3, 444, 222, 0, 1221, 1222, 5,
		318, 0, 0, 1222, 1224, 3, 328, 164, 0, 1223, 1225, 3, 162, 81, 0, 1224,
		1223, 1, 0, 0, 0, 1224, 1225, 1, 0, 0, 0, 1225, 1487, 1, 0, 0, 0, 1226,
		1227, 5, 101, 0, 0, 1227, 1231, 5, 227, 0, 0, 1228, 1229, 5, 222, 0, 0,
		1229, 1230, 5, 312, 0, 0, 1230, 1232, 5, 170, 0, 0, 1231, 1228, 1, 0, 0,
		0, 1231, 1232, 1, 0, 0, 0, 1232, 1233, 1, 0, 0, 0, 1233, 1234, 3, 444,
		222, 0, 1234, 1235, 5, 318, 0, 0, 1235, 1236, 3, 328, 164, 0, 1236, 1239,
		3, 306, 153, 0, 1237, 1238, 5, 493, 0, 0, 1238, 1240, 7, 8, 0, 0, 1239,
		1237, 1, 0, 0, 0, 1239, 1240, 1, 0, 0, 0, 1240, 1242, 1, 0, 0, 0, 1241,
		1243, 3, 316, 158, 0, 1242, 1241, 1, 0, 0, 0, 1242, 1243, 1, 0, 0, 0, 1243,
		1246, 1, 0, 0, 0, 1244, 1245, 5, 83, 0, 0, 1245, 1247, 5, 544, 0, 0, 1246,
		1244, 1, 0, 0, 0, 1246, 1247, 1, 0, 0, 0, 1247, 1487, 1, 0, 0, 0, 1248,
		1249, 5, 101, 0, 0, 1249, 1250, 5, 514, 0, 0, 1250, 1254, 5, 351, 0, 0,
		1251, 1252, 5, 222, 0, 0, 1252, 1253, 5, 312, 0, 0, 1253, 1255, 5, 170,
		0, 0, 1254, 1251, 1, 0, 0, 0, 1254, 1255, 1, 0, 0, 0, 1255, 1256, 1, 0,
		0, 0, 1256, 1262, 3, 184, 92, 0, 1257, 1258, 5, 90, 0, 0, 1258, 1259, 5,
		2, 0, 0, 1259, 1260, 3, 128, 64, 0, 1260, 1261, 5, 3, 0, 0, 1261, 1263,
		1, 0, 0, 0, 1262, 1257, 1, 0, 0, 0, 1262, 1263, 1, 0, 0, 0, 1263, 1269,
		1, 0, 0, 0, 1264, 1265, 5, 13, 0, 0, 1265, 1266, 5, 2, 0, 0, 1266, 1267,
		3, 124, 62, 0, 1267, 1268, 5, 3, 0, 0, 1268, 1270, 1, 0, 0, 0, 1269, 1264,
		1, 0, 0, 0, 1269, 1270, 1, 0, 0, 0, 1270, 1272, 1, 0, 0, 0, 1271, 1273,
		3, 316, 158, 0, 1272, 1271, 1, 0, 0, 0, 1272, 1273, 1, 0, 0, 0, 1273, 1487,
		1, 0, 0, 0, 1274, 1275, 5, 101, 0, 0, 1275, 1279, 5, 433, 0, 0, 1276, 1277,
		5, 222, 0, 0, 1277, 1278, 5, 312, 0, 0, 1278, 1280, 5, 170, 0, 0, 1279,
		1276, 1, 0, 0, 0, 1279, 1280, 1, 0, 0, 0, 1280, 1281, 1, 0, 0, 0, 1281,
		1283, 3, 444, 222, 0, 1282, 1284, 3, 316, 158, 0, 1283, 1282, 1, 0, 0,
		0, 1283, 1284, 1, 0, 0, 0, 1284, 1487, 1, 0, 0, 0, 1285, 1286, 5, 101,
		0, 0, 1286, 1290, 5, 156, 0, 0, 1287, 1288, 5, 222, 0, 0, 1288, 1289, 5,
		312, 0, 0, 1289, 1291, 5, 170, 0, 0, 1290, 1287, 1, 0, 0, 0, 1290, 1291,
		1, 0, 0, 0, 1291, 1292, 1, 0, 0, 0, 1292, 1293, 3, 328, 164, 0, 1293, 1294,
		5, 29, 0, 0, 1294, 1295, 5, 544, 0, 0, 1295, 1487, 1, 0, 0, 0, 1296, 1298,
		5, 101, 0, 0, 1297, 1299, 3, 172, 86, 0, 1298, 1297, 1, 0, 0, 0, 1298,
		1299, 1, 0, 0, 0, 1299, 1301, 1, 0, 0, 0, 1300, 1302, 7, 9, 0, 0, 1301,
		1300, 1, 0, 0, 0, 1301, 1302, 1, 0, 0, 0, 1302, 1303, 1, 0, 0, 0, 1303,
		1307, 5, 197, 0, 0, 1304, 1305, 5, 222, 0, 0, 1305, 1306, 5, 312, 0, 0,
		1306, 1308, 5, 170, 0, 0, 1307, 1304, 1, 0, 0, 0, 1307, 1308, 1, 0, 0,
		0, 1308, 1309, 1, 0, 0, 0, 1309, 1310, 3, 394, 197, 0, 1310, 1312, 5, 2,
		0, 0, 1311, 1313, 3, 136, 68, 0, 1312, 1311, 1, 0, 0, 0, 1312, 1313, 1,
		0, 0, 0, 1313, 1314, 1, 0, 0, 0, 1314, 1315, 5, 3, 0, 0, 1315, 1316, 5,
		396, 0, 0, 1316, 1319, 3, 424, 212, 0, 1317, 1318, 5, 235, 0, 0, 1318,
		1320, 3, 424, 212, 0, 1319, 1317, 1, 0, 0, 0, 1319, 1320, 1, 0, 0, 0, 1320,
		1322, 1, 0, 0, 0, 1321, 1323, 3, 316, 158, 0, 1322, 1321, 1, 0, 0, 0, 1322,
		1323, 1, 0, 0, 0, 1323, 1487, 1, 0, 0, 0, 1324, 1326, 5, 101, 0, 0, 1325,
		1327, 3, 172, 86, 0, 1326, 1325, 1, 0, 0, 0, 1326, 1327, 1, 0, 0, 0, 1327,
		1328, 1, 0, 0, 0, 1328, 1329, 5, 19, 0, 0, 1329, 1333, 5, 197, 0, 0, 1330,
		1331, 5, 222, 0, 0, 1331, 1332, 5, 312, 0, 0, 1332, 1334, 5, 170, 0, 0,
		1333, 1330, 1, 0, 0, 0, 1333, 1334, 1, 0, 0, 0, 1334, 1335, 1, 0, 0, 0,
		1335, 1336, 3, 394, 197, 0, 1336, 1338, 5, 2, 0, 0, 1337, 1339, 3, 136,
		68, 0, 1338, 1337, 1, 0, 0, 0, 1338, 1339, 1, 0, 0, 0, 1339, 1340, 1, 0,
		0, 0, 1340, 1341, 5, 3, 0, 0, 1341, 1342, 5, 512, 0, 0, 1342, 1343, 5,
		328, 0, 0, 1343, 1345, 5, 2, 0, 0, 1344, 1346, 3, 308, 154, 0, 1345, 1344,
		1, 0, 0, 0, 1345, 1346, 1, 0, 0, 0, 1346, 1347, 1, 0, 0, 0, 1347, 1348,
		5, 3, 0, 0, 1348, 1349, 5, 29, 0, 0, 1349, 1350, 3, 372, 186, 0, 1350,
		1487, 1, 0, 0, 0, 1351, 1352, 5, 101, 0, 0, 1352, 1356, 5, 491, 0, 0, 1353,
		1354, 5, 222, 0, 0, 1354, 1355, 5, 312, 0, 0, 1355, 1357, 5, 170, 0, 0,
		1356, 1353, 1, 0, 0, 0, 1356, 1357, 1, 0, 0, 0, 1357, 1358, 1, 0, 0, 0,
		1358, 1363, 3, 194, 97, 0, 1359, 1364, 5, 447, 0, 0, 1360, 1361, 5, 127,
		0, 0, 1361, 1362, 5, 401, 0, 0, 1362, 1364, 5, 544, 0, 0, 1363, 1359, 1,
		0, 0, 0, 1363, 1360, 1, 0, 0, 0, 1363, 1364, 1, 0, 0, 0, 1364, 1365, 1,
		0, 0, 0, 1365, 1367, 3, 134, 67, 0, 1366, 1368, 3, 432, 216, 0, 1367, 1366,
		1, 0, 0, 0, 1367, 1368, 1, 0, 0, 0, 1368, 1487, 1, 0, 0, 0, 1369, 1370,
		5, 101, 0, 0, 1370, 1374, 7, 10, 0, 0, 1371, 1372, 5, 222, 0, 0, 1372,
		1373, 5, 312, 0, 0, 1373, 1375, 5, 170, 0, 0, 1374, 1371, 1, 0, 0, 0, 1374,
		1375, 1, 0, 0, 0, 1375, 1376, 1, 0, 0, 0, 1376, 1378, 3, 328, 164, 0, 1377,
		1379, 3, 316, 158, 0, 1378, 1377, 1, 0, 0, 0, 1378, 1379, 1, 0, 0, 0, 1379,
		1487, 1, 0, 0, 0, 1380, 1383, 5, 101, 0, 0, 1381, 1382, 5, 370, 0, 0, 1382,
		1384, 5, 319, 0, 0, 1383, 1381, 1, 0, 0, 0, 1383, 1384, 1, 0, 0, 0, 1384,
		1385, 1, 0, 0, 0, 1385, 1386, 5, 388, 0, 0, 1386, 1387, 3, 444, 222, 0,
		1387, 1388, 5, 512, 0, 0, 1388, 1389, 3, 132, 66, 0, 1389, 1487, 1, 0,
		0, 0, 1390, 1392, 5, 101, 0, 0, 1391, 1393, 5, 175, 0, 0, 1392, 1391, 1,
		0, 0, 0, 1392, 1393, 1, 0, 0, 0, 1393, 1394, 1, 0, 0, 0, 1394, 1398, 5,
		389, 0, 0, 1395, 1396, 5, 222, 0, 0, 1396, 1397, 5, 312, 0, 0, 1397, 1399,
		5, 170, 0, 0, 1398, 1395, 1, 0, 0, 0, 1398, 1399, 1, 0, 0, 0, 1399, 1400,
		1, 0, 0, 0, 1400, 1402, 3, 184, 92, 0, 1401, 1403, 3, 316, 158, 0, 1402,
		1401, 1, 0, 0, 0, 1402, 1403, 1, 0, 0, 0, 1403, 1487, 1, 0, 0, 0, 1404,
		1405, 5, 101, 0, 0, 1405, 1409, 5, 136, 0, 0, 1406, 1407, 5, 222, 0, 0,
		1407, 1408, 5, 312, 0, 0, 1408, 1410, 5, 170, 0, 0, 1409, 1406, 1, 0, 0,
		0, 1409, 1410, 1, 0, 0, 0, 1410, 1411, 1, 0, 0, 0, 1411, 1412, 3, 328,
		164, 0, 1412, 1413, 5, 493, 0, 0, 1413, 1414, 3, 328, 164, 0, 1414, 1415,
		5, 2, 0, 0, 1415, 1416, 3, 20, 10, 0, 1416, 1417, 5, 3, 0, 0, 1417, 1418,
		5, 258, 0, 0, 1418, 1419, 5, 2, 0, 0, 1419, 1420, 3, 444, 222, 0, 1420,
		1422, 5, 3, 0, 0, 1421, 1423, 3, 316, 158, 0, 1422, 1421, 1, 0, 0, 0, 1422,
		1423, 1, 0, 0, 0, 1423, 1487, 1, 0, 0, 0, 1424, 1425, 5, 101, 0, 0, 1425,
		1429, 5, 434, 0, 0, 1426, 1427, 5, 222, 0, 0, 1427, 1428, 5, 312, 0, 0,
		1428, 1430, 5, 170, 0, 0, 1429, 1426, 1, 0, 0, 0, 1429, 1430, 1, 0, 0,
		0, 1430, 1431, 1, 0, 0, 0, 1431, 1433, 3, 444, 222, 0, 1432, 1434, 3, 316,
		158, 0, 1433, 1432, 1, 0, 0, 0, 1433, 1434, 1, 0, 0, 0, 1434, 1487, 1,
		0, 0, 0, 1435, 1436, 5, 101, 0, 0, 1436, 1437, 5, 441, 0, 0, 1437, 1441,
		5, 500, 0, 0, 1438, 1439, 5, 222, 0, 0, 1439, 1440, 5, 312, 0, 0, 1440,
		1442, 5, 170, 0, 0, 1441, 1438, 1, 0, 0, 0, 1441, 1442, 1, 0, 0, 0, 1442,
		1443, 1, 0, 0, 0, 1443, 1445, 3, 184, 92, 0, 1444, 1446, 3, 316, 158, 0,
		1445, 1444, 1, 0, 0, 0, 1445, 1446, 1, 0, 0, 0, 1446, 1487, 1, 0, 0, 0,
		1447, 1448, 5, 101, 0, 0, 1448, 1449, 5, 239, 0, 0, 1449, 1450, 5, 227,
		0, 0, 1450, 1454, 5, 24, 0, 0, 1451, 1452, 5, 222, 0, 0, 1452, 1453, 5,
		312, 0, 0, 1453, 1455, 5, 170, 0, 0, 1454, 1451, 1, 0, 0, 0, 1454, 1455,
		1, 0, 0, 0, 1455, 1456, 1, 0, 0, 0, 1456, 1458, 3, 444, 222, 0, 1457, 1459,
		3, 316, 158, 0, 1458, 1457, 1, 0, 0, 0, 1458, 1459, 1, 0, 0, 0, 1459, 1487,
		1, 0, 0, 0, 1460, 1461, 5, 101, 0, 0, 1461, 1462, 5, 239, 0, 0, 1462, 1463,
		5, 227, 0, 0, 1463, 1467, 5, 468, 0, 0, 1464, 1465, 5, 222, 0, 0, 1465,
		1466, 5, 312, 0, 0, 1466, 1468, 5, 170, 0, 0, 1467, 1464, 1, 0, 0, 0, 1467,
		1468, 1, 0, 0, 0, 1468, 1469, 1, 0, 0, 0, 1469, 1471, 3, 444, 222, 0, 1470,
		1472, 3, 316, 158, 0, 1471, 1470, 1, 0, 0, 0, 1471, 1472, 1, 0, 0, 0, 1472,
		1487, 1, 0, 0, 0, 1473, 1474, 5, 101, 0, 0, 1474, 1475, 5, 239, 0, 0, 1475,
		1476, 5, 227, 0, 0, 1476, 1480, 5, 469, 0, 0, 1477, 1478, 5, 222, 0, 0,
		1478, 1479, 5, 312, 0, 0, 1479, 1481, 5, 170, 0, 0, 1480, 1477, 1, 0, 0,
		0, 1480, 1481, 1, 0, 0, 0, 1481, 1482, 1, 0, 0, 0, 1482, 1484, 3, 444,
		222, 0, 1483, 1485, 3, 316, 158, 0, 1484, 1483, 1, 0, 0, 0, 1484, 1485,
		1, 0, 0, 0, 1485, 1487, 1, 0, 0, 0, 1486, 998, 1, 0, 0, 0, 1486, 1081,
		1, 0, 0, 0, 1486, 1106, 1, 0, 0, 0, 1486, 1114, 1, 0, 0, 0, 1486, 1134,
		1, 0, 0, 0, 1486, 1146, 1, 0, 0, 0, 1486, 1162, 1, 0, 0, 0, 1486, 1182,
		1, 0, 0, 0, 1486, 1206, 1, 0, 0, 0, 1486, 1218, 1, 0, 0, 0, 1486, 1226,
		1, 0, 0, 0, 1486, 1248, 1, 0, 0, 0, 1486, 1274, 1, 0, 0, 0, 1486, 1285,
		1, 0, 0, 0, 1486, 1296, 1, 0, 0, 0, 1486, 1324, 1, 0, 0, 0, 1486, 1351,
		1, 0, 0, 0, 1486, 1369, 1, 0, 0, 0, 1486, 1380, 1, 0, 0, 0, 1486, 1390,
		1, 0, 0, 0, 1486, 1404, 1, 0, 0, 0, 1486, 1424, 1, 0, 0, 0, 1486, 1435,
		1, 0, 0, 0, 1486, 1447, 1, 0, 0, 0, 1486, 1460, 1, 0, 0, 0, 1486, 1473,
		1, 0, 0, 0, 1487, 19, 1, 0, 0, 0, 1488, 1493, 3, 22, 11, 0, 1489, 1490,
		5, 4, 0, 0, 1490, 1492, 3, 22, 11, 0, 1491, 1489, 1, 0, 0, 0, 1492, 1495,
		1, 0, 0, 0, 1493, 1491, 1, 0, 0, 0, 1493, 1494, 1, 0, 0, 0, 1494, 21, 1,
		0, 0, 0, 1495, 1493, 1, 0, 0, 0, 1496, 1497, 3, 444, 222, 0, 1497, 1498,
		7, 11, 0, 0, 1498, 23, 1, 0, 0, 0, 1499, 1500, 5, 21, 0, 0, 1500, 1501,
		5, 450, 0, 0, 1501, 1712, 3, 84, 42, 0, 1502, 1503, 5, 21, 0, 0, 1503,
		1504, 5, 504, 0, 0, 1504, 1519, 3, 328, 164, 0, 1505, 1506, 5, 299, 0,
		0, 1506, 1520, 3, 432, 216, 0, 1507, 1508, 5, 2, 0, 0, 1508, 1509, 3, 330,
		165, 0, 1509, 1510, 5, 3, 0, 0, 1510, 1512, 1, 0, 0, 0, 1511, 1507, 1,
		0, 0, 0, 1511, 1512, 1, 0, 0, 0, 1512, 1515, 1, 0, 0, 0, 1513, 1514, 5,
		83, 0, 0, 1514, 1516, 5, 544, 0, 0, 1515, 1513, 1, 0, 0, 0, 1515, 1516,
		1, 0, 0, 0, 1516, 1517, 1, 0, 0, 0, 1517, 1518, 5, 29, 0, 0, 1518, 1520,
		3, 230, 115, 0, 1519, 1505, 1, 0, 0, 0, 1519, 1511, 1, 0, 0, 0, 1520, 1712,
		1, 0, 0, 0, 1521, 1522, 5, 21, 0, 0, 1522, 1523, 5, 68, 0, 0, 1523, 1524,
		3, 444, 222, 0, 1524, 1525, 5, 380, 0, 0, 1525, 1526, 3, 444, 222, 0, 1526,
		1712, 1, 0, 0, 0, 1527, 1528, 5, 21, 0, 0, 1528, 1529, 5, 401, 0, 0, 1529,
		1530, 3, 184, 92, 0, 1530, 1531, 3, 432, 216, 0, 1531, 1712, 1, 0, 0, 0,
		1532, 1533, 5, 21, 0, 0, 1533, 1534, 5, 441, 0, 0, 1534, 1535, 5, 500,
		0, 0, 1535, 1536, 3, 328, 164, 0, 1536, 1537, 3, 316, 158, 0, 1537, 1712,
		1, 0, 0, 0, 1538, 1539, 5, 21, 0, 0, 1539, 1540, 5, 514, 0, 0, 1540, 1541,
		5, 205, 0, 0, 1541, 1544, 3, 184, 92, 0, 1542, 1543, 5, 188, 0, 0, 1543,
		1545, 3, 184, 92, 0, 1544, 1542, 1, 0, 0, 0, 1544, 1545, 1, 0, 0, 0, 1545,
		1547, 1, 0, 0, 0, 1546, 1548, 3, 316, 158, 0, 1547, 1546, 1, 0, 0, 0, 1547,
		1548, 1, 0, 0, 0, 1548, 1712, 1, 0, 0, 0, 1549, 1550, 5, 21, 0, 0, 1550,
		1551, 5, 68, 0, 0, 1551, 1552, 3, 444, 222, 0, 1552, 1553, 5, 420, 0, 0,
		1553, 1554, 5, 359, 0, 0, 1554, 1555, 5, 2, 0, 0, 1555, 1556, 3, 318, 159,
		0, 1556, 1557, 5, 3, 0, 0, 1557, 1712, 1, 0, 0, 0, 1558, 1559, 5, 21, 0,
		0, 1559, 1560, 5, 514, 0, 0, 1560, 1561, 5, 351, 0, 0, 1561, 1563, 3, 184,
		92, 0, 1562, 1564, 3, 316, 158, 0, 1563, 1562, 1, 0, 0, 0, 1563, 1564,
		1, 0, 0, 0, 1564, 1712, 1, 0, 0, 0, 1565, 1566, 5, 21, 0, 0, 1566, 1567,
		5, 433, 0, 0, 1567, 1569, 3, 444, 222, 0, 1568, 1570, 3, 316, 158, 0, 1569,
		1568, 1, 0, 0, 0, 1569, 1570, 1, 0, 0, 0, 1570, 1712, 1, 0, 0, 0, 1571,
		1572, 5, 21, 0, 0, 1572, 1573, 5, 68, 0, 0, 1573, 1574, 3, 444, 222, 0,
		1574, 1575, 5, 299, 0, 0, 1575, 1576, 5, 83, 0, 0, 1576, 1577, 5, 544,
		0, 0, 1577, 1712, 1, 0, 0, 0, 1578, 1579, 5, 21, 0, 0, 1579, 1580, 5, 113,
		0, 0, 1580, 1581, 3, 444, 222, 0, 1581, 1582, 5, 380, 0, 0, 1582, 1583,
		3, 444, 222, 0, 1583, 1712, 1, 0, 0, 0, 1584, 1585, 5, 21, 0, 0, 1585,
		1586, 5, 441, 0, 0, 1586, 1587, 5, 351, 0, 0, 1587, 1588, 3, 184, 92, 0,
		1588, 1589, 3, 316, 158, 0, 1589, 1712, 1, 0, 0, 0, 1590, 1591, 5, 21,
		0, 0, 1591, 1592, 5, 451, 0, 0, 1592, 1593, 3, 328, 164, 0, 1593, 1598,
		3, 90, 45, 0, 1594, 1595, 5, 4, 0, 0, 1595, 1597, 3, 90, 45, 0, 1596, 1594,
		1, 0, 0, 0, 1597, 1600, 1, 0, 0, 0, 1598, 1596, 1, 0, 0, 0, 1598, 1599,
		1, 0, 0, 0, 1599, 1712, 1, 0, 0, 0, 1600, 1598, 1, 0, 0, 0, 1601, 1602,
		5, 21, 0, 0, 1602, 1603, 5, 451, 0, 0, 1603, 1604, 3, 328, 164, 0, 1604,
		1605, 5, 14, 0, 0, 1605, 1606, 5, 404, 0, 0, 1606, 1611, 3, 88, 44, 0,
		1607, 1608, 5, 4, 0, 0, 1608, 1610, 3, 88, 44, 0, 1609, 1607, 1, 0, 0,
		0, 1610, 1613, 1, 0, 0, 0, 1611, 1609, 1, 0, 0, 0, 1611, 1612, 1, 0, 0,
		0, 1612, 1712, 1, 0, 0, 0, 1613, 1611, 1, 0, 0, 0, 1614, 1615, 5, 21, 0,
		0, 1615, 1616, 5, 451, 0, 0, 1616, 1617, 3, 328, 164, 0, 1617, 1618, 5,
		147, 0, 0, 1618, 1619, 5, 404, 0, 0, 1619, 1624, 3, 86, 43, 0, 1620, 1621,
		5, 4, 0, 0, 1621, 1623, 3, 86, 43, 0, 1622, 1620, 1, 0, 0, 0, 1623, 1626,
		1, 0, 0, 0, 1624, 1622, 1, 0, 0, 0, 1624, 1625, 1, 0, 0, 0, 1625, 1712,
		1, 0, 0, 0, 1626, 1624, 1, 0, 0, 0, 1627, 1628, 5, 21, 0, 0, 1628, 1629,
		5, 451, 0, 0, 1629, 1630, 3, 328, 164, 0, 1630, 1631, 5, 420, 0, 0, 1631,
		1632, 5, 2, 0, 0, 1632, 1633, 3, 318, 159, 0, 1633, 1634, 5, 3, 0, 0, 1634,
		1712, 1, 0, 0, 0, 1635, 1636, 5, 21, 0, 0, 1636, 1637, 5, 113, 0, 0, 1637,
		1638, 3, 444, 222, 0, 1638, 1639, 5, 420, 0, 0, 1639, 1640, 7, 12, 0, 0,
		1640, 1643, 5, 365, 0, 0, 1641, 1644, 3, 444, 222, 0, 1642, 1644, 5, 549,
		0, 0, 1643, 1641, 1, 0, 0, 0, 1643, 1642, 1, 0, 0, 0, 1644, 1712, 1, 0,
		0, 0, 1645, 1646, 5, 21, 0, 0, 1646, 1647, 5, 113, 0, 0, 1647, 1648, 3,
		444, 222, 0, 1648, 1649, 5, 420, 0, 0, 1649, 1650, 5, 359, 0, 0, 1650,
		1651, 5, 2, 0, 0, 1651, 1652, 3, 318, 159, 0, 1652, 1653, 5, 3, 0, 0, 1653,
		1712, 1, 0, 0, 0, 1654, 1655, 5, 21, 0, 0, 1655, 1656, 5, 450, 0, 0, 1656,
		1657, 5, 380, 0, 0, 1657, 1658, 5, 89, 0, 0, 1658, 1659, 5, 205, 0, 0,
		1659, 1660, 3, 444, 222, 0, 1660, 1661, 3, 444, 222, 0, 1661, 1712, 1,
		0, 0, 0, 1662, 1663, 5, 21, 0, 0, 1663, 1664, 5, 389, 0, 0, 1664, 1666,
		3, 184, 92, 0, 1665, 1667, 3, 316, 158, 0, 1666, 1665, 1, 0, 0, 0, 1666,
		1667, 1, 0, 0, 0, 1667, 1712, 1, 0, 0, 0, 1668, 1669, 5, 21, 0, 0, 1669,
		1670, 5, 388, 0, 0, 1670, 1672, 3, 444, 222, 0, 1671, 1673, 3, 316, 158,
		0, 1672, 1671, 1, 0, 0, 0, 1672, 1673, 1, 0, 0, 0, 1673, 1712, 1, 0, 0,
		0, 1674, 1675, 5, 21, 0, 0, 1675, 1676, 5, 405, 0, 0, 1676, 1677, 5, 271,
		0, 0, 1677, 1678, 5, 188, 0, 0, 1678, 1680, 3, 328, 164, 0, 1679, 1681,
		3, 316, 158, 0, 1680, 1679, 1, 0, 0, 0, 1680, 1681, 1, 0, 0, 0, 1681, 1688,
		1, 0, 0, 0, 1682, 1683, 5, 193, 0, 0, 1683, 1684, 3, 444, 222, 0, 1684,
		1685, 5, 2, 0, 0, 1685, 1686, 3, 318, 159, 0, 1686, 1687, 5, 3, 0, 0, 1687,
		1689, 1, 0, 0, 0, 1688, 1682, 1, 0, 0, 0, 1688, 1689, 1, 0, 0, 0, 1689,
		1712, 1, 0, 0, 0, 1690, 1691, 5, 21, 0, 0, 1691, 1692, 5, 80, 0, 0, 1692,
		1693, 5, 205, 0, 0, 1693, 1694, 3, 328, 164, 0, 1694, 1695, 5, 420, 0,
		0, 1695, 1696, 5, 2, 0, 0, 1696, 1697, 3, 318, 159, 0, 1697, 1698, 5, 3,
		0, 0, 1698, 1712, 1, 0, 0, 0, 1699, 1700, 5, 21, 0, 0, 1700, 1703, 5, 491,
		0, 0, 1701, 1702, 5, 222, 0, 0, 1702, 1704, 5, 170, 0, 0, 1703, 1701, 1,
		0, 0, 0, 1703, 1704, 1, 0, 0, 0, 1704, 1705, 1, 0, 0, 0, 1705, 1706, 3,
		194, 97, 0, 1706, 1709, 3, 134, 67, 0, 1707, 1708, 5, 83, 0, 0, 1708, 1710,
		5, 544, 0, 0, 1709, 1707, 1, 0, 0, 0, 1709, 1710, 1, 0, 0, 0, 1710, 1712,
		1, 0, 0, 0, 1711, 1499, 1, 0, 0, 0, 1711, 1502, 1, 0, 0, 0, 1711, 1521,
		1, 0, 0, 0, 1711, 1527, 1, 0, 0, 0, 1711, 1532, 1, 0, 0, 0, 1711, 1538,
		1, 0, 0, 0, 1711, 1549, 1, 0, 0, 0, 1711, 1558, 1, 0, 0, 0, 1711, 1565,
		1, 0, 0, 0, 1711, 1571, 1, 0, 0, 0, 1711, 1578, 1, 0, 0, 0, 1711, 1584,
		1, 0, 0, 0, 1711, 1590, 1, 0, 0, 0, 1711, 1601, 1, 0, 0, 0, 1711, 1614,
		1, 0, 0, 0, 1711, 1627, 1, 0, 0, 0, 1711, 1635, 1, 0, 0, 0, 1711, 1645,
		1, 0, 0, 0, 1711, 1654, 1, 0, 0, 0, 1711, 1662, 1, 0, 0, 0, 1711, 1668,
		1, 0, 0, 0, 1711, 1674, 1, 0, 0, 0, 1711, 1690, 1, 0, 0, 0, 1711, 1699,
		1, 0, 0, 0, 1712, 25, 1, 0, 0, 0, 1713, 1714, 5, 147, 0, 0, 1714, 1715,
		5, 68, 0, 0, 1715, 1716, 5, 375, 0, 0, 1716, 1717, 5, 43, 0, 0, 1717, 1718,
		5, 510, 0, 0, 1718, 1719, 5, 544, 0, 0, 1719, 1720, 5, 518, 0, 0, 1720,
		1915, 5, 549, 0, 0, 1721, 1722, 5, 147, 0, 0, 1722, 1725, 5, 156, 0, 0,
		1723, 1724, 5, 222, 0, 0, 1724, 1726, 5, 170, 0, 0, 1725, 1723, 1, 0, 0,
		0, 1725, 1726, 1, 0, 0, 0, 1726, 1727, 1, 0, 0, 0, 1727, 1915, 3, 328,
		164, 0, 1728, 1729, 5, 147, 0, 0, 1729, 1732, 5, 401, 0, 0, 1730, 1731,
		5, 222, 0, 0, 1731, 1733, 5, 170, 0, 0, 1732, 1730, 1, 0, 0, 0, 1732, 1733,
		1, 0, 0, 0, 1733, 1734, 1, 0, 0, 0, 1734, 1915, 3, 184, 92, 0, 1735, 1736,
		5, 147, 0, 0, 1736, 1739, 5, 433, 0, 0, 1737, 1738, 5, 222, 0, 0, 1738,
		1740, 5, 170, 0, 0, 1739, 1737, 1, 0, 0, 0, 1739, 1740, 1, 0, 0, 0, 1740,
		1741, 1, 0, 0, 0, 1741, 1915, 3, 308, 154, 0, 1742, 1743, 5, 147, 0, 0,
		1743, 1746, 5, 491, 0, 0, 1744, 1745, 5, 222, 0, 0, 1745, 1747, 5, 170,
		0, 0, 1746, 1744, 1, 0, 0, 0, 1746, 1747, 1, 0, 0, 0, 1747, 1748, 1, 0,
		0, 0, 1748, 1915, 3, 192, 96, 0, 1749, 1750, 5, 147, 0, 0, 1750, 1751,
		5, 441, 0, 0, 1751, 1754, 5, 351, 0, 0, 1752, 1753, 5, 222, 0, 0, 1753,
		1755, 5, 170, 0, 0, 1754, 1752, 1, 0, 0, 0, 1754, 1755, 1, 0, 0, 0, 1755,
		1756, 1, 0, 0, 0, 1756, 1915, 3, 444, 222, 0, 1757, 1758, 5, 147, 0, 0,
		1758, 1759, 5, 514, 0, 0, 1759, 1762, 5, 205, 0, 0, 1760, 1761, 5, 222,
		0, 0, 1761, 1763, 5, 170, 0, 0, 1762, 1760, 1, 0, 0, 0, 1762, 1763, 1,
		0, 0, 0, 1763, 1764, 1, 0, 0, 0, 1764, 1767, 3, 184, 92, 0, 1765, 1766,
		5, 188, 0, 0, 1766, 1768, 3, 184, 92, 0, 1767, 1765, 1, 0, 0, 0, 1767,
		1768, 1, 0, 0, 0, 1768, 1915, 1, 0, 0, 0, 1769, 1770, 5, 147, 0, 0, 1770,
		1773, 5, 68, 0, 0, 1771, 1772, 5, 222, 0, 0, 1772, 1774, 5, 170, 0, 0,
		1773, 1771, 1, 0, 0, 0, 1773, 1774, 1, 0, 0, 0, 1774, 1775, 1, 0, 0, 0,
		1775, 1915, 3, 444, 222, 0, 1776, 1777, 5, 147, 0, 0, 1777, 1778, 5, 182,
		0, 0, 1778, 1781, 5, 544, 0, 0, 1779, 1780, 7, 6, 0, 0, 1780, 1782, 3,
		444, 222, 0, 1781, 1779, 1, 0, 0, 0, 1781, 1782, 1, 0, 0, 0, 1782, 1783,
		1, 0, 0, 0, 1783, 1915, 3, 316, 158, 0, 1784, 1785, 5, 147, 0, 0, 1785,
		1786, 5, 514, 0, 0, 1786, 1789, 5, 351, 0, 0, 1787, 1788, 5, 222, 0, 0,
		1788, 1790, 5, 170, 0, 0, 1789, 1787, 1, 0, 0, 0, 1789, 1790, 1, 0, 0,
		0, 1790, 1791, 1, 0, 0, 0, 1791, 1915, 3, 184, 92, 0, 1792, 1793, 5, 147,
		0, 0, 1793, 1794, 5, 388, 0, 0, 1794, 1915, 3, 444, 222, 0, 1795, 1796,
		5, 147, 0, 0, 1796, 1799, 5, 451, 0, 0, 1797, 1798, 5, 222, 0, 0, 1798,
		1800, 5, 170, 0, 0, 1799, 1797, 1, 0, 0, 0, 1799, 1800, 1, 0, 0, 0, 1800,
		1801, 1, 0, 0, 0, 1801, 1803, 3, 328, 164, 0, 1802, 1804, 5, 190, 0, 0,
		1803, 1802, 1, 0, 0, 0, 1803, 1804, 1, 0, 0, 0, 1804, 1915, 1, 0, 0, 0,
		1805, 1806, 5, 147, 0, 0, 1806, 1809, 7, 10, 0, 0, 1807, 1808, 5, 222,
		0, 0, 1808, 1810, 5, 170, 0, 0, 1809, 1807, 1, 0, 0, 0, 1809, 1810, 1,
		0, 0, 0, 1810, 1811, 1, 0, 0, 0, 1811, 1813, 3, 328, 164, 0, 1812, 1814,
		5, 190, 0, 0, 1813, 1812, 1, 0, 0, 0, 1813, 1814, 1, 0, 0, 0, 1814, 1915,
		1, 0, 0, 0, 1815, 1817, 5, 147, 0, 0, 1816, 1818, 3, 172, 86, 0, 1817,
		1816, 1, 0, 0, 0, 1817, 1818, 1, 0, 0, 0, 1818, 1819, 1, 0, 0, 0, 1819,
		1822, 5, 197, 0, 0, 1820, 1821, 5, 222, 0, 0, 1821, 1823, 5, 170, 0, 0,
		1822, 1820, 1, 0, 0, 0, 1822, 1823, 1, 0, 0, 0, 1823, 1824, 1, 0, 0, 0,
		1824, 1825, 3, 394, 197, 0, 1825, 1827, 5, 2, 0, 0, 1826, 1828, 3, 136,
		68, 0, 1827, 1826, 1, 0, 0, 0, 1827, 1828, 1, 0, 0, 0, 1828, 1829, 1, 0,
		0, 0, 1829, 1830, 5, 3, 0, 0, 1830, 1915, 1, 0, 0, 0, 1831, 1832, 5, 147,
		0, 0, 1832, 1835, 5, 227, 0, 0, 1833, 1834, 5, 222, 0, 0, 1834, 1836, 5,
		170, 0, 0, 1835, 1833, 1, 0, 0, 0, 1835, 1836, 1, 0, 0, 0, 1836, 1837,
		1, 0, 0, 0, 1837, 1838, 3, 444, 222, 0, 1838, 1839, 5, 318, 0, 0, 1839,
		1840, 3, 328, 164, 0, 1840, 1915, 1, 0, 0, 0, 1841, 1842, 5, 147, 0, 0,
		1842, 1845, 5, 389, 0, 0, 1843, 1844, 5, 222, 0, 0, 1844, 1846, 5, 170,
		0, 0, 1845, 1843, 1, 0, 0, 0, 1845, 1846, 1, 0, 0, 0, 1846, 1847, 1, 0,
		0, 0, 1847, 1915, 3, 184, 92, 0, 1848, 1849, 5, 147, 0, 0, 1849, 1850,
		5, 406, 0, 0, 1850, 1853, 5, 351, 0, 0, 1851, 1852, 5, 222, 0, 0, 1852,
		1854, 5, 170, 0, 0, 1853, 1851, 1, 0, 0, 0, 1853, 1854, 1, 0, 0, 0, 1854,
		1855, 1, 0, 0, 0, 1855, 1856, 3, 444, 222, 0, 1856, 1857, 5, 318, 0, 0,
		1857, 1864, 3, 328, 164, 0, 1858, 1862, 5, 188, 0, 0, 1859, 1863, 3, 192,
		96, 0, 1860, 1861, 5, 401, 0, 0, 1861, 1863, 3, 444, 222, 0, 1862, 1859,
		1, 0, 0, 0, 1862, 1860, 1, 0, 0, 0, 1863, 1865, 1, 0, 0, 0, 1864, 1858,
		1, 0, 0, 0, 1864, 1865, 1, 0, 0, 0, 1865, 1915, 1, 0, 0, 0, 1866, 1867,
		5, 147, 0, 0, 1867, 1870, 5, 136, 0, 0, 1868, 1869, 5, 222, 0, 0, 1869,
		1871, 5, 170, 0, 0, 1870, 1868, 1, 0, 0, 0, 1870, 1871, 1, 0, 0, 0, 1871,
		1872, 1, 0, 0, 0, 1872, 1915, 3, 328, 164, 0, 1873, 1874, 5, 147, 0, 0,
		1874, 1877, 5, 434, 0, 0, 1875, 1876, 5, 222, 0, 0, 1876, 1878, 5, 170,
		0, 0, 1877, 1875, 1, 0, 0, 0, 1877, 1878, 1, 0, 0, 0, 1878, 1879, 1, 0,
		0, 0, 1879, 1915, 3, 444, 222, 0, 1880, 1881, 5, 147, 0, 0, 1881, 1884,
		5, 504, 0, 0, 1882, 1883, 5, 222, 0, 0, 1883, 1885, 5, 170, 0, 0, 1884,
		1882, 1, 0, 0, 0, 1884, 1885, 1, 0, 0, 0, 1885, 1886, 1, 0, 0, 0, 1886,
		1915, 3, 328, 164, 0, 1887, 1888, 5, 147, 0, 0, 1888, 1889, 5, 239, 0,
		0, 1889, 1890, 5, 227, 0, 0, 1890, 1893, 5, 24, 0, 0, 1891, 1892, 5, 222,
		0, 0, 1892, 1894, 5, 170, 0, 0, 1893, 1891, 1, 0, 0, 0, 1893, 1894, 1,
		0, 0, 0, 1894, 1895, 1, 0, 0, 0, 1895, 1915, 3, 444, 222, 0, 1896, 1897,
		5, 147, 0, 0, 1897, 1898, 5, 239, 0, 0, 1898, 1899, 5, 227, 0, 0, 1899,
		1902, 5, 468, 0, 0, 1900, 1901, 5, 222, 0, 0, 1901, 1903, 5, 170, 0, 0,
		1902, 1900, 1, 0, 0, 0, 1902, 1903, 1, 0, 0, 0, 1903, 1904, 1, 0, 0, 0,
		1904, 1915, 3, 444, 222, 0, 1905, 1906, 5, 147, 0, 0, 1906, 1907, 5, 239,
		0, 0, 1907, 1908, 5, 227, 0, 0, 1908, 1911, 5, 469, 0, 0, 1909, 1910, 5,
		222, 0, 0, 1910, 1912, 5, 170, 0, 0, 1911, 1909, 1, 0, 0, 0, 1911, 1912,
		1, 0, 0, 0, 1912, 1913, 1, 0, 0, 0, 1913, 1915, 3, 444, 222, 0, 1914, 1713,
		1, 0, 0, 0, 1914, 1721, 1, 0, 0, 0, 1914, 1728, 1, 0, 0, 0, 1914, 1735,
		1, 0, 0, 0, 1914, 1742, 1, 0, 0, 0, 1914, 1749, 1, 0, 0, 0, 1914, 1757,
		1, 0, 0, 0, 1914, 1769, 1, 0, 0, 0, 1914, 1776, 1, 0, 0, 0, 1914, 1784,
		1, 0, 0, 0, 1914, 1792, 1, 0, 0, 0, 1914, 1795, 1, 0, 0, 0, 1914, 1805,
		1, 0, 0, 0, 1914, 1815, 1, 0, 0, 0, 1914, 1831, 1, 0, 0, 0, 1914, 1841,
		1, 0, 0, 0, 1914, 1848, 1, 0, 0, 0, 1914, 1866, 1, 0, 0, 0, 1914, 1873,
		1, 0, 0, 0, 1914, 1880, 1, 0, 0, 0, 1914, 1887, 1, 0, 0, 0, 1914, 1896,
		1, 0, 0, 0, 1914, 1905, 1, 0, 0, 0, 1915, 27, 1, 0, 0, 0, 1916, 1918, 5,
		424, 0, 0, 1917, 1919, 3, 172, 86, 0, 1918, 1917, 1, 0, 0, 0, 1918, 1919,
		1, 0, 0, 0, 1919, 1920, 1, 0, 0, 0, 1920, 1922, 5, 498, 0, 0, 1921, 1923,
		3, 74, 37, 0, 1922, 1921, 1, 0, 0, 0, 1922, 1923, 1, 0, 0, 0, 1923, 2615,
		1, 0, 0, 0, 1924, 1925, 5, 424, 0, 0, 1925, 2615, 5, 32, 0, 0, 1926, 1927,
		5, 424, 0, 0, 1927, 1928, 5, 21, 0, 0, 1928, 1933, 5, 451, 0, 0, 1929,
		1934, 5, 404, 0, 0, 1930, 1931, 5, 288, 0, 0, 1931, 1934, 5, 504, 0, 0,
		1932, 1934, 5, 81, 0, 0, 1933, 1929, 1, 0, 0, 0, 1933, 1930, 1, 0, 0, 0,
		1933, 1932, 1, 0, 0, 0, 1934, 1937, 1, 0, 0, 0, 1935, 1936, 7, 6, 0, 0,
		1936, 1938, 3, 328, 164, 0, 1937, 1935, 1, 0, 0, 0, 1937, 1938, 1, 0, 0,
		0, 1938, 1940, 1, 0, 0, 0, 1939, 1941, 3, 74, 37, 0, 1940, 1939, 1, 0,
		0, 0, 1940, 1941, 1, 0, 0, 0, 1941, 1943, 1, 0, 0, 0, 1942, 1944, 3, 294,
		147, 0, 1943, 1942, 1, 0, 0, 0, 1943, 1944, 1, 0, 0, 0, 1944, 1946, 1,
		0, 0, 0, 1945, 1947, 3, 298, 149, 0, 1946, 1945, 1, 0, 0, 0, 1946, 1947,
		1, 0, 0, 0, 1947, 2615, 1, 0, 0, 0, 1948, 1949, 5, 424, 0, 0, 1949, 1950,
		5, 101, 0, 0, 1950, 1951, 7, 10, 0, 0, 1951, 2615, 3, 328, 164, 0, 1952,
		1953, 5, 424, 0, 0, 1953, 1956, 5, 38, 0, 0, 1954, 1955, 7, 6, 0, 0, 1955,
		1957, 3, 444, 222, 0, 1956, 1954, 1, 0, 0, 0, 1956, 1957, 1, 0, 0, 0, 1957,
		1959, 1, 0, 0, 0, 1958, 1960, 3, 74, 37, 0, 1959, 1958, 1, 0, 0, 0, 1959,
		1960, 1, 0, 0, 0, 1960, 2615, 1, 0, 0, 0, 1961, 1962, 5, 424, 0, 0, 1962,
		2615, 5, 56, 0, 0, 1963, 1964, 5, 424, 0, 0, 1964, 1965, 5, 58, 0, 0, 1965,
		1968, 5, 227, 0, 0, 1966, 1967, 7, 6, 0, 0, 1967, 1969, 3, 444, 222, 0,
		1968, 1966, 1, 0, 0, 0, 1968, 1969, 1, 0, 0, 0, 1969, 1971, 1, 0, 0, 0,
		1970, 1972, 3, 74, 37, 0, 1971, 1970, 1, 0, 0, 0, 1971, 1972, 1, 0, 0,
		0, 1972, 1974, 1, 0, 0, 0, 1973, 1975, 3, 294, 147, 0, 1974, 1973, 1, 0,
		0, 0, 1974, 1975, 1, 0, 0, 0, 1975, 1977, 1, 0, 0, 0, 1976, 1978, 3, 298,
		149, 0, 1977, 1976, 1, 0, 0, 0, 1977, 1978, 1, 0, 0, 0, 1978, 2615, 1,
		0, 0, 0, 1979, 1980, 5, 424, 0, 0, 1980, 1981, 5, 152, 0, 0, 1981, 1982,
		5, 330, 0, 0, 1982, 1985, 5, 452, 0, 0, 1983, 1984, 7, 6, 0, 0, 1984, 1986,
		3, 328, 164, 0, 1985, 1983, 1, 0, 0, 0, 1985, 1986, 1, 0, 0, 0, 1986, 2615,
		1, 0, 0, 0, 1987, 1988, 5, 424, 0, 0, 1988, 1991, 5, 165, 0, 0, 1989, 1990,
		7, 6, 0, 0, 1990, 1992, 3, 328, 164, 0, 1991, 1989, 1, 0, 0, 0, 1991, 1992,
		1, 0, 0, 0, 1992, 1994, 1, 0, 0, 0, 1993, 1995, 3, 74, 37, 0, 1994, 1993,
		1, 0, 0, 0, 1994, 1995, 1, 0, 0, 0, 1995, 2615, 1, 0, 0, 0, 1996, 1997,
		5, 424, 0, 0, 1997, 2000, 5, 173, 0, 0, 1998, 1999, 7, 6, 0, 0, 1999, 2001,
		3, 328, 164, 0, 2000, 1998, 1, 0, 0, 0, 2000, 2001, 1, 0, 0, 0, 2001, 2003,
		1, 0, 0, 0, 2002, 2004, 3, 74, 37, 0, 2003, 2002, 1, 0, 0, 0, 2003, 2004,
		1, 0, 0, 0, 2004, 2006, 1, 0, 0, 0, 2005, 2007, 3, 294, 147, 0, 2006, 2005,
		1, 0, 0, 0, 2006, 2007, 1, 0, 0, 0, 2007, 2009, 1, 0, 0, 0, 2008, 2010,
		3, 298, 149, 0, 2009, 2008, 1, 0, 0, 0, 2009, 2010, 1, 0, 0, 0, 2010, 2615,
		1, 0, 0, 0, 2011, 2012, 5, 424, 0, 0, 2012, 2013, 5, 259, 0, 0, 2013, 2615,
		5, 231, 0, 0, 2014, 2018, 5, 424, 0, 0, 2015, 2016, 5, 71, 0, 0, 2016,
		2019, 5, 420, 0, 0, 2017, 2019, 5, 72, 0, 0, 2018, 2015, 1, 0, 0, 0, 2018,
		2017, 1, 0, 0, 0, 2019, 2615, 1, 0, 0, 0, 2020, 2021, 5, 424, 0, 0, 2021,
		2024, 5, 129, 0, 0, 2022, 2023, 7, 6, 0, 0, 2023, 2025, 3, 328, 164, 0,
		2024, 2022, 1, 0, 0, 0, 2024, 2025, 1, 0, 0, 0, 2025, 2615, 1, 0, 0, 0,
		2026, 2027, 5, 424, 0, 0, 2027, 2029, 5, 101, 0, 0, 2028, 2030, 3, 172,
		86, 0, 2029, 2028, 1, 0, 0, 0, 2029, 2030, 1, 0, 0, 0, 2030, 2031, 1, 0,
		0, 0, 2031, 2032, 5, 197, 0, 0, 2032, 2033, 3, 394, 197, 0, 2033, 2035,
		5, 2, 0, 0, 2034, 2036, 3, 136, 68, 0, 2035, 2034, 1, 0, 0, 0, 2035, 2036,
		1, 0, 0, 0, 2036, 2037, 1, 0, 0, 0, 2037, 2040, 5, 3, 0, 0, 2038, 2039,
		7, 6, 0, 0, 2039, 2041, 3, 328, 164, 0, 2040, 2038, 1, 0, 0, 0, 2040, 2041,
		1, 0, 0, 0, 2041, 2615, 1, 0, 0, 0, 2042, 2044, 5, 424, 0, 0, 2043, 2045,
		5, 196, 0, 0, 2044, 2043, 1, 0, 0, 0, 2044, 2045, 1, 0, 0, 0, 2045, 2047,
		1, 0, 0, 0, 2046, 2048, 5, 59, 0, 0, 2047, 2046, 1, 0, 0, 0, 2047, 2048,
		1, 0, 0, 0, 2048, 2049, 1, 0, 0, 0, 2049, 2052, 5, 198, 0, 0, 2050, 2051,
		7, 6, 0, 0, 2051, 2053, 3, 328, 164, 0, 2052, 2050, 1, 0, 0, 0, 2052, 2053,
		1, 0, 0, 0, 2053, 2056, 1, 0, 0, 0, 2054, 2055, 5, 266, 0, 0, 2055, 2057,
		5, 544, 0, 0, 2056, 2054, 1, 0, 0, 0, 2056, 2057, 1, 0, 0, 0, 2057, 2615,
		1, 0, 0, 0, 2058, 2059, 5, 424, 0, 0, 2059, 2061, 5, 201, 0, 0, 2060, 2062,
		5, 196, 0, 0, 2061, 2060, 1, 0, 0, 0, 2061, 2062, 1, 0, 0, 0, 2062, 2063,
		1, 0, 0, 0, 2063, 2066, 5, 198, 0, 0, 2064, 2065, 5, 266, 0, 0, 2065, 2067,
		5, 544, 0, 0, 2066, 2064, 1, 0, 0, 0, 2066, 2067, 1, 0, 0, 0, 2067, 2615,
		1, 0, 0, 0, 2068, 2070, 5, 424, 0, 0, 2069, 2071, 5, 20, 0, 0, 2070, 2069,
		1, 0, 0, 0, 2070, 2071, 1, 0, 0, 0, 2071, 2072, 1, 0, 0, 0, 2072, 2615,
		5, 203, 0, 0, 2073, 2074, 5, 424, 0, 0, 2074, 2075, 5, 203, 0, 0, 2075,
		2076, 5, 188, 0, 0, 2076, 2615, 3, 192, 96, 0, 2077, 2078, 5, 424, 0, 0,
		2078, 2079, 5, 101, 0, 0, 2079, 2080, 5, 491, 0, 0, 2080, 2615, 3, 192,
		96, 0, 2081, 2082, 5, 424, 0, 0, 2082, 2083, 5, 428, 0, 0, 2083, 2084,
		5, 318, 0, 0, 2084, 2086, 3, 444, 222, 0, 2085, 2087, 3, 74, 37, 0, 2086,
		2085, 1, 0, 0, 0, 2086, 2087, 1, 0, 0, 0, 2087, 2615, 1, 0, 0, 0, 2088,
		2089, 5, 424, 0, 0, 2089, 2090, 5, 271, 0, 0, 2090, 2092, 5, 358, 0, 0,
		2091, 2093, 5, 544, 0, 0, 2092, 2091, 1, 0, 0, 0, 2092, 2093, 1, 0, 0,
		0, 2093, 2095, 1, 0, 0, 0, 2094, 2096, 3, 298, 149, 0, 2095, 2094, 1, 0,
		0, 0, 2095, 2096, 1, 0, 0, 0, 2096, 2615, 1, 0, 0, 0, 2097, 2098, 5, 424,
		0, 0, 2098, 2099, 5, 101, 0, 0, 2099, 2100, 5, 388, 0, 0, 2100, 2101, 5,
		188, 0, 0, 2101, 2615, 3, 444, 222, 0, 2102, 2103, 5, 424, 0, 0, 2103,
		2104, 5, 504, 0, 0, 2104, 2105, 7, 6, 0, 0, 2105, 2108, 3, 328, 164, 0,
		2106, 2107, 7, 6, 0, 0, 2107, 2109, 3, 444, 222, 0, 2108, 2106, 1, 0, 0,
		0, 2108, 2109, 1, 0, 0, 0, 2109, 2615, 1, 0, 0, 0, 2110, 2111, 5, 424,
		0, 0, 2111, 2615, 5, 350, 0, 0, 2112, 2113, 5, 424, 0, 0, 2113, 2114, 5,
		441, 0, 0, 2114, 2615, 7, 13, 0, 0, 2115, 2116, 5, 424, 0, 0, 2116, 2615,
		5, 387, 0, 0, 2117, 2118, 5, 424, 0, 0, 2118, 2121, 5, 157, 0, 0, 2119,
		2120, 7, 6, 0, 0, 2120, 2122, 3, 328, 164, 0, 2121, 2119, 1, 0, 0, 0, 2121,
		2122, 1, 0, 0, 0, 2122, 2125, 1, 0, 0, 0, 2123, 2124, 5, 266, 0, 0, 2124,
		2126, 5, 544, 0, 0, 2125, 2123, 1, 0, 0, 0, 2125, 2126, 1, 0, 0, 0, 2126,
		2615, 1, 0, 0, 0, 2127, 2129, 5, 424, 0, 0, 2128, 2130, 5, 55, 0, 0, 2129,
		2128, 1, 0, 0, 0, 2129, 2130, 1, 0, 0, 0, 2130, 2131, 1, 0, 0, 0, 2131,
		2132, 5, 101, 0, 0, 2132, 2133, 5, 451, 0, 0, 2133, 2615, 3, 328, 164,
		0, 2134, 2136, 5, 424, 0, 0, 2135, 2137, 5, 196, 0, 0, 2136, 2135, 1, 0,
		0, 0, 2136, 2137, 1, 0, 0, 0, 2137, 2138, 1, 0, 0, 0, 2138, 2615, 5, 357,
		0, 0, 2139, 2141, 5, 424, 0, 0, 2140, 2142, 5, 459, 0, 0, 2141, 2140, 1,
		0, 0, 0, 2141, 2142, 1, 0, 0, 0, 2142, 2143, 1, 0, 0, 0, 2143, 2144, 5,
		331, 0, 0, 2144, 2145, 5, 193, 0, 0, 2145, 2147, 3, 328, 164, 0, 2146,
		2148, 3, 74, 37, 0, 2147, 2146, 1, 0, 0, 0, 2147, 2148, 1, 0, 0, 0, 2148,
		2150, 1, 0, 0, 0, 2149, 2151, 3, 294, 147, 0, 2150, 2149, 1, 0, 0, 0, 2150,
		2151, 1, 0, 0, 0, 2151, 2153, 1, 0, 0, 0, 2152, 2154, 3, 298, 149, 0, 2153,
		2152, 1, 0, 0, 0, 2153, 2154, 1, 0, 0, 0, 2154, 2615, 1, 0, 0, 0, 2155,
		2157, 5, 424, 0, 0, 2156, 2158, 5, 55, 0, 0, 2157, 2156, 1, 0, 0, 0, 2157,
		2158, 1, 0, 0, 0, 2158, 2159, 1, 0, 0, 0, 2159, 2162, 5, 391, 0, 0, 2160,
		2161, 7, 6, 0, 0, 2161, 2163, 3, 444, 222, 0, 2162, 2160, 1, 0, 0, 0, 2162,
		2163, 1, 0, 0, 0, 2163, 2165, 1, 0, 0, 0, 2164, 2166, 3, 74, 37, 0, 2165,
		2164, 1, 0, 0, 0, 2165, 2166, 1, 0, 0, 0, 2166, 2615, 1, 0, 0, 0, 2167,
		2168, 5, 424, 0, 0, 2168, 2615, 5, 402, 0, 0, 2169, 2170, 5, 424, 0, 0,
		2170, 2171, 5, 330, 0, 0, 2171, 2615, 5, 549, 0, 0, 2172, 2173, 5, 424,
		0, 0, 2173, 2615, 5, 347, 0, 0, 2174, 2175, 5, 424, 0, 0, 2175, 2176, 5,
		355, 0, 0, 2176, 2615, 5, 544, 0, 0, 2177, 2178, 5, 424, 0, 0, 2178, 2181,
		5, 182, 0, 0, 2179, 2180, 7, 6, 0, 0, 2180, 2182, 3, 328, 164, 0, 2181,
		2179, 1, 0, 0, 0, 2181, 2182, 1, 0, 0, 0, 2182, 2615, 1, 0, 0, 0, 2183,
		2185, 5, 424, 0, 0, 2184, 2186, 5, 441, 0, 0, 2185, 2184, 1, 0, 0, 0, 2185,
		2186, 1, 0, 0, 0, 2186, 2187, 1, 0, 0, 0, 2187, 2615, 5, 161, 0, 0, 2188,
		2189, 5, 424, 0, 0, 2189, 2190, 5, 101, 0, 0, 2190, 2191, 5, 68, 0, 0,
		2191, 2615, 3, 444, 222, 0, 2192, 2193, 5, 424, 0, 0, 2193, 2194, 5, 68,
		0, 0, 2194, 2615, 3, 444, 222, 0, 2195, 2196, 5, 424, 0, 0, 2196, 2198,
		5, 69, 0, 0, 2197, 2199, 3, 74, 37, 0, 2198, 2197, 1, 0, 0, 0, 2198, 2199,
		1, 0, 0, 0, 2199, 2615, 1, 0, 0, 0, 2200, 2201, 5, 424, 0, 0, 2201, 2204,
		5, 360, 0, 0, 2202, 2203, 5, 188, 0, 0, 2203, 2205, 3, 184, 92, 0, 2204,
		2202, 1, 0, 0, 0, 2204, 2205, 1, 0, 0, 0, 2205, 2208, 1, 0, 0, 0, 2206,
		2207, 5, 266, 0, 0, 2207, 2209, 5, 544, 0, 0, 2208, 2206, 1, 0, 0, 0, 2208,
		2209, 1, 0, 0, 0, 2209, 2615, 1, 0, 0, 0, 2210, 2211, 5, 424, 0, 0, 2211,
		2212, 5, 20, 0, 0, 2212, 2215, 5, 359, 0, 0, 2213, 2214, 5, 266, 0, 0,
		2214, 2216, 5, 544, 0, 0, 2215, 2213, 1, 0, 0, 0, 2215, 2216, 1, 0, 0,
		0, 2216, 2615, 1, 0, 0, 0, 2217, 2218, 5, 424, 0, 0, 2218, 2220, 5, 78,
		0, 0, 2219, 2221, 3, 74, 37, 0, 2220, 2219, 1, 0, 0, 0, 2220, 2221, 1,
		0, 0, 0, 2221, 2615, 1, 0, 0, 0, 2222, 2223, 5, 424, 0, 0, 2223, 2224,
		5, 406, 0, 0, 2224, 2231, 5, 351, 0, 0, 2225, 2229, 5, 188, 0, 0, 2226,
		2230, 3, 192, 96, 0, 2227, 2228, 5, 401, 0, 0, 2228, 2230, 3, 444, 222,
		0, 2229, 2226, 1, 0, 0, 0, 2229, 2227, 1, 0, 0, 0, 2230, 2232, 1, 0, 0,
		0, 2231, 2225, 1, 0, 0, 0, 2231, 2232, 1, 0, 0, 0, 2232, 2615, 1, 0, 0,
		0, 2233, 2234, 5, 424, 0, 0, 2234, 2235, 5, 441, 0, 0, 2235, 2241, 5, 351,
		0, 0, 2236, 2239, 5, 493, 0, 0, 2237, 2238, 5, 188, 0, 0, 2238, 2240, 3,
		184, 92, 0, 2239, 2237, 1, 0, 0, 0, 2239, 2240, 1, 0, 0, 0, 2240, 2242,
		1, 0, 0, 0, 2241, 2236, 1, 0, 0, 0, 2241, 2242, 1, 0, 0, 0, 2242, 2615,
		1, 0, 0, 0, 2243, 2244, 5, 424, 0, 0, 2244, 2247, 5, 433, 0, 0, 2245, 2246,
		5, 188, 0, 0, 2246, 2248, 3, 444, 222, 0, 2247, 2245, 1, 0, 0, 0, 2247,
		2248, 1, 0, 0, 0, 2248, 2615, 1, 0, 0, 0, 2249, 2250, 5, 424, 0, 0, 2250,
		2251, 5, 101, 0, 0, 2251, 2252, 5, 504, 0, 0, 2252, 2615, 3, 328, 164,
		0, 2253, 2254, 5, 424, 0, 0, 2254, 2255, 5, 112, 0, 0, 2255, 2615, 5, 479,
		0, 0, 2256, 2257, 5, 424, 0, 0, 2257, 2259, 5, 112, 0, 0, 2258, 2260, 5,
		20, 0, 0, 2259, 2258, 1, 0, 0, 0, 2259, 2260, 1, 0, 0, 0, 2260, 2263, 1,
		0, 0, 0, 2261, 2262, 5, 193, 0, 0, 2262, 2264, 3, 328, 164, 0, 2263, 2261,
		1, 0, 0, 0, 2263, 2264, 1, 0, 0, 0, 2264, 2266, 1, 0, 0, 0, 2265, 2267,
		3, 294, 147, 0, 2266, 2265, 1, 0, 0, 0, 2266, 2267, 1, 0, 0, 0, 2267, 2269,
		1, 0, 0, 0, 2268, 2270, 3, 316, 158, 0, 2269, 2268, 1, 0, 0, 0, 2269, 2270,
		1, 0, 0, 0, 2270, 2615, 1, 0, 0, 0, 2271, 2272, 5, 424, 0, 0, 2272, 2273,
		5, 101, 0, 0, 2273, 2274, 5, 288, 0, 0, 2274, 2275, 5, 504, 0, 0, 2275,
		2276, 3, 444, 222, 0, 2276, 2277, 5, 318, 0, 0, 2277, 2278, 3, 328, 164,
		0, 2278, 2615, 1, 0, 0, 0, 2279, 2280, 5, 424, 0, 0, 2280, 2282, 7, 14,
		0, 0, 2281, 2283, 3, 298, 149, 0, 2282, 2281, 1, 0, 0, 0, 2282, 2283, 1,
		0, 0, 0, 2283, 2615, 1, 0, 0, 0, 2284, 2285, 5, 424, 0, 0, 2285, 2286,
		5, 100, 0, 0, 2286, 2287, 5, 2, 0, 0, 2287, 2288, 5, 527, 0, 0, 2288, 2289,
		5, 3, 0, 0, 2289, 2615, 7, 14, 0, 0, 2290, 2291, 5, 424, 0, 0, 2291, 2615,
		5, 37, 0, 0, 2292, 2293, 5, 424, 0, 0, 2293, 2615, 5, 435, 0, 0, 2294,
		2295, 5, 424, 0, 0, 2295, 2296, 5, 386, 0, 0, 2296, 2297, 5, 142, 0, 0,
		2297, 2298, 5, 193, 0, 0, 2298, 2615, 3, 72, 36, 0, 2299, 2300, 5, 424,
		0, 0, 2300, 2302, 5, 390, 0, 0, 2301, 2303, 3, 74, 37, 0, 2302, 2301, 1,
		0, 0, 0, 2302, 2303, 1, 0, 0, 0, 2303, 2305, 1, 0, 0, 0, 2304, 2306, 3,
		294, 147, 0, 2305, 2304, 1, 0, 0, 0, 2305, 2306, 1, 0, 0, 0, 2306, 2308,
		1, 0, 0, 0, 2307, 2309, 3, 298, 149, 0, 2308, 2307, 1, 0, 0, 0, 2308, 2309,
		1, 0, 0, 0, 2309, 2615, 1, 0, 0, 0, 2310, 2312, 5, 424, 0, 0, 2311, 2313,
		5, 442, 0, 0, 2312, 2311, 1, 0, 0, 0, 2312, 2313, 1, 0, 0, 0, 2313, 2314,
		1, 0, 0, 0, 2314, 2317, 5, 271, 0, 0, 2315, 2316, 7, 6, 0, 0, 2316, 2318,
		3, 444, 222, 0, 2317, 2315, 1, 0, 0, 0, 2317, 2318, 1, 0, 0, 0, 2318, 2320,
		1, 0, 0, 0, 2319, 2321, 3, 74, 37, 0, 2320, 2319, 1, 0, 0, 0, 2320, 2321,
		1, 0, 0, 0, 2321, 2323, 1, 0, 0, 0, 2322, 2324, 3, 294, 147, 0, 2323, 2322,
		1, 0, 0, 0, 2323, 2324, 1, 0, 0, 0, 2324, 2326, 1, 0, 0, 0, 2325, 2327,
		3, 298, 149, 0, 2326, 2325, 1, 0, 0, 0, 2326, 2327, 1, 0, 0, 0, 2327, 2615,
		1, 0, 0, 0, 2328, 2329, 5, 424, 0, 0, 2329, 2330, 5, 271, 0, 0, 2330, 2343,
		5, 507, 0, 0, 2331, 2332, 7, 6, 0, 0, 2332, 2334, 3, 444, 222, 0, 2333,
		2331, 1, 0, 0, 0, 2333, 2334, 1, 0, 0, 0, 2334, 2336, 1, 0, 0, 0, 2335,
		2337, 3, 74, 37, 0, 2336, 2335, 1, 0, 0, 0, 2336, 2337, 1, 0, 0, 0, 2337,
		2339, 1, 0, 0, 0, 2338, 2340, 3, 298, 149, 0, 2339, 2338, 1, 0, 0, 0, 2339,
		2340, 1, 0, 0, 0, 2340, 2344, 1, 0, 0, 0, 2341, 2342, 5, 318, 0, 0, 2342,
		2344, 5, 544, 0, 0, 2343, 2333, 1, 0, 0, 0, 2343, 2341, 1, 0, 0, 0, 2344,
		2615, 1, 0, 0, 0, 2345, 2347, 5, 424, 0, 0, 2346, 2348, 5, 196, 0, 0, 2347,
		2346, 1, 0, 0, 0, 2347, 2348, 1, 0, 0, 0, 2348, 2349, 1, 0, 0, 0, 2349,
		2352, 5, 473, 0, 0, 2350, 2351, 7, 6, 0, 0, 2351, 2353, 3, 328, 164, 0,
		2352, 2350, 1, 0, 0, 0, 2352, 2353, 1, 0, 0, 0, 2353, 2355, 1, 0, 0, 0,
		2354, 2356, 3, 74, 37, 0, 2355, 2354, 1, 0, 0, 0, 2355, 2356, 1, 0, 0,
		0, 2356, 2615, 1, 0, 0, 0, 2357, 2358, 5, 424, 0, 0, 2358, 2359, 5, 454,
		0, 0, 2359, 2360, 5, 134, 0, 0, 2360, 2615, 5, 549, 0, 0, 2361, 2362, 5,
		424, 0, 0, 2362, 2363, 5, 320, 0, 0, 2363, 2366, 5, 452, 0, 0, 2364, 2365,
		7, 6, 0, 0, 2365, 2367, 3, 328, 164, 0, 2366, 2364, 1, 0, 0, 0, 2366, 2367,
		1, 0, 0, 0, 2367, 2369, 1, 0, 0, 0, 2368, 2370, 3, 74, 37, 0, 2369, 2368,
		1, 0, 0, 0, 2369, 2370, 1, 0, 0, 0, 2370, 2615, 1, 0, 0, 0, 2371, 2372,
		5, 424, 0, 0, 2372, 2374, 5, 195, 0, 0, 2373, 2375, 3, 444, 222, 0, 2374,
		2373, 1, 0, 0, 0, 2374, 2375, 1, 0, 0, 0, 2375, 2615, 1, 0, 0, 0, 2376,
		2377, 5, 424, 0, 0, 2377, 2378, 5, 113, 0, 0, 2378, 2615, 5, 549, 0, 0,
		2379, 2381, 5, 424, 0, 0, 2380, 2382, 5, 196, 0, 0, 2381, 2380, 1, 0, 0,
		0, 2381, 2382, 1, 0, 0, 0, 2382, 2383, 1, 0, 0, 0, 2383, 2384, 7, 15, 0,
		0, 2384, 2385, 7, 6, 0, 0, 2385, 2388, 3, 328, 164, 0, 2386, 2387, 7, 6,
		0, 0, 2387, 2389, 3, 328, 164, 0, 2388, 2386, 1, 0, 0, 0, 2388, 2389, 1,
		0, 0, 0, 2389, 2391, 1, 0, 0, 0, 2390, 2392, 3, 74, 37, 0, 2391, 2390,
		1, 0, 0, 0, 2391, 2392, 1, 0, 0, 0, 2392, 2615, 1, 0, 0, 0, 2393, 2394,
		5, 424, 0, 0, 2394, 2395, 5, 451, 0, 0, 2395, 2615, 5, 549, 0, 0, 2396,
		2397, 5, 424, 0, 0, 2397, 2400, 5, 471, 0, 0, 2398, 2399, 5, 318, 0, 0,
		2399, 2401, 5, 544, 0, 0, 2400, 2398, 1, 0, 0, 0, 2400, 2401, 1, 0, 0,
		0, 2401, 2615, 1, 0, 0, 0, 2402, 2403, 5, 424, 0, 0, 2403, 2406, 5, 478,
		0, 0, 2404, 2405, 7, 6, 0, 0, 2405, 2407, 3, 444, 222, 0, 2406, 2404, 1,
		0, 0, 0, 2406, 2407, 1, 0, 0, 0, 2407, 2615, 1, 0, 0, 0, 2408, 2412, 5,
		424, 0, 0, 2409, 2413, 5, 76, 0, 0, 2410, 2411, 5, 89, 0, 0, 2411, 2413,
		5, 207, 0, 0, 2412, 2409, 1, 0, 0, 0, 2412, 2410, 1, 0, 0, 0, 2413, 2615,
		1, 0, 0, 0, 2414, 2416, 5, 424, 0, 0, 2415, 2417, 3, 172, 86, 0, 2416,
		2415, 1, 0, 0, 0, 2416, 2417, 1, 0, 0, 0, 2417, 2418, 1, 0, 0, 0, 2418,
		2615, 5, 439, 0, 0, 2419, 2420, 5, 424, 0, 0, 2420, 2615, 5, 511, 0, 0,
		2421, 2422, 5, 424, 0, 0, 2422, 2423, 5, 455, 0, 0, 2423, 2424, 5, 40,
		0, 0, 2424, 2429, 5, 549, 0, 0, 2425, 2426, 5, 4, 0, 0, 2426, 2428, 5,
		549, 0, 0, 2427, 2425, 1, 0, 0, 0, 2428, 2431, 1, 0, 0, 0, 2429, 2427,
		1, 0, 0, 0, 2429, 2430, 1, 0, 0, 0, 2430, 2615, 1, 0, 0, 0, 2431, 2429,
		1, 0, 0, 0, 2432, 2433, 5, 424, 0, 0, 2433, 2434, 5, 112, 0, 0, 2434, 2435,
		5, 426, 0, 0, 2435, 2436, 5, 193, 0, 0, 2436, 2615, 3, 72, 36, 0, 2437,
		2438, 5, 424, 0, 0, 2438, 2439, 5, 451, 0, 0, 2439, 2442, 5, 102, 0, 0,
		2440, 2441, 7, 6, 0, 0, 2441, 2443, 3, 328, 164, 0, 2442, 2440, 1, 0, 0,
		0, 2442, 2443, 1, 0, 0, 0, 2443, 2446, 1, 0, 0, 0, 2444, 2445, 5, 266,
		0, 0, 2445, 2447, 5, 544, 0, 0, 2446, 2444, 1, 0, 0, 0, 2446, 2447, 1,
		0, 0, 0, 2447, 2615, 1, 0, 0, 0, 2448, 2449, 5, 424, 0, 0, 2449, 2450,
		5, 454, 0, 0, 2450, 2451, 5, 441, 0, 0, 2451, 2453, 5, 191, 0, 0, 2452,
		2454, 5, 502, 0, 0, 2453, 2452, 1, 0, 0, 0, 2453, 2454, 1, 0, 0, 0, 2454,
		2615, 1, 0, 0, 0, 2455, 2456, 5, 424, 0, 0, 2456, 2457, 5, 363, 0, 0, 2457,
		2459, 5, 358, 0, 0, 2458, 2460, 5, 544, 0, 0, 2459, 2458, 1, 0, 0, 0, 2459,
		2460, 1, 0, 0, 0, 2460, 2462, 1, 0, 0, 0, 2461, 2463, 3, 298, 149, 0, 2462,
		2461, 1, 0, 0, 0, 2462, 2463, 1, 0, 0, 0, 2463, 2615, 1, 0, 0, 0, 2464,
		2465, 5, 424, 0, 0, 2465, 2468, 5, 98, 0, 0, 2466, 2467, 7, 6, 0, 0, 2467,
		2469, 3, 328, 164, 0, 2468, 2466, 1, 0, 0, 0, 2468, 2469, 1, 0, 0, 0, 2469,
		2615, 1, 0, 0, 0, 2470, 2472, 5, 424, 0, 0, 2471, 2473, 5, 196, 0, 0, 2472,
		2471, 1, 0, 0, 0, 2472, 2473, 1, 0, 0, 0, 2473, 2474, 1, 0, 0, 0, 2474,
		2477, 5, 452, 0, 0, 2475, 2476, 7, 6, 0, 0, 2476, 2478, 3, 328, 164, 0,
		2477, 2475, 1, 0, 0, 0, 2477, 2478, 1, 0, 0, 0, 2478, 2480, 1, 0, 0, 0,
		2479, 2481, 3, 74, 37, 0, 2480, 2479, 1, 0, 0, 0, 2480, 2481, 1, 0, 0,
		0, 2481, 2615, 1, 0, 0, 0, 2482, 2484, 5, 424, 0, 0, 2483, 2485, 5, 196,
		0, 0, 2484, 2483, 1, 0, 0, 0, 2484, 2485, 1, 0, 0, 0, 2485, 2486, 1, 0,
		0, 0, 2486, 2489, 5, 505, 0, 0, 2487, 2488, 7, 6, 0, 0, 2488, 2490, 3,
		328, 164, 0, 2489, 2487, 1, 0, 0, 0, 2489, 2490, 1, 0, 0, 0, 2490, 2492,
		1, 0, 0, 0, 2491, 2493, 3, 74, 37, 0, 2492, 2491, 1, 0, 0, 0, 2492, 2493,
		1, 0, 0, 0, 2493, 2615, 1, 0, 0, 0, 2494, 2495, 5, 424, 0, 0, 2495, 2496,
		5, 451, 0, 0, 2496, 2499, 5, 439, 0, 0, 2497, 2498, 7, 6, 0, 0, 2498, 2500,
		3, 328, 164, 0, 2499, 2497, 1, 0, 0, 0, 2499, 2500, 1, 0, 0, 0, 2500, 2502,
		1, 0, 0, 0, 2501, 2503, 3, 74, 37, 0, 2502, 2501, 1, 0, 0, 0, 2502, 2503,
		1, 0, 0, 0, 2503, 2615, 1, 0, 0, 0, 2504, 2505, 5, 424, 0, 0, 2505, 2508,
		7, 16, 0, 0, 2506, 2507, 5, 193, 0, 0, 2507, 2509, 3, 444, 222, 0, 2508,
		2506, 1, 0, 0, 0, 2508, 2509, 1, 0, 0, 0, 2509, 2511, 1, 0, 0, 0, 2510,
		2512, 3, 74, 37, 0, 2511, 2510, 1, 0, 0, 0, 2511, 2512, 1, 0, 0, 0, 2512,
		2615, 1, 0, 0, 0, 2513, 2514, 5, 424, 0, 0, 2514, 2515, 5, 455, 0, 0, 2515,
		2516, 5, 193, 0, 0, 2516, 2518, 3, 328, 164, 0, 2517, 2519, 3, 162, 81,
		0, 2518, 2517, 1, 0, 0, 0, 2518, 2519, 1, 0, 0, 0, 2519, 2521, 1, 0, 0,
		0, 2520, 2522, 3, 74, 37, 0, 2521, 2520, 1, 0, 0, 0, 2521, 2522, 1, 0,
		0, 0, 2522, 2524, 1, 0, 0, 0, 2523, 2525, 3, 294, 147, 0, 2524, 2523, 1,
		0, 0, 0, 2524, 2525, 1, 0, 0, 0, 2525, 2527, 1, 0, 0, 0, 2526, 2528, 3,
		298, 149, 0, 2527, 2526, 1, 0, 0, 0, 2527, 2528, 1, 0, 0, 0, 2528, 2615,
		1, 0, 0, 0, 2529, 2530, 5, 424, 0, 0, 2530, 2531, 5, 68, 0, 0, 2531, 2532,
		5, 375, 0, 0, 2532, 2535, 5, 43, 0, 0, 2533, 2534, 5, 510, 0, 0, 2534,
		2536, 3, 372, 186, 0, 2535, 2533, 1, 0, 0, 0, 2535, 2536, 1, 0, 0, 0, 2536,
		2615, 1, 0, 0, 0, 2537, 2538, 5, 424, 0, 0, 2538, 2539, 5, 454, 0, 0, 2539,
		2615, 5, 549, 0, 0, 2540, 2541, 5, 424, 0, 0, 2541, 2543, 5, 135, 0, 0,
		2542, 2544, 3, 74, 37, 0, 2543, 2542, 1, 0, 0, 0, 2543, 2544, 1, 0, 0,
		0, 2544, 2615, 1, 0, 0, 0, 2545, 2546, 5, 424, 0, 0, 2546, 2549, 5, 470,
		0, 0, 2547, 2548, 7, 6, 0, 0, 2548, 2550, 3, 328, 164, 0, 2549, 2547, 1,
		0, 0, 0, 2549, 2550, 1, 0, 0, 0, 2550, 2552, 1, 0, 0, 0, 2551, 2553, 3,
		74, 37, 0, 2552, 2551, 1, 0, 0, 0, 2552, 2553, 1, 0, 0, 0, 2553, 2615,
		1, 0, 0, 0, 2554, 2555, 5, 424, 0, 0, 2555, 2556, 5, 386, 0, 0, 2556, 2557,
		5, 439, 0, 0, 2557, 2558, 5, 193, 0, 0, 2558, 2560, 3, 72, 36, 0, 2559,
		2561, 3, 250, 125, 0, 2560, 2559, 1, 0, 0, 0, 2560, 2561, 1, 0, 0, 0, 2561,
		2615, 1, 0, 0, 0, 2562, 2563, 5, 424, 0, 0, 2563, 2564, 5, 514, 0, 0, 2564,
		2567, 5, 207, 0, 0, 2565, 2566, 5, 266, 0, 0, 2566, 2568, 5, 544, 0, 0,
		2567, 2565, 1, 0, 0, 0, 2567, 2568, 1, 0, 0, 0, 2568, 2615, 1, 0, 0, 0,
		2569, 2570, 5, 424, 0, 0, 2570, 2573, 5, 99, 0, 0, 2571, 2572, 7, 6, 0,
		0, 2572, 2574, 3, 444, 222, 0, 2573, 2571, 1, 0, 0, 0, 2573, 2574, 1, 0,
		0, 0, 2574, 2576, 1, 0, 0, 0, 2575, 2577, 3, 250, 125, 0, 2576, 2575, 1,
		0, 0, 0, 2576, 2577, 1, 0, 0, 0, 2577, 2579, 1, 0, 0, 0, 2578, 2580, 3,
		294, 147, 0, 2579, 2578, 1, 0, 0, 0, 2579, 2580, 1, 0, 0, 0, 2580, 2582,
		1, 0, 0, 0, 2581, 2583, 3, 298, 149, 0, 2582, 2581, 1, 0, 0, 0, 2582, 2583,
		1, 0, 0, 0, 2583, 2615, 1, 0, 0, 0, 2584, 2585, 5, 424, 0, 0, 2585, 2586,
		5, 363, 0, 0, 2586, 2597, 5, 438, 0, 0, 2587, 2588, 5, 188, 0, 0, 2588,
		2598, 3, 444, 222, 0, 2589, 2590, 5, 193, 0, 0, 2590, 2595, 3, 328, 164,
		0, 2591, 2593, 5, 20, 0, 0, 2592, 2594, 5, 502, 0, 0, 2593, 2592, 1, 0,
		0, 0, 2593, 2594, 1, 0, 0, 0, 2594, 2596, 1, 0, 0, 0, 2595, 2591, 1, 0,
		0, 0, 2595, 2596, 1, 0, 0, 0, 2596, 2598, 1, 0, 0, 0, 2597, 2587, 1, 0,
		0, 0, 2597, 2589, 1, 0, 0, 0, 2597, 2598, 1, 0, 0, 0, 2598, 2615, 1, 0,
		0, 0, 2599, 2600, 5, 424, 0, 0, 2600, 2601, 7, 17, 0, 0, 2601, 2602, 7,
		6, 0, 0, 2602, 2605, 3, 328, 164, 0, 2603, 2604, 7, 6, 0, 0, 2604, 2606,
		3, 328, 164, 0, 2605, 2603, 1, 0, 0, 0, 2605, 2606, 1, 0, 0, 0, 2606, 2615,
		1, 0, 0, 0, 2607, 2608, 5, 424, 0, 0, 2608, 2609, 5, 506, 0, 0, 2609, 2610,
		5, 488, 0, 0, 2610, 2612, 5, 248, 0, 0, 2611, 2613, 3, 74, 37, 0, 2612,
		2611, 1, 0, 0, 0, 2612, 2613, 1, 0, 0, 0, 2613, 2615, 1, 0, 0, 0, 2614,
		1916, 1, 0, 0, 0, 2614, 1924, 1, 0, 0, 0, 2614, 1926, 1, 0, 0, 0, 2614,
		1948, 1, 0, 0, 0, 2614, 1952, 1, 0, 0, 0, 2614, 1961, 1, 0, 0, 0, 2614,
		1963, 1, 0, 0, 0, 2614, 1979, 1, 0, 0, 0, 2614, 1987, 1, 0, 0, 0, 2614,
		1996, 1, 0, 0, 0, 2614, 2011, 1, 0, 0, 0, 2614, 2014, 1, 0, 0, 0, 2614,
		2020, 1, 0, 0, 0, 2614, 2026, 1, 0, 0, 0, 2614, 2042, 1, 0, 0, 0, 2614,
		2058, 1, 0, 0, 0, 2614, 2068, 1, 0, 0, 0, 2614, 2073, 1, 0, 0, 0, 2614,
		2077, 1, 0, 0, 0, 2614, 2081, 1, 0, 0, 0, 2614, 2088, 1, 0, 0, 0, 2614,
		2097, 1, 0, 0, 0, 2614, 2102, 1, 0, 0, 0, 2614, 2110, 1, 0, 0, 0, 2614,
		2112, 1, 0, 0, 0, 2614, 2115, 1, 0, 0, 0, 2614, 2117, 1, 0, 0, 0, 2614,
		2127, 1, 0, 0, 0, 2614, 2134, 1, 0, 0, 0, 2614, 2139, 1, 0, 0, 0, 2614,
		2155, 1, 0, 0, 0, 2614, 2167, 1, 0, 0, 0, 2614, 2169, 1, 0, 0, 0, 2614,
		2172, 1, 0, 0, 0, 2614, 2174, 1, 0, 0, 0, 2614, 2177, 1, 0, 0, 0, 2614,
		2183, 1, 0, 0, 0, 2614, 2188, 1, 0, 0, 0, 2614, 2192, 1, 0, 0, 0, 2614,
		2195, 1, 0, 0, 0, 2614, 2200, 1, 0, 0, 0, 2614, 2210, 1, 0, 0, 0, 2614,
		2217, 1, 0, 0, 0, 2614, 2222, 1, 0, 0, 0, 2614, 2233, 1, 0, 0, 0, 2614,
		2243, 1, 0, 0, 0, 2614, 2249, 1, 0, 0, 0, 2614, 2253, 1, 0, 0, 0, 2614,
		2256, 1, 0, 0, 0, 2614, 2271, 1, 0, 0, 0, 2614, 2279, 1, 0, 0, 0, 2614,
		2284, 1, 0, 0, 0, 2614, 2290, 1, 0, 0, 0, 2614, 2292, 1, 0, 0, 0, 2614,
		2294, 1, 0, 0, 0, 2614, 2299, 1, 0, 0, 0, 2614, 2310, 1, 0, 0, 0, 2614,
		2328, 1, 0, 0, 0, 2614, 2345, 1, 0, 0, 0, 2614, 2357, 1, 0, 0, 0, 2614,
		2361, 1, 0, 0, 0, 2614, 2371, 1, 0, 0, 0, 2614, 2376, 1, 0, 0, 0, 2614,
		2379, 1, 0, 0, 0, 2614, 2393, 1, 0, 0, 0, 2614, 2396, 1, 0, 0, 0, 2614,
		2402, 1, 0, 0, 0, 2614, 2408, 1, 0, 0, 0, 2614, 2414, 1, 0, 0, 0, 2614,
		2419, 1, 0, 0, 0, 2614, 2421, 1, 0, 0, 0, 2614, 2432, 1, 0, 0, 0, 2614,
		2437, 1, 0, 0, 0, 2614, 2448, 1, 0, 0, 0, 2614, 2455, 1, 0, 0, 0, 2614,
		2464, 1, 0, 0, 0, 2614, 2470, 1, 0, 0, 0, 2614, 2482, 1, 0, 0, 0, 2614,
		2494, 1, 0, 0, 0, 2614, 2504, 1, 0, 0, 0, 2614, 2513, 1, 0, 0, 0, 2614,
		2529, 1, 0, 0, 0, 2614, 2537, 1, 0, 0, 0, 2614, 2540, 1, 0, 0, 0, 2614,
		2545, 1, 0, 0, 0, 2614, 2554, 1, 0, 0, 0, 2614, 2562, 1, 0, 0, 0, 2614,
		2569, 1, 0, 0, 0, 2614, 2584, 1, 0, 0, 0, 2614, 2599, 1, 0, 0, 0, 2614,
		2607, 1, 0, 0, 0, 2615, 29, 1, 0, 0, 0, 2616, 2688, 5, 449, 0, 0, 2617,
		2688, 3, 42, 21, 0, 2618, 2620, 5, 424, 0, 0, 2619, 2621, 5, 20, 0, 0,
		2620, 2619, 1, 0, 0, 0, 2620, 2621, 1, 0, 0, 0, 2621, 2622, 1, 0, 0, 0,
		2622, 2623, 5, 101, 0, 0, 2623, 2624, 5, 405, 0, 0, 2624, 2625, 5, 271,
		0, 0, 2625, 2626, 5, 188, 0, 0, 2626, 2688, 3, 328, 164, 0, 2627, 2628,
		5, 338, 0, 0, 2628, 2629, 5, 405, 0, 0, 2629, 2630, 5, 271, 0, 0, 2630,
		2631, 5, 188, 0, 0, 2631, 2688, 3, 328, 164, 0, 2632, 2633, 5, 338, 0,
		0, 2633, 2634, 5, 20, 0, 0, 2634, 2635, 5, 405, 0, 0, 2635, 2688, 5, 271,
		0, 0, 2636, 2637, 5, 393, 0, 0, 2637, 2638, 5, 405, 0, 0, 2638, 2639, 5,
		271, 0, 0, 2639, 2640, 5, 188, 0, 0, 2640, 2688, 3, 328, 164, 0, 2641,
		2642, 5, 393, 0, 0, 2642, 2643, 5, 20, 0, 0, 2643, 2644, 5, 405, 0, 0,
		2644, 2688, 5, 271, 0, 0, 2645, 2646, 5, 440, 0, 0, 2646, 2647, 5, 405,
		0, 0, 2647, 2648, 5, 271, 0, 0, 2648, 2649, 5, 188, 0, 0, 2649, 2688, 3,
		328, 164, 0, 2650, 2652, 5, 424, 0, 0, 2651, 2653, 5, 20, 0, 0, 2652, 2651,
		1, 0, 0, 0, 2652, 2653, 1, 0, 0, 0, 2653, 2654, 1, 0, 0, 0, 2654, 2655,
		5, 405, 0, 0, 2655, 2662, 5, 271, 0, 0, 2656, 2657, 5, 188, 0, 0, 2657,
		2663, 3, 328, 164, 0, 2658, 2659, 5, 266, 0, 0, 2659, 2661, 5, 544, 0,
		0, 2660, 2658, 1, 0, 0, 0, 2660, 2661, 1, 0, 0, 0, 2661, 2663, 1, 0, 0,
		0, 2662, 2656, 1, 0, 0, 0, 2662, 2660, 1, 0, 0, 0, 2663, 2688, 1, 0, 0,
		0, 2664, 2665, 5, 424, 0, 0, 2665, 2666, 5, 405, 0, 0, 2666, 2667, 5, 271,
		0, 0, 2667, 2670, 5, 457, 0, 0, 2668, 2669, 7, 6, 0, 0, 2669, 2671, 3,
		444, 222, 0, 2670, 2668, 1, 0, 0, 0, 2670, 2671, 1, 0, 0, 0, 2671, 2673,
		1, 0, 0, 0, 2672, 2674, 3, 74, 37, 0, 2673, 2672, 1, 0, 0, 0, 2673, 2674,
		1, 0, 0, 0, 2674, 2688, 1, 0, 0, 0, 2675, 2676, 5, 424, 0, 0, 2676, 2677,
		5, 239, 0, 0, 2677, 2678, 5, 227, 0, 0, 2678, 2688, 5, 24, 0, 0, 2679,
		2680, 5, 424, 0, 0, 2680, 2681, 5, 239, 0, 0, 2681, 2682, 5, 227, 0, 0,
		2682, 2688, 5, 468, 0, 0, 2683, 2684, 5, 424, 0, 0, 2684, 2685, 5, 239,
		0, 0, 2685, 2686, 5, 227, 0, 0, 2686, 2688, 5, 469, 0, 0, 2687, 2616, 1,
		0, 0, 0, 2687, 2617, 1, 0, 0, 0, 2687, 2618, 1, 0, 0, 0, 2687, 2627, 1,
		0, 0, 0, 2687, 2632, 1, 0, 0, 0, 2687, 2636, 1, 0, 0, 0, 2687, 2641, 1,
		0, 0, 0, 2687, 2645, 1, 0, 0, 0, 2687, 2650, 1, 0, 0, 0, 2687, 2664, 1,
		0, 0, 0, 2687, 2675, 1, 0, 0, 0, 2687, 2679, 1, 0, 0, 0, 2687, 2683, 1,
		0, 0, 0, 2688, 31, 1, 0, 0, 0, 2689, 2691, 5, 255, 0, 0, 2690, 2692, 5,
		92, 0, 0, 2691, 2690, 1, 0, 0, 0, 2691, 2692, 1, 0, 0, 0, 2692, 2693, 1,
		0, 0, 0, 2693, 2698, 5, 549, 0, 0, 2694, 2695, 5, 255, 0, 0, 2695, 2696,
		5, 363, 0, 0, 2696, 2698, 7, 18, 0, 0, 2697, 2689, 1, 0, 0, 0, 2697, 2694,
		1, 0, 0, 0, 2698, 33, 1, 0, 0, 0, 2699, 2700, 5, 212, 0, 0, 2700, 2798,
		3, 184, 92, 0, 2701, 2702, 5, 485, 0, 0, 2702, 2798, 5, 452, 0, 0, 2703,
		2704, 5, 232, 0, 0, 2704, 2705, 5, 349, 0, 0, 2705, 2706, 5, 193, 0, 0,
		2706, 2708, 3, 184, 92, 0, 2707, 2709, 3, 316, 158, 0, 2708, 2707, 1, 0,
		0, 0, 2708, 2709, 1, 0, 0, 0, 2709, 2798, 1, 0, 0, 0, 2710, 2711, 5, 482,
		0, 0, 2711, 2712, 5, 349, 0, 0, 2712, 2798, 3, 184, 92, 0, 2713, 2714,
		5, 276, 0, 0, 2714, 2723, 5, 452, 0, 0, 2715, 2720, 3, 40, 20, 0, 2716,
		2717, 5, 4, 0, 0, 2717, 2719, 3, 40, 20, 0, 2718, 2716, 1, 0, 0, 0, 2719,
		2722, 1, 0, 0, 0, 2720, 2718, 1, 0, 0, 0, 2720, 2721, 1, 0, 0, 0, 2721,
		2724, 1, 0, 0, 0, 2722, 2720, 1, 0, 0, 0, 2723, 2715, 1, 0, 0, 0, 2723,
		2724, 1, 0, 0, 0, 2724, 2798, 1, 0, 0, 0, 2725, 2726, 5, 391, 0, 0, 2726,
		2727, 5, 428, 0, 0, 2727, 2728, 3, 328, 164, 0, 2728, 2729, 5, 193, 0,
		0, 2729, 2742, 3, 444, 222, 0, 2730, 2731, 7, 19, 0, 0, 2731, 2732, 5,
		2, 0, 0, 2732, 2737, 3, 72, 36, 0, 2733, 2734, 5, 4, 0, 0, 2734, 2736,
		3, 72, 36, 0, 2735, 2733, 1, 0, 0, 0, 2736, 2739, 1, 0, 0, 0, 2737, 2735,
		1, 0, 0, 0, 2737, 2738, 1, 0, 0, 0, 2738, 2740, 1, 0, 0, 0, 2739, 2737,
		1, 0, 0, 0, 2740, 2741, 5, 3, 0, 0, 2741, 2743, 1, 0, 0, 0, 2742, 2730,
		1, 0, 0, 0, 2742, 2743, 1, 0, 0, 0, 2743, 2745, 1, 0, 0, 0, 2744, 2746,
		3, 316, 158, 0, 2745, 2744, 1, 0, 0, 0, 2745, 2746, 1, 0, 0, 0, 2746, 2798,
		1, 0, 0, 0, 2747, 2748, 5, 506, 0, 0, 2748, 2752, 5, 488, 0, 0, 2749, 2753,
		5, 75, 0, 0, 2750, 2751, 5, 89, 0, 0, 2751, 2753, 5, 205, 0, 0, 2752, 2749,
		1, 0, 0, 0, 2752, 2750, 1, 0, 0, 0, 2753, 2754, 1, 0, 0, 0, 2754, 2755,
		3, 444, 222, 0, 2755, 2770, 5, 512, 0, 0, 2756, 2760, 5, 75, 0, 0, 2757,
		2758, 5, 89, 0, 0, 2758, 2760, 5, 205, 0, 0, 2759, 2756, 1, 0, 0, 0, 2759,
		2757, 1, 0, 0, 0, 2760, 2761, 1, 0, 0, 0, 2761, 2771, 3, 444, 222, 0, 2762,
		2767, 3, 38, 19, 0, 2763, 2764, 5, 25, 0, 0, 2764, 2766, 3, 38, 19, 0,
		2765, 2763, 1, 0, 0, 0, 2766, 2769, 1, 0, 0, 0, 2767, 2765, 1, 0, 0, 0,
		2767, 2768, 1, 0, 0, 0, 2768, 2771, 1, 0, 0, 0, 2769, 2767, 1, 0, 0, 0,
		2770, 2759, 1, 0, 0, 0, 2770, 2762, 1, 0, 0, 0, 2771, 2773, 1, 0, 0, 0,
		2772, 2774, 5, 190, 0, 0, 2773, 2772, 1, 0, 0, 0, 2773, 2774, 1, 0, 0,
		0, 2774, 2798, 1, 0, 0, 0, 2775, 2776, 5, 38, 0, 0, 2776, 2777, 5, 428,
		0, 0, 2777, 2778, 3, 328, 164, 0, 2778, 2779, 5, 467, 0, 0, 2779, 2792,
		3, 444, 222, 0, 2780, 2781, 7, 19, 0, 0, 2781, 2782, 5, 2, 0, 0, 2782,
		2787, 3, 72, 36, 0, 2783, 2784, 5, 4, 0, 0, 2784, 2786, 3, 72, 36, 0, 2785,
		2783, 1, 0, 0, 0, 2786, 2789, 1, 0, 0, 0, 2787, 2785, 1, 0, 0, 0, 2787,
		2788, 1, 0, 0, 0, 2788, 2790, 1, 0, 0, 0, 2789, 2787, 1, 0, 0, 0, 2790,
		2791, 5, 3, 0, 0, 2791, 2793, 1, 0, 0, 0, 2792, 2780, 1, 0, 0, 0, 2792,
		2793, 1, 0, 0, 0, 2793, 2795, 1, 0, 0, 0, 2794, 2796, 3, 316, 158, 0, 2795,
		2794, 1, 0, 0, 0, 2795, 2796, 1, 0, 0, 0, 2796, 2798, 1, 0, 0, 0, 2797,
		2699, 1, 0, 0, 0, 2797, 2701, 1, 0, 0, 0, 2797, 2703, 1, 0, 0, 0, 2797,
		2710, 1, 0, 0, 0, 2797, 2713, 1, 0, 0, 0, 2797, 2725, 1, 0, 0, 0, 2797,
		2747, 1, 0, 0, 0, 2797, 2775, 1, 0, 0, 0, 2798, 35, 1, 0, 0, 0, 2799, 2800,
		5, 436, 0, 0, 2800, 2804, 5, 470, 0, 0, 2801, 2802, 5, 512, 0, 0, 2802,
		2803, 5, 94, 0, 0, 2803, 2805, 5, 428, 0, 0, 2804, 2801, 1, 0, 0, 0, 2804,
		2805, 1, 0, 0, 0, 2805, 37, 1, 0, 0, 0, 2806, 2807, 5, 451, 0, 0, 2807,
		2810, 3, 328, 164, 0, 2808, 2809, 5, 330, 0, 0, 2809, 2811, 3, 444, 222,
		0, 2810, 2808, 1, 0, 0, 0, 2810, 2811, 1, 0, 0, 0, 2811, 39, 1, 0, 0, 0,
		2812, 2815, 3, 328, 164, 0, 2813, 2814, 5, 29, 0, 0, 2814, 2816, 3, 184,
		92, 0, 2815, 2813, 1, 0, 0, 0, 2815, 2816, 1, 0, 0, 0, 2816, 2825, 1, 0,
		0, 0, 2817, 2819, 5, 370, 0, 0, 2818, 2820, 5, 272, 0, 0, 2819, 2818, 1,
		0, 0, 0, 2819, 2820, 1, 0, 0, 0, 2820, 2826, 1, 0, 0, 0, 2821, 2823, 5,
		278, 0, 0, 2822, 2821, 1, 0, 0, 0, 2822, 2823, 1, 0, 0, 0, 2823, 2824,
		1, 0, 0, 0, 2824, 2826, 5, 515, 0, 0, 2825, 2817, 1, 0, 0, 0, 2825, 2822,
		1, 0, 0, 0, 2826, 41, 1, 0, 0, 0, 2827, 2828, 5, 101, 0, 0, 2828, 2829,
		5, 405, 0, 0, 2829, 2830, 5, 271, 0, 0, 2830, 2833, 3, 328, 164, 0, 2831,
		2832, 5, 318, 0, 0, 2832, 2834, 3, 444, 222, 0, 2833, 2831, 1, 0, 0, 0,
		2833, 2834, 1, 0, 0, 0, 2834, 2837, 1, 0, 0, 0, 2835, 2836, 5, 512, 0,
		0, 2836, 2838, 7, 20, 0, 0, 2837, 2835, 1, 0, 0, 0, 2837, 2838, 1, 0, 0,
		0, 2838, 2847, 1, 0, 0, 0, 2839, 2844, 3, 46, 23, 0, 2840, 2841, 5, 4,
		0, 0, 2841, 2843, 3, 46, 23, 0, 2842, 2840, 1, 0, 0, 0, 2843, 2846, 1,
		0, 0, 0, 2844, 2842, 1, 0, 0, 0, 2844, 2845, 1, 0, 0, 0, 2845, 2848, 1,
		0, 0, 0, 2846, 2844, 1, 0, 0, 0, 2847, 2839, 1, 0, 0, 0, 2847, 2848, 1,
		0, 0, 0, 2848, 2850, 1, 0, 0, 0, 2849, 2851, 3, 316, 158, 0, 2850, 2849,
		1, 0, 0, 0, 2850, 2851, 1, 0, 0, 0, 2851, 2852, 1, 0, 0, 0, 2852, 2853,
		5, 193, 0, 0, 2853, 2854, 3, 444, 222, 0, 2854, 2855, 5, 2, 0, 0, 2855,
		2856, 3, 318, 159, 0, 2856, 2858, 5, 3, 0, 0, 2857, 2859, 3, 432, 216,
		0, 2858, 2857, 1, 0, 0, 0, 2858, 2859, 1, 0, 0, 0, 2859, 43, 1, 0, 0, 0,
		2860, 2861, 5, 271, 0, 0, 2861, 2867, 3, 224, 112, 0, 2862, 2863, 5, 359,
		0, 0, 2863, 2864, 5, 2, 0, 0, 2864, 2865, 3, 318, 159, 0, 2865, 2866, 5,
		3, 0, 0, 2866, 2868, 1, 0, 0, 0, 2867, 2862, 1, 0, 0, 0, 2867, 2868, 1,
		0, 0, 0, 2868, 2870, 1, 0, 0, 0, 2869, 2871, 3, 432, 216, 0, 2870, 2869,
		1, 0, 0, 0, 2870, 2871, 1, 0, 0, 0, 2871, 2878, 1, 0, 0, 0, 2872, 2873,
		5, 424, 0, 0, 2873, 2874, 5, 101, 0, 0, 2874, 2875, 5, 271, 0, 0, 2875,
		2876, 5, 188, 0, 0, 2876, 2878, 3, 328, 164, 0, 2877, 2860, 1, 0, 0, 0,
		2877, 2872, 1, 0, 0, 0, 2878, 45, 1, 0, 0, 0, 2879, 2880, 5, 82, 0, 0,
		2880, 2881, 5, 460, 0, 0, 2881, 2882, 5, 61, 0, 0, 2882, 2890, 5, 544,
		0, 0, 2883, 2890, 3, 56, 28, 0, 2884, 2890, 3, 54, 27, 0, 2885, 2890, 3,
		52, 26, 0, 2886, 2890, 3, 50, 25, 0, 2887, 2890, 3, 48, 24, 0, 2888, 2890,
		3, 162, 81, 0, 2889, 2879, 1, 0, 0, 0, 2889, 2883, 1, 0, 0, 0, 2889, 2884,
		1, 0, 0, 0, 2889, 2885, 1, 0, 0, 0, 2889, 2886, 1, 0, 0, 0, 2889, 2887,
		1, 0, 0, 0, 2889, 2888, 1, 0, 0, 0, 2890, 47, 1, 0, 0, 0, 2891, 2892, 5,
		323, 0, 0, 2892, 2893, 5, 61, 0, 0, 2893, 2894, 3, 444, 222, 0, 2894, 49,
		1, 0, 0, 0, 2895, 2896, 5, 129, 0, 0, 2896, 2897, 5, 318, 0, 0, 2897, 2898,
		3, 376, 188, 0, 2898, 51, 1, 0, 0, 0, 2899, 2900, 5, 510, 0, 0, 2900, 2901,
		3, 376, 188, 0, 2901, 53, 1, 0, 0, 0, 2902, 2903, 5, 352, 0, 0, 2903, 2904,
		5, 183, 0, 0, 2904, 2905, 3, 376, 188, 0, 2905, 55, 1, 0, 0, 0, 2906, 2907,
		5, 82, 0, 0, 2907, 2908, 5, 2, 0, 0, 2908, 2913, 3, 58, 29, 0, 2909, 2910,
		5, 4, 0, 0, 2910, 2912, 3, 58, 29, 0, 2911, 2909, 1, 0, 0, 0, 2912, 2915,
		1, 0, 0, 0, 2913, 2911, 1, 0, 0, 0, 2913, 2914, 1, 0, 0, 0, 2914, 2916,
		1, 0, 0, 0, 2915, 2913, 1, 0, 0, 0, 2916, 2917, 5, 3, 0, 0, 2917, 57, 1,
		0, 0, 0, 2918, 2921, 3, 444, 222, 0, 2919, 2920, 5, 518, 0, 0, 2920, 2922,
		3, 376, 188, 0, 2921, 2919, 1, 0, 0, 0, 2921, 2922, 1, 0, 0, 0, 2922, 2932,
		1, 0, 0, 0, 2923, 2924, 5, 2, 0, 0, 2924, 2927, 3, 444, 222, 0, 2925, 2926,
		5, 518, 0, 0, 2926, 2928, 3, 376, 188, 0, 2927, 2925, 1, 0, 0, 0, 2927,
		2928, 1, 0, 0, 0, 2928, 2929, 1, 0, 0, 0, 2929, 2930, 5, 3, 0, 0, 2930,
		2932, 1, 0, 0, 0, 2931, 2918, 1, 0, 0, 0, 2931, 2923, 1, 0, 0, 0, 2932,
		59, 1, 0, 0, 0, 2933, 2934, 5, 376, 0, 0, 2934, 2935, 5, 68, 0, 0, 2935,
		2937, 3, 444, 222, 0, 2936, 2938, 3, 316, 158, 0, 2937, 2936, 1, 0, 0,
		0, 2937, 2938, 1, 0, 0, 0, 2938, 2959, 1, 0, 0, 0, 2939, 2940, 5, 376,
		0, 0, 2940, 2941, 5, 113, 0, 0, 2941, 2943, 3, 328, 164, 0, 2942, 2944,
		3, 316, 158, 0, 2943, 2942, 1, 0, 0, 0, 2943, 2944, 1, 0, 0, 0, 2944, 2959,
		1, 0, 0, 0, 2945, 2946, 5, 376, 0, 0, 2946, 2947, 5, 451, 0, 0, 2947, 2959,
		3, 328, 164, 0, 2948, 2949, 5, 376, 0, 0, 2949, 2950, 5, 136, 0, 0, 2950,
		2959, 3, 328, 164, 0, 2951, 2952, 5, 376, 0, 0, 2952, 2956, 5, 261, 0,
		0, 2953, 2957, 5, 20, 0, 0, 2954, 2955, 5, 188, 0, 0, 2955, 2957, 3, 184,
		92, 0, 2956, 2953, 1, 0, 0, 0, 2956, 2954, 1, 0, 0, 0, 2957, 2959, 1, 0,
		0, 0, 2958, 2933, 1, 0, 0, 0, 2958, 2939, 1, 0, 0, 0, 2958, 2945, 1, 0,
		0, 0, 2958, 2948, 1, 0, 0, 0, 2958, 2951, 1, 0, 0, 0, 2959, 61, 1, 0, 0,
		0, 2960, 2961, 5, 74, 0, 0, 2961, 2962, 5, 20, 0, 0, 2962, 2984, 5, 358,
		0, 0, 2963, 2964, 5, 74, 0, 0, 2964, 2966, 5, 256, 0, 0, 2965, 2967, 3,
		444, 222, 0, 2966, 2965, 1, 0, 0, 0, 2966, 2967, 1, 0, 0, 0, 2967, 2968,
		1, 0, 0, 0, 2968, 2969, 7, 6, 0, 0, 2969, 2984, 3, 444, 222, 0, 2970, 2971,
		5, 74, 0, 0, 2971, 2972, 5, 363, 0, 0, 2972, 2977, 5, 438, 0, 0, 2973,
		2974, 5, 188, 0, 0, 2974, 2978, 3, 444, 222, 0, 2975, 2976, 7, 6, 0, 0,
		2976, 2978, 3, 328, 164, 0, 2977, 2973, 1, 0, 0, 0, 2977, 2975, 1, 0, 0,
		0, 2978, 2984, 1, 0, 0, 0, 2979, 2980, 5, 74, 0, 0, 2980, 2981, 5, 20,
		0, 0, 2981, 2982, 5, 363, 0, 0, 2982, 2984, 5, 438, 0, 0, 2983, 2960, 1,
		0, 0, 0, 2983, 2963, 1, 0, 0, 0, 2983, 2970, 1, 0, 0, 0, 2983, 2979, 1,
		0, 0, 0, 2984, 63, 1, 0, 0, 0, 2985, 2986, 5, 65, 0, 0, 2986, 2989, 5,
		271, 0, 0, 2987, 2988, 7, 6, 0, 0, 2988, 2990, 3, 444, 222, 0, 2989, 2987,
		1, 0, 0, 0, 2989, 2990, 1, 0, 0, 0, 2990, 2992, 1, 0, 0, 0, 2991, 2993,
		3, 74, 37, 0, 2992, 2991, 1, 0, 0, 0, 2992, 2993, 1, 0, 0, 0, 2993, 3074,
		1, 0, 0, 0, 2994, 2995, 5, 65, 0, 0, 2995, 2998, 5, 173, 0, 0, 2996, 2997,
		7, 6, 0, 0, 2997, 2999, 3, 444, 222, 0, 2998, 2996, 1, 0, 0, 0, 2998, 2999,
		1, 0, 0, 0, 2999, 3001, 1, 0, 0, 0, 3000, 3002, 3, 74, 37, 0, 3001, 3000,
		1, 0, 0, 0, 3001, 3002, 1, 0, 0, 0, 3002, 3074, 1, 0, 0, 0, 3003, 3004,
		5, 65, 0, 0, 3004, 3005, 5, 506, 0, 0, 3005, 3006, 5, 488, 0, 0, 3006,
		3008, 5, 248, 0, 0, 3007, 3009, 3, 74, 37, 0, 3008, 3007, 1, 0, 0, 0, 3008,
		3009, 1, 0, 0, 0, 3009, 3074, 1, 0, 0, 0, 3010, 3011, 5, 65, 0, 0, 3011,
		3012, 5, 126, 0, 0, 3012, 3013, 5, 36, 0, 0, 3013, 3018, 5, 544, 0, 0,
		3014, 3015, 5, 4, 0, 0, 3015, 3017, 5, 544, 0, 0, 3016, 3014, 1, 0, 0,
		0, 3017, 3020, 1, 0, 0, 0, 3018, 3016, 1, 0, 0, 0, 3018, 3019, 1, 0, 0,
		0, 3019, 3074, 1, 0, 0, 0, 3020, 3018, 1, 0, 0, 0, 3021, 3022, 5, 65, 0,
		0, 3022, 3025, 5, 38, 0, 0, 3023, 3024, 7, 6, 0, 0, 3024, 3026, 3, 444,
		222, 0, 3025, 3023, 1, 0, 0, 0, 3025, 3026, 1, 0, 0, 0, 3026, 3074, 1,
		0, 0, 0, 3027, 3028, 5, 65, 0, 0, 3028, 3031, 5, 391, 0, 0, 3029, 3030,
		7, 6, 0, 0, 3030, 3032, 3, 444, 222, 0, 3031, 3029, 1, 0, 0, 0, 3031, 3032,
		1, 0, 0, 0, 3032, 3074, 1, 0, 0, 0, 3033, 3034, 5, 65, 0, 0, 3034, 3035,
		5, 58, 0, 0, 3035, 3036, 5, 227, 0, 0, 3036, 3037, 5, 318, 0, 0, 3037,
		3048, 3, 328, 164, 0, 3038, 3039, 5, 2, 0, 0, 3039, 3044, 5, 549, 0, 0,
		3040, 3041, 5, 4, 0, 0, 3041, 3043, 5, 549, 0, 0, 3042, 3040, 1, 0, 0,
		0, 3043, 3046, 1, 0, 0, 0, 3044, 3042, 1, 0, 0, 0, 3044, 3045, 1, 0, 0,
		0, 3045, 3047, 1, 0, 0, 0, 3046, 3044, 1, 0, 0, 0, 3047, 3049, 5, 3, 0,
		0, 3048, 3038, 1, 0, 0, 0, 3048, 3049, 1, 0, 0, 0, 3049, 3074, 1, 0, 0,
		0, 3050, 3051, 5, 65, 0, 0, 3051, 3052, 5, 21, 0, 0, 3052, 3057, 5, 451,
		0, 0, 3053, 3058, 5, 404, 0, 0, 3054, 3055, 5, 288, 0, 0, 3055, 3058, 5,
		504, 0, 0, 3056, 3058, 5, 81, 0, 0, 3057, 3053, 1, 0, 0, 0, 3057, 3054,
		1, 0, 0, 0, 3057, 3056, 1, 0, 0, 0, 3058, 3059, 1, 0, 0, 0, 3059, 3060,
		5, 193, 0, 0, 3060, 3071, 3, 328, 164, 0, 3061, 3062, 5, 2, 0, 0, 3062,
		3067, 5, 549, 0, 0, 3063, 3064, 5, 4, 0, 0, 3064, 3066, 5, 549, 0, 0, 3065,
		3063, 1, 0, 0, 0, 3066, 3069, 1, 0, 0, 0, 3067, 3065, 1, 0, 0, 0, 3067,
		3068, 1, 0, 0, 0, 3068, 3070, 1, 0, 0, 0, 3069, 3067, 1, 0, 0, 0, 3070,
		3072, 5, 3, 0, 0, 3071, 3061, 1, 0, 0, 0, 3071, 3072, 1, 0, 0, 0, 3072,
		3074, 1, 0, 0, 0, 3073, 2985, 1, 0, 0, 0, 3073, 2994, 1, 0, 0, 0, 3073,
		3003, 1, 0, 0, 0, 3073, 3010, 1, 0, 0, 0, 3073, 3021, 1, 0, 0, 0, 3073,
		3027, 1, 0, 0, 0, 3073, 3033, 1, 0, 0, 0, 3073, 3050, 1, 0, 0, 0, 3074,
		65, 1, 0, 0, 0, 3075, 3076, 5, 15, 0, 0, 3076, 3077, 5, 424, 0, 0, 3077,
		3078, 5, 386, 0, 0, 3078, 3079, 5, 142, 0, 0, 3079, 3080, 5, 193, 0, 0,
		3080, 3231, 3, 72, 36, 0, 3081, 3082, 5, 15, 0, 0, 3082, 3083, 5, 372,
		0, 0, 3083, 3095, 5, 137, 0, 0, 3084, 3085, 5, 318, 0, 0, 3085, 3086, 5,
		2, 0, 0, 3086, 3091, 5, 544, 0, 0, 3087, 3088, 5, 4, 0, 0, 3088, 3090,
		5, 544, 0, 0, 3089, 3087, 1, 0, 0, 0, 3090, 3093, 1, 0, 0, 0, 3091, 3089,
		1, 0, 0, 0, 3091, 3092, 1, 0, 0, 0, 3092, 3094, 1, 0, 0, 0, 3093, 3091,
		1, 0, 0, 0, 3094, 3096, 5, 3, 0, 0, 3095, 3084, 1, 0, 0, 0, 3095, 3096,
		1, 0, 0, 0, 3096, 3231, 1, 0, 0, 0, 3097, 3098, 5, 15, 0, 0, 3098, 3099,
		5, 65, 0, 0, 3099, 3100, 5, 372, 0, 0, 3100, 3112, 5, 137, 0, 0, 3101,
		3102, 5, 318, 0, 0, 3102, 3103, 5, 2, 0, 0, 3103, 3108, 5, 544, 0, 0, 3104,
		3105, 5, 4, 0, 0, 3105, 3107, 5, 544, 0, 0, 3106, 3104, 1, 0, 0, 0, 3107,
		3110, 1, 0, 0, 0, 3108, 3106, 1, 0, 0, 0, 3108, 3109, 1, 0, 0, 0, 3109,
		3111, 1, 0, 0, 0, 3110, 3108, 1, 0, 0, 0, 3111, 3113, 5, 3, 0, 0, 3112,
		3101, 1, 0, 0, 0, 3112, 3113, 1, 0, 0, 0, 3113, 3231, 1, 0, 0, 0, 3114,
		3115, 5, 15, 0, 0, 3115, 3116, 5, 133, 0, 0, 3116, 3117, 5, 454, 0, 0,
		3117, 3231, 5, 549, 0, 0, 3118, 3119, 5, 15, 0, 0, 3119, 3120, 5, 424,
		0, 0, 3120, 3121, 5, 386, 0, 0, 3121, 3122, 5, 439, 0, 0, 3122, 3123, 5,
		193, 0, 0, 3123, 3129, 3, 72, 36, 0, 3124, 3125, 5, 510, 0, 0, 3125, 3126,
		5, 439, 0, 0, 3126, 3130, 5, 518, 0, 0, 3127, 3128, 5, 520, 0, 0, 3128,
		3130, 5, 544, 0, 0, 3129, 3124, 1, 0, 0, 0, 3129, 3127, 1, 0, 0, 0, 3129,
		3130, 1, 0, 0, 0, 3130, 3231, 1, 0, 0, 0, 3131, 3132, 5, 15, 0, 0, 3132,
		3133, 5, 86, 0, 0, 3133, 3134, 5, 451, 0, 0, 3134, 3139, 3, 72, 36, 0,
		3135, 3136, 5, 510, 0, 0, 3136, 3137, 5, 477, 0, 0, 3137, 3138, 5, 518,
		0, 0, 3138, 3140, 5, 544, 0, 0, 3139, 3135, 1, 0, 0, 0, 3139, 3140, 1,
		0, 0, 0, 3140, 3231, 1, 0, 0, 0, 3141, 3142, 5, 15, 0, 0, 3142, 3143, 5,
		73, 0, 0, 3143, 3145, 3, 364, 182, 0, 3144, 3146, 3, 316, 158, 0, 3145,
		3144, 1, 0, 0, 0, 3145, 3146, 1, 0, 0, 0, 3146, 3231, 1, 0, 0, 0, 3147,
		3148, 5, 15, 0, 0, 3148, 3149, 5, 424, 0, 0, 3149, 3150, 5, 454, 0, 0,
		3150, 3151, 5, 441, 0, 0, 3151, 3153, 5, 191, 0, 0, 3152, 3154, 5, 502,
		0, 0, 3153, 3152, 1, 0, 0, 0, 3153, 3154, 1, 0, 0, 0, 3154, 3231, 1, 0,
		0, 0, 3155, 3156, 5, 15, 0, 0, 3156, 3160, 5, 420, 0, 0, 3157, 3161, 5,
		194, 0, 0, 3158, 3159, 5, 20, 0, 0, 3159, 3161, 5, 195, 0, 0, 3160, 3157,
		1, 0, 0, 0, 3160, 3158, 1, 0, 0, 0, 3161, 3162, 1, 0, 0, 0, 3162, 3167,
		5, 91, 0, 0, 3163, 3164, 5, 2, 0, 0, 3164, 3165, 3, 318, 159, 0, 3165,
		3166, 5, 3, 0, 0, 3166, 3168, 1, 0, 0, 0, 3167, 3163, 1, 0, 0, 0, 3167,
		3168, 1, 0, 0, 0, 3168, 3170, 1, 0, 0, 0, 3169, 3171, 5, 20, 0, 0, 3170,
		3169, 1, 0, 0, 0, 3170, 3171, 1, 0, 0, 0, 3171, 3231, 1, 0, 0, 0, 3172,
		3173, 5, 15, 0, 0, 3173, 3174, 5, 74, 0, 0, 3174, 3186, 5, 471, 0, 0, 3175,
		3176, 5, 318, 0, 0, 3176, 3177, 5, 2, 0, 0, 3177, 3182, 5, 544, 0, 0, 3178,
		3179, 5, 4, 0, 0, 3179, 3181, 5, 544, 0, 0, 3180, 3178, 1, 0, 0, 0, 3181,
		3184, 1, 0, 0, 0, 3182, 3180, 1, 0, 0, 0, 3182, 3183, 1, 0, 0, 0, 3183,
		3185, 1, 0, 0, 0, 3184, 3182, 1, 0, 0, 0, 3185, 3187, 5, 3, 0, 0, 3186,
		3175, 1, 0, 0, 0, 3186, 3187, 1, 0, 0, 0, 3187, 3231, 1, 0, 0, 0, 3188,
		3189, 5, 15, 0, 0, 3189, 3190, 5, 420, 0, 0, 3190, 3191, 5, 386, 0, 0,
		3191, 3192, 5, 503, 0, 0, 3192, 3193, 5, 359, 0, 0, 3193, 3194, 5, 2, 0,
		0, 3194, 3195, 3, 318, 159, 0, 3195, 3196, 5, 3, 0, 0, 3196, 3231, 1, 0,
		0, 0, 3197, 3198, 5, 15, 0, 0, 3198, 3199, 5, 420, 0, 0, 3199, 3200, 5,
		451, 0, 0, 3200, 3201, 3, 328, 164, 0, 3201, 3203, 5, 439, 0, 0, 3202,
		3204, 3, 316, 158, 0, 3203, 3202, 1, 0, 0, 0, 3203, 3204, 1, 0, 0, 0, 3204,
		3231, 1, 0, 0, 0, 3205, 3206, 5, 15, 0, 0, 3206, 3207, 5, 420, 0, 0, 3207,
		3208, 5, 386, 0, 0, 3208, 3209, 5, 439, 0, 0, 3209, 3210, 5, 359, 0, 0,
		3210, 3211, 5, 2, 0, 0, 3211, 3212, 3, 318, 159, 0, 3212, 3213, 5, 3, 0,
		0, 3213, 3231, 1, 0, 0, 0, 3214, 3215, 5, 15, 0, 0, 3215, 3216, 5, 381,
		0, 0, 3216, 3217, 5, 451, 0, 0, 3217, 3231, 3, 72, 36, 0, 3218, 3219, 5,
		15, 0, 0, 3219, 3220, 5, 65, 0, 0, 3220, 3221, 5, 381, 0, 0, 3221, 3222,
		5, 451, 0, 0, 3222, 3231, 3, 72, 36, 0, 3223, 3224, 5, 15, 0, 0, 3224,
		3225, 5, 99, 0, 0, 3225, 3226, 5, 454, 0, 0, 3226, 3228, 5, 549, 0, 0,
		3227, 3229, 3, 316, 158, 0, 3228, 3227, 1, 0, 0, 0, 3228, 3229, 1, 0, 0,
		0, 3229, 3231, 1, 0, 0, 0, 3230, 3075, 1, 0, 0, 0, 3230, 3081, 1, 0, 0,
		0, 3230, 3097, 1, 0, 0, 0, 3230, 3114, 1, 0, 0, 0, 3230, 3118, 1, 0, 0,
		0, 3230, 3131, 1, 0, 0, 0, 3230, 3141, 1, 0, 0, 0, 3230, 3147, 1, 0, 0,
		0, 3230, 3155, 1, 0, 0, 0, 3230, 3172, 1, 0, 0, 0, 3230, 3188, 1, 0, 0,
		0, 3230, 3197, 1, 0, 0, 0, 3230, 3205, 1, 0, 0, 0, 3230, 3214, 1, 0, 0,
		0, 3230, 3218, 1, 0, 0, 0, 3230, 3223, 1, 0, 0, 0, 3231, 67, 1, 0, 0, 0,
		3232, 3233, 5, 374, 0, 0, 3233, 3234, 5, 113, 0, 0, 3234, 3236, 3, 444,
		222, 0, 3235, 3237, 5, 549, 0, 0, 3236, 3235, 1, 0, 0, 0, 3236, 3237, 1,
		0, 0, 0, 3237, 3240, 1, 0, 0, 0, 3238, 3239, 5, 29, 0, 0, 3239, 3241, 3,
		444, 222, 0, 3240, 3238, 1, 0, 0, 0, 3240, 3241, 1, 0, 0, 0, 3241, 3266,
		1, 0, 0, 0, 3242, 3243, 5, 374, 0, 0, 3243, 3244, 5, 451, 0, 0, 3244, 3246,
		3, 328, 164, 0, 3245, 3247, 5, 549, 0, 0, 3246, 3245, 1, 0, 0, 0, 3246,
		3247, 1, 0, 0, 0, 3247, 3250, 1, 0, 0, 0, 3248, 3249, 5, 29, 0, 0, 3249,
		3251, 3, 444, 222, 0, 3250, 3248, 1, 0, 0, 0, 3250, 3251, 1, 0, 0, 0, 3251,
		3266, 1, 0, 0, 0, 3252, 3253, 5, 374, 0, 0, 3253, 3254, 5, 330, 0, 0, 3254,
		3256, 3, 444, 222, 0, 3255, 3257, 5, 549, 0, 0, 3256, 3255, 1, 0, 0, 0,
		3256, 3257, 1, 0, 0, 0, 3257, 3260, 1, 0, 0, 0, 3258, 3259, 5, 29, 0, 0,
		3259, 3261, 3, 444, 222, 0, 3260, 3258, 1, 0, 0, 0, 3260, 3261, 1, 0, 0,
		0, 3261, 3262, 1, 0, 0, 0, 3262, 3263, 5, 193, 0, 0, 3263, 3264, 3, 328,
		164, 0, 3264, 3266, 1, 0, 0, 0, 3265, 3232, 1, 0, 0, 0, 3265, 3242, 1,
		0, 0, 0, 3265, 3252, 1, 0, 0, 0, 3266, 69, 1, 0, 0, 0, 3267, 3268, 5, 15,
		0, 0, 3268, 3269, 5, 420, 0, 0, 3269, 3270, 5, 451, 0, 0, 3270, 3271, 3,
		328, 164, 0, 3271, 3272, 5, 330, 0, 0, 3272, 3274, 5, 503, 0, 0, 3273,
		3275, 3, 316, 158, 0, 3274, 3273, 1, 0, 0, 0, 3274, 3275, 1, 0, 0, 0, 3275,
		71, 1, 0, 0, 0, 3276, 3278, 3, 328, 164, 0, 3277, 3279, 3, 310, 155, 0,
		3278, 3277, 1, 0, 0, 0, 3278, 3279, 1, 0, 0, 0, 3279, 3281, 1, 0, 0, 0,
		3280, 3282, 3, 438, 219, 0, 3281, 3280, 1, 0, 0, 0, 3281, 3282, 1, 0, 0,
		0, 3282, 3284, 1, 0, 0, 0, 3283, 3285, 3, 408, 204, 0, 3284, 3283, 1, 0,
		0, 0, 3284, 3285, 1, 0, 0, 0, 3285, 3287, 1, 0, 0, 0, 3286, 3288, 3, 364,
		182, 0, 3287, 3286, 1, 0, 0, 0, 3287, 3288, 1, 0, 0, 0, 3288, 3289, 1,
		0, 0, 0, 3289, 3291, 3, 326, 163, 0, 3290, 3292, 3, 434, 217, 0, 3291,
		3290, 1, 0, 0, 0, 3291, 3292, 1, 0, 0, 0, 3292, 3294, 1, 0, 0, 0, 3293,
		3295, 3, 268, 134, 0, 3294, 3293, 1, 0, 0, 0, 3294, 3295, 1, 0, 0, 0, 3295,
		73, 1, 0, 0, 0, 3296, 3297, 5, 266, 0, 0, 3297, 3301, 5, 544, 0, 0, 3298,
		3299, 5, 510, 0, 0, 3299, 3301, 3, 372, 186, 0, 3300, 3296, 1, 0, 0, 0,
		3300, 3298, 1, 0, 0, 0, 3301, 75, 1, 0, 0, 0, 3302, 3308, 5, 39, 0, 0,
		3303, 3304, 5, 512, 0, 0, 3304, 3306, 5, 256, 0, 0, 3305, 3307, 3, 444,
		222, 0, 3306, 3305, 1, 0, 0, 0, 3306, 3307, 1, 0, 0, 0, 3307, 3309, 1,
		0, 0, 0, 3308, 3303, 1, 0, 0, 0, 3308, 3309, 1, 0, 0, 0, 3309, 3345, 1,
		0, 0, 0, 3310, 3312, 5, 84, 0, 0, 3311, 3313, 5, 513, 0, 0, 3312, 3311,
		1, 0, 0, 0, 3312, 3313, 1, 0, 0, 0, 3313, 3319, 1, 0, 0, 0, 3314, 3316,
		5, 25, 0, 0, 3315, 3317, 5, 309, 0, 0, 3316, 3315, 1, 0, 0, 0, 3316, 3317,
		1, 0, 0, 0, 3317, 3318, 1, 0, 0, 0, 3318, 3320, 5, 70, 0, 0, 3319, 3314,
		1, 0, 0, 0, 3319, 3320, 1, 0, 0, 0, 3320, 3325, 1, 0, 0, 0, 3321, 3323,
		5, 309, 0, 0, 3322, 3321, 1, 0, 0, 0, 3322, 3323, 1, 0, 0, 0, 3323, 3324,
		1, 0, 0, 0, 3324, 3326, 5, 379, 0, 0, 3325, 3322, 1, 0, 0, 0, 3325, 3326,
		1, 0, 0, 0, 3326, 3345, 1, 0, 0, 0, 3327, 3329, 5, 403, 0, 0, 3328, 3330,
		5, 513, 0, 0, 3329, 3328, 1, 0, 0, 0, 3329, 3330, 1, 0, 0, 0, 3330, 3336,
		1, 0, 0, 0, 3331, 3333, 5, 25, 0, 0, 3332, 3334, 5, 309, 0, 0, 3333, 3332,
		1, 0, 0, 0, 3333, 3334, 1, 0, 0, 0, 3334, 3335, 1, 0, 0, 0, 3335, 3337,
		5, 70, 0, 0, 3336, 3331, 1, 0, 0, 0, 3336, 3337, 1, 0, 0, 0, 3337, 3342,
		1, 0, 0, 0, 3338, 3340, 5, 309, 0, 0, 3339, 3338, 1, 0, 0, 0, 3339, 3340,
		1, 0, 0, 0, 3340, 3341, 1, 0, 0, 0, 3341, 3343, 5, 379, 0, 0, 3342, 3339,
		1, 0, 0, 0, 3342, 3343, 1, 0, 0, 0, 3343, 3345, 1, 0, 0, 0, 3344, 3302,
		1, 0, 0, 0, 3344, 3310, 1, 0, 0, 0, 3344, 3327, 1, 0, 0, 0, 3345, 77, 1,
		0, 0, 0, 3346, 3347, 5, 202, 0, 0, 3347, 3348, 3, 82, 41, 0, 3348, 3349,
		5, 318, 0, 0, 3349, 3350, 3, 188, 94, 0, 3350, 3354, 5, 467, 0, 0, 3351,
		3355, 3, 192, 96, 0, 3352, 3353, 5, 401, 0, 0, 3353, 3355, 3, 184, 92,
		0, 3354, 3351, 1, 0, 0, 0, 3354, 3352, 1, 0, 0, 0, 3355, 3433, 1, 0, 0,
		0, 3356, 3357, 5, 202, 0, 0, 3357, 3358, 3, 82, 41, 0, 3358, 3368, 5, 318,
		0, 0, 3359, 3369, 5, 389, 0, 0, 3360, 3369, 5, 75, 0, 0, 3361, 3362, 5,
		89, 0, 0, 3362, 3369, 5, 205, 0, 0, 3363, 3369, 5, 434, 0, 0, 3364, 3365,
		5, 441, 0, 0, 3365, 3369, 5, 500, 0, 0, 3366, 3367, 5, 514, 0, 0, 3367,
		3369, 5, 205, 0, 0, 3368, 3359, 1, 0, 0, 0, 3368, 3360, 1, 0, 0, 0, 3368,
		3361, 1, 0, 0, 0, 3368, 3363, 1, 0, 0, 0, 3368, 3364, 1, 0, 0, 0, 3368,
		3366, 1, 0, 0, 0, 3369, 3370, 1, 0, 0, 0, 3370, 3371, 3, 186, 93, 0, 3371,
		3375, 5, 467, 0, 0, 3372, 3376, 3, 192, 96, 0, 3373, 3374, 5, 401, 0, 0,
		3374, 3376, 3, 184, 92, 0, 3375, 3372, 1, 0, 0, 0, 3375, 3373, 1, 0, 0,
		0, 3376, 3433, 1, 0, 0, 0, 3377, 3378, 5, 202, 0, 0, 3378, 3383, 3, 184,
		92, 0, 3379, 3380, 5, 4, 0, 0, 3380, 3382, 3, 184, 92, 0, 3381, 3379, 1,
		0, 0, 0, 3382, 3385, 1, 0, 0, 0, 3383, 3381, 1, 0, 0, 0, 3383, 3384, 1,
		0, 0, 0, 3384, 3386, 1, 0, 0, 0, 3385, 3383, 1, 0, 0, 0, 3386, 3387, 5,
		467, 0, 0, 3387, 3388, 3, 192, 96, 0, 3388, 3433, 1, 0, 0, 0, 3389, 3390,
		5, 397, 0, 0, 3390, 3395, 3, 184, 92, 0, 3391, 3392, 5, 4, 0, 0, 3392,
		3394, 3, 184, 92, 0, 3393, 3391, 1, 0, 0, 0, 3394, 3397, 1, 0, 0, 0, 3395,
		3393, 1, 0, 0, 0, 3395, 3396, 1, 0, 0, 0, 3396, 3398, 1, 0, 0, 0, 3397,
		3395, 1, 0, 0, 0, 3398, 3399, 5, 193, 0, 0, 3399, 3400, 3, 192, 96, 0,
		3400, 3433, 1, 0, 0, 0, 3401, 3402, 5, 397, 0, 0, 3402, 3403, 3, 82, 41,
		0, 3403, 3413, 5, 318, 0, 0, 3404, 3414, 5, 389, 0, 0, 3405, 3414, 5, 75,
		0, 0, 3406, 3407, 5, 89, 0, 0, 3407, 3414, 5, 205, 0, 0, 3408, 3414, 5,
		434, 0, 0, 3409, 3410, 5, 441, 0, 0, 3410, 3414, 5, 500, 0, 0, 3411, 3412,
		5, 514, 0, 0, 3412, 3414, 5, 205, 0, 0, 3413, 3404, 1, 0, 0, 0, 3413, 3405,
		1, 0, 0, 0, 3413, 3406, 1, 0, 0, 0, 3413, 3408, 1, 0, 0, 0, 3413, 3409,
		1, 0, 0, 0, 3413, 3411, 1, 0, 0, 0, 3414, 3415, 1, 0, 0, 0, 3415, 3416,
		3, 186, 93, 0, 3416, 3420, 5, 193, 0, 0, 3417, 3421, 3, 192, 96, 0, 3418,
		3419, 5, 401, 0, 0, 3419, 3421, 3, 184, 92, 0, 3420, 3417, 1, 0, 0, 0,
		3420, 3418, 1, 0, 0, 0, 3421, 3433, 1, 0, 0, 0, 3422, 3423, 5, 397, 0,
		0, 3423, 3424, 3, 82, 41, 0, 3424, 3425, 5, 318, 0, 0, 3425, 3426, 3, 188,
		94, 0, 3426, 3430, 5, 193, 0, 0, 3427, 3431, 3, 192, 96, 0, 3428, 3429,
		5, 401, 0, 0, 3429, 3431, 3, 184, 92, 0, 3430, 3427, 1, 0, 0, 0, 3430,
		3428, 1, 0, 0, 0, 3431, 3433, 1, 0, 0, 0, 3432, 3346, 1, 0, 0, 0, 3432,
		3356, 1, 0, 0, 0, 3432, 3377, 1, 0, 0, 0, 3432, 3389, 1, 0, 0, 0, 3432,
		3401, 1, 0, 0, 0, 3432, 3422, 1, 0, 0, 0, 3433, 79, 1, 0, 0, 0, 3434, 3436,
		3, 444, 222, 0, 3435, 3437, 3, 306, 153, 0, 3436, 3435, 1, 0, 0, 0, 3436,
		3437, 1, 0, 0, 0, 3437, 3440, 1, 0, 0, 0, 3438, 3440, 5, 20, 0, 0, 3439,
		3434, 1, 0, 0, 0, 3439, 3438, 1, 0, 0, 0, 3440, 81, 1, 0, 0, 0, 3441, 3446,
		3, 80, 40, 0, 3442, 3443, 5, 4, 0, 0, 3443, 3445, 3, 80, 40, 0, 3444, 3442,
		1, 0, 0, 0, 3445, 3448, 1, 0, 0, 0, 3446, 3444, 1, 0, 0, 0, 3446, 3447,
		1, 0, 0, 0, 3447, 83, 1, 0, 0, 0, 3448, 3446, 1, 0, 0, 0, 3449, 3450, 5,
		14, 0, 0, 3450, 3451, 5, 36, 0, 0, 3451, 3456, 5, 544, 0, 0, 3452, 3453,
		5, 4, 0, 0, 3453, 3455, 5, 544, 0, 0, 3454, 3452, 1, 0, 0, 0, 3455, 3458,
		1, 0, 0, 0, 3456, 3454, 1, 0, 0, 0, 3456, 3457, 1, 0, 0, 0, 3457, 3460,
		1, 0, 0, 0, 3458, 3456, 1, 0, 0, 0, 3459, 3461, 3, 316, 158, 0, 3460, 3459,
		1, 0, 0, 0, 3460, 3461, 1, 0, 0, 0, 3461, 3548, 1, 0, 0, 0, 3462, 3463,
		7, 21, 0, 0, 3463, 3464, 5, 36, 0, 0, 3464, 3469, 5, 544, 0, 0, 3465, 3466,
		5, 4, 0, 0, 3466, 3468, 5, 544, 0, 0, 3467, 3465, 1, 0, 0, 0, 3468, 3471,
		1, 0, 0, 0, 3469, 3467, 1, 0, 0, 0, 3469, 3470, 1, 0, 0, 0, 3470, 3548,
		1, 0, 0, 0, 3471, 3469, 1, 0, 0, 0, 3472, 3473, 5, 126, 0, 0, 3473, 3474,
		5, 36, 0, 0, 3474, 3479, 5, 544, 0, 0, 3475, 3476, 5, 4, 0, 0, 3476, 3478,
		5, 544, 0, 0, 3477, 3475, 1, 0, 0, 0, 3478, 3481, 1, 0, 0, 0, 3479, 3477,
		1, 0, 0, 0, 3479, 3480, 1, 0, 0, 0, 3480, 3548, 1, 0, 0, 0, 3481, 3479,
		1, 0, 0, 0, 3482, 3483, 5, 14, 0, 0, 3483, 3484, 5, 315, 0, 0, 3484, 3548,
		5, 544, 0, 0, 3485, 3486, 5, 147, 0, 0, 3486, 3487, 5, 315, 0, 0, 3487,
		3548, 5, 544, 0, 0, 3488, 3489, 5, 14, 0, 0, 3489, 3490, 5, 186, 0, 0,
		3490, 3548, 5, 544, 0, 0, 3491, 3492, 5, 147, 0, 0, 3492, 3493, 5, 186,
		0, 0, 3493, 3548, 5, 544, 0, 0, 3494, 3495, 5, 14, 0, 0, 3495, 3496, 5,
		56, 0, 0, 3496, 3497, 3, 184, 92, 0, 3497, 3502, 5, 544, 0, 0, 3498, 3499,
		5, 4, 0, 0, 3499, 3501, 5, 544, 0, 0, 3500, 3498, 1, 0, 0, 0, 3501, 3504,
		1, 0, 0, 0, 3502, 3500, 1, 0, 0, 0, 3502, 3503, 1, 0, 0, 0, 3503, 3548,
		1, 0, 0, 0, 3504, 3502, 1, 0, 0, 0, 3505, 3506, 5, 147, 0, 0, 3506, 3507,
		5, 56, 0, 0, 3507, 3508, 3, 184, 92, 0, 3508, 3513, 5, 544, 0, 0, 3509,
		3510, 5, 4, 0, 0, 3510, 3512, 5, 544, 0, 0, 3511, 3509, 1, 0, 0, 0, 3512,
		3515, 1, 0, 0, 0, 3513, 3511, 1, 0, 0, 0, 3513, 3514, 1, 0, 0, 0, 3514,
		3548, 1, 0, 0, 0, 3515, 3513, 1, 0, 0, 0, 3516, 3517, 5, 147, 0, 0, 3517,
		3518, 5, 20, 0, 0, 3518, 3519, 5, 56, 0, 0, 3519, 3548, 3, 184, 92, 0,
		3520, 3521, 5, 420, 0, 0, 3521, 3522, 5, 271, 0, 0, 3522, 3523, 5, 163,
		0, 0, 3523, 3525, 5, 220, 0, 0, 3524, 3526, 3, 316, 158, 0, 3525, 3524,
		1, 0, 0, 0, 3525, 3526, 1, 0, 0, 0, 3526, 3548, 1, 0, 0, 0, 3527, 3528,
		5, 299, 0, 0, 3528, 3529, 5, 36, 0, 0, 3529, 3534, 5, 544, 0, 0, 3530,
		3531, 5, 4, 0, 0, 3531, 3533, 5, 544, 0, 0, 3532, 3530, 1, 0, 0, 0, 3533,
		3536, 1, 0, 0, 0, 3534, 3532, 1, 0, 0, 0, 3534, 3535, 1, 0, 0, 0, 3535,
		3537, 1, 0, 0, 0, 3536, 3534, 1, 0, 0, 0, 3537, 3538, 5, 420, 0, 0, 3538,
		3539, 5, 2, 0, 0, 3539, 3540, 3, 318, 159, 0, 3540, 3541, 5, 3, 0, 0, 3541,
		3548, 1, 0, 0, 0, 3542, 3543, 5, 299, 0, 0, 3543, 3544, 7, 2, 0, 0, 3544,
		3545, 5, 544, 0, 0, 3545, 3546, 5, 216, 0, 0, 3546, 3548, 5, 544, 0, 0,
		3547, 3449, 1, 0, 0, 0, 3547, 3462, 1, 0, 0, 0, 3547, 3472, 1, 0, 0, 0,
		3547, 3482, 1, 0, 0, 0, 3547, 3485, 1, 0, 0, 0, 3547, 3488, 1, 0, 0, 0,
		3547, 3491, 1, 0, 0, 0, 3547, 3494, 1, 0, 0, 0, 3547, 3505, 1, 0, 0, 0,
		3547, 3516, 1, 0, 0, 0, 3547, 3520, 1, 0, 0, 0, 3547, 3527, 1, 0, 0, 0,
		3547, 3542, 1, 0, 0, 0, 3548, 85, 1, 0, 0, 0, 3549, 3551, 3, 444, 222,
		0, 3550, 3552, 3, 316, 158, 0, 3551, 3550, 1, 0, 0, 0, 3551, 3552, 1, 0,
		0, 0, 3552, 87, 1, 0, 0, 0, 3553, 3554, 3, 444, 222, 0, 3554, 3558, 3,
		306, 153, 0, 3555, 3556, 5, 151, 0, 0, 3556, 3557, 5, 253, 0, 0, 3557,
		3559, 3, 306, 153, 0, 3558, 3555, 1, 0, 0, 0, 3558, 3559, 1, 0, 0, 0, 3559,
		3561, 1, 0, 0, 0, 3560, 3562, 3, 116, 58, 0, 3561, 3560, 1, 0, 0, 0, 3561,
		3562, 1, 0, 0, 0, 3562, 3564, 1, 0, 0, 0, 3563, 3565, 3, 316, 158, 0, 3564,
		3563, 1, 0, 0, 0, 3564, 3565, 1, 0, 0, 0, 3565, 89, 1, 0, 0, 0, 3566, 3567,
		5, 14, 0, 0, 3567, 3568, 5, 81, 0, 0, 3568, 3570, 3, 336, 168, 0, 3569,
		3571, 3, 112, 56, 0, 3570, 3569, 1, 0, 0, 0, 3570, 3571, 1, 0, 0, 0, 3571,
		3573, 1, 0, 0, 0, 3572, 3574, 3, 114, 57, 0, 3573, 3572, 1, 0, 0, 0, 3573,
		3574, 1, 0, 0, 0, 3574, 3576, 1, 0, 0, 0, 3575, 3577, 3, 316, 158, 0, 3576,
		3575, 1, 0, 0, 0, 3576, 3577, 1, 0, 0, 0, 3577, 3791, 1, 0, 0, 0, 3578,
		3579, 5, 14, 0, 0, 3579, 3580, 5, 81, 0, 0, 3580, 3581, 5, 2, 0, 0, 3581,
		3582, 3, 334, 167, 0, 3582, 3584, 5, 3, 0, 0, 3583, 3585, 3, 114, 57, 0,
		3584, 3583, 1, 0, 0, 0, 3584, 3585, 1, 0, 0, 0, 3585, 3587, 1, 0, 0, 0,
		3586, 3588, 3, 316, 158, 0, 3587, 3586, 1, 0, 0, 0, 3587, 3588, 1, 0, 0,
		0, 3588, 3791, 1, 0, 0, 0, 3589, 3590, 5, 147, 0, 0, 3590, 3591, 5, 81,
		0, 0, 3591, 3593, 3, 444, 222, 0, 3592, 3594, 3, 116, 58, 0, 3593, 3592,
		1, 0, 0, 0, 3593, 3594, 1, 0, 0, 0, 3594, 3596, 1, 0, 0, 0, 3595, 3597,
		3, 316, 158, 0, 3596, 3595, 1, 0, 0, 0, 3596, 3597, 1, 0, 0, 0, 3597, 3791,
		1, 0, 0, 0, 3598, 3599, 5, 299, 0, 0, 3599, 3600, 5, 81, 0, 0, 3600, 3602,
		3, 336, 168, 0, 3601, 3603, 3, 112, 56, 0, 3602, 3601, 1, 0, 0, 0, 3602,
		3603, 1, 0, 0, 0, 3603, 3605, 1, 0, 0, 0, 3604, 3606, 3, 116, 58, 0, 3605,
		3604, 1, 0, 0, 0, 3605, 3606, 1, 0, 0, 0, 3606, 3608, 1, 0, 0, 0, 3607,
		3609, 3, 316, 158, 0, 3608, 3607, 1, 0, 0, 0, 3608, 3609, 1, 0, 0, 0, 3609,
		3791, 1, 0, 0, 0, 3610, 3611, 5, 323, 0, 0, 3611, 3612, 5, 61, 0, 0, 3612,
		3614, 3, 306, 153, 0, 3613, 3615, 3, 116, 58, 0, 3614, 3613, 1, 0, 0, 0,
		3614, 3615, 1, 0, 0, 0, 3615, 3617, 1, 0, 0, 0, 3616, 3618, 3, 316, 158,
		0, 3617, 3616, 1, 0, 0, 0, 3617, 3618, 1, 0, 0, 0, 3618, 3791, 1, 0, 0,
		0, 3619, 3621, 5, 14, 0, 0, 3620, 3622, 5, 459, 0, 0, 3621, 3620, 1, 0,
		0, 0, 3621, 3622, 1, 0, 0, 0, 3622, 3623, 1, 0, 0, 0, 3623, 3638, 3, 344,
		172, 0, 3624, 3625, 5, 141, 0, 0, 3625, 3629, 5, 61, 0, 0, 3626, 3627,
		5, 208, 0, 0, 3627, 3630, 3, 306, 153, 0, 3628, 3630, 5, 368, 0, 0, 3629,
		3626, 1, 0, 0, 0, 3629, 3628, 1, 0, 0, 0, 3630, 3636, 1, 0, 0, 0, 3631,
		3634, 5, 57, 0, 0, 3632, 3635, 5, 549, 0, 0, 3633, 3635, 5, 33, 0, 0, 3634,
		3632, 1, 0, 0, 0, 3634, 3633, 1, 0, 0, 0, 3635, 3637, 1, 0, 0, 0, 3636,
		3631, 1, 0, 0, 0, 3636, 3637, 1, 0, 0, 0, 3637, 3639, 1, 0, 0, 0, 3638,
		3624, 1, 0, 0, 0, 3638, 3639, 1, 0, 0, 0, 3639, 3641, 1, 0, 0, 0, 3640,
		3642, 3, 316, 158, 0, 3641, 3640, 1, 0, 0, 0, 3641, 3642, 1, 0, 0, 0, 3642,
		3791, 1, 0, 0, 0, 3643, 3645, 5, 147, 0, 0, 3644, 3646, 5, 459, 0, 0, 3645,
		3644, 1, 0, 0, 0, 3645, 3646, 1, 0, 0, 0, 3646, 3647, 1, 0, 0, 0, 3647,
		3650, 5, 330, 0, 0, 3648, 3649, 5, 222, 0, 0, 3649, 3651, 5, 170, 0, 0,
		3650, 3648, 1, 0, 0, 0, 3650, 3651, 1, 0, 0, 0, 3651, 3652, 1, 0, 0, 0,
		3652, 3654, 3, 444, 222, 0, 3653, 3655, 5, 190, 0, 0, 3654, 3653, 1, 0,
		0, 0, 3654, 3655, 1, 0, 0, 0, 3655, 3659, 1, 0, 0, 0, 3656, 3657, 5, 193,
		0, 0, 3657, 3658, 5, 227, 0, 0, 3658, 3660, 3, 444, 222, 0, 3659, 3656,
		1, 0, 0, 0, 3659, 3660, 1, 0, 0, 0, 3660, 3791, 1, 0, 0, 0, 3661, 3663,
		5, 299, 0, 0, 3662, 3664, 5, 459, 0, 0, 3663, 3662, 1, 0, 0, 0, 3663, 3664,
		1, 0, 0, 0, 3664, 3665, 1, 0, 0, 0, 3665, 3671, 5, 330, 0, 0, 3666, 3672,
		3, 444, 222, 0, 3667, 3672, 3, 306, 153, 0, 3668, 3669, 5, 2, 0, 0, 3669,
		3670, 5, 527, 0, 0, 3670, 3672, 5, 3, 0, 0, 3671, 3666, 1, 0, 0, 0, 3671,
		3667, 1, 0, 0, 0, 3671, 3668, 1, 0, 0, 0, 3672, 3673, 1, 0, 0, 0, 3673,
		3674, 5, 420, 0, 0, 3674, 3675, 5, 2, 0, 0, 3675, 3676, 3, 318, 159, 0,
		3676, 3677, 5, 3, 0, 0, 3677, 3791, 1, 0, 0, 0, 3678, 3680, 5, 383, 0,
		0, 3679, 3681, 3, 162, 81, 0, 3680, 3679, 1, 0, 0, 0, 3680, 3681, 1, 0,
		0, 0, 3681, 3682, 1, 0, 0, 0, 3682, 3684, 5, 512, 0, 0, 3683, 3685, 3,
		162, 81, 0, 3684, 3683, 1, 0, 0, 0, 3684, 3685, 1, 0, 0, 0, 3685, 3687,
		1, 0, 0, 0, 3686, 3688, 5, 190, 0, 0, 3687, 3686, 1, 0, 0, 0, 3687, 3688,
		1, 0, 0, 0, 3688, 3690, 1, 0, 0, 0, 3689, 3691, 3, 316, 158, 0, 3690, 3689,
		1, 0, 0, 0, 3690, 3691, 1, 0, 0, 0, 3691, 3791, 1, 0, 0, 0, 3692, 3693,
		5, 383, 0, 0, 3693, 3694, 5, 512, 0, 0, 3694, 3695, 5, 451, 0, 0, 3695,
		3697, 3, 444, 222, 0, 3696, 3698, 3, 316, 158, 0, 3697, 3696, 1, 0, 0,
		0, 3697, 3698, 1, 0, 0, 0, 3698, 3700, 1, 0, 0, 0, 3699, 3701, 5, 190,
		0, 0, 3700, 3699, 1, 0, 0, 0, 3700, 3701, 1, 0, 0, 0, 3701, 3791, 1, 0,
		0, 0, 3702, 3703, 5, 380, 0, 0, 3703, 3791, 3, 444, 222, 0, 3704, 3705,
		5, 380, 0, 0, 3705, 3706, 5, 404, 0, 0, 3706, 3707, 3, 444, 222, 0, 3707,
		3708, 3, 444, 222, 0, 3708, 3791, 1, 0, 0, 0, 3709, 3710, 5, 380, 0, 0,
		3710, 3711, 5, 330, 0, 0, 3711, 3712, 3, 444, 222, 0, 3712, 3713, 3, 444,
		222, 0, 3713, 3791, 1, 0, 0, 0, 3714, 3715, 5, 380, 0, 0, 3715, 3716, 5,
		81, 0, 0, 3716, 3717, 3, 444, 222, 0, 3717, 3718, 3, 444, 222, 0, 3718,
		3791, 1, 0, 0, 0, 3719, 3720, 5, 14, 0, 0, 3720, 3791, 3, 340, 170, 0,
		3721, 3722, 5, 147, 0, 0, 3722, 3725, 5, 227, 0, 0, 3723, 3724, 5, 222,
		0, 0, 3724, 3726, 5, 170, 0, 0, 3725, 3723, 1, 0, 0, 0, 3725, 3726, 1,
		0, 0, 0, 3726, 3727, 1, 0, 0, 0, 3727, 3791, 3, 444, 222, 0, 3728, 3729,
		5, 155, 0, 0, 3729, 3730, 5, 180, 0, 0, 3730, 3733, 5, 544, 0, 0, 3731,
		3732, 5, 512, 0, 0, 3732, 3734, 3, 316, 158, 0, 3733, 3731, 1, 0, 0, 0,
		3733, 3734, 1, 0, 0, 0, 3734, 3791, 1, 0, 0, 0, 3735, 3736, 5, 299, 0,
		0, 3736, 3751, 5, 142, 0, 0, 3737, 3738, 5, 141, 0, 0, 3738, 3742, 5, 61,
		0, 0, 3739, 3740, 5, 208, 0, 0, 3740, 3743, 3, 306, 153, 0, 3741, 3743,
		5, 368, 0, 0, 3742, 3739, 1, 0, 0, 0, 3742, 3741, 1, 0, 0, 0, 3743, 3749,
		1, 0, 0, 0, 3744, 3747, 5, 57, 0, 0, 3745, 3748, 5, 549, 0, 0, 3746, 3748,
		5, 33, 0, 0, 3747, 3745, 1, 0, 0, 0, 3747, 3746, 1, 0, 0, 0, 3748, 3750,
		1, 0, 0, 0, 3749, 3744, 1, 0, 0, 0, 3749, 3750, 1, 0, 0, 0, 3750, 3752,
		1, 0, 0, 0, 3751, 3737, 1, 0, 0, 0, 3751, 3752, 1, 0, 0, 0, 3752, 3791,
		1, 0, 0, 0, 3753, 3754, 5, 299, 0, 0, 3754, 3755, 5, 83, 0, 0, 3755, 3791,
		5, 544, 0, 0, 3756, 3757, 5, 299, 0, 0, 3757, 3758, 5, 81, 0, 0, 3758,
		3759, 3, 444, 222, 0, 3759, 3760, 5, 83, 0, 0, 3760, 3761, 5, 544, 0, 0,
		3761, 3791, 1, 0, 0, 0, 3762, 3763, 5, 299, 0, 0, 3763, 3764, 5, 160, 0,
		0, 3764, 3765, 5, 467, 0, 0, 3765, 3767, 3, 444, 222, 0, 3766, 3768, 3,
		316, 158, 0, 3767, 3766, 1, 0, 0, 0, 3767, 3768, 1, 0, 0, 0, 3768, 3791,
		1, 0, 0, 0, 3769, 3771, 5, 14, 0, 0, 3770, 3772, 5, 459, 0, 0, 3771, 3770,
		1, 0, 0, 0, 3771, 3772, 1, 0, 0, 0, 3772, 3773, 1, 0, 0, 0, 3773, 3774,
		5, 331, 0, 0, 3774, 3775, 5, 193, 0, 0, 3775, 3776, 3, 354, 177, 0, 3776,
		3777, 5, 467, 0, 0, 3777, 3778, 3, 354, 177, 0, 3778, 3779, 5, 237, 0,
		0, 3779, 3781, 5, 549, 0, 0, 3780, 3782, 3, 444, 222, 0, 3781, 3780, 1,
		0, 0, 0, 3781, 3782, 1, 0, 0, 0, 3782, 3784, 1, 0, 0, 0, 3783, 3785, 3,
		316, 158, 0, 3784, 3783, 1, 0, 0, 0, 3784, 3785, 1, 0, 0, 0, 3785, 3791,
		1, 0, 0, 0, 3786, 3791, 3, 92, 46, 0, 3787, 3791, 3, 94, 47, 0, 3788, 3791,
		3, 108, 54, 0, 3789, 3791, 3, 110, 55, 0, 3790, 3566, 1, 0, 0, 0, 3790,
		3578, 1, 0, 0, 0, 3790, 3589, 1, 0, 0, 0, 3790, 3598, 1, 0, 0, 0, 3790,
		3610, 1, 0, 0, 0, 3790, 3619, 1, 0, 0, 0, 3790, 3643, 1, 0, 0, 0, 3790,
		3661, 1, 0, 0, 0, 3790, 3678, 1, 0, 0, 0, 3790, 3692, 1, 0, 0, 0, 3790,
		3702, 1, 0, 0, 0, 3790, 3704, 1, 0, 0, 0, 3790, 3709, 1, 0, 0, 0, 3790,
		3714, 1, 0, 0, 0, 3790, 3719, 1, 0, 0, 0, 3790, 3721, 1, 0, 0, 0, 3790,
		3728, 1, 0, 0, 0, 3790, 3735, 1, 0, 0, 0, 3790, 3753, 1, 0, 0, 0, 3790,
		3756, 1, 0, 0, 0, 3790, 3762, 1, 0, 0, 0, 3790, 3769, 1, 0, 0, 0, 3790,
		3786, 1, 0, 0, 0, 3790, 3787, 1, 0, 0, 0, 3790, 3788, 1, 0, 0, 0, 3790,
		3789, 1, 0, 0, 0, 3791, 91, 1, 0, 0, 0, 3792, 3793, 5, 101, 0, 0, 3793,
		3797, 5, 456, 0, 0, 3794, 3795, 5, 222, 0, 0, 3795, 3796, 5, 312, 0, 0,
		3796, 3798, 5, 170, 0, 0, 3797, 3794, 1, 0, 0, 0, 3797, 3798, 1, 0, 0,
		0, 3798, 3799, 1, 0, 0, 0, 3799, 3800, 3, 444, 222, 0, 3800, 3801, 3, 96,
		48, 0, 3801, 3812, 1, 0, 0, 0, 3802, 3803, 5, 101, 0, 0, 3803, 3805, 5,
		322, 0, 0, 3804, 3802, 1, 0, 0, 0, 3804, 3805, 1, 0, 0, 0, 3805, 3806,
		1, 0, 0, 0, 3806, 3807, 5, 383, 0, 0, 3807, 3808, 5, 456, 0, 0, 3808, 3809,
		3, 444, 222, 0, 3809, 3810, 3, 96, 48, 0, 3810, 3812, 1, 0, 0, 0, 3811,
		3792, 1, 0, 0, 0, 3811, 3804, 1, 0, 0, 0, 3812, 93, 1, 0, 0, 0, 3813, 3814,
		5, 101, 0, 0, 3814, 3818, 5, 54, 0, 0, 3815, 3816, 5, 222, 0, 0, 3816,
		3817, 5, 312, 0, 0, 3817, 3819, 5, 170, 0, 0, 3818, 3815, 1, 0, 0, 0, 3818,
		3819, 1, 0, 0, 0, 3819, 3820, 1, 0, 0, 0, 3820, 3821, 3, 444, 222, 0, 3821,
		3822, 3, 98, 49, 0, 3822, 3833, 1, 0, 0, 0, 3823, 3824, 5, 101, 0, 0, 3824,
		3826, 5, 322, 0, 0, 3825, 3823, 1, 0, 0, 0, 3825, 3826, 1, 0, 0, 0, 3826,
		3827, 1, 0, 0, 0, 3827, 3828, 5, 383, 0, 0, 3828, 3829, 5, 54, 0, 0, 3829,
		3830, 3, 444, 222, 0, 3830, 3831, 3, 98, 49, 0, 3831, 3833, 1, 0, 0, 0,
		3832, 3813, 1, 0, 0, 0, 3832, 3825, 1, 0, 0, 0, 3833, 95, 1, 0, 0, 0, 3834,
		3835, 5, 29, 0, 0, 3835, 3836, 5, 316, 0, 0, 3836, 3837, 5, 503, 0, 0,
		3837, 3839, 5, 549, 0, 0, 3838, 3834, 1, 0, 0, 0, 3838, 3839, 1, 0, 0,
		0, 3839, 3841, 1, 0, 0, 0, 3840, 3842, 3, 100, 50, 0, 3841, 3840, 1, 0,
		0, 0, 3841, 3842, 1, 0, 0, 0, 3842, 97, 1, 0, 0, 0, 3843, 3844, 5, 29,
		0, 0, 3844, 3845, 5, 316, 0, 0, 3845, 3846, 5, 503, 0, 0, 3846, 3848, 5,
		549, 0, 0, 3847, 3843, 1, 0, 0, 0, 3847, 3848, 1, 0, 0, 0, 3848, 3850,
		1, 0, 0, 0, 3849, 3851, 3, 100, 50, 0, 3850, 3849, 1, 0, 0, 0, 3850, 3851,
		1, 0, 0, 0, 3851, 3853, 1, 0, 0, 0, 3852, 3854, 3, 102, 51, 0, 3853, 3852,
		1, 0, 0, 0, 3853, 3854, 1, 0, 0, 0, 3854, 99, 1, 0, 0, 0, 3855, 3856, 5,
		394, 0, 0, 3856, 3857, 3, 106, 53, 0, 3857, 101, 1, 0, 0, 0, 3858, 3859,
		5, 512, 0, 0, 3859, 3860, 5, 428, 0, 0, 3860, 3861, 5, 395, 0, 0, 3861,
		3873, 3, 104, 52, 0, 3862, 3863, 5, 512, 0, 0, 3863, 3864, 5, 428, 0, 0,
		3864, 3865, 5, 395, 0, 0, 3865, 3873, 3, 106, 53, 0, 3866, 3867, 5, 512,
		0, 0, 3867, 3868, 5, 428, 0, 0, 3868, 3869, 5, 395, 0, 0, 3869, 3870, 3,
		104, 52, 0, 3870, 3871, 3, 106, 53, 0, 3871, 3873, 1, 0, 0, 0, 3872, 3858,
		1, 0, 0, 0, 3872, 3862, 1, 0, 0, 0, 3872, 3866, 1, 0, 0, 0, 3873, 103,
		1, 0, 0, 0, 3874, 3875, 5, 549, 0, 0, 3875, 3876, 5, 429, 0, 0, 3876, 105,
		1, 0, 0, 0, 3877, 3878, 5, 549, 0, 0, 3878, 3879, 7, 22, 0, 0, 3879, 107,
		1, 0, 0, 0, 3880, 3881, 5, 147, 0, 0, 3881, 3884, 5, 54, 0, 0, 3882, 3883,
		5, 222, 0, 0, 3883, 3885, 5, 170, 0, 0, 3884, 3882, 1, 0, 0, 0, 3884, 3885,
		1, 0, 0, 0, 3885, 3886, 1, 0, 0, 0, 3886, 3887, 3, 444, 222, 0, 3887, 109,
		1, 0, 0, 0, 3888, 3889, 5, 147, 0, 0, 3889, 3892, 5, 456, 0, 0, 3890, 3891,
		5, 222, 0, 0, 3891, 3893, 5, 170, 0, 0, 3892, 3890, 1, 0, 0, 0, 3892, 3893,
		1, 0, 0, 0, 3893, 3894, 1, 0, 0, 0, 3894, 3895, 3, 444, 222, 0, 3895, 111,
		1, 0, 0, 0, 3896, 3900, 5, 184, 0, 0, 3897, 3898, 5, 16, 0, 0, 3898, 3900,
		3, 444, 222, 0, 3899, 3896, 1, 0, 0, 0, 3899, 3897, 1, 0, 0, 0, 3900, 113,
		1, 0, 0, 0, 3901, 3902, 7, 23, 0, 0, 3902, 3903, 3, 444, 222, 0, 3903,
		115, 1, 0, 0, 0, 3904, 3905, 5, 193, 0, 0, 3905, 3906, 3, 444, 222, 0,
		3906, 117, 1, 0, 0, 0, 3907, 3909, 5, 424, 0, 0, 3908, 3910, 5, 33, 0,
		0, 3909, 3908, 1, 0, 0, 0, 3909, 3910, 1, 0, 0, 0, 3910, 3911, 1, 0, 0,
		0, 3911, 3914, 5, 22, 0, 0, 3912, 3915, 5, 549, 0, 0, 3913, 3915, 3, 328,
		164, 0, 3914, 3912, 1, 0, 0, 0, 3914, 3913, 1, 0, 0, 0, 3914, 3915, 1,
		0, 0, 0, 3915, 3921, 1, 0, 0, 0, 3916, 3917, 5, 510, 0, 0, 3917, 3918,
		3, 444, 222, 0, 3918, 3919, 5, 518, 0, 0, 3919, 3920, 5, 544, 0, 0, 3920,
		3922, 1, 0, 0, 0, 3921, 3916, 1, 0, 0, 0, 3921, 3922, 1, 0, 0, 0, 3922,
		4048, 1, 0, 0, 0, 3923, 3924, 5, 424, 0, 0, 3924, 3925, 5, 364, 0, 0, 3925,
		3926, 5, 22, 0, 0, 3926, 3928, 5, 249, 0, 0, 3927, 3929, 3, 328, 164, 0,
		3928, 3927, 1, 0, 0, 0, 3928, 3929, 1, 0, 0, 0, 3929, 3935, 1, 0, 0, 0,
		3930, 3931, 5, 510, 0, 0, 3931, 3932, 3, 444, 222, 0, 3932, 3933, 5, 518,
		0, 0, 3933, 3934, 5, 544, 0, 0, 3934, 3936, 1, 0, 0, 0, 3935, 3930, 1,
		0, 0, 0, 3935, 3936, 1, 0, 0, 0, 3936, 4048, 1, 0, 0, 0, 3937, 3938, 5,
		424, 0, 0, 3938, 3939, 5, 81, 0, 0, 3939, 3940, 5, 213, 0, 0, 3940, 3941,
		3, 328, 164, 0, 3941, 3942, 3, 306, 153, 0, 3942, 4048, 1, 0, 0, 0, 3943,
		3944, 5, 22, 0, 0, 3944, 3945, 5, 113, 0, 0, 3945, 3950, 3, 328, 164, 0,
		3946, 3947, 5, 512, 0, 0, 3947, 3949, 3, 122, 61, 0, 3948, 3946, 1, 0,
		0, 0, 3949, 3952, 1, 0, 0, 0, 3950, 3948, 1, 0, 0, 0, 3950, 3951, 1, 0,
		0, 0, 3951, 3954, 1, 0, 0, 0, 3952, 3950, 1, 0, 0, 0, 3953, 3955, 3, 316,
		158, 0, 3954, 3953, 1, 0, 0, 0, 3954, 3955, 1, 0, 0, 0, 3955, 4048, 1,
		0, 0, 0, 3956, 3957, 5, 22, 0, 0, 3957, 3958, 5, 451, 0, 0, 3958, 3960,
		3, 328, 164, 0, 3959, 3961, 3, 162, 81, 0, 3960, 3959, 1, 0, 0, 0, 3960,
		3961, 1, 0, 0, 0, 3961, 3963, 1, 0, 0, 0, 3962, 3964, 3, 306, 153, 0, 3963,
		3962, 1, 0, 0, 0, 3963, 3964, 1, 0, 0, 0, 3964, 3969, 1, 0, 0, 0, 3965,
		3966, 5, 512, 0, 0, 3966, 3968, 3, 122, 61, 0, 3967, 3965, 1, 0, 0, 0,
		3968, 3971, 1, 0, 0, 0, 3969, 3967, 1, 0, 0, 0, 3969, 3970, 1, 0, 0, 0,
		3970, 3973, 1, 0, 0, 0, 3971, 3969, 1, 0, 0, 0, 3972, 3974, 3, 316, 158,
		0, 3973, 3972, 1, 0, 0, 0, 3973, 3974, 1, 0, 0, 0, 3974, 4048, 1, 0, 0,
		0, 3975, 3976, 5, 21, 0, 0, 3976, 3977, 5, 451, 0, 0, 3977, 3978, 3, 328,
		164, 0, 3978, 3979, 5, 420, 0, 0, 3979, 3980, 5, 438, 0, 0, 3980, 3981,
		5, 2, 0, 0, 3981, 3982, 3, 318, 159, 0, 3982, 3984, 5, 3, 0, 0, 3983, 3985,
		3, 162, 81, 0, 3984, 3983, 1, 0, 0, 0, 3984, 3985, 1, 0, 0, 0, 3985, 4048,
		1, 0, 0, 0, 3986, 3987, 5, 21, 0, 0, 3987, 3988, 5, 451, 0, 0, 3988, 3991,
		3, 328, 164, 0, 3989, 3990, 5, 227, 0, 0, 3990, 3992, 3, 444, 222, 0, 3991,
		3989, 1, 0, 0, 0, 3991, 3992, 1, 0, 0, 0, 3992, 3993, 1, 0, 0, 0, 3993,
		3994, 5, 299, 0, 0, 3994, 3995, 5, 81, 0, 0, 3995, 3996, 3, 444, 222, 0,
		3996, 3997, 5, 420, 0, 0, 3997, 3998, 5, 438, 0, 0, 3998, 3999, 5, 2, 0,
		0, 3999, 4000, 3, 318, 159, 0, 4000, 4002, 5, 3, 0, 0, 4001, 4003, 3, 162,
		81, 0, 4002, 4001, 1, 0, 0, 0, 4002, 4003, 1, 0, 0, 0, 4003, 4048, 1, 0,
		0, 0, 4004, 4005, 5, 424, 0, 0, 4005, 4006, 5, 227, 0, 0, 4006, 4007, 5,
		438, 0, 0, 4007, 4008, 3, 328, 164, 0, 4008, 4009, 3, 444, 222, 0, 4009,
		4048, 1, 0, 0, 0, 4010, 4011, 5, 147, 0, 0, 4011, 4012, 5, 438, 0, 0, 4012,
		4014, 3, 328, 164, 0, 4013, 4015, 3, 306, 153, 0, 4014, 4013, 1, 0, 0,
		0, 4014, 4015, 1, 0, 0, 0, 4015, 4017, 1, 0, 0, 0, 4016, 4018, 3, 162,
		81, 0, 4017, 4016, 1, 0, 0, 0, 4017, 4018, 1, 0, 0, 0, 4018, 4048, 1, 0,
		0, 0, 4019, 4020, 5, 147, 0, 0, 4020, 4021, 5, 63, 0, 0, 4021, 4022, 5,
		438, 0, 0, 4022, 4048, 3, 328, 164, 0, 4023, 4024, 5, 147, 0, 0, 4024,
		4025, 5, 171, 0, 0, 4025, 4048, 5, 438, 0, 0, 4026, 4027, 5, 255, 0, 0,
		4027, 4028, 5, 22, 0, 0, 4028, 4048, 5, 549, 0, 0, 4029, 4030, 5, 147,
		0, 0, 4030, 4031, 5, 22, 0, 0, 4031, 4032, 5, 248, 0, 0, 4032, 4048, 5,
		549, 0, 0, 4033, 4034, 5, 424, 0, 0, 4034, 4035, 5, 451, 0, 0, 4035, 4036,
		5, 438, 0, 0, 4036, 4038, 3, 328, 164, 0, 4037, 4039, 3, 162, 81, 0, 4038,
		4037, 1, 0, 0, 0, 4038, 4039, 1, 0, 0, 0, 4039, 4041, 1, 0, 0, 0, 4040,
		4042, 3, 306, 153, 0, 4041, 4040, 1, 0, 0, 0, 4041, 4042, 1, 0, 0, 0, 4042,
		4048, 1, 0, 0, 0, 4043, 4044, 5, 424, 0, 0, 4044, 4045, 5, 451, 0, 0, 4045,
		4046, 5, 438, 0, 0, 4046, 4048, 5, 549, 0, 0, 4047, 3907, 1, 0, 0, 0, 4047,
		3923, 1, 0, 0, 0, 4047, 3937, 1, 0, 0, 0, 4047, 3943, 1, 0, 0, 0, 4047,
		3956, 1, 0, 0, 0, 4047, 3975, 1, 0, 0, 0, 4047, 3986, 1, 0, 0, 0, 4047,
		4004, 1, 0, 0, 0, 4047, 4010, 1, 0, 0, 0, 4047, 4019, 1, 0, 0, 0, 4047,
		4023, 1, 0, 0, 0, 4047, 4026, 1, 0, 0, 0, 4047, 4029, 1, 0, 0, 0, 4047,
		4033, 1, 0, 0, 0, 4047, 4043, 1, 0, 0, 0, 4048, 119, 1, 0, 0, 0, 4049,
		4050, 5, 424, 0, 0, 4050, 4052, 5, 81, 0, 0, 4051, 4053, 5, 63, 0, 0, 4052,
		4051, 1, 0, 0, 0, 4052, 4053, 1, 0, 0, 0, 4053, 4054, 1, 0, 0, 0, 4054,
		4055, 5, 438, 0, 0, 4055, 4057, 3, 328, 164, 0, 4056, 4058, 3, 306, 153,
		0, 4057, 4056, 1, 0, 0, 0, 4057, 4058, 1, 0, 0, 0, 4058, 4060, 1, 0, 0,
		0, 4059, 4061, 3, 162, 81, 0, 4060, 4059, 1, 0, 0, 0, 4060, 4061, 1, 0,
		0, 0, 4061, 4068, 1, 0, 0, 0, 4062, 4063, 5, 424, 0, 0, 4063, 4064, 5,
		22, 0, 0, 4064, 4065, 5, 457, 0, 0, 4065, 4066, 5, 439, 0, 0, 4066, 4068,
		5, 549, 0, 0, 4067, 4049, 1, 0, 0, 0, 4067, 4062, 1, 0, 0, 0, 4068, 121,
		1, 0, 0, 0, 4069, 4088, 5, 449, 0, 0, 4070, 4088, 5, 226, 0, 0, 4071, 4088,
		5, 196, 0, 0, 4072, 4088, 5, 432, 0, 0, 4073, 4088, 5, 213, 0, 0, 4074,
		4079, 5, 409, 0, 0, 4075, 4076, 5, 407, 0, 0, 4076, 4080, 5, 549, 0, 0,
		4077, 4078, 5, 339, 0, 0, 4078, 4080, 5, 549, 0, 0, 4079, 4075, 1, 0, 0,
		0, 4079, 4077, 1, 0, 0, 0, 4080, 4088, 1, 0, 0, 0, 4081, 4082, 5, 57, 0,
		0, 4082, 4088, 5, 549, 0, 0, 4083, 4084, 5, 340, 0, 0, 4084, 4088, 5, 549,
		0, 0, 4085, 4086, 5, 103, 0, 0, 4086, 4088, 5, 544, 0, 0, 4087, 4069, 1,
		0, 0, 0, 4087, 4070, 1, 0, 0, 0, 4087, 4071, 1, 0, 0, 0, 4087, 4072, 1,
		0, 0, 0, 4087, 4073, 1, 0, 0, 0, 4087, 4074, 1, 0, 0, 0, 4087, 4081, 1,
		0, 0, 0, 4087, 4083, 1, 0, 0, 0, 4087, 4085, 1, 0, 0, 0, 4088, 123, 1,
		0, 0, 0, 4089, 4094, 3, 126, 63, 0, 4090, 4091, 5, 4, 0, 0, 4091, 4093,
		3, 126, 63, 0, 4092, 4090, 1, 0, 0, 0, 4093, 4096, 1, 0, 0, 0, 4094, 4092,
		1, 0, 0, 0, 4094, 4095, 1, 0, 0, 0, 4095, 125, 1, 0, 0, 0, 4096, 4094,
		1, 0, 0, 0, 4097, 4098, 5, 422, 0, 0, 4098, 4104, 5, 544, 0, 0, 4099, 4101,
		3, 444, 222, 0, 4100, 4102, 5, 544, 0, 0, 4101, 4100, 1, 0, 0, 0, 4101,
		4102, 1, 0, 0, 0, 4102, 4104, 1, 0, 0, 0, 4103, 4097, 1, 0, 0, 0, 4103,
		4099, 1, 0, 0, 0, 4104, 127, 1, 0, 0, 0, 4105, 4110, 3, 130, 65, 0, 4106,
		4107, 5, 4, 0, 0, 4107, 4109, 3, 130, 65, 0, 4108, 4106, 1, 0, 0, 0, 4109,
		4112, 1, 0, 0, 0, 4110, 4108, 1, 0, 0, 0, 4110, 4111, 1, 0, 0, 0, 4111,
		129, 1, 0, 0, 0, 4112, 4110, 1, 0, 0, 0, 4113, 4114, 3, 444, 222, 0, 4114,
		4117, 3, 412, 206, 0, 4115, 4118, 3, 450, 225, 0, 4116, 4118, 5, 544, 0,
		0, 4117, 4115, 1, 0, 0, 0, 4117, 4116, 1, 0, 0, 0, 4118, 131, 1, 0, 0,
		0, 4119, 4121, 7, 24, 0, 0, 4120, 4122, 3, 444, 222, 0, 4121, 4120, 1,
		0, 0, 0, 4121, 4122, 1, 0, 0, 0, 4122, 4123, 1, 0, 0, 0, 4123, 4124, 5,
		318, 0, 0, 4124, 4125, 5, 275, 0, 0, 4125, 4127, 5, 544, 0, 0, 4126, 4128,
		3, 316, 158, 0, 4127, 4126, 1, 0, 0, 0, 4127, 4128, 1, 0, 0, 0, 4128, 133,
		1, 0, 0, 0, 4129, 4132, 5, 334, 0, 0, 4130, 4133, 5, 127, 0, 0, 4131, 4133,
		5, 549, 0, 0, 4132, 4130, 1, 0, 0, 0, 4132, 4131, 1, 0, 0, 0, 4133, 4135,
		1, 0, 0, 0, 4134, 4129, 1, 0, 0, 0, 4134, 4135, 1, 0, 0, 0, 4135, 4144,
		1, 0, 0, 0, 4136, 4142, 5, 333, 0, 0, 4137, 4143, 5, 127, 0, 0, 4138, 4143,
		5, 306, 0, 0, 4139, 4140, 5, 237, 0, 0, 4140, 4141, 5, 549, 0, 0, 4141,
		4143, 7, 25, 0, 0, 4142, 4137, 1, 0, 0, 0, 4142, 4138, 1, 0, 0, 0, 4142,
		4139, 1, 0, 0, 0, 4143, 4145, 1, 0, 0, 0, 4144, 4136, 1, 0, 0, 0, 4144,
		4145, 1, 0, 0, 0, 4145, 4153, 1, 0, 0, 0, 4146, 4147, 5, 336, 0, 0, 4147,
		4151, 5, 237, 0, 0, 4148, 4152, 5, 127, 0, 0, 4149, 4150, 5, 549, 0, 0,
		4150, 4152, 5, 121, 0, 0, 4151, 4148, 1, 0, 0, 0, 4151, 4149, 1, 0, 0,
		0, 4152, 4154, 1, 0, 0, 0, 4153, 4146, 1, 0, 0, 0, 4153, 4154, 1, 0, 0,
		0, 4154, 4157, 1, 0, 0, 0, 4155, 4156, 5, 177, 0, 0, 4156, 4158, 5, 549,
		0, 0, 4157, 4155, 1, 0, 0, 0, 4157, 4158, 1, 0, 0, 0, 4158, 4165, 1, 0,
		0, 0, 4159, 4163, 5, 335, 0, 0, 4160, 4164, 5, 480, 0, 0, 4161, 4162, 5,
		549, 0, 0, 4162, 4164, 7, 25, 0, 0, 4163, 4160, 1, 0, 0, 0, 4163, 4161,
		1, 0, 0, 0, 4164, 4166, 1, 0, 0, 0, 4165, 4159, 1, 0, 0, 0, 4165, 4166,
		1, 0, 0, 0, 4166, 4168, 1, 0, 0, 0, 4167, 4169, 7, 26, 0, 0, 4168, 4167,
		1, 0, 0, 0, 4168, 4169, 1, 0, 0, 0, 4169, 135, 1, 0, 0, 0, 4170, 4177,
		5, 6, 0, 0, 4171, 4177, 3, 138, 69, 0, 4172, 4173, 3, 138, 69, 0, 4173,
		4174, 5, 4, 0, 0, 4174, 4175, 5, 6, 0, 0, 4175, 4177, 1, 0, 0, 0, 4176,
		4170, 1, 0, 0, 0, 4176, 4171, 1, 0, 0, 0, 4176, 4172, 1, 0, 0, 0, 4177,
		137, 1, 0, 0, 0, 4178, 4183, 3, 424, 212, 0, 4179, 4180, 5, 4, 0, 0, 4180,
		4182, 3, 424, 212, 0, 4181, 4179, 1, 0, 0, 0, 4182, 4185, 1, 0, 0, 0, 4183,
		4181, 1, 0, 0, 0, 4183, 4184, 1, 0, 0, 0, 4184, 139, 1, 0, 0, 0, 4185,
		4183, 1, 0, 0, 0, 4186, 4189, 5, 420, 0, 0, 4187, 4190, 3, 142, 71, 0,
		4188, 4190, 3, 144, 72, 0, 4189, 4187, 1, 0, 0, 0, 4189, 4188, 1, 0, 0,
		0, 4190, 4198, 1, 0, 0, 0, 4191, 4194, 5, 4, 0, 0, 4192, 4195, 3, 142,
		71, 0, 4193, 4195, 3, 144, 72, 0, 4194, 4192, 1, 0, 0, 0, 4194, 4193, 1,
		0, 0, 0, 4195, 4197, 1, 0, 0, 0, 4196, 4191, 1, 0, 0, 0, 4197, 4200, 1,
		0, 0, 0, 4198, 4196, 1, 0, 0, 0, 4198, 4199, 1, 0, 0, 0, 4199, 4233, 1,
		0, 0, 0, 4200, 4198, 1, 0, 0, 0, 4201, 4202, 5, 420, 0, 0, 4202, 4203,
		3, 444, 222, 0, 4203, 4204, 5, 29, 0, 0, 4204, 4205, 5, 127, 0, 0, 4205,
		4206, 5, 441, 0, 0, 4206, 4207, 5, 500, 0, 0, 4207, 4233, 1, 0, 0, 0, 4208,
		4209, 5, 420, 0, 0, 4209, 4212, 5, 360, 0, 0, 4210, 4211, 5, 188, 0, 0,
		4211, 4213, 3, 184, 92, 0, 4212, 4210, 1, 0, 0, 0, 4212, 4213, 1, 0, 0,
		0, 4213, 4214, 1, 0, 0, 0, 4214, 4233, 3, 318, 159, 0, 4215, 4217, 5, 420,
		0, 0, 4216, 4218, 3, 172, 86, 0, 4217, 4216, 1, 0, 0, 0, 4217, 4218, 1,
		0, 0, 0, 4218, 4219, 1, 0, 0, 0, 4219, 4230, 5, 470, 0, 0, 4220, 4231,
		3, 148, 74, 0, 4221, 4231, 3, 150, 75, 0, 4222, 4223, 3, 148, 74, 0, 4223,
		4224, 5, 4, 0, 0, 4224, 4225, 3, 150, 75, 0, 4225, 4231, 1, 0, 0, 0, 4226,
		4227, 3, 150, 75, 0, 4227, 4228, 5, 4, 0, 0, 4228, 4229, 3, 148, 74, 0,
		4229, 4231, 1, 0, 0, 0, 4230, 4220, 1, 0, 0, 0, 4230, 4221, 1, 0, 0, 0,
		4230, 4222, 1, 0, 0, 0, 4230, 4226, 1, 0, 0, 0, 4231, 4233, 1, 0, 0, 0,
		4232, 4186, 1, 0, 0, 0, 4232, 4201, 1, 0, 0, 0, 4232, 4208, 1, 0, 0, 0,
		4232, 4215, 1, 0, 0, 0, 4233, 141, 1, 0, 0, 0, 4234, 4235, 3, 172, 86,
		0, 4235, 4236, 3, 444, 222, 0, 4236, 4239, 5, 518, 0, 0, 4237, 4240, 3,
		372, 186, 0, 4238, 4240, 5, 127, 0, 0, 4239, 4237, 1, 0, 0, 0, 4239, 4238,
		1, 0, 0, 0, 4240, 143, 1, 0, 0, 0, 4241, 4242, 5, 303, 0, 0, 4242, 4243,
		5, 518, 0, 0, 4243, 4287, 3, 372, 186, 0, 4244, 4245, 5, 71, 0, 0, 4245,
		4248, 5, 420, 0, 0, 4246, 4248, 5, 72, 0, 0, 4247, 4244, 1, 0, 0, 0, 4247,
		4246, 1, 0, 0, 0, 4248, 4251, 1, 0, 0, 0, 4249, 4252, 3, 184, 92, 0, 4250,
		4252, 5, 127, 0, 0, 4251, 4249, 1, 0, 0, 0, 4251, 4250, 1, 0, 0, 0, 4252,
		4287, 1, 0, 0, 0, 4253, 4256, 5, 303, 0, 0, 4254, 4257, 3, 184, 92, 0,
		4255, 4257, 5, 127, 0, 0, 4256, 4254, 1, 0, 0, 0, 4256, 4255, 1, 0, 0,
		0, 4257, 4261, 1, 0, 0, 0, 4258, 4259, 5, 77, 0, 0, 4259, 4262, 3, 184,
		92, 0, 4260, 4262, 5, 127, 0, 0, 4261, 4258, 1, 0, 0, 0, 4261, 4260, 1,
		0, 0, 0, 4261, 4262, 1, 0, 0, 0, 4262, 4287, 1, 0, 0, 0, 4263, 4266, 5,
		332, 0, 0, 4264, 4265, 5, 188, 0, 0, 4265, 4267, 3, 192, 96, 0, 4266, 4264,
		1, 0, 0, 0, 4266, 4267, 1, 0, 0, 0, 4267, 4268, 1, 0, 0, 0, 4268, 4274,
		5, 518, 0, 0, 4269, 4275, 5, 544, 0, 0, 4270, 4271, 5, 332, 0, 0, 4271,
		4272, 5, 2, 0, 0, 4272, 4273, 5, 544, 0, 0, 4273, 4275, 5, 3, 0, 0, 4274,
		4269, 1, 0, 0, 0, 4274, 4270, 1, 0, 0, 0, 4275, 4287, 1, 0, 0, 0, 4276,
		4277, 5, 262, 0, 0, 4277, 4283, 5, 518, 0, 0, 4278, 4284, 5, 544, 0, 0,
		4279, 4280, 5, 332, 0, 0, 4280, 4281, 5, 2, 0, 0, 4281, 4282, 5, 544, 0,
		0, 4282, 4284, 5, 3, 0, 0, 4283, 4278, 1, 0, 0, 0, 4283, 4279, 1, 0, 0,
		0, 4284, 4287, 1, 0, 0, 0, 4285, 4287, 3, 146, 73, 0, 4286, 4241, 1, 0,
		0, 0, 4286, 4247, 1, 0, 0, 0, 4286, 4253, 1, 0, 0, 0, 4286, 4263, 1, 0,
		0, 0, 4286, 4276, 1, 0, 0, 0, 4286, 4285, 1, 0, 0, 0, 4287, 145, 1, 0,
		0, 0, 4288, 4292, 5, 543, 0, 0, 4289, 4290, 3, 172, 86, 0, 4290, 4291,
		5, 5, 0, 0, 4291, 4293, 1, 0, 0, 0, 4292, 4289, 1, 0, 0, 0, 4292, 4293,
		1, 0, 0, 0, 4293, 4295, 1, 0, 0, 0, 4294, 4288, 1, 0, 0, 0, 4294, 4295,
		1, 0, 0, 0, 4295, 4296, 1, 0, 0, 0, 4296, 4297, 3, 444, 222, 0, 4297, 4300,
		5, 518, 0, 0, 4298, 4301, 3, 372, 186, 0, 4299, 4301, 5, 127, 0, 0, 4300,
		4298, 1, 0, 0, 0, 4300, 4299, 1, 0, 0, 0, 4301, 4308, 1, 0, 0, 0, 4302,
		4303, 5, 542, 0, 0, 4303, 4304, 3, 444, 222, 0, 4304, 4305, 5, 518, 0,
		0, 4305, 4306, 3, 372, 186, 0, 4306, 4308, 1, 0, 0, 0, 4307, 4294, 1, 0,
		0, 0, 4307, 4302, 1, 0, 0, 0, 4308, 147, 1, 0, 0, 0, 4309, 4310, 5, 370,
		0, 0, 4310, 4311, 7, 27, 0, 0, 4311, 149, 1, 0, 0, 0, 4312, 4313, 5, 247,
		0, 0, 4313, 4321, 5, 265, 0, 0, 4314, 4315, 5, 370, 0, 0, 4315, 4322, 5,
		481, 0, 0, 4316, 4317, 5, 370, 0, 0, 4317, 4322, 5, 85, 0, 0, 4318, 4319,
		5, 382, 0, 0, 4319, 4322, 5, 370, 0, 0, 4320, 4322, 5, 417, 0, 0, 4321,
		4314, 1, 0, 0, 0, 4321, 4316, 1, 0, 0, 0, 4321, 4318, 1, 0, 0, 0, 4321,
		4320, 1, 0, 0, 0, 4322, 151, 1, 0, 0, 0, 4323, 4325, 5, 486, 0, 0, 4324,
		4326, 3, 172, 86, 0, 4325, 4324, 1, 0, 0, 0, 4325, 4326, 1, 0, 0, 0, 4326,
		4327, 1, 0, 0, 0, 4327, 4330, 5, 497, 0, 0, 4328, 4331, 5, 20, 0, 0, 4329,
		4331, 3, 444, 222, 0, 4330, 4328, 1, 0, 0, 0, 4330, 4329, 1, 0, 0, 0, 4331,
		4337, 1, 0, 0, 0, 4332, 4333, 5, 486, 0, 0, 4333, 4334, 5, 127, 0, 0, 4334,
		4335, 5, 441, 0, 0, 4335, 4337, 5, 500, 0, 0, 4336, 4323, 1, 0, 0, 0, 4336,
		4332, 1, 0, 0, 0, 4337, 153, 1, 0, 0, 0, 4338, 4339, 5, 448, 0, 0, 4339,
		4359, 3, 444, 222, 0, 4340, 4344, 5, 490, 0, 0, 4341, 4342, 3, 444, 222,
		0, 4342, 4343, 5, 5, 0, 0, 4343, 4345, 1, 0, 0, 0, 4344, 4341, 1, 0, 0,
		0, 4344, 4345, 1, 0, 0, 0, 4345, 4346, 1, 0, 0, 0, 4346, 4359, 3, 444,
		222, 0, 4347, 4354, 5, 490, 0, 0, 4348, 4349, 3, 444, 222, 0, 4349, 4350,
		5, 5, 0, 0, 4350, 4352, 1, 0, 0, 0, 4351, 4348, 1, 0, 0, 0, 4351, 4352,
		1, 0, 0, 0, 4352, 4353, 1, 0, 0, 0, 4353, 4355, 3, 444, 222, 0, 4354, 4351,
		1, 0, 0, 0, 4354, 4355, 1, 0, 0, 0, 4355, 4356, 1, 0, 0, 0, 4356, 4357,
		5, 542, 0, 0, 4357, 4359, 3, 444, 222, 0, 4358, 4338, 1, 0, 0, 0, 4358,
		4340, 1, 0, 0, 0, 4358, 4347, 1, 0, 0, 0, 4359, 155, 1, 0, 0, 0, 4360,
		4363, 5, 542, 0, 0, 4361, 4364, 3, 444, 222, 0, 4362, 4364, 5, 530, 0,
		0, 4363, 4361, 1, 0, 0, 0, 4363, 4362, 1, 0, 0, 0, 4364, 4368, 1, 0, 0,
		0, 4365, 4366, 5, 2, 0, 0, 4366, 4367, 5, 544, 0, 0, 4367, 4369, 5, 3,
		0, 0, 4368, 4365, 1, 0, 0, 0, 4368, 4369, 1, 0, 0, 0, 4369, 157, 1, 0,
		0, 0, 4370, 4371, 3, 198, 99, 0, 4371, 4372, 5, 197, 0, 0, 4372, 4373,
		3, 444, 222, 0, 4373, 4375, 5, 2, 0, 0, 4374, 4376, 3, 318, 159, 0, 4375,
		4374, 1, 0, 0, 0, 4375, 4376, 1, 0, 0, 0, 4376, 4377, 1, 0, 0, 0, 4377,
		4378, 5, 3, 0, 0, 4378, 4379, 3, 326, 163, 0, 4379, 4394, 1, 0, 0, 0, 4380,
		4381, 3, 198, 99, 0, 4381, 4382, 3, 328, 164, 0, 4382, 4383, 5, 20, 0,
		0, 4383, 4394, 1, 0, 0, 0, 4384, 4385, 3, 198, 99, 0, 4385, 4387, 3, 328,
		164, 0, 4386, 4388, 3, 408, 204, 0, 4387, 4386, 1, 0, 0, 0, 4387, 4388,
		1, 0, 0, 0, 4388, 4394, 1, 0, 0, 0, 4389, 4390, 3, 198, 99, 0, 4390, 4391,
		5, 136, 0, 0, 4391, 4392, 3, 328, 164, 0, 4392, 4394, 1, 0, 0, 0, 4393,
		4370, 1, 0, 0, 0, 4393, 4380, 1, 0, 0, 0, 4393, 4384, 1, 0, 0, 0, 4393,
		4389, 1, 0, 0, 0, 4394, 159, 1, 0, 0, 0, 4395, 4396, 5, 354, 0, 0, 4396,
		4397, 5, 253, 0, 0, 4397, 4408, 3, 306, 153, 0, 4398, 4399, 5, 484, 0,
		0, 4399, 4408, 3, 306, 153, 0, 4400, 4401, 5, 189, 0, 0, 4401, 4402, 5,
		253, 0, 0, 4402, 4403, 3, 306, 153, 0, 4403, 4404, 5, 377, 0, 0, 4404,
		4405, 3, 328, 164, 0, 4405, 4406, 3, 306, 153, 0, 4406, 4408, 1, 0, 0,
		0, 4407, 4395, 1, 0, 0, 0, 4407, 4398, 1, 0, 0, 0, 4407, 4400, 1, 0, 0,
		0, 4408, 161, 1, 0, 0, 0, 4409, 4411, 5, 459, 0, 0, 4410, 4409, 1, 0, 0,
		0, 4410, 4411, 1, 0, 0, 0, 4411, 4412, 1, 0, 0, 0, 4412, 4413, 7, 28, 0,
		0, 4413, 4424, 3, 306, 153, 0, 4414, 4416, 5, 459, 0, 0, 4415, 4414, 1,
		0, 0, 0, 4415, 4416, 1, 0, 0, 0, 4416, 4417, 1, 0, 0, 0, 4417, 4418, 5,
		330, 0, 0, 4418, 4424, 3, 440, 220, 0, 4419, 4420, 7, 28, 0, 0, 4420, 4421,
		5, 2, 0, 0, 4421, 4422, 5, 527, 0, 0, 4422, 4424, 5, 3, 0, 0, 4423, 4410,
		1, 0, 0, 0, 4423, 4415, 1, 0, 0, 0, 4423, 4419, 1, 0, 0, 0, 4424, 163,
		1, 0, 0, 0, 4425, 4427, 5, 33, 0, 0, 4426, 4425, 1, 0, 0, 0, 4426, 4427,
		1, 0, 0, 0, 4427, 4428, 1, 0, 0, 0, 4428, 4429, 5, 330, 0, 0, 4429, 4431,
		5, 61, 0, 0, 4430, 4432, 7, 29, 0, 0, 4431, 4430, 1, 0, 0, 0, 4431, 4432,
		1, 0, 0, 0, 4432, 4433, 1, 0, 0, 0, 4433, 4434, 3, 166, 83, 0, 4434, 4436,
		5, 2, 0, 0, 4435, 4437, 3, 342, 171, 0, 4436, 4435, 1, 0, 0, 0, 4436, 4437,
		1, 0, 0, 0, 4437, 4438, 1, 0, 0, 0, 4438, 4439, 5, 3, 0, 0, 4439, 165,
		1, 0, 0, 0, 4440, 4441, 5, 2, 0, 0, 4441, 4446, 3, 168, 84, 0, 4442, 4443,
		5, 4, 0, 0, 4443, 4445, 3, 168, 84, 0, 4444, 4442, 1, 0, 0, 0, 4445, 4448,
		1, 0, 0, 0, 4446, 4444, 1, 0, 0, 0, 4446, 4447, 1, 0, 0, 0, 4447, 4449,
		1, 0, 0, 0, 4448, 4446, 1, 0, 0, 0, 4449, 4450, 5, 3, 0, 0, 4450, 167,
		1, 0, 0, 0, 4451, 4454, 3, 444, 222, 0, 4452, 4454, 3, 392, 196, 0, 4453,
		4451, 1, 0, 0, 0, 4453, 4452, 1, 0, 0, 0, 4454, 169, 1, 0, 0, 0, 4455,
		4457, 5, 512, 0, 0, 4456, 4455, 1, 0, 0, 0, 4456, 4457, 1, 0, 0, 0, 4457,
		4458, 1, 0, 0, 0, 4458, 4460, 3, 206, 103, 0, 4459, 4456, 1, 0, 0, 0, 4459,
		4460, 1, 0, 0, 0, 4460, 4461, 1, 0, 0, 0, 4461, 4462, 5, 112, 0, 0, 4462,
		4463, 5, 229, 0, 0, 4463, 4464, 5, 2, 0, 0, 4464, 4469, 5, 544, 0, 0, 4465,
		4466, 5, 4, 0, 0, 4466, 4468, 5, 544, 0, 0, 4467, 4465, 1, 0, 0, 0, 4468,
		4471, 1, 0, 0, 0, 4469, 4467, 1, 0, 0, 0, 4469, 4470, 1, 0, 0, 0, 4470,
		4472, 1, 0, 0, 0, 4471, 4469, 1, 0, 0, 0, 4472, 4473, 5, 3, 0, 0, 4473,
		4474, 5, 238, 0, 0, 4474, 4475, 5, 451, 0, 0, 4475, 4477, 3, 444, 222,
		0, 4476, 4478, 3, 162, 81, 0, 4477, 4476, 1, 0, 0, 0, 4477, 4478, 1, 0,
		0, 0, 4478, 4483, 1, 0, 0, 0, 4479, 4480, 5, 82, 0, 0, 4480, 4481, 5, 460,
		0, 0, 4481, 4482, 5, 61, 0, 0, 4482, 4484, 5, 544, 0, 0, 4483, 4479, 1,
		0, 0, 0, 4483, 4484, 1, 0, 0, 0, 4484, 4489, 1, 0, 0, 0, 4485, 4486, 5,
		268, 0, 0, 4486, 4487, 5, 460, 0, 0, 4487, 4488, 5, 61, 0, 0, 4488, 4490,
		5, 544, 0, 0, 4489, 4485, 1, 0, 0, 0, 4489, 4490, 1, 0, 0, 0, 4490, 4494,
		1, 0, 0, 0, 4491, 4492, 5, 191, 0, 0, 4492, 4493, 5, 29, 0, 0, 4493, 4495,
		3, 184, 92, 0, 4494, 4491, 1, 0, 0, 0, 4494, 4495, 1, 0, 0, 0, 4495, 4499,
		1, 0, 0, 0, 4496, 4497, 5, 88, 0, 0, 4497, 4498, 5, 29, 0, 0, 4498, 4500,
		3, 184, 92, 0, 4499, 4496, 1, 0, 0, 0, 4499, 4500, 1, 0, 0, 0, 4500, 4502,
		1, 0, 0, 0, 4501, 4503, 3, 306, 153, 0, 4502, 4501, 1, 0, 0, 0, 4502, 4503,
		1, 0, 0, 0, 4503, 4505, 1, 0, 0, 0, 4504, 4506, 3, 214, 107, 0, 4505, 4504,
		1, 0, 0, 0, 4505, 4506, 1, 0, 0, 0, 4506, 4508, 1, 0, 0, 0, 4507, 4509,
		3, 216, 108, 0, 4508, 4507, 1, 0, 0, 0, 4508, 4509, 1, 0, 0, 0, 4509, 4511,
		1, 0, 0, 0, 4510, 4512, 3, 208, 104, 0, 4511, 4510, 1, 0, 0, 0, 4511, 4512,
		1, 0, 0, 0, 4512, 4514, 1, 0, 0, 0, 4513, 4515, 3, 250, 125, 0, 4514, 4513,
		1, 0, 0, 0, 4514, 4515, 1, 0, 0, 0, 4515, 4517, 1, 0, 0, 0, 4516, 4518,
		3, 210, 105, 0, 4517, 4516, 1, 0, 0, 0, 4517, 4518, 1, 0, 0, 0, 4518, 4520,
		1, 0, 0, 0, 4519, 4521, 3, 212, 106, 0, 4520, 4519, 1, 0, 0, 0, 4520, 4521,
		1, 0, 0, 0, 4521, 4523, 1, 0, 0, 0, 4522, 4524, 3, 316, 158, 0, 4523, 4522,
		1, 0, 0, 0, 4523, 4524, 1, 0, 0, 0, 4524, 4555, 1, 0, 0, 0, 4525, 4527,
		5, 512, 0, 0, 4526, 4525, 1, 0, 0, 0, 4526, 4527, 1, 0, 0, 0, 4527, 4528,
		1, 0, 0, 0, 4528, 4530, 3, 206, 103, 0, 4529, 4526, 1, 0, 0, 0, 4529, 4530,
		1, 0, 0, 0, 4530, 4531, 1, 0, 0, 0, 4531, 4532, 5, 112, 0, 0, 4532, 4533,
		5, 193, 0, 0, 4533, 4534, 5, 451, 0, 0, 4534, 4535, 3, 444, 222, 0, 4535,
		4536, 5, 238, 0, 0, 4536, 4537, 5, 451, 0, 0, 4537, 4540, 3, 444, 222,
		0, 4538, 4539, 5, 330, 0, 0, 4539, 4541, 3, 306, 153, 0, 4540, 4538, 1,
		0, 0, 0, 4540, 4541, 1, 0, 0, 0, 4541, 4543, 1, 0, 0, 0, 4542, 4544, 3,
		216, 108, 0, 4543, 4542, 1, 0, 0, 0, 4543, 4544, 1, 0, 0, 0, 4544, 4546,
		1, 0, 0, 0, 4545, 4547, 3, 250, 125, 0, 4546, 4545, 1, 0, 0, 0, 4546, 4547,
		1, 0, 0, 0, 4547, 4549, 1, 0, 0, 0, 4548, 4550, 3, 210, 105, 0, 4549, 4548,
		1, 0, 0, 0, 4549, 4550, 1, 0, 0, 0, 4550, 4552, 1, 0, 0, 0, 4551, 4553,
		3, 316, 158, 0, 4552, 4551, 1, 0, 0, 0, 4552, 4553, 1, 0, 0, 0, 4553, 4555,
		1, 0, 0, 0, 4554, 4459, 1, 0, 0, 0, 4554, 4529, 1, 0, 0, 0, 4555, 171,
		1, 0, 0, 0, 4556, 4557, 7, 30, 0, 0, 4557, 173, 1, 0, 0, 0, 4558, 4559,
		5, 58, 0, 0, 4559, 4560, 7, 31, 0, 0, 4560, 175, 1, 0, 0, 0, 4561, 4562,
		5, 318, 0, 0, 4562, 4569, 5, 279, 0, 0, 4563, 4564, 5, 318, 0, 0, 4564,
		4565, 5, 410, 0, 0, 4565, 4569, 3, 178, 89, 0, 4566, 4567, 5, 318, 0, 0,
		4567, 4569, 5, 84, 0, 0, 4568, 4561, 1, 0, 0, 0, 4568, 4563, 1, 0, 0, 0,
		4568, 4566, 1, 0, 0, 0, 4569, 177, 1, 0, 0, 0, 4570, 4571, 5, 166, 0, 0,
		4571, 4572, 5, 549, 0, 0, 4572, 4575, 3, 444, 222, 0, 4573, 4574, 5, 437,
		0, 0, 4574, 4576, 5, 544, 0, 0, 4575, 4573, 1, 0, 0, 0, 4575, 4576, 1,
		0, 0, 0, 4576, 179, 1, 0, 0, 0, 4577, 4578, 7, 32, 0, 0, 4578, 181, 1,
		0, 0, 0, 4579, 4582, 3, 444, 222, 0, 4580, 4582, 3, 392, 196, 0, 4581,
		4579, 1, 0, 0, 0, 4581, 4580, 1, 0, 0, 0, 4582, 183, 1, 0, 0, 0, 4583,
		4586, 3, 444, 222, 0, 4584, 4586, 5, 544, 0, 0, 4585, 4583, 1, 0, 0, 0,
		4585, 4584, 1, 0, 0, 0, 4586, 185, 1, 0, 0, 0, 4587, 4591, 3, 444, 222,
		0, 4588, 4591, 5, 544, 0, 0, 4589, 4591, 5, 527, 0, 0, 4590, 4587, 1, 0,
		0, 0, 4590, 4588, 1, 0, 0, 0, 4590, 4589, 1, 0, 0, 0, 4591, 187, 1, 0,
		0, 0, 4592, 4597, 3, 190, 95, 0, 4593, 4594, 5, 5, 0, 0, 4594, 4596, 3,
		190, 95, 0, 4595, 4593, 1, 0, 0, 0, 4596, 4599, 1, 0, 0, 0, 4597, 4595,
		1, 0, 0, 0, 4597, 4598, 1, 0, 0, 0, 4598, 189, 1, 0, 0, 0, 4599, 4597,
		1, 0, 0, 0, 4600, 4603, 3, 184, 92, 0, 4601, 4603, 5, 527, 0, 0, 4602,
		4600, 1, 0, 0, 0, 4602, 4601, 1, 0, 0, 0, 4603, 191, 1, 0, 0, 0, 4604,
		4613, 3, 184, 92, 0, 4605, 4611, 5, 542, 0, 0, 4606, 4612, 3, 184, 92,
		0, 4607, 4608, 5, 2, 0, 0, 4608, 4609, 3, 184, 92, 0, 4609, 4610, 5, 3,
		0, 0, 4610, 4612, 1, 0, 0, 0, 4611, 4606, 1, 0, 0, 0, 4611, 4607, 1, 0,
		0, 0, 4612, 4614, 1, 0, 0, 0, 4613, 4605, 1, 0, 0, 0, 4613, 4614, 1, 0,
		0, 0, 4614, 193, 1, 0, 0, 0, 4615, 4622, 3, 192, 96, 0, 4616, 4617, 5,
		221, 0, 0, 4617, 4619, 5, 61, 0, 0, 4618, 4620, 5, 332, 0, 0, 4619, 4618,
		1, 0, 0, 0, 4619, 4620, 1, 0, 0, 0, 4620, 4621, 1, 0, 0, 0, 4621, 4623,
		5, 544, 0, 0, 4622, 4616, 1, 0, 0, 0, 4622, 4623, 1, 0, 0, 0, 4623, 195,
		1, 0, 0, 0, 4624, 4626, 3, 198, 99, 0, 4625, 4627, 3, 200, 100, 0, 4626,
		4625, 1, 0, 0, 0, 4626, 4627, 1, 0, 0, 0, 4627, 4629, 1, 0, 0, 0, 4628,
		4630, 7, 33, 0, 0, 4629, 4628, 1, 0, 0, 0, 4629, 4630, 1, 0, 0, 0, 4630,
		4632, 1, 0, 0, 0, 4631, 4633, 5, 348, 0, 0, 4632, 4631, 1, 0, 0, 0, 4632,
		4633, 1, 0, 0, 0, 4633, 197, 1, 0, 0, 0, 4634, 4635, 7, 34, 0, 0, 4635,
		199, 1, 0, 0, 0, 4636, 4637, 7, 35, 0, 0, 4637, 201, 1, 0, 0, 0, 4638,
		4639, 5, 345, 0, 0, 4639, 4640, 5, 385, 0, 0, 4640, 4641, 3, 204, 102,
		0, 4641, 203, 1, 0, 0, 0, 4642, 4643, 5, 150, 0, 0, 4643, 4647, 3, 230,
		115, 0, 4644, 4645, 5, 346, 0, 0, 4645, 4647, 5, 544, 0, 0, 4646, 4642,
		1, 0, 0, 0, 4646, 4644, 1, 0, 0, 0, 4647, 205, 1, 0, 0, 0, 4648, 4649,
		7, 20, 0, 0, 4649, 207, 1, 0, 0, 0, 4650, 4651, 5, 352, 0, 0, 4651, 4652,
		5, 183, 0, 0, 4652, 4653, 3, 372, 186, 0, 4653, 209, 1, 0, 0, 0, 4654,
		4655, 5, 129, 0, 0, 4655, 4656, 5, 318, 0, 0, 4656, 4657, 3, 372, 186,
		0, 4657, 211, 1, 0, 0, 0, 4658, 4659, 5, 323, 0, 0, 4659, 4660, 5, 61,
		0, 0, 4660, 4661, 3, 444, 222, 0, 4661, 213, 1, 0, 0, 0, 4662, 4663, 5,
		82, 0, 0, 4663, 4664, 5, 193, 0, 0, 4664, 4665, 5, 337, 0, 0, 4665, 4666,
		5, 29, 0, 0, 4666, 4667, 3, 306, 153, 0, 4667, 215, 1, 0, 0, 0, 4668, 4669,
		5, 420, 0, 0, 4669, 4670, 5, 2, 0, 0, 4670, 4675, 3, 218, 109, 0, 4671,
		4672, 5, 4, 0, 0, 4672, 4674, 3, 218, 109, 0, 4673, 4671, 1, 0, 0, 0, 4674,
		4677, 1, 0, 0, 0, 4675, 4673, 1, 0, 0, 0, 4675, 4676, 1, 0, 0, 0, 4676,
		4678, 1, 0, 0, 0, 4677, 4675, 1, 0, 0, 0, 4678, 4679, 5, 3, 0, 0, 4679,
		217, 1, 0, 0, 0, 4680, 4681, 3, 444, 222, 0, 4681, 4682, 5, 518, 0, 0,
		4682, 4683, 3, 372, 186, 0, 4683, 219, 1, 0, 0, 0, 4684, 4713, 3, 222,
		111, 0, 4685, 4686, 5, 512, 0, 0, 4686, 4687, 5, 408, 0, 0, 4687, 4688,
		5, 2, 0, 0, 4688, 4689, 3, 318, 159, 0, 4689, 4690, 5, 3, 0, 0, 4690, 4713,
		1, 0, 0, 0, 4691, 4692, 5, 512, 0, 0, 4692, 4693, 5, 211, 0, 0, 4693, 4694,
		5, 2, 0, 0, 4694, 4695, 3, 318, 159, 0, 4695, 4696, 5, 3, 0, 0, 4696, 4713,
		1, 0, 0, 0, 4697, 4698, 5, 512, 0, 0, 4698, 4699, 5, 272, 0, 0, 4699, 4700,
		5, 2, 0, 0, 4700, 4701, 3, 318, 159, 0, 4701, 4702, 5, 3, 0, 0, 4702, 4713,
		1, 0, 0, 0, 4703, 4704, 5, 512, 0, 0, 4704, 4705, 5, 56, 0, 0, 4705, 4710,
		3, 184, 92, 0, 4706, 4707, 5, 2, 0, 0, 4707, 4708, 3, 318, 159, 0, 4708,
		4709, 5, 3, 0, 0, 4709, 4711, 1, 0, 0, 0, 4710, 4706, 1, 0, 0, 0, 4710,
		4711, 1, 0, 0, 0, 4711, 4713, 1, 0, 0, 0, 4712, 4684, 1, 0, 0, 0, 4712,
		4685, 1, 0, 0, 0, 4712, 4691, 1, 0, 0, 0, 4712, 4697, 1, 0, 0, 0, 4712,
		4703, 1, 0, 0, 0, 4713, 221, 1, 0, 0, 0, 4714, 4715, 5, 512, 0, 0, 4715,
		4716, 5, 389, 0, 0, 4716, 4721, 3, 184, 92, 0, 4717, 4718, 5, 2, 0, 0,
		4718, 4719, 3, 318, 159, 0, 4719, 4720, 5, 3, 0, 0, 4720, 4722, 1, 0, 0,
		0, 4721, 4717, 1, 0, 0, 0, 4721, 4722, 1, 0, 0, 0, 4722, 223, 1, 0, 0,
		0, 4723, 4725, 5, 112, 0, 0, 4724, 4726, 5, 272, 0, 0, 4725, 4724, 1, 0,
		0, 0, 4725, 4726, 1, 0, 0, 0, 4726, 4727, 1, 0, 0, 0, 4727, 4728, 5, 229,
		0, 0, 4728, 4729, 5, 544, 0, 0, 4729, 4730, 5, 238, 0, 0, 4730, 4731, 5,
		451, 0, 0, 4731, 4734, 3, 328, 164, 0, 4732, 4733, 5, 330, 0, 0, 4733,
		4735, 3, 306, 153, 0, 4734, 4732, 1, 0, 0, 0, 4734, 4735, 1, 0, 0, 0, 4735,
		4740, 1, 0, 0, 0, 4736, 4737, 5, 82, 0, 0, 4737, 4738, 5, 460, 0, 0, 4738,
		4739, 5, 61, 0, 0, 4739, 4741, 5, 544, 0, 0, 4740, 4736, 1, 0, 0, 0, 4740,
		4741, 1, 0, 0, 0, 4741, 4746, 1, 0, 0, 0, 4742, 4743, 5, 268, 0, 0, 4743,
		4744, 5, 460, 0, 0, 4744, 4745, 5, 61, 0, 0, 4745, 4747, 5, 544, 0, 0,
		4746, 4742, 1, 0, 0, 0, 4746, 4747, 1, 0, 0, 0, 4747, 4749, 1, 0, 0, 0,
		4748, 4750, 3, 226, 113, 0, 4749, 4748, 1, 0, 0, 0, 4749, 4750, 1, 0, 0,
		0, 4750, 4752, 1, 0, 0, 0, 4751, 4753, 3, 306, 153, 0, 4752, 4751, 1, 0,
		0, 0, 4752, 4753, 1, 0, 0, 0, 4753, 4755, 1, 0, 0, 0, 4754, 4756, 3, 216,
		108, 0, 4755, 4754, 1, 0, 0, 0, 4755, 4756, 1, 0, 0, 0, 4756, 4758, 1,
		0, 0, 0, 4757, 4759, 3, 316, 158, 0, 4758, 4757, 1, 0, 0, 0, 4758, 4759,
		1, 0, 0, 0, 4759, 225, 1, 0, 0, 0, 4760, 4761, 5, 223, 0, 0, 4761, 4762,
		5, 549, 0, 0, 4762, 4767, 5, 268, 0, 0, 4763, 4764, 5, 223, 0, 0, 4764,
		4765, 5, 549, 0, 0, 4765, 4767, 5, 407, 0, 0, 4766, 4760, 1, 0, 0, 0, 4766,
		4763, 1, 0, 0, 0, 4767, 227, 1, 0, 0, 0, 4768, 4769, 5, 238, 0, 0, 4769,
		4770, 5, 325, 0, 0, 4770, 4774, 3, 410, 205, 0, 4771, 4772, 5, 191, 0,
		0, 4772, 4773, 5, 29, 0, 0, 4773, 4775, 3, 444, 222, 0, 4774, 4771, 1,
		0, 0, 0, 4774, 4775, 1, 0, 0, 0, 4775, 4777, 1, 0, 0, 0, 4776, 4778, 3,
		316, 158, 0, 4777, 4776, 1, 0, 0, 0, 4777, 4778, 1, 0, 0, 0, 4778, 229,
		1, 0, 0, 0, 4779, 4781, 3, 240, 120, 0, 4780, 4779, 1, 0, 0, 0, 4780, 4781,
		1, 0, 0, 0, 4781, 4782, 1, 0, 0, 0, 4782, 4783, 3, 232, 116, 0, 4783, 4784,
		3, 292, 146, 0, 4784, 231, 1, 0, 0, 0, 4785, 4786, 6, 116, -1, 0, 4786,
		4787, 3, 236, 118, 0, 4787, 4802, 1, 0, 0, 0, 4788, 4789, 10, 2, 0, 0,
		4789, 4791, 5, 236, 0, 0, 4790, 4792, 3, 234, 117, 0, 4791, 4790, 1, 0,
		0, 0, 4791, 4792, 1, 0, 0, 0, 4792, 4793, 1, 0, 0, 0, 4793, 4801, 3, 232,
		116, 3, 4794, 4795, 10, 1, 0, 0, 4795, 4797, 7, 36, 0, 0, 4796, 4798, 3,
		234, 117, 0, 4797, 4796, 1, 0, 0, 0, 4797, 4798, 1, 0, 0, 0, 4798, 4799,
		1, 0, 0, 0, 4799, 4801, 3, 232, 116, 2, 4800, 4788, 1, 0, 0, 0, 4800, 4794,
		1, 0, 0, 0, 4801, 4804, 1, 0, 0, 0, 4802, 4800, 1, 0, 0, 0, 4802, 4803,
		1, 0, 0, 0, 4803, 233, 1, 0, 0, 0, 4804, 4802, 1, 0, 0, 0, 4805, 4806,
		7, 37, 0, 0, 4806, 235, 1, 0, 0, 0, 4807, 4814, 3, 238, 119, 0, 4808, 4809,
		5, 2, 0, 0, 4809, 4810, 3, 230, 115, 0, 4810, 4811, 5, 3, 0, 0, 4811, 4814,
		1, 0, 0, 0, 4812, 4814, 3, 366, 183, 0, 4813, 4807, 1, 0, 0, 0, 4813, 4808,
		1, 0, 0, 0, 4813, 4812, 1, 0, 0, 0, 4814, 237, 1, 0, 0, 0, 4815, 4817,
		3, 246, 123, 0, 4816, 4818, 3, 254, 127, 0, 4817, 4816, 1, 0, 0, 0, 4817,
		4818, 1, 0, 0, 0, 4818, 4820, 1, 0, 0, 0, 4819, 4821, 3, 252, 126, 0, 4820,
		4819, 1, 0, 0, 0, 4820, 4821, 1, 0, 0, 0, 4821, 4823, 1, 0, 0, 0, 4822,
		4824, 3, 250, 125, 0, 4823, 4822, 1, 0, 0, 0, 4823, 4824, 1, 0, 0, 0, 4824,
		4826, 1, 0, 0, 0, 4825, 4827, 3, 270, 135, 0, 4826, 4825, 1, 0, 0, 0, 4826,
		4827, 1, 0, 0, 0, 4827, 4829, 1, 0, 0, 0, 4828, 4830, 3, 276, 138, 0, 4829,
		4828, 1, 0, 0, 0, 4829, 4830, 1, 0, 0, 0, 4830, 4832, 1, 0, 0, 0, 4831,
		4833, 3, 278, 139, 0, 4832, 4831, 1, 0, 0, 0, 4832, 4833, 1, 0, 0, 0, 4833,
		4837, 1, 0, 0, 0, 4834, 4835, 4, 119, 2, 0, 4835, 4838, 3, 292, 146, 0,
		4836, 4838, 4, 119, 3, 0, 4837, 4834, 1, 0, 0, 0, 4837, 4836, 1, 0, 0,
		0, 4838, 239, 1, 0, 0, 0, 4839, 4840, 5, 512, 0, 0, 4840, 4845, 3, 242,
		121, 0, 4841, 4842, 5, 4, 0, 0, 4842, 4844, 3, 242, 121, 0, 4843, 4841,
		1, 0, 0, 0, 4844, 4847, 1, 0, 0, 0, 4845, 4843, 1, 0, 0, 0, 4845, 4846,
		1, 0, 0, 0, 4846, 241, 1, 0, 0, 0, 4847, 4845, 1, 0, 0, 0, 4848, 4850,
		3, 444, 222, 0, 4849, 4851, 3, 244, 122, 0, 4850, 4849, 1, 0, 0, 0, 4850,
		4851, 1, 0, 0, 0, 4851, 4852, 1, 0, 0, 0, 4852, 4853, 5, 29, 0, 0, 4853,
		4854, 5, 2, 0, 0, 4854, 4855, 3, 230, 115, 0, 4855, 4856, 5, 3, 0, 0, 4856,
		243, 1, 0, 0, 0, 4857, 4858, 5, 2, 0, 0, 4858, 4863, 3, 444, 222, 0, 4859,
		4860, 5, 4, 0, 0, 4860, 4862, 3, 444, 222, 0, 4861, 4859, 1, 0, 0, 0, 4862,
		4865, 1, 0, 0, 0, 4863, 4861, 1, 0, 0, 0, 4863, 4864, 1, 0, 0, 0, 4864,
		4866, 1, 0, 0, 0, 4865, 4863, 1, 0, 0, 0, 4866, 4867, 5, 3, 0, 0, 4867,
		245, 1, 0, 0, 0, 4868, 4870, 5, 415, 0, 0, 4869, 4871, 7, 37, 0, 0, 4870,
		4869, 1, 0, 0, 0, 4870, 4871, 1, 0, 0, 0, 4871, 4872, 1, 0, 0, 0, 4872,
		4873, 3, 248, 124, 0, 4873, 247, 1, 0, 0, 0, 4874, 4875, 3, 370, 185, 0,
		4875, 249, 1, 0, 0, 0, 4876, 4877, 5, 510, 0, 0, 4877, 4878, 3, 376, 188,
		0, 4878, 251, 1, 0, 0, 0, 4879, 4880, 5, 193, 0, 0, 4880, 4881, 3, 260,
		130, 0, 4881, 253, 1, 0, 0, 0, 4882, 4884, 3, 256, 128, 0, 4883, 4882,
		1, 0, 0, 0, 4883, 4884, 1, 0, 0, 0, 4884, 4885, 1, 0, 0, 0, 4885, 4888,
		5, 238, 0, 0, 4886, 4889, 3, 258, 129, 0, 4887, 4889, 3, 444, 222, 0, 4888,
		4886, 1, 0, 0, 0, 4888, 4887, 1, 0, 0, 0, 4889, 4897, 1, 0, 0, 0, 4890,
		4893, 5, 4, 0, 0, 4891, 4894, 3, 258, 129, 0, 4892, 4894, 3, 444, 222,
		0, 4893, 4891, 1, 0, 0, 0, 4893, 4892, 1, 0, 0, 0, 4894, 4896, 1, 0, 0,
		0, 4895, 4890, 1, 0, 0, 0, 4896, 4899, 1, 0, 0, 0, 4897, 4895, 1, 0, 0,
		0, 4897, 4898, 1, 0, 0, 0, 4898, 255, 1, 0, 0, 0, 4899, 4897, 1, 0, 0,
		0, 4900, 4901, 5, 60, 0, 0, 4901, 4902, 5, 79, 0, 0, 4902, 257, 1, 0, 0,
		0, 4903, 4904, 3, 444, 222, 0, 4904, 4905, 5, 2, 0, 0, 4905, 4906, 5, 549,
		0, 0, 4906, 4907, 5, 3, 0, 0, 4907, 259, 1, 0, 0, 0, 4908, 4913, 3, 262,
		131, 0, 4909, 4910, 5, 4, 0, 0, 4910, 4912, 3, 262, 131, 0, 4911, 4909,
		1, 0, 0, 0, 4912, 4915, 1, 0, 0, 0, 4913, 4911, 1, 0, 0, 0, 4913, 4914,
		1, 0, 0, 0, 4914, 261, 1, 0, 0, 0, 4915, 4913, 1, 0, 0, 0, 4916, 4920,
		3, 312, 156, 0, 4917, 4919, 3, 264, 132, 0, 4918, 4917, 1, 0, 0, 0, 4919,
		4922, 1, 0, 0, 0, 4920, 4918, 1, 0, 0, 0, 4920, 4921, 1, 0, 0, 0, 4921,
		263, 1, 0, 0, 0, 4922, 4920, 1, 0, 0, 0, 4923, 4924, 3, 302, 151, 0, 4924,
		4926, 5, 250, 0, 0, 4925, 4927, 3, 266, 133, 0, 4926, 4925, 1, 0, 0, 0,
		4926, 4927, 1, 0, 0, 0, 4927, 4928, 1, 0, 0, 0, 4928, 4930, 3, 312, 156,
		0, 4929, 4931, 3, 304, 152, 0, 4930, 4929, 1, 0, 0, 0, 4930, 4931, 1, 0,
		0, 0, 4931, 265, 1, 0, 0, 0, 4932, 4933, 5, 7, 0, 0, 4933, 4934, 3, 444,
		222, 0, 4934, 4935, 5, 8, 0, 0, 4935, 4941, 1, 0, 0, 0, 4936, 4937, 5,
		539, 0, 0, 4937, 4938, 3, 444, 222, 0, 4938, 4939, 5, 540, 0, 0, 4939,
		4941, 1, 0, 0, 0, 4940, 4932, 1, 0, 0, 0, 4940, 4936, 1, 0, 0, 0, 4941,
		267, 1, 0, 0, 0, 4942, 4943, 5, 7, 0, 0, 4943, 4948, 3, 444, 222, 0, 4944,
		4945, 5, 4, 0, 0, 4945, 4947, 3, 444, 222, 0, 4946, 4944, 1, 0, 0, 0, 4947,
		4950, 1, 0, 0, 0, 4948, 4946, 1, 0, 0, 0, 4948, 4949, 1, 0, 0, 0, 4949,
		4951, 1, 0, 0, 0, 4950, 4948, 1, 0, 0, 0, 4951, 4952, 5, 8, 0, 0, 4952,
		4965, 1, 0, 0, 0, 4953, 4954, 5, 539, 0, 0, 4954, 4959, 3, 444, 222, 0,
		4955, 4956, 5, 4, 0, 0, 4956, 4958, 3, 444, 222, 0, 4957, 4955, 1, 0, 0,
		0, 4958, 4961, 1, 0, 0, 0, 4959, 4957, 1, 0, 0, 0, 4959, 4960, 1, 0, 0,
		0, 4960, 4962, 1, 0, 0, 0, 4961, 4959, 1, 0, 0, 0, 4962, 4963, 5, 540,
		0, 0, 4963, 4965, 1, 0, 0, 0, 4964, 4942, 1, 0, 0, 0, 4964, 4953, 1, 0,
		0, 0, 4965, 269, 1, 0, 0, 0, 4966, 4967, 5, 205, 0, 0, 4967, 4968, 5, 61,
		0, 0, 4968, 4969, 3, 272, 136, 0, 4969, 271, 1, 0, 0, 0, 4970, 4971, 5,
		404, 0, 0, 4971, 4980, 5, 2, 0, 0, 4972, 4977, 3, 372, 186, 0, 4973, 4974,
		5, 4, 0, 0, 4974, 4976, 3, 372, 186, 0, 4975, 4973, 1, 0, 0, 0, 4976, 4979,
		1, 0, 0, 0, 4977, 4975, 1, 0, 0, 0, 4977, 4978, 1, 0, 0, 0, 4978, 4981,
		1, 0, 0, 0, 4979, 4977, 1, 0, 0, 0, 4980, 4972, 1, 0, 0, 0, 4980, 4981,
		1, 0, 0, 0, 4981, 4982, 1, 0, 0, 0, 4982, 5022, 5, 3, 0, 0, 4983, 4984,
		5, 105, 0, 0, 4984, 4993, 5, 2, 0, 0, 4985, 4990, 3, 372, 186, 0, 4986,
		4987, 5, 4, 0, 0, 4987, 4989, 3, 372, 186, 0, 4988, 4986, 1, 0, 0, 0, 4989,
		4992, 1, 0, 0, 0, 4990, 4988, 1, 0, 0, 0, 4990, 4991, 1, 0, 0, 0, 4991,
		4994, 1, 0, 0, 0, 4992, 4990, 1, 0, 0, 0, 4993, 4985, 1, 0, 0, 0, 4993,
		4994, 1, 0, 0, 0, 4994, 4995, 1, 0, 0, 0, 4995, 5022, 5, 3, 0, 0, 4996,
		4997, 5, 206, 0, 0, 4997, 4998, 5, 421, 0, 0, 4998, 4999, 5, 2, 0, 0, 4999,
		5004, 3, 274, 137, 0, 5000, 5001, 5, 4, 0, 0, 5001, 5003, 3, 274, 137,
		0, 5002, 5000, 1, 0, 0, 0, 5003, 5006, 1, 0, 0, 0, 5004, 5002, 1, 0, 0,
		0, 5004, 5005, 1, 0, 0, 0, 5005, 5007, 1, 0, 0, 0, 5006, 5004, 1, 0, 0,
		0, 5007, 5008, 5, 3, 0, 0, 5008, 5022, 1, 0, 0, 0, 5009, 5014, 3, 372,
		186, 0, 5010, 5011, 5, 4, 0, 0, 5011, 5013, 3, 372, 186, 0, 5012, 5010,
		1, 0, 0, 0, 5013, 5016, 1, 0, 0, 0, 5014, 5012, 1, 0, 0, 0, 5014, 5015,
		1, 0, 0, 0, 5015, 5019, 1, 0, 0, 0, 5016, 5014, 1, 0, 0, 0, 5017, 5018,
		5, 512, 0, 0, 5018, 5020, 5, 404, 0, 0, 5019, 5017, 1, 0, 0, 0, 5019, 5020,
		1, 0, 0, 0, 5020, 5022, 1, 0, 0, 0, 5021, 4970, 1, 0, 0, 0, 5021, 4983,
		1, 0, 0, 0, 5021, 4996, 1, 0, 0, 0, 5021, 5009, 1, 0, 0, 0, 5022, 273,
		1, 0, 0, 0, 5023, 5032, 5, 2, 0, 0, 5024, 5029, 3, 372, 186, 0, 5025, 5026,
		5, 4, 0, 0, 5026, 5028, 3, 372, 186, 0, 5027, 5025, 1, 0, 0, 0, 5028, 5031,
		1, 0, 0, 0, 5029, 5027, 1, 0, 0, 0, 5029, 5030, 1, 0, 0, 0, 5030, 5033,
		1, 0, 0, 0, 5031, 5029, 1, 0, 0, 0, 5032, 5024, 1, 0, 0, 0, 5032, 5033,
		1, 0, 0, 0, 5033, 5034, 1, 0, 0, 0, 5034, 5035, 5, 3, 0, 0, 5035, 275,
		1, 0, 0, 0, 5036, 5037, 5, 210, 0, 0, 5037, 5038, 3, 376, 188, 0, 5038,
		277, 1, 0, 0, 0, 5039, 5040, 5, 366, 0, 0, 5040, 5041, 3, 376, 188, 0,
		5041, 279, 1, 0, 0, 0, 5042, 5049, 3, 282, 141, 0, 5043, 5045, 5, 4, 0,
		0, 5044, 5043, 1, 0, 0, 0, 5044, 5045, 1, 0, 0, 0, 5045, 5046, 1, 0, 0,
		0, 5046, 5048, 3, 282, 141, 0, 5047, 5044, 1, 0, 0, 0, 5048, 5051, 1, 0,
		0, 0, 5049, 5047, 1, 0, 0, 0, 5049, 5050, 1, 0, 0, 0, 5050, 5052, 1, 0,
		0, 0, 5051, 5049, 1, 0, 0, 0, 5052, 5053, 5, 540, 0, 0, 5053, 281, 1, 0,
		0, 0, 5054, 5068, 3, 444, 222, 0, 5055, 5056, 5, 2, 0, 0, 5056, 5063, 3,
		284, 142, 0, 5057, 5059, 5, 4, 0, 0, 5058, 5057, 1, 0, 0, 0, 5058, 5059,
		1, 0, 0, 0, 5059, 5060, 1, 0, 0, 0, 5060, 5062, 3, 284, 142, 0, 5061, 5058,
		1, 0, 0, 0, 5062, 5065, 1, 0, 0, 0, 5063, 5061, 1, 0, 0, 0, 5063, 5064,
		1, 0, 0, 0, 5064, 5066, 1, 0, 0, 0, 5065, 5063, 1, 0, 0, 0, 5066, 5067,
		5, 3, 0, 0, 5067, 5069, 1, 0, 0, 0, 5068, 5055, 1, 0, 0, 0, 5068, 5069,
		1, 0, 0, 0, 5069, 5085, 1, 0, 0, 0, 5070, 5082, 7, 38, 0, 0, 5071, 5072,
		5, 2, 0, 0, 5072, 5077, 3, 328, 164, 0, 5073, 5074, 5, 4, 0, 0, 5074, 5076,
		3, 328, 164, 0, 5075, 5073, 1, 0, 0, 0, 5076, 5079, 1, 0, 0, 0, 5077, 5075,
		1, 0, 0, 0, 5077, 5078, 1, 0, 0, 0, 5078, 5080, 1, 0, 0, 0, 5079, 5077,
		1, 0, 0, 0, 5080, 5081, 5, 3, 0, 0, 5081, 5083, 1, 0, 0, 0, 5082, 5071,
		1, 0, 0, 0, 5082, 5083, 1, 0, 0, 0, 5083, 5085, 1, 0, 0, 0, 5084, 5054,
		1, 0, 0, 0, 5084, 5070, 1, 0, 0, 0, 5085, 283, 1, 0, 0, 0, 5086, 5092,
		3, 184, 92, 0, 5087, 5090, 5, 518, 0, 0, 5088, 5091, 3, 410, 205, 0, 5089,
		5091, 3, 444, 222, 0, 5090, 5088, 1, 0, 0, 0, 5090, 5089, 1, 0, 0, 0, 5091,
		5093, 1, 0, 0, 0, 5092, 5087, 1, 0, 0, 0, 5092, 5093, 1, 0, 0, 0, 5093,
		5096, 1, 0, 0, 0, 5094, 5096, 3, 410, 205, 0, 5095, 5086, 1, 0, 0, 0, 5095,
		5094, 1, 0, 0, 0, 5096, 285, 1, 0, 0, 0, 5097, 5098, 3, 328, 164, 0, 5098,
		5101, 5, 518, 0, 0, 5099, 5102, 3, 372, 186, 0, 5100, 5102, 5, 127, 0,
		0, 5101, 5099, 1, 0, 0, 0, 5101, 5100, 1, 0, 0, 0, 5102, 287, 1, 0, 0,
		0, 5103, 5108, 3, 286, 143, 0, 5104, 5105, 5, 4, 0, 0, 5105, 5107, 3, 286,
		143, 0, 5106, 5104, 1, 0, 0, 0, 5107, 5110, 1, 0, 0, 0, 5108, 5106, 1,
		0, 0, 0, 5108, 5109, 1, 0, 0, 0, 5109, 289, 1, 0, 0, 0, 5110, 5108, 1,
		0, 0, 0, 5111, 5112, 5, 260, 0, 0, 5112, 5113, 5, 504, 0, 0, 5113, 5114,
		3, 444, 222, 0, 5114, 5123, 5, 2, 0, 0, 5115, 5120, 3, 372, 186, 0, 5116,
		5117, 5, 4, 0, 0, 5117, 5119, 3, 372, 186, 0, 5118, 5116, 1, 0, 0, 0, 5119,
		5122, 1, 0, 0, 0, 5120, 5118, 1, 0, 0, 0, 5120, 5121, 1, 0, 0, 0, 5121,
		5124, 1, 0, 0, 0, 5122, 5120, 1, 0, 0, 0, 5123, 5115, 1, 0, 0, 0, 5123,
		5124, 1, 0, 0, 0, 5124, 5125, 1, 0, 0, 0, 5125, 5126, 5, 3, 0, 0, 5126,
		5127, 3, 444, 222, 0, 5127, 5128, 5, 29, 0, 0, 5128, 5133, 3, 444, 222,
		0, 5129, 5130, 5, 4, 0, 0, 5130, 5132, 3, 444, 222, 0, 5131, 5129, 1, 0,
		0, 0, 5132, 5135, 1, 0, 0, 0, 5133, 5131, 1, 0, 0, 0, 5133, 5134, 1, 0,
		0, 0, 5134, 291, 1, 0, 0, 0, 5135, 5133, 1, 0, 0, 0, 5136, 5138, 3, 294,
		147, 0, 5137, 5136, 1, 0, 0, 0, 5137, 5138, 1, 0, 0, 0, 5138, 5140, 1,
		0, 0, 0, 5139, 5141, 3, 298, 149, 0, 5140, 5139, 1, 0, 0, 0, 5140, 5141,
		1, 0, 0, 0, 5141, 293, 1, 0, 0, 0, 5142, 5143, 5, 323, 0, 0, 5143, 5144,
		5, 61, 0, 0, 5144, 5149, 3, 296, 148, 0, 5145, 5146, 5, 4, 0, 0, 5146,
		5148, 3, 296, 148, 0, 5147, 5145, 1, 0, 0, 0, 5148, 5151, 1, 0, 0, 0, 5149,
		5147, 1, 0, 0, 0, 5149, 5150, 1, 0, 0, 0, 5150, 295, 1, 0, 0, 0, 5151,
		5149, 1, 0, 0, 0, 5152, 5154, 3, 372, 186, 0, 5153, 5155, 7, 39, 0, 0,
		5154, 5153, 1, 0, 0, 0, 5154, 5155, 1, 0, 0, 0, 5155, 5158, 1, 0, 0, 0,
		5156, 5157, 5, 314, 0, 0, 5157, 5159, 7, 40, 0, 0, 5158, 5156, 1, 0, 0,
		0, 5158, 5159, 1, 0, 0, 0, 5159, 297, 1, 0, 0, 0, 5160, 5161, 5, 267, 0,
		0, 5161, 5171, 5, 549, 0, 0, 5162, 5163, 5, 267, 0, 0, 5163, 5164, 5, 549,
		0, 0, 5164, 5165, 5, 317, 0, 0, 5165, 5171, 5, 549, 0, 0, 5166, 5167, 5,
		267, 0, 0, 5167, 5168, 5, 549, 0, 0, 5168, 5169, 5, 4, 0, 0, 5169, 5171,
		5, 549, 0, 0, 5170, 5160, 1, 0, 0, 0, 5170, 5162, 1, 0, 0, 0, 5170, 5166,
		1, 0, 0, 0, 5171, 299, 1, 0, 0, 0, 5172, 5173, 5, 330, 0, 0, 5173, 5174,
		5, 61, 0, 0, 5174, 5179, 3, 372, 186, 0, 5175, 5176, 5, 4, 0, 0, 5176,
		5178, 3, 372, 186, 0, 5177, 5175, 1, 0, 0, 0, 5178, 5181, 1, 0, 0, 0, 5179,
		5177, 1, 0, 0, 0, 5179, 5180, 1, 0, 0, 0, 5180, 301, 1, 0, 0, 0, 5181,
		5179, 1, 0, 0, 0, 5182, 5184, 5, 230, 0, 0, 5183, 5182, 1, 0, 0, 0, 5183,
		5184, 1, 0, 0, 0, 5184, 5207, 1, 0, 0, 0, 5185, 5207, 5, 104, 0, 0, 5186,
		5188, 5, 263, 0, 0, 5187, 5189, 5, 324, 0, 0, 5188, 5187, 1, 0, 0, 0, 5188,
		5189, 1, 0, 0, 0, 5189, 5207, 1, 0, 0, 0, 5190, 5192, 5, 399, 0, 0, 5191,
		5193, 5, 324, 0, 0, 5192, 5191, 1, 0, 0, 0, 5192, 5193, 1, 0, 0, 0, 5193,
		5207, 1, 0, 0, 0, 5194, 5196, 5, 196, 0, 0, 5195, 5197, 5, 324, 0, 0, 5196,
		5195, 1, 0, 0, 0, 5196, 5197, 1, 0, 0, 0, 5197, 5207, 1, 0, 0, 0, 5198,
		5199, 5, 263, 0, 0, 5199, 5207, 5, 416, 0, 0, 5200, 5201, 5, 399, 0, 0,
		5201, 5207, 5, 416, 0, 0, 5202, 5203, 5, 263, 0, 0, 5203, 5207, 5, 26,
		0, 0, 5204, 5205, 5, 399, 0, 0, 5205, 5207, 5, 26, 0, 0, 5206, 5183, 1,
		0, 0, 0, 5206, 5185, 1, 0, 0, 0, 5206, 5186, 1, 0, 0, 0, 5206, 5190, 1,
		0, 0, 0, 5206, 5194, 1, 0, 0, 0, 5206, 5198, 1, 0, 0, 0, 5206, 5200, 1,
		0, 0, 0, 5206, 5202, 1, 0, 0, 0, 5206, 5204, 1, 0, 0, 0, 5207, 303, 1,
		0, 0, 0, 5208, 5209, 5, 318, 0, 0, 5209, 5213, 3, 376, 188, 0, 5210, 5211,
		5, 493, 0, 0, 5211, 5213, 3, 306, 153, 0, 5212, 5208, 1, 0, 0, 0, 5212,
		5210, 1, 0, 0, 0, 5213, 305, 1, 0, 0, 0, 5214, 5215, 5, 2, 0, 0, 5215,
		5216, 3, 308, 154, 0, 5216, 5217, 5, 3, 0, 0, 5217, 307, 1, 0, 0, 0, 5218,
		5223, 3, 440, 220, 0, 5219, 5220, 5, 4, 0, 0, 5220, 5222, 3, 440, 220,
		0, 5221, 5219, 1, 0, 0, 0, 5222, 5225, 1, 0, 0, 0, 5223, 5221, 1, 0, 0,
		0, 5223, 5224, 1, 0, 0, 0, 5224, 309, 1, 0, 0, 0, 5225, 5223, 1, 0, 0,
		0, 5226, 5227, 5, 542, 0, 0, 5227, 5228, 3, 444, 222, 0, 5228, 5231, 5,
		2, 0, 0, 5229, 5232, 3, 318, 159, 0, 5230, 5232, 3, 308, 154, 0, 5231,
		5229, 1, 0, 0, 0, 5231, 5230, 1, 0, 0, 0, 5231, 5232, 1, 0, 0, 0, 5232,
		5233, 1, 0, 0, 0, 5233, 5234, 5, 3, 0, 0, 5234, 311, 1, 0, 0, 0, 5235,
		5237, 3, 328, 164, 0, 5236, 5238, 3, 310, 155, 0, 5237, 5236, 1, 0, 0,
		0, 5237, 5238, 1, 0, 0, 0, 5238, 5240, 1, 0, 0, 0, 5239, 5241, 3, 314,
		157, 0, 5240, 5239, 1, 0, 0, 0, 5240, 5241, 1, 0, 0, 0, 5241, 5243, 1,
		0, 0, 0, 5242, 5244, 3, 438, 219, 0, 5243, 5242, 1, 0, 0, 0, 5243, 5244,
		1, 0, 0, 0, 5244, 5246, 1, 0, 0, 0, 5245, 5247, 3, 408, 204, 0, 5246, 5245,
		1, 0, 0, 0, 5246, 5247, 1, 0, 0, 0, 5247, 5249, 1, 0, 0, 0, 5248, 5250,
		3, 364, 182, 0, 5249, 5248, 1, 0, 0, 0, 5249, 5250, 1, 0, 0, 0, 5250, 5251,
		1, 0, 0, 0, 5251, 5253, 3, 326, 163, 0, 5252, 5254, 3, 434, 217, 0, 5253,
		5252, 1, 0, 0, 0, 5253, 5254, 1, 0, 0, 0, 5254, 5256, 1, 0, 0, 0, 5255,
		5257, 3, 268, 134, 0, 5256, 5255, 1, 0, 0, 0, 5256, 5257, 1, 0, 0, 0, 5257,
		5261, 1, 0, 0, 0, 5258, 5260, 3, 290, 145, 0, 5259, 5258, 1, 0, 0, 0, 5260,
		5263, 1, 0, 0, 0, 5261, 5259, 1, 0, 0, 0, 5261, 5262, 1, 0, 0, 0, 5262,
		5287, 1, 0, 0, 0, 5263, 5261, 1, 0, 0, 0, 5264, 5265, 5, 2, 0, 0, 5265,
		5266, 3, 230, 115, 0, 5266, 5267, 5, 3, 0, 0, 5267, 5271, 3, 326, 163,
		0, 5268, 5270, 3, 290, 145, 0, 5269, 5268, 1, 0, 0, 0, 5270, 5273, 1, 0,
		0, 0, 5271, 5269, 1, 0, 0, 0, 5271, 5272, 1, 0, 0, 0, 5272, 5287, 1, 0,
		0, 0, 5273, 5271, 1, 0, 0, 0, 5274, 5275, 3, 444, 222, 0, 5275, 5277, 5,
		2, 0, 0, 5276, 5278, 3, 318, 159, 0, 5277, 5276, 1, 0, 0, 0, 5277, 5278,
		1, 0, 0, 0, 5278, 5279, 1, 0, 0, 0, 5279, 5280, 5, 3, 0, 0, 5280, 5281,
		3, 326, 163, 0, 5281, 5287, 1, 0, 0, 0, 5282, 5283, 5, 2, 0, 0, 5283, 5284,
		3, 260, 130, 0, 5284, 5285, 5, 3, 0, 0, 5285, 5287, 1, 0, 0, 0, 5286, 5235,
		1, 0, 0, 0, 5286, 5264, 1, 0, 0, 0, 5286, 5274, 1, 0, 0, 0, 5286, 5282,
		1, 0, 0, 0, 5287, 313, 1, 0, 0, 0, 5288, 5289, 5, 227, 0, 0, 5289, 5290,
		3, 444, 222, 0, 5290, 315, 1, 0, 0, 0, 5291, 5292, 5, 359, 0, 0, 5292,
		5293, 5, 2, 0, 0, 5293, 5294, 3, 318, 159, 0, 5294, 5295, 5, 3, 0, 0, 5295,
		317, 1, 0, 0, 0, 5296, 5301, 3, 320, 160, 0, 5297, 5298, 5, 4, 0, 0, 5298,
		5300, 3, 320, 160, 0, 5299, 5297, 1, 0, 0, 0, 5300, 5303, 1, 0, 0, 0, 5301,
		5299, 1, 0, 0, 0, 5301, 5302, 1, 0, 0, 0, 5302, 319, 1, 0, 0, 0, 5303,
		5301, 1, 0, 0, 0, 5304, 5305, 3, 322, 161, 0, 5305, 5306, 5, 518, 0, 0,
		5306, 5307, 3, 324, 162, 0, 5307, 321, 1, 0, 0, 0, 5308, 5311, 3, 444,
		222, 0, 5309, 5311, 3, 410, 205, 0, 5310, 5308, 1, 0, 0, 0, 5310, 5309,
		1, 0, 0, 0, 5311, 323, 1, 0, 0, 0, 5312, 5315, 3, 444, 222, 0, 5313, 5315,
		3, 410, 205, 0, 5314, 5312, 1, 0, 0, 0, 5314, 5313, 1, 0, 0, 0, 5315, 325,
		1, 0, 0, 0, 5316, 5318, 5, 29, 0, 0, 5317, 5316, 1, 0, 0, 0, 5317, 5318,
		1, 0, 0, 0, 5318, 5319, 1, 0, 0, 0, 5319, 5321, 3, 446, 223, 0, 5320, 5322,
		3, 306, 153, 0, 5321, 5320, 1, 0, 0, 0, 5321, 5322, 1, 0, 0, 0, 5322, 5324,
		1, 0, 0, 0, 5323, 5317, 1, 0, 0, 0, 5323, 5324, 1, 0, 0, 0, 5324, 327,
		1, 0, 0, 0, 5325, 5330, 3, 440, 220, 0, 5326, 5327, 5, 5, 0, 0, 5327, 5329,
		3, 440, 220, 0, 5328, 5326, 1, 0, 0, 0, 5329, 5332, 1, 0, 0, 0, 5330, 5328,
		1, 0, 0, 0, 5330, 5331, 1, 0, 0, 0, 5331, 329, 1, 0, 0, 0, 5332, 5330,
		1, 0, 0, 0, 5333, 5338, 3, 332, 166, 0, 5334, 5335, 5, 4, 0, 0, 5335, 5337,
		3, 332, 166, 0, 5336, 5334, 1, 0, 0, 0, 5337, 5340, 1, 0, 0, 0, 5338, 5336,
		1, 0, 0, 0, 5338, 5339, 1, 0, 0, 0, 5339, 331, 1, 0, 0, 0, 5340, 5338,
		1, 0, 0, 0, 5341, 5344, 3, 444, 222, 0, 5342, 5343, 5, 83, 0, 0, 5343,
		5345, 5, 544, 0, 0, 5344, 5342, 1, 0, 0, 0, 5344, 5345, 1, 0, 0, 0, 5345,
		333, 1, 0, 0, 0, 5346, 5351, 3, 336, 168, 0, 5347, 5348, 5, 4, 0, 0, 5348,
		5350, 3, 336, 168, 0, 5349, 5347, 1, 0, 0, 0, 5350, 5353, 1, 0, 0, 0, 5351,
		5349, 1, 0, 0, 0, 5351, 5352, 1, 0, 0, 0, 5352, 335, 1, 0, 0, 0, 5353,
		5351, 1, 0, 0, 0, 5354, 5355, 3, 444, 222, 0, 5355, 5357, 3, 424, 212,
		0, 5356, 5358, 5, 253, 0, 0, 5357, 5356, 1, 0, 0, 0, 5357, 5358, 1, 0,
		0, 0, 5358, 5360, 1, 0, 0, 0, 5359, 5361, 3, 362, 181, 0, 5360, 5359, 1,
		0, 0, 0, 5360, 5361, 1, 0, 0, 0, 5361, 5371, 1, 0, 0, 0, 5362, 5363, 5,
		199, 0, 0, 5363, 5365, 5, 35, 0, 0, 5364, 5362, 1, 0, 0, 0, 5364, 5365,
		1, 0, 0, 0, 5365, 5366, 1, 0, 0, 0, 5366, 5367, 5, 29, 0, 0, 5367, 5368,
		5, 2, 0, 0, 5368, 5369, 3, 372, 186, 0, 5369, 5370, 5, 3, 0, 0, 5370, 5372,
		1, 0, 0, 0, 5371, 5364, 1, 0, 0, 0, 5371, 5372, 1, 0, 0, 0, 5372, 5377,
		1, 0, 0, 0, 5373, 5375, 5, 312, 0, 0, 5374, 5373, 1, 0, 0, 0, 5374, 5375,
		1, 0, 0, 0, 5375, 5376, 1, 0, 0, 0, 5376, 5378, 5, 313, 0, 0, 5377, 5374,
		1, 0, 0, 0, 5377, 5378, 1, 0, 0, 0, 5378, 5386, 1, 0, 0, 0, 5379, 5384,
		5, 34, 0, 0, 5380, 5381, 5, 2, 0, 0, 5381, 5382, 3, 450, 225, 0, 5382,
		5383, 5, 3, 0, 0, 5383, 5385, 1, 0, 0, 0, 5384, 5380, 1, 0, 0, 0, 5384,
		5385, 1, 0, 0, 0, 5385, 5387, 1, 0, 0, 0, 5386, 5379, 1, 0, 0, 0, 5386,
		5387, 1, 0, 0, 0, 5387, 5412, 1, 0, 0, 0, 5388, 5410, 5, 127, 0, 0, 5389,
		5411, 5, 313, 0, 0, 5390, 5392, 5, 526, 0, 0, 5391, 5390, 1, 0, 0, 0, 5391,
		5392, 1, 0, 0, 0, 5392, 5393, 1, 0, 0, 0, 5393, 5411, 5, 549, 0, 0, 5394,
		5396, 5, 526, 0, 0, 5395, 5394, 1, 0, 0, 0, 5395, 5396, 1, 0, 0, 0, 5396,
		5397, 1, 0, 0, 0, 5397, 5411, 5, 551, 0, 0, 5398, 5411, 5, 343, 0, 0, 5399,
		5411, 5, 153, 0, 0, 5400, 5411, 5, 48, 0, 0, 5401, 5411, 5, 544, 0, 0,
		5402, 5411, 5, 108, 0, 0, 5403, 5408, 5, 110, 0, 0, 5404, 5405, 5, 2, 0,
		0, 5405, 5406, 3, 450, 225, 0, 5406, 5407, 5, 3, 0, 0, 5407, 5409, 1, 0,
		0, 0, 5408, 5404, 1, 0, 0, 0, 5408, 5409, 1, 0, 0, 0, 5409, 5411, 1, 0,
		0, 0, 5410, 5389, 1, 0, 0, 0, 5410, 5391, 1, 0, 0, 0, 5410, 5395, 1, 0,
		0, 0, 5410, 5398, 1, 0, 0, 0, 5410, 5399, 1, 0, 0, 0, 5410, 5400, 1, 0,
		0, 0, 5410, 5401, 1, 0, 0, 0, 5410, 5402, 1, 0, 0, 0, 5410, 5403, 1, 0,
		0, 0, 5411, 5413, 1, 0, 0, 0, 5412, 5388, 1, 0, 0, 0, 5412, 5413, 1, 0,
		0, 0, 5413, 5423, 1, 0, 0, 0, 5414, 5415, 5, 318, 0, 0, 5415, 5416, 5,
		489, 0, 0, 5416, 5421, 5, 110, 0, 0, 5417, 5418, 5, 2, 0, 0, 5418, 5419,
		3, 450, 225, 0, 5419, 5420, 5, 3, 0, 0, 5420, 5422, 1, 0, 0, 0, 5421, 5417,
		1, 0, 0, 0, 5421, 5422, 1, 0, 0, 0, 5422, 5424, 1, 0, 0, 0, 5423, 5414,
		1, 0, 0, 0, 5423, 5424, 1, 0, 0, 0, 5424, 5427, 1, 0, 0, 0, 5425, 5426,
		5, 83, 0, 0, 5426, 5428, 5, 544, 0, 0, 5427, 5425, 1, 0, 0, 0, 5427, 5428,
		1, 0, 0, 0, 5428, 337, 1, 0, 0, 0, 5429, 5434, 3, 340, 170, 0, 5430, 5431,
		5, 4, 0, 0, 5431, 5433, 3, 340, 170, 0, 5432, 5430, 1, 0, 0, 0, 5433, 5436,
		1, 0, 0, 0, 5434, 5432, 1, 0, 0, 0, 5434, 5435, 1, 0, 0, 0, 5435, 339,
		1, 0, 0, 0, 5436, 5434, 1, 0, 0, 0, 5437, 5441, 5, 227, 0, 0, 5438, 5439,
		5, 222, 0, 0, 5439, 5440, 5, 312, 0, 0, 5440, 5442, 5, 170, 0, 0, 5441,
		5438, 1, 0, 0, 0, 5441, 5442, 1, 0, 0, 0, 5442, 5443, 1, 0, 0, 0, 5443,
		5444, 3, 444, 222, 0, 5444, 5447, 3, 306, 153, 0, 5445, 5446, 5, 493, 0,
		0, 5446, 5448, 7, 8, 0, 0, 5447, 5445, 1, 0, 0, 0, 5447, 5448, 1, 0, 0,
		0, 5448, 5454, 1, 0, 0, 0, 5449, 5450, 5, 359, 0, 0, 5450, 5451, 5, 2,
		0, 0, 5451, 5452, 3, 318, 159, 0, 5452, 5453, 5, 3, 0, 0, 5453, 5455, 1,
		0, 0, 0, 5454, 5449, 1, 0, 0, 0, 5454, 5455, 1, 0, 0, 0, 5455, 5458, 1,
		0, 0, 0, 5456, 5457, 5, 83, 0, 0, 5457, 5459, 5, 544, 0, 0, 5458, 5456,
		1, 0, 0, 0, 5458, 5459, 1, 0, 0, 0, 5459, 341, 1, 0, 0, 0, 5460, 5465,
		3, 344, 172, 0, 5461, 5462, 5, 4, 0, 0, 5462, 5464, 3, 344, 172, 0, 5463,
		5461, 1, 0, 0, 0, 5464, 5467, 1, 0, 0, 0, 5465, 5463, 1, 0, 0, 0, 5465,
		5466, 1, 0, 0, 0, 5466, 343, 1, 0, 0, 0, 5467, 5465, 1, 0, 0, 0, 5468,
		5473, 3, 346, 173, 0, 5469, 5473, 3, 348, 174, 0, 5470, 5473, 3, 350, 175,
		0, 5471, 5473, 3, 352, 176, 0, 5472, 5468, 1, 0, 0, 0, 5472, 5469, 1, 0,
		0, 0, 5472, 5470, 1, 0, 0, 0, 5472, 5471, 1, 0, 0, 0, 5473, 5478, 1, 0,
		0, 0, 5474, 5475, 5, 2, 0, 0, 5475, 5476, 3, 318, 159, 0, 5476, 5477, 5,
		3, 0, 0, 5477, 5479, 1, 0, 0, 0, 5478, 5474, 1, 0, 0, 0, 5478, 5479, 1,
		0, 0, 0, 5479, 345, 1, 0, 0, 0, 5480, 5484, 5, 330, 0, 0, 5481, 5482, 5,
		222, 0, 0, 5482, 5483, 5, 312, 0, 0, 5483, 5485, 5, 170, 0, 0, 5484, 5481,
		1, 0, 0, 0, 5484, 5485, 1, 0, 0, 0, 5485, 5486, 1, 0, 0, 0, 5486, 5487,
		3, 444, 222, 0, 5487, 5488, 5, 495, 0, 0, 5488, 5489, 5, 264, 0, 0, 5489,
		5492, 5, 462, 0, 0, 5490, 5493, 5, 290, 0, 0, 5491, 5493, 3, 354, 177,
		0, 5492, 5490, 1, 0, 0, 0, 5492, 5491, 1, 0, 0, 0, 5493, 347, 1, 0, 0,
		0, 5494, 5498, 5, 330, 0, 0, 5495, 5496, 5, 222, 0, 0, 5496, 5497, 5, 312,
		0, 0, 5497, 5499, 5, 170, 0, 0, 5498, 5495, 1, 0, 0, 0, 5498, 5499, 1,
		0, 0, 0, 5499, 5500, 1, 0, 0, 0, 5500, 5501, 3, 444, 222, 0, 5501, 5502,
		5, 495, 0, 0, 5502, 5503, 5, 7, 0, 0, 5503, 5504, 3, 354, 177, 0, 5504,
		5505, 5, 4, 0, 0, 5505, 5506, 3, 354, 177, 0, 5506, 5507, 5, 3, 0, 0, 5507,
		349, 1, 0, 0, 0, 5508, 5509, 5, 193, 0, 0, 5509, 5510, 3, 354, 177, 0,
		5510, 5511, 5, 467, 0, 0, 5511, 5512, 3, 354, 177, 0, 5512, 5513, 5, 237,
		0, 0, 5513, 5515, 5, 549, 0, 0, 5514, 5516, 3, 420, 210, 0, 5515, 5514,
		1, 0, 0, 0, 5515, 5516, 1, 0, 0, 0, 5516, 351, 1, 0, 0, 0, 5517, 5521,
		5, 330, 0, 0, 5518, 5519, 5, 222, 0, 0, 5519, 5520, 5, 312, 0, 0, 5520,
		5522, 5, 170, 0, 0, 5521, 5518, 1, 0, 0, 0, 5521, 5522, 1, 0, 0, 0, 5522,
		5523, 1, 0, 0, 0, 5523, 5540, 3, 444, 222, 0, 5524, 5525, 5, 495, 0, 0,
		5525, 5538, 5, 225, 0, 0, 5526, 5527, 5, 2, 0, 0, 5527, 5532, 3, 354, 177,
		0, 5528, 5529, 5, 4, 0, 0, 5529, 5531, 3, 354, 177, 0, 5530, 5528, 1, 0,
		0, 0, 5531, 5534, 1, 0, 0, 0, 5532, 5530, 1, 0, 0, 0, 5532, 5533, 1, 0,
		0, 0, 5533, 5535, 1, 0, 0, 0, 5534, 5532, 1, 0, 0, 0, 5535, 5536, 5, 3,
		0, 0, 5536, 5539, 1, 0, 0, 0, 5537, 5539, 3, 354, 177, 0, 5538, 5526, 1,
		0, 0, 0, 5538, 5537, 1, 0, 0, 0, 5539, 5541, 1, 0, 0, 0, 5540, 5524, 1,
		0, 0, 0, 5540, 5541, 1, 0, 0, 0, 5541, 353, 1, 0, 0, 0, 5542, 5543, 5,
		2, 0, 0, 5543, 5548, 3, 356, 178, 0, 5544, 5545, 5, 4, 0, 0, 5545, 5547,
		3, 356, 178, 0, 5546, 5544, 1, 0, 0, 0, 5547, 5550, 1, 0, 0, 0, 5548, 5546,
		1, 0, 0, 0, 5548, 5549, 1, 0, 0, 0, 5549, 5551, 1, 0, 0, 0, 5550, 5548,
		1, 0, 0, 0, 5551, 5552, 5, 3, 0, 0, 5552, 355, 1, 0, 0, 0, 5553, 5555,
		5, 526, 0, 0, 5554, 5553, 1, 0, 0, 0, 5554, 5555, 1, 0, 0, 0, 5555, 5556,
		1, 0, 0, 0, 5556, 5561, 5, 549, 0, 0, 5557, 5561, 5, 544, 0, 0, 5558, 5561,
		5, 290, 0, 0, 5559, 5561, 5, 313, 0, 0, 5560, 5554, 1, 0, 0, 0, 5560, 5557,
		1, 0, 0, 0, 5560, 5558, 1, 0, 0, 0, 5560, 5559, 1, 0, 0, 0, 5561, 357,
		1, 0, 0, 0, 5562, 5567, 3, 360, 180, 0, 5563, 5564, 5, 4, 0, 0, 5564, 5566,
		3, 360, 180, 0, 5565, 5563, 1, 0, 0, 0, 5566, 5569, 1, 0, 0, 0, 5567, 5565,
		1, 0, 0, 0, 5567, 5568, 1, 0, 0, 0, 5568, 359, 1, 0, 0, 0, 5569, 5567,
		1, 0, 0, 0, 5570, 5571, 3, 444, 222, 0, 5571, 5575, 3, 306, 153, 0, 5572,
		5573, 5, 151, 0, 0, 5573, 5574, 5, 253, 0, 0, 5574, 5576, 3, 306, 153,
		0, 5575, 5572, 1, 0, 0, 0, 5575, 5576, 1, 0, 0, 0, 5576, 5578, 1, 0, 0,
		0, 5577, 5579, 3, 316, 158, 0, 5578, 5577, 1, 0, 0, 0, 5578, 5579, 1, 0,
		0, 0, 5579, 361, 1, 0, 0, 0, 5580, 5581, 7, 41, 0, 0, 5581, 363, 1, 0,
		0, 0, 5582, 5583, 5, 454, 0, 0, 5583, 5584, 5, 2, 0, 0, 5584, 5589, 5,
		549, 0, 0, 5585, 5586, 5, 4, 0, 0, 5586, 5588, 5, 549, 0, 0, 5587, 5585,
		1, 0, 0, 0, 5588, 5591, 1, 0, 0, 0, 5589, 5587, 1, 0, 0, 0, 5589, 5590,
		1, 0, 0, 0, 5590, 5592, 1, 0, 0, 0, 5591, 5589, 1, 0, 0, 0, 5592, 5593,
		5, 3, 0, 0, 5593, 365, 1, 0, 0, 0, 5594, 5595, 5, 495, 0, 0, 5595, 5600,
		3, 378, 189, 0, 5596, 5597, 5, 4, 0, 0, 5597, 5599, 3, 378, 189, 0, 5598,
		5596, 1, 0, 0, 0, 5599, 5602, 1, 0, 0, 0, 5600, 5598, 1, 0, 0, 0, 5600,
		5601, 1, 0, 0, 0, 5601, 367, 1, 0, 0, 0, 5602, 5600, 1, 0, 0, 0, 5603,
		5608, 3, 372, 186, 0, 5604, 5606, 5, 29, 0, 0, 5605, 5604, 1, 0, 0, 0,
		5605, 5606, 1, 0, 0, 0, 5606, 5607, 1, 0, 0, 0, 5607, 5609, 3, 184, 92,
		0, 5608, 5605, 1, 0, 0, 0, 5608, 5609, 1, 0, 0, 0, 5609, 369, 1, 0, 0,
		0, 5610, 5615, 3, 368, 184, 0, 5611, 5612, 5, 4, 0, 0, 5612, 5614, 3, 368,
		184, 0, 5613, 5611, 1, 0, 0, 0, 5614, 5617, 1, 0, 0, 0, 5615, 5613, 1,
		0, 0, 0, 5615, 5616, 1, 0, 0, 0, 5616, 371, 1, 0, 0, 0, 5617, 5615, 1,
		0, 0, 0, 5618, 5621, 3, 376, 188, 0, 5619, 5621, 3, 374, 187, 0, 5620,
		5618, 1, 0, 0, 0, 5620, 5619, 1, 0, 0, 0, 5621, 373, 1, 0, 0, 0, 5622,
		5623, 3, 440, 220, 0, 5623, 5624, 5, 538, 0, 0, 5624, 5625, 3, 376, 188,
		0, 5625, 5639, 1, 0, 0, 0, 5626, 5627, 5, 2, 0, 0, 5627, 5630, 3, 440,
		220, 0, 5628, 5629, 5, 4, 0, 0, 5629, 5631, 3, 440, 220, 0, 5630, 5628,
		1, 0, 0, 0, 5631, 5632, 1, 0, 0, 0, 5632, 5630, 1, 0, 0, 0, 5632, 5633,
		1, 0, 0, 0, 5633, 5634, 1, 0, 0, 0, 5634, 5635, 5, 3, 0, 0, 5635, 5636,
		5, 538, 0, 0, 5636, 5637, 3, 376, 188, 0, 5637, 5639, 1, 0, 0, 0, 5638,
		5622, 1, 0, 0, 0, 5638, 5626, 1, 0, 0, 0, 5639, 375, 1, 0, 0, 0, 5640,
		5641, 6, 188, -1, 0, 5641, 5642, 5, 533, 0, 0, 5642, 5665, 3, 376, 188,
		10, 5643, 5644, 5, 170, 0, 0, 5644, 5645, 5, 2, 0, 0, 5645, 5646, 3, 230,
		115, 0, 5646, 5647, 5, 3, 0, 0, 5647, 5665, 1, 0, 0, 0, 5648, 5649, 7,
		42, 0, 0, 5649, 5650, 5, 2, 0, 0, 5650, 5651, 3, 384, 192, 0, 5651, 5652,
		5, 3, 0, 0, 5652, 5665, 1, 0, 0, 0, 5653, 5654, 5, 244, 0, 0, 5654, 5655,
		5, 2, 0, 0, 5655, 5656, 3, 384, 192, 0, 5656, 5657, 5, 3, 0, 0, 5657, 5665,
		1, 0, 0, 0, 5658, 5660, 3, 384, 192, 0, 5659, 5661, 3, 382, 191, 0, 5660,
		5659, 1, 0, 0, 0, 5660, 5661, 1, 0, 0, 0, 5661, 5665, 1, 0, 0, 0, 5662,
		5663, 5, 312, 0, 0, 5663, 5665, 3, 376, 188, 5, 5664, 5640, 1, 0, 0, 0,
		5664, 5643, 1, 0, 0, 0, 5664, 5648, 1, 0, 0, 0, 5664, 5653, 1, 0, 0, 0,
		5664, 5658, 1, 0, 0, 0, 5664, 5662, 1, 0, 0, 0, 5665, 5680, 1, 0, 0, 0,
		5666, 5667, 10, 4, 0, 0, 5667, 5668, 7, 43, 0, 0, 5668, 5679, 3, 376, 188,
		5, 5669, 5670, 10, 3, 0, 0, 5670, 5671, 5, 516, 0, 0, 5671, 5679, 3, 376,
		188, 4, 5672, 5673, 10, 2, 0, 0, 5673, 5674, 5, 322, 0, 0, 5674, 5679,
		3, 376, 188, 3, 5675, 5676, 10, 1, 0, 0, 5676, 5677, 5, 535, 0, 0, 5677,
		5679, 3, 376, 188, 2, 5678, 5666, 1, 0, 0, 0, 5678, 5669, 1, 0, 0, 0, 5678,
		5672, 1, 0, 0, 0, 5678, 5675, 1, 0, 0, 0, 5679, 5682, 1, 0, 0, 0, 5680,
		5678, 1, 0, 0, 0, 5680, 5681, 1, 0, 0, 0, 5681, 377, 1, 0, 0, 0, 5682,
		5680, 1, 0, 0, 0, 5683, 5692, 5, 2, 0, 0, 5684, 5689, 3, 380, 190, 0, 5685,
		5686, 5, 4, 0, 0, 5686, 5688, 3, 380, 190, 0, 5687, 5685, 1, 0, 0, 0, 5688,
		5691, 1, 0, 0, 0, 5689, 5687, 1, 0, 0, 0, 5689, 5690, 1, 0, 0, 0, 5690,
		5693, 1, 0, 0, 0, 5691, 5689, 1, 0, 0, 0, 5692, 5684, 1, 0, 0, 0, 5692,
		5693, 1, 0, 0, 0, 5693, 5694, 1, 0, 0, 0, 5694, 5695, 5, 3, 0, 0, 5695,
		379, 1, 0, 0, 0, 5696, 5700, 3, 410, 205, 0, 5697, 5700, 5, 127, 0, 0,
		5698, 5700, 3, 368, 184, 0, 5699, 5696, 1, 0, 0, 0, 5699, 5697, 1, 0, 0,
		0, 5699, 5698, 1, 0, 0, 0, 5700, 381, 1, 0, 0, 0, 5701, 5703, 5, 312, 0,
		0, 5702, 5701, 1, 0, 0, 0, 5702, 5703, 1, 0, 0, 0, 5703, 5704, 1, 0, 0,
		0, 5704, 5705, 5, 41, 0, 0, 5705, 5706, 3, 384, 192, 0, 5706, 5707, 5,
		25, 0, 0, 5707, 5708, 3, 384, 192, 0, 5708, 5762, 1, 0, 0, 0, 5709, 5711,
		5, 312, 0, 0, 5710, 5709, 1, 0, 0, 0, 5710, 5711, 1, 0, 0, 0, 5711, 5712,
		1, 0, 0, 0, 5712, 5713, 7, 44, 0, 0, 5713, 5762, 3, 384, 192, 0, 5714,
		5716, 5, 312, 0, 0, 5715, 5714, 1, 0, 0, 0, 5715, 5716, 1, 0, 0, 0, 5716,
		5717, 1, 0, 0, 0, 5717, 5718, 5, 266, 0, 0, 5718, 5721, 3, 384, 192, 0,
		5719, 5720, 5, 164, 0, 0, 5720, 5722, 3, 384, 192, 0, 5721, 5719, 1, 0,
		0, 0, 5721, 5722, 1, 0, 0, 0, 5722, 5762, 1, 0, 0, 0, 5723, 5725, 5, 312,
		0, 0, 5724, 5723, 1, 0, 0, 0, 5724, 5725, 1, 0, 0, 0, 5725, 5726, 1, 0,
		0, 0, 5726, 5727, 7, 45, 0, 0, 5727, 5762, 3, 384, 192, 0, 5728, 5730,
		5, 312, 0, 0, 5729, 5728, 1, 0, 0, 0, 5729, 5730, 1, 0, 0, 0, 5730, 5731,
		1, 0, 0, 0, 5731, 5732, 5, 225, 0, 0, 5732, 5733, 5, 2, 0, 0, 5733, 5734,
		3, 230, 115, 0, 5734, 5735, 5, 3, 0, 0, 5735, 5762, 1, 0, 0, 0, 5736, 5738,
		5, 312, 0, 0, 5737, 5736, 1, 0, 0, 0, 5737, 5738, 1, 0, 0, 0, 5738, 5739,
		1, 0, 0, 0, 5739, 5740, 5, 225, 0, 0, 5740, 5741, 5, 2, 0, 0, 5741, 5746,
		3, 372, 186, 0, 5742, 5743, 5, 4, 0, 0, 5743, 5745, 3, 372, 186, 0, 5744,
		5742, 1, 0, 0, 0, 5745, 5748, 1, 0, 0, 0, 5746, 5744, 1, 0, 0, 0, 5746,
		5747, 1, 0, 0, 0, 5747, 5749, 1, 0, 0, 0, 5748, 5746, 1, 0, 0, 0, 5749,
		5750, 5, 3, 0, 0, 5750, 5762, 1, 0, 0, 0, 5751, 5753, 5, 243, 0, 0, 5752,
		5754, 5, 312, 0, 0, 5753, 5752, 1, 0, 0, 0, 5753, 5754, 1, 0, 0, 0, 5754,
		5755, 1, 0, 0, 0, 5755, 5762, 5, 313, 0, 0, 5756, 5758, 5, 243, 0, 0, 5757,
		5759, 5, 312, 0, 0, 5758, 5757, 1, 0, 0, 0, 5758, 5759, 1, 0, 0, 0, 5759,
		5760, 1, 0, 0, 0, 5760, 5762, 7, 46, 0, 0, 5761, 5702, 1, 0, 0, 0, 5761,
		5710, 1, 0, 0, 0, 5761, 5715, 1, 0, 0, 0, 5761, 5724, 1, 0, 0, 0, 5761,
		5729, 1, 0, 0, 0, 5761, 5737, 1, 0, 0, 0, 5761, 5751, 1, 0, 0, 0, 5761,
		5756, 1, 0, 0, 0, 5762, 383, 1, 0, 0, 0, 5763, 5764, 6, 192, -1, 0, 5764,
		5768, 3, 386, 193, 0, 5765, 5766, 7, 47, 0, 0, 5766, 5768, 3, 384, 192,
		7, 5767, 5763, 1, 0, 0, 0, 5767, 5765, 1, 0, 0, 0, 5768, 5790, 1, 0, 0,
		0, 5769, 5770, 10, 6, 0, 0, 5770, 5771, 5, 536, 0, 0, 5771, 5789, 3, 384,
		192, 7, 5772, 5773, 10, 5, 0, 0, 5773, 5774, 7, 48, 0, 0, 5774, 5789, 3,
		384, 192, 6, 5775, 5776, 10, 4, 0, 0, 5776, 5777, 7, 49, 0, 0, 5777, 5789,
		3, 384, 192, 5, 5778, 5779, 10, 3, 0, 0, 5779, 5780, 5, 531, 0, 0, 5780,
		5789, 3, 384, 192, 4, 5781, 5782, 10, 2, 0, 0, 5782, 5783, 5, 534, 0, 0,
		5783, 5789, 3, 384, 192, 3, 5784, 5785, 10, 1, 0, 0, 5785, 5786, 3, 412,
		206, 0, 5786, 5787, 3, 384, 192, 2, 5787, 5789, 1, 0, 0, 0, 5788, 5769,
		1, 0, 0, 0, 5788, 5772, 1, 0, 0, 0, 5788, 5775, 1, 0, 0, 0, 5788, 5778,
		1, 0, 0, 0, 5788, 5781, 1, 0, 0, 0, 5788, 5784, 1, 0, 0, 0, 5789, 5792,
		1, 0, 0, 0, 5790, 5788, 1, 0, 0, 0, 5790, 5791, 1, 0, 0, 0, 5791, 385,
		1, 0, 0, 0, 5792, 5790, 1, 0, 0, 0, 5793, 5794, 6, 193, -1, 0, 5794, 5920,
		5, 108, 0, 0, 5795, 5920, 5, 109, 0, 0, 5796, 5920, 5, 110, 0, 0, 5797,
		5920, 5, 273, 0, 0, 5798, 5920, 5, 274, 0, 0, 5799, 5920, 5, 111, 0, 0,
		5800, 5920, 5, 419, 0, 0, 5801, 5803, 5, 66, 0, 0, 5802, 5804, 3, 416,
		208, 0, 5803, 5802, 1, 0, 0, 0, 5804, 5805, 1, 0, 0, 0, 5805, 5803, 1,
		0, 0, 0, 5805, 5806, 1, 0, 0, 0, 5806, 5809, 1, 0, 0, 0, 5807, 5808, 5,
		154, 0, 0, 5808, 5810, 3, 372, 186, 0, 5809, 5807, 1, 0, 0, 0, 5809, 5810,
		1, 0, 0, 0, 5810, 5811, 1, 0, 0, 0, 5811, 5812, 5, 158, 0, 0, 5812, 5920,
		1, 0, 0, 0, 5813, 5814, 5, 66, 0, 0, 5814, 5816, 3, 372, 186, 0, 5815,
		5817, 3, 416, 208, 0, 5816, 5815, 1, 0, 0, 0, 5817, 5818, 1, 0, 0, 0, 5818,
		5816, 1, 0, 0, 0, 5818, 5819, 1, 0, 0, 0, 5819, 5822, 1, 0, 0, 0, 5820,
		5821, 5, 154, 0, 0, 5821, 5823, 3, 372, 186, 0, 5822, 5820, 1, 0, 0, 0,
		5822, 5823, 1, 0, 0, 0, 5823, 5824, 1, 0, 0, 0, 5824, 5825, 5, 158, 0,
		0, 5825, 5920, 1, 0, 0, 0, 5826, 5827, 5, 67, 0, 0, 5827, 5828, 5, 2, 0,
		0, 5828, 5829, 3, 372, 186, 0, 5829, 5830, 5, 29, 0, 0, 5830, 5831, 3,
		390, 195, 0, 5831, 5832, 5, 3, 0, 0, 5832, 5920, 1, 0, 0, 0, 5833, 5920,
		3, 410, 205, 0, 5834, 5920, 3, 418, 209, 0, 5835, 5839, 5, 527, 0, 0, 5836,
		5838, 3, 388, 194, 0, 5837, 5836, 1, 0, 0, 0, 5838, 5841, 1, 0, 0, 0, 5839,
		5837, 1, 0, 0, 0, 5839, 5840, 1, 0, 0, 0, 5840, 5920, 1, 0, 0, 0, 5841,
		5839, 1, 0, 0, 0, 5842, 5843, 3, 406, 203, 0, 5843, 5844, 5, 5, 0, 0, 5844,
		5848, 5, 527, 0, 0, 5845, 5847, 3, 388, 194, 0, 5846, 5845, 1, 0, 0, 0,
		5847, 5850, 1, 0, 0, 0, 5848, 5846, 1, 0, 0, 0, 5848, 5849, 1, 0, 0, 0,
		5849, 5920, 1, 0, 0, 0, 5850, 5848, 1, 0, 0, 0, 5851, 5852, 5, 71, 0, 0,
		5852, 5853, 5, 2, 0, 0, 5853, 5858, 3, 372, 186, 0, 5854, 5855, 5, 4, 0,
		0, 5855, 5857, 3, 372, 186, 0, 5856, 5854, 1, 0, 0, 0, 5857, 5860, 1, 0,
		0, 0, 5858, 5856, 1, 0, 0, 0, 5858, 5859, 1, 0, 0, 0, 5859, 5863, 1, 0,
		0, 0, 5860, 5858, 1, 0, 0, 0, 5861, 5862, 5, 493, 0, 0, 5862, 5864, 3,
		184, 92, 0, 5863, 5861, 1, 0, 0, 0, 5863, 5864, 1, 0, 0, 0, 5864, 5865,
		1, 0, 0, 0, 5865, 5866, 5, 3, 0, 0, 5866, 5920, 1, 0, 0, 0, 5867, 5868,
		5, 97, 0, 0, 5868, 5869, 5, 2, 0, 0, 5869, 5870, 3, 372, 186, 0, 5870,
		5871, 5, 493, 0, 0, 5871, 5872, 3, 184, 92, 0, 5872, 5873, 5, 3, 0, 0,
		5873, 5920, 1, 0, 0, 0, 5874, 5875, 5, 97, 0, 0, 5875, 5876, 5, 2, 0, 0,
		5876, 5877, 3, 372, 186, 0, 5877, 5878, 5, 4, 0, 0, 5878, 5879, 3, 390,
		195, 0, 5879, 5880, 5, 3, 0, 0, 5880, 5920, 1, 0, 0, 0, 5881, 5920, 3,
		392, 196, 0, 5882, 5883, 5, 2, 0, 0, 5883, 5884, 3, 230, 115, 0, 5884,
		5885, 5, 3, 0, 0, 5885, 5920, 1, 0, 0, 0, 5886, 5887, 5, 542, 0, 0, 5887,
		5920, 3, 184, 92, 0, 5888, 5891, 5, 543, 0, 0, 5889, 5890, 7, 50, 0, 0,
		5890, 5892, 5, 5, 0, 0, 5891, 5889, 1, 0, 0, 0, 5891, 5892, 1, 0, 0, 0,
		5892, 5893, 1, 0, 0, 0, 5893, 5920, 3, 444, 222, 0, 5894, 5896, 5, 44,
		0, 0, 5895, 5894, 1, 0, 0, 0, 5895, 5896, 1, 0, 0, 0, 5896, 5897, 1, 0,
		0, 0, 5897, 5920, 3, 444, 222, 0, 5898, 5899, 5, 2, 0, 0, 5899, 5900, 3,
		372, 186, 0, 5900, 5901, 5, 3, 0, 0, 5901, 5920, 1, 0, 0, 0, 5902, 5906,
		5, 253, 0, 0, 5903, 5904, 3, 444, 222, 0, 5904, 5905, 5, 5, 0, 0, 5905,
		5907, 1, 0, 0, 0, 5906, 5903, 1, 0, 0, 0, 5906, 5907, 1, 0, 0, 0, 5907,
		5908, 1, 0, 0, 0, 5908, 5920, 3, 444, 222, 0, 5909, 5910, 5, 176, 0, 0,
		5910, 5911, 5, 2, 0, 0, 5911, 5912, 3, 444, 222, 0, 5912, 5914, 5, 193,
		0, 0, 5913, 5915, 7, 51, 0, 0, 5914, 5913, 1, 0, 0, 0, 5914, 5915, 1, 0,
		0, 0, 5915, 5916, 1, 0, 0, 0, 5916, 5917, 3, 384, 192, 0, 5917, 5918, 5,
		3, 0, 0, 5918, 5920, 1, 0, 0, 0, 5919, 5793, 1, 0, 0, 0, 5919, 5795, 1,
		0, 0, 0, 5919, 5796, 1, 0, 0, 0, 5919, 5797, 1, 0, 0, 0, 5919, 5798, 1,
		0, 0, 0, 5919, 5799, 1, 0, 0, 0, 5919, 5800, 1, 0, 0, 0, 5919, 5801, 1,
		0, 0, 0, 5919, 5813, 1, 0, 0, 0, 5919, 5826, 1, 0, 0, 0, 5919, 5833, 1,
		0, 0, 0, 5919, 5834, 1, 0, 0, 0, 5919, 5835, 1, 0, 0, 0, 5919, 5842, 1,
		0, 0, 0, 5919, 5851, 1, 0, 0, 0, 5919, 5867, 1, 0, 0, 0, 5919, 5874, 1,
		0, 0, 0, 5919, 5881, 1, 0, 0, 0, 5919, 5882, 1, 0, 0, 0, 5919, 5886, 1,
		0, 0, 0, 5919, 5888, 1, 0, 0, 0, 5919, 5895, 1, 0, 0, 0, 5919, 5898, 1,
		0, 0, 0, 5919, 5902, 1, 0, 0, 0, 5919, 5909, 1, 0, 0, 0, 5920, 5947, 1,
		0, 0, 0, 5921, 5922, 10, 11, 0, 0, 5922, 5923, 5, 7, 0, 0, 5923, 5924,
		3, 384, 192, 0, 5924, 5925, 5, 8, 0, 0, 5925, 5946, 1, 0, 0, 0, 5926, 5927,
		10, 10, 0, 0, 5927, 5928, 5, 7, 0, 0, 5928, 5929, 3, 384, 192, 0, 5929,
		5931, 5, 537, 0, 0, 5930, 5932, 3, 384, 192, 0, 5931, 5930, 1, 0, 0, 0,
		5931, 5932, 1, 0, 0, 0, 5932, 5933, 1, 0, 0, 0, 5933, 5934, 5, 8, 0, 0,
		5934, 5946, 1, 0, 0, 0, 5935, 5936, 10, 5, 0, 0, 5936, 5937, 5, 5, 0, 0,
		5937, 5946, 3, 444, 222, 0, 5938, 5939, 10, 1, 0, 0, 5939, 5943, 5, 77,
		0, 0, 5940, 5944, 3, 444, 222, 0, 5941, 5944, 5, 544, 0, 0, 5942, 5944,
		5, 127, 0, 0, 5943, 5940, 1, 0, 0, 0, 5943, 5941, 1, 0, 0, 0, 5943, 5942,
		1, 0, 0, 0, 5944, 5946, 1, 0, 0, 0, 5945, 5921, 1, 0, 0, 0, 5945, 5926,
		1, 0, 0, 0, 5945, 5935, 1, 0, 0, 0, 5945, 5938, 1, 0, 0, 0, 5946, 5949,
		1, 0, 0, 0, 5947, 5945, 1, 0, 0, 0, 5947, 5948, 1, 0, 0, 0, 5948, 387,
		1, 0, 0, 0, 5949, 5947, 1, 0, 0, 0, 5950, 5951, 5, 167, 0, 0, 5951, 5952,
		5, 2, 0, 0, 5952, 5953, 3, 370, 185, 0, 5953, 5954, 5, 3, 0, 0, 5954, 5961,
		1, 0, 0, 0, 5955, 5956, 5, 383, 0, 0, 5956, 5957, 5, 2, 0, 0, 5957, 5958,
		3, 370, 185, 0, 5958, 5959, 5, 3, 0, 0, 5959, 5961, 1, 0, 0, 0, 5960, 5950,
		1, 0, 0, 0, 5960, 5955, 1, 0, 0, 0, 5961, 389, 1, 0, 0, 0, 5962, 5968,
		3, 424, 212, 0, 5963, 5965, 7, 52, 0, 0, 5964, 5966, 7, 53, 0, 0, 5965,
		5964, 1, 0, 0, 0, 5965, 5966, 1, 0, 0, 0, 5966, 5968, 1, 0, 0, 0, 5967,
		5962, 1, 0, 0, 0, 5967, 5963, 1, 0, 0, 0, 5968, 391, 1, 0, 0, 0, 5969,
		5970, 3, 394, 197, 0, 5970, 5994, 5, 2, 0, 0, 5971, 5973, 7, 37, 0, 0,
		5972, 5971, 1, 0, 0, 0, 5972, 5973, 1, 0, 0, 0, 5973, 5974, 1, 0, 0, 0,
		5974, 5979, 3, 372, 186, 0, 5975, 5976, 5, 4, 0, 0, 5976, 5978, 3, 372,
		186, 0, 5977, 5975, 1, 0, 0, 0, 5978, 5981, 1, 0, 0, 0, 5979, 5977, 1,
		0, 0, 0, 5979, 5980, 1, 0, 0, 0, 5980, 5992, 1, 0, 0, 0, 5981, 5979, 1,
		0, 0, 0, 5982, 5983, 5, 323, 0, 0, 5983, 5984, 5, 61, 0, 0, 5984, 5989,
		3, 296, 148, 0, 5985, 5986, 5, 4, 0, 0, 5986, 5988, 3, 296, 148, 0, 5987,
		5985, 1, 0, 0, 0, 5988, 5991, 1, 0, 0, 0, 5989, 5987, 1, 0, 0, 0, 5989,
		5990, 1, 0, 0, 0, 5990, 5993, 1, 0, 0, 0, 5991, 5989, 1, 0, 0, 0, 5992,
		5982, 1, 0, 0, 0, 5992, 5993, 1, 0, 0, 0, 5993, 5995, 1, 0, 0, 0, 5994,
		5972, 1, 0, 0, 0, 5994, 5995, 1, 0, 0, 0, 5995, 5996, 1, 0, 0, 0, 5996,
		5999, 5, 3, 0, 0, 5997, 5998, 5, 326, 0, 0, 5998, 6000, 3, 398, 199, 0,
		5999, 5997, 1, 0, 0, 0, 5999, 6000, 1, 0, 0, 0, 6000, 393, 1, 0, 0, 0,
		6001, 6002, 3, 444, 222, 0, 6002, 6003, 5, 5, 0, 0, 6003, 6005, 1, 0, 0,
		0, 6004, 6001, 1, 0, 0, 0, 6004, 6005, 1, 0, 0, 0, 6005, 6006, 1, 0, 0,
		0, 6006, 6007, 3, 396, 198, 0, 6007, 395, 1, 0, 0, 0, 6008, 6025, 3, 444,
		222, 0, 6009, 6025, 5, 14, 0, 0, 6010, 6025, 5, 93, 0, 0, 6011, 6025, 5,
		107, 0, 0, 6012, 6025, 5, 111, 0, 0, 6013, 6025, 5, 113, 0, 0, 6014, 6025,
		5, 222, 0, 0, 6015, 6025, 5, 263, 0, 0, 6016, 6025, 5, 266, 0, 0, 6017,
		6025, 5, 332, 0, 0, 6018, 6025, 5, 378, 0, 0, 6019, 6025, 5, 399, 0, 0,
		6020, 6025, 5, 412, 0, 0, 6021, 6025, 5, 419, 0, 0, 6022, 6025, 5, 474,
		0, 0, 6023, 6025, 5, 491, 0, 0, 6024, 6008, 1, 0, 0, 0, 6024, 6009, 1,
		0, 0, 0, 6024, 6010, 1, 0, 0, 0, 6024, 6011, 1, 0, 0, 0, 6024, 6012, 1,
		0, 0, 0, 6024, 6013, 1, 0, 0, 0, 6024, 6014, 1, 0, 0, 0, 6024, 6015, 1,
		0, 0, 0, 6024, 6016, 1, 0, 0, 0, 6024, 6017, 1, 0, 0, 0, 6024, 6018, 1,
		0, 0, 0, 6024, 6019, 1, 0, 0, 0, 6024, 6020, 1, 0, 0, 0, 6024, 6021, 1,
		0, 0, 0, 6024, 6022, 1, 0, 0, 0, 6024, 6023, 1, 0, 0, 0, 6025, 397, 1,
		0, 0, 0, 6026, 6028, 5, 2, 0, 0, 6027, 6029, 3, 300, 150, 0, 6028, 6027,
		1, 0, 0, 0, 6028, 6029, 1, 0, 0, 0, 6029, 6031, 1, 0, 0, 0, 6030, 6032,
		3, 294, 147, 0, 6031, 6030, 1, 0, 0, 0, 6031, 6032, 1, 0, 0, 0, 6032, 6034,
		1, 0, 0, 0, 6033, 6035, 3, 400, 200, 0, 6034, 6033, 1, 0, 0, 0, 6034, 6035,
		1, 0, 0, 0, 6035, 6036, 1, 0, 0, 0, 6036, 6037, 5, 3, 0, 0, 6037, 399,
		1, 0, 0, 0, 6038, 6039, 3, 402, 201, 0, 6039, 6040, 3, 404, 202, 0, 6040,
		6048, 1, 0, 0, 0, 6041, 6042, 3, 402, 201, 0, 6042, 6043, 5, 41, 0, 0,
		6043, 6044, 3, 404, 202, 0, 6044, 6045, 5, 25, 0, 0, 6045, 6046, 3, 404,
		202, 0, 6046, 6048, 1, 0, 0, 0, 6047, 6038, 1, 0, 0, 0, 6047, 6041, 1,
		0, 0, 0, 6048, 401, 1, 0, 0, 0, 6049, 6050, 7, 54, 0, 0, 6050, 403, 1,
		0, 0, 0, 6051, 6052, 5, 480, 0, 0, 6052, 6059, 7, 55, 0, 0, 6053, 6054,
		5, 106, 0, 0, 6054, 6059, 5, 406, 0, 0, 6055, 6056, 3, 372, 186, 0, 6056,
		6057, 7, 55, 0, 0, 6057, 6059, 1, 0, 0, 0, 6058, 6051, 1, 0, 0, 0, 6058,
		6053, 1, 0, 0, 0, 6058, 6055, 1, 0, 0, 0, 6059, 405, 1, 0, 0, 0, 6060,
		6065, 3, 444, 222, 0, 6061, 6062, 5, 5, 0, 0, 6062, 6064, 3, 444, 222,
		0, 6063, 6061, 1, 0, 0, 0, 6064, 6067, 1, 0, 0, 0, 6065, 6063, 1, 0, 0,
		0, 6065, 6066, 1, 0, 0, 0, 6066, 407, 1, 0, 0, 0, 6067, 6065, 1, 0, 0,
		0, 6068, 6070, 5, 459, 0, 0, 6069, 6068, 1, 0, 0, 0, 6069, 6070, 1, 0,
		0, 0, 6070, 6071, 1, 0, 0, 0, 6071, 6074, 5, 330, 0, 0, 6072, 6075, 3,
		444, 222, 0, 6073, 6075, 3, 306, 153, 0, 6074, 6072, 1, 0, 0, 0, 6074,
		6073, 1, 0, 0, 0, 6075, 6082, 1, 0, 0, 0, 6076, 6078, 5, 459, 0, 0, 6077,
		6076, 1, 0, 0, 0, 6077, 6078, 1, 0, 0, 0, 6078, 6079, 1, 0, 0, 0, 6079,
		6080, 5, 331, 0, 0, 6080, 6082, 3, 306, 153, 0, 6081, 6069, 1, 0, 0, 0,
		6081, 6077, 1, 0, 0, 0, 6082, 409, 1, 0, 0, 0, 6083, 6135, 5, 313, 0, 0,
		6084, 6085, 7, 56, 0, 0, 6085, 6135, 5, 544, 0, 0, 6086, 6135, 3, 450,
		225, 0, 6087, 6135, 3, 414, 207, 0, 6088, 6090, 5, 44, 0, 0, 6089, 6088,
		1, 0, 0, 0, 6089, 6090, 1, 0, 0, 0, 6090, 6091, 1, 0, 0, 0, 6091, 6135,
		5, 544, 0, 0, 6092, 6094, 5, 7, 0, 0, 6093, 6095, 3, 410, 205, 0, 6094,
		6093, 1, 0, 0, 0, 6094, 6095, 1, 0, 0, 0, 6095, 6100, 1, 0, 0, 0, 6096,
		6097, 5, 4, 0, 0, 6097, 6099, 3, 410, 205, 0, 6098, 6096, 1, 0, 0, 0, 6099,
		6102, 1, 0, 0, 0, 6100, 6098, 1, 0, 0, 0, 6100, 6101, 1, 0, 0, 0, 6101,
		6103, 1, 0, 0, 0, 6102, 6100, 1, 0, 0, 0, 6103, 6135, 5, 8, 0, 0, 6104,
		6109, 5, 9, 0, 0, 6105, 6106, 3, 410, 205, 0, 6106, 6107, 5, 537, 0, 0,
		6107, 6108, 3, 410, 205, 0, 6108, 6110, 1, 0, 0, 0, 6109, 6105, 1, 0, 0,
		0, 6109, 6110, 1, 0, 0, 0, 6110, 6118, 1, 0, 0, 0, 6111, 6112, 5, 4, 0,
		0, 6112, 6113, 3, 410, 205, 0, 6113, 6114, 5, 537, 0, 0, 6114, 6115, 3,
		410, 205, 0, 6115, 6117, 1, 0, 0, 0, 6116, 6111, 1, 0, 0, 0, 6117, 6120,
		1, 0, 0, 0, 6118, 6116, 1, 0, 0, 0, 6118, 6119, 1, 0, 0, 0, 6119, 6121,
		1, 0, 0, 0, 6120, 6118, 1, 0, 0, 0, 6121, 6135, 5, 10, 0, 0, 6122, 6123,
		5, 9, 0, 0, 6123, 6128, 3, 410, 205, 0, 6124, 6125, 5, 4, 0, 0, 6125, 6127,
		3, 410, 205, 0, 6126, 6124, 1, 0, 0, 0, 6127, 6130, 1, 0, 0, 0, 6128, 6126,
		1, 0, 0, 0, 6128, 6129, 1, 0, 0, 0, 6129, 6131, 1, 0, 0, 0, 6130, 6128,
		1, 0, 0, 0, 6131, 6132, 5, 10, 0, 0, 6132, 6135, 1, 0, 0, 0, 6133, 6135,
		5, 344, 0, 0, 6134, 6083, 1, 0, 0, 0, 6134, 6084, 1, 0, 0, 0, 6134, 6086,
		1, 0, 0, 0, 6134, 6087, 1, 0, 0, 0, 6134, 6089, 1, 0, 0, 0, 6134, 6092,
		1, 0, 0, 0, 6134, 6104, 1, 0, 0, 0, 6134, 6122, 1, 0, 0, 0, 6134, 6133,
		1, 0, 0, 0, 6135, 411, 1, 0, 0, 0, 6136, 6137, 7, 57, 0, 0, 6137, 413,
		1, 0, 0, 0, 6138, 6139, 7, 46, 0, 0, 6139, 415, 1, 0, 0, 0, 6140, 6141,
		5, 509, 0, 0, 6141, 6142, 3, 372, 186, 0, 6142, 6143, 5, 463, 0, 0, 6143,
		6144, 3, 372, 186, 0, 6144, 417, 1, 0, 0, 0, 6145, 6146, 5, 237, 0, 0,
		6146, 6147, 3, 372, 186, 0, 6147, 6148, 3, 420, 210, 0, 6148, 419, 1, 0,
		0, 0, 6149, 6150, 7, 58, 0, 0, 6150, 421, 1, 0, 0, 0, 6151, 6156, 3, 424,
		212, 0, 6152, 6154, 5, 312, 0, 0, 6153, 6152, 1, 0, 0, 0, 6153, 6154, 1,
		0, 0, 0, 6154, 6155, 1, 0, 0, 0, 6155, 6157, 5, 313, 0, 0, 6156, 6153,
		1, 0, 0, 0, 6156, 6157, 1, 0, 0, 0, 6157, 423, 1, 0, 0, 0, 6158, 6159,
		5, 28, 0, 0, 6159, 6160, 5, 521, 0, 0, 6160, 6161, 3, 424, 212, 0, 6161,
		6162, 5, 523, 0, 0, 6162, 6204, 1, 0, 0, 0, 6163, 6164, 5, 280, 0, 0, 6164,
		6165, 5, 521, 0, 0, 6165, 6166, 3, 424, 212, 0, 6166, 6167, 5, 4, 0, 0,
		6167, 6168, 3, 424, 212, 0, 6168, 6169, 5, 523, 0, 0, 6169, 6204, 1, 0,
		0, 0, 6170, 6171, 5, 445, 0, 0, 6171, 6172, 5, 521, 0, 0, 6172, 6173, 3,
		428, 214, 0, 6173, 6174, 5, 523, 0, 0, 6174, 6204, 1, 0, 0, 0, 6175, 6176,
		5, 17, 0, 0, 6176, 6177, 5, 521, 0, 0, 6177, 6178, 3, 396, 198, 0, 6178,
		6179, 5, 2, 0, 0, 6179, 6184, 3, 422, 211, 0, 6180, 6181, 5, 4, 0, 0, 6181,
		6183, 3, 422, 211, 0, 6182, 6180, 1, 0, 0, 0, 6183, 6186, 1, 0, 0, 0, 6184,
		6182, 1, 0, 0, 0, 6184, 6185, 1, 0, 0, 0, 6185, 6187, 1, 0, 0, 0, 6186,
		6184, 1, 0, 0, 0, 6187, 6188, 5, 3, 0, 0, 6188, 6189, 5, 523, 0, 0, 6189,
		6204, 1, 0, 0, 0, 6190, 6201, 3, 426, 213, 0, 6191, 6192, 5, 2, 0, 0, 6192,
		6197, 7, 59, 0, 0, 6193, 6194, 5, 4, 0, 0, 6194, 6196, 5, 549, 0, 0, 6195,
		6193, 1, 0, 0, 0, 6196, 6199, 1, 0, 0, 0, 6197, 6195, 1, 0, 0, 0, 6197,
		6198, 1, 0, 0, 0, 6198, 6200, 1, 0, 0, 0, 6199, 6197, 1, 0, 0, 0, 6200,
		6202, 5, 3, 0, 0, 6201, 6191, 1, 0, 0, 0, 6201, 6202, 1, 0, 0, 0, 6202,
		6204, 1, 0, 0, 0, 6203, 6158, 1, 0, 0, 0, 6203, 6163, 1, 0, 0, 0, 6203,
		6170, 1, 0, 0, 0, 6203, 6175, 1, 0, 0, 0, 6203, 6190, 1, 0, 0, 0, 6204,
		425, 1, 0, 0, 0, 6205, 6238, 5, 466, 0, 0, 6206, 6238, 5, 427, 0, 0, 6207,
		6238, 7, 53, 0, 0, 6208, 6238, 5, 42, 0, 0, 6209, 6238, 5, 257, 0, 0, 6210,
		6238, 5, 53, 0, 0, 6211, 6238, 5, 185, 0, 0, 6212, 6238, 5, 146, 0, 0,
		6213, 6238, 5, 115, 0, 0, 6214, 6238, 5, 116, 0, 0, 6215, 6238, 5, 464,
		0, 0, 6216, 6238, 5, 118, 0, 0, 6217, 6238, 5, 117, 0, 0, 6218, 6238, 5,
		120, 0, 0, 6219, 6238, 5, 119, 0, 0, 6220, 6238, 5, 47, 0, 0, 6221, 6238,
		5, 361, 0, 0, 6222, 6238, 5, 214, 0, 0, 6223, 6238, 5, 17, 0, 0, 6224,
		6238, 5, 444, 0, 0, 6225, 6238, 5, 251, 0, 0, 6226, 6238, 5, 252, 0, 0,
		6227, 6238, 5, 461, 0, 0, 6228, 6238, 5, 496, 0, 0, 6229, 6238, 5, 71,
		0, 0, 6230, 6238, 5, 123, 0, 0, 6231, 6238, 5, 124, 0, 0, 6232, 6238, 5,
		125, 0, 0, 6233, 6238, 5, 241, 0, 0, 6234, 6238, 5, 242, 0, 0, 6235, 6238,
		5, 499, 0, 0, 6236, 6238, 5, 20, 0, 0, 6237, 6205, 1, 0, 0, 0, 6237, 6206,
		1, 0, 0, 0, 6237, 6207, 1, 0, 0, 0, 6237, 6208, 1, 0, 0, 0, 6237, 6209,
		1, 0, 0, 0, 6237, 6210, 1, 0, 0, 0, 6237, 6211, 1, 0, 0, 0, 6237, 6212,
		1, 0, 0, 0, 6237, 6213, 1, 0, 0, 0, 6237, 6214, 1, 0, 0, 0, 6237, 6215,
		1, 0, 0, 0, 6237, 6216, 1, 0, 0, 0, 6237, 6217, 1, 0, 0, 0, 6237, 6218,
		1, 0, 0, 0, 6237, 6219, 1, 0, 0, 0, 6237, 6220, 1, 0, 0, 0, 6237, 6221,
		1, 0, 0, 0, 6237, 6222, 1, 0, 0, 0, 6237, 6223, 1, 0, 0, 0, 6237, 6224,
		1, 0, 0, 0, 6237, 6225, 1, 0, 0, 0, 6237, 6226, 1, 0, 0, 0, 6237, 6227,
		1, 0, 0, 0, 6237, 6228, 1, 0, 0, 0, 6237, 6229, 1, 0, 0, 0, 6237, 6230,
		1, 0, 0, 0, 6237, 6231, 1, 0, 0, 0, 6237, 6232, 1, 0, 0, 0, 6237, 6233,
		1, 0, 0, 0, 6237, 6234, 1, 0, 0, 0, 6237, 6235, 1, 0, 0, 0, 6237, 6236,
		1, 0, 0, 0, 6238, 427, 1, 0, 0, 0, 6239, 6244, 3, 430, 215, 0, 6240, 6241,
		5, 4, 0, 0, 6241, 6243, 3, 430, 215, 0, 6242, 6240, 1, 0, 0, 0, 6243, 6246,
		1, 0, 0, 0, 6244, 6242, 1, 0, 0, 0, 6244, 6245, 1, 0, 0, 0, 6245, 429,
		1, 0, 0, 0, 6246, 6244, 1, 0, 0, 0, 6247, 6248, 3, 444, 222, 0, 6248, 6249,
		5, 537, 0, 0, 6249, 6251, 3, 424, 212, 0, 6250, 6252, 3, 432, 216, 0, 6251,
		6250, 1, 0, 0, 0, 6251, 6252, 1, 0, 0, 0, 6252, 431, 1, 0, 0, 0, 6253,
		6254, 5, 83, 0, 0, 6254, 6255, 5, 544, 0, 0, 6255, 433, 1, 0, 0, 0, 6256,
		6257, 5, 453, 0, 0, 6257, 6259, 5, 2, 0, 0, 6258, 6260, 3, 436, 218, 0,
		6259, 6258, 1, 0, 0, 0, 6259, 6260, 1, 0, 0, 0, 6260, 6261, 1, 0, 0, 0,
		6261, 6264, 5, 3, 0, 0, 6262, 6263, 5, 382, 0, 0, 6263, 6265, 5, 549, 0,
		0, 6264, 6262, 1, 0, 0, 0, 6264, 6265, 1, 0, 0, 0, 6265, 435, 1, 0, 0,
		0, 6266, 6267, 5, 549, 0, 0, 6267, 6271, 5, 339, 0, 0, 6268, 6269, 5, 549,
		0, 0, 6269, 6271, 5, 407, 0, 0, 6270, 6266, 1, 0, 0, 0, 6270, 6268, 1,
		0, 0, 0, 6271, 437, 1, 0, 0, 0, 6272, 6273, 5, 188, 0, 0, 6273, 6274, 5,
		503, 0, 0, 6274, 6275, 5, 29, 0, 0, 6275, 6276, 5, 316, 0, 0, 6276, 6283,
		7, 18, 0, 0, 6277, 6278, 5, 188, 0, 0, 6278, 6279, 5, 464, 0, 0, 6279,
		6280, 5, 29, 0, 0, 6280, 6281, 5, 316, 0, 0, 6281, 6283, 5, 544, 0, 0,
		6282, 6272, 1, 0, 0, 0, 6282, 6277, 1, 0, 0, 0, 6283, 439, 1, 0, 0, 0,
		6284, 6285, 3, 444, 222, 0, 6285, 6286, 3, 442, 221, 0, 6286, 441, 1, 0,
		0, 0, 6287, 6288, 5, 526, 0, 0, 6288, 6290, 3, 444, 222, 0, 6289, 6287,
		1, 0, 0, 0, 6290, 6291, 1, 0, 0, 0, 6291, 6289, 1, 0, 0, 0, 6291, 6292,
		1, 0, 0, 0, 6292, 6295, 1, 0, 0, 0, 6293, 6295, 1, 0, 0, 0, 6294, 6289,
		1, 0, 0, 0, 6294, 6293, 1, 0, 0, 0, 6295, 443, 1, 0, 0, 0, 6296, 6297,
		3, 446, 223, 0, 6297, 445, 1, 0, 0, 0, 6298, 6302, 5, 553, 0, 0, 6299,
		6302, 3, 448, 224, 0, 6300, 6302, 3, 452, 226, 0, 6301, 6298, 1, 0, 0,
		0, 6301, 6299, 1, 0, 0, 0, 6301, 6300, 1, 0, 0, 0, 6302, 447, 1, 0, 0,
		0, 6303, 6304, 5, 554, 0, 0, 6304, 449, 1, 0, 0, 0, 6305, 6307, 5, 526,
		0, 0, 6306, 6305, 1, 0, 0, 0, 6306, 6307, 1, 0, 0, 0, 6307, 6308, 1, 0,
		0, 0, 6308, 6314, 5, 549, 0, 0, 6309, 6311, 5, 526, 0, 0, 6310, 6309, 1,
		0, 0, 0, 6310, 6311, 1, 0, 0, 0, 6311, 6312, 1, 0, 0, 0, 6312, 6314, 7,
		60, 0, 0, 6313, 6306, 1, 0, 0, 0, 6313, 6310, 1, 0, 0, 0, 6314, 451, 1,
		0, 0, 0, 6315, 6316, 7, 61, 0, 0, 6316, 453, 1, 0, 0, 0, 898, 457, 461,
		466, 471, 477, 485, 489, 494, 508, 511, 519, 522, 530, 537, 544, 553, 560,
		567, 571, 573, 576, 580, 606, 612, 620, 627, 630, 634, 637, 639, 642, 646,
		650, 658, 665, 669, 671, 674, 686, 700, 708, 715, 722, 727, 753, 766, 768,
		772, 777, 779, 782, 798, 823, 844, 847, 850, 856, 863, 866, 871, 874, 880,
		884, 887, 895, 898, 901, 904, 910, 915, 918, 929, 934, 937, 940, 947, 950,
		955, 958, 964, 968, 978, 982, 985, 991, 994, 996, 1000, 1006, 1010, 1016,
		1019, 1023, 1028, 1036, 1038, 1042, 1045, 1052, 1057, 1059, 1061, 1068,
		1071, 1075, 1079, 1084, 1090, 1097, 1101, 1111, 1116, 1122, 1130, 1132,
		1139, 1144, 1152, 1157, 1160, 1167, 1173, 1177, 1180, 1188, 1199, 1212,
		1216, 1224, 1231, 1239, 1242, 1246, 1254, 1262, 1269, 1272, 1279, 1283,
		1290, 1298, 1301, 1307, 1312, 1319, 1322, 1326, 1333, 1338, 1345, 1356,
		1363, 1367, 1374, 1378, 1383, 1392, 1398, 1402, 1409, 1422, 1429, 1433,
		1441, 1445, 1454, 1458, 1467, 1471, 1480, 1484, 1486, 1493, 1511, 1515,
		1519, 1544, 1547, 1563, 1569, 1598, 1611, 1624, 1643, 1666, 1672, 1680,
		1688, 1703, 1709, 1711, 1725, 1732, 1739, 1746, 1754, 1762, 1767, 1773,
		1781, 1789, 1799, 1803, 1809, 1813, 1817, 1822, 1827, 1835, 1845, 1853,
		1862, 1864, 1870, 1877, 1884, 1893, 1902, 1911, 1914, 1918, 1922, 1933,
		1937, 1940, 1943, 1946, 1956, 1959, 1968, 1971, 1974, 1977, 1985, 1991,
		1994, 2000, 2003, 2006, 2009, 2018, 2024, 2029, 2035, 2040, 2044, 2047,
		2052, 2056, 2061, 2066, 2070, 2086, 2092, 2095, 2108, 2121, 2125, 2129,
		2136, 2141, 2147, 2150, 2153, 2157, 2162, 2165, 2181, 2185, 2198, 2204,
		2208, 2215, 2220, 2229, 2231, 2239, 2241, 2247, 2259, 2263, 2266, 2269,
		2282, 2302, 2305, 2308, 2312, 2317, 2320, 2323, 2326, 2333, 2336, 2339,
		2343, 2347, 2352, 2355, 2366, 2369, 2374, 2381, 2388, 2391, 2400, 2406,
		2412, 2416, 2429, 2442, 2446, 2453, 2459, 2462, 2468, 2472, 2477, 2480,
		2484, 2489, 2492, 2499, 2502, 2508, 2511, 2518, 2521, 2524, 2527, 2535,
		2543, 2549, 2552, 2560, 2567, 2573, 2576, 2579, 2582, 2593, 2595, 2597,
		2605, 2612, 2614, 2620, 2652, 2660, 2662, 2670, 2673, 2687, 2691, 2697,
		2708, 2720, 2723, 2737, 2742, 2745, 2752, 2759, 2767, 2770, 2773, 2787,
		2792, 2795, 2797, 2804, 2810, 2815, 2819, 2822, 2825, 2833, 2837, 2844,
		2847, 2850, 2858, 2867, 2870, 2877, 2889, 2913, 2921, 2927, 2931, 2937,
		2943, 2956, 2958, 2966, 2977, 2983, 2989, 2992, 2998, 3001, 3008, 3018,
		3025, 3031, 3044, 3048, 3057, 3067, 3071, 3073, 3091, 3095, 3108, 3112,
		3129, 3139, 3145, 3153, 3160, 3167, 3170, 3182, 3186, 3203, 3228, 3230,
		3236, 3240, 3246, 3250, 3256, 3260, 3265, 3274, 3278, 3281, 3284, 3287,
		3291, 3294, 3300, 3306, 3308, 3312, 3316, 3319, 3322, 3325, 3329, 3333,
		3336, 3339, 3342, 3344, 3354, 3368, 3375, 3383, 3395, 3413, 3420, 3430,
		3432, 3436, 3439, 3446, 3456, 3460, 3469, 3479, 3502, 3513, 3525, 3534,
		3547, 3551, 3558, 3561, 3564, 3570, 3573, 3576, 3584, 3587, 3593, 3596,
		3602, 3605, 3608, 3614, 3617, 3621, 3629, 3634, 3636, 3638, 3641, 3645,
		3650, 3654, 3659, 3663, 3671, 3680, 3684, 3687, 3690, 3697, 3700, 3725,
		3733, 3742, 3747, 3749, 3751, 3767, 3771, 3781, 3784, 3790, 3797, 3804,
		3811, 3818, 3825, 3832, 3838, 3841, 3847, 3850, 3853, 3872, 3884, 3892,
		3899, 3909, 3914, 3921, 3928, 3935, 3950, 3954, 3960, 3963, 3969, 3973,
		3984, 3991, 4002, 4014, 4017, 4038, 4041, 4047, 4052, 4057, 4060, 4067,
		4079, 4087, 4094, 4101, 4103, 4110, 4117, 4121, 4127, 4132, 4134, 4142,
		4144, 4151, 4153, 4157, 4163, 4165, 4168, 4176, 4183, 4189, 4194, 4198,
		4212, 4217, 4230, 4232, 4239, 4247, 4251, 4256, 4261, 4266, 4274, 4283,
		4286, 4292, 4294, 4300, 4307, 4321, 4325, 4330, 4336, 4344, 4351, 4354,
		4358, 4363, 4368, 4375, 4387, 4393, 4407, 4410, 4415, 4423, 4426, 4431,
		4436, 4446, 4453, 4456, 4459, 4469, 4477, 4483, 4489, 4494, 4499, 4502,
		4505, 4508, 4511, 4514, 4517, 4520, 4523, 4526, 4529, 4540, 4543, 4546,
		4549, 4552, 4554, 4568, 4575, 4581, 4585, 4590, 4597, 4602, 4611, 4613,
		4619, 4622, 4626, 4629, 4632, 4646, 4675, 4710, 4712, 4721, 4725, 4734,
		4740, 4746, 4749, 4752, 4755, 4758, 4766, 4774, 4777, 4780, 4791, 4797,
		4800, 4802, 4813, 4817, 4820, 4823, 4826, 4829, 4832, 4837, 4845, 4850,
		4863, 4870, 4883, 4888, 4893, 4897, 4913, 4920, 4926, 4930, 4940, 4948,
		4959, 4964, 4977, 4980, 4990, 4993, 5004, 5014, 5019, 5021, 5029, 5032,
		5044, 5049, 5058, 5063, 5068, 5077, 5082, 5084, 5090, 5092, 5095, 5101,
		5108, 5120, 5123, 5133, 5137, 5140, 5149, 5154, 5158, 5170, 5179, 5183,
		5188, 5192, 5196, 5206, 5212, 5223, 5231, 5237, 5240, 5243, 5246, 5249,
		5253, 5256, 5261, 5271, 5277, 5286, 5301, 5310, 5314, 5317, 5321, 5323,
		5330, 5338, 5344, 5351, 5357, 5360, 5364, 5371, 5374, 5377, 5384, 5386,
		5391, 5395, 5408, 5410, 5412, 5421, 5423, 5427, 5434, 5441, 5447, 5454,
		5458, 5465, 5472, 5478, 5484, 5492, 5498, 5515, 5521, 5532, 5538, 5540,
		5548, 5554, 5560, 5567, 5575, 5578, 5589, 5600, 5605, 5608, 5615, 5620,
		5632, 5638, 5660, 5664, 5678, 5680, 5689, 5692, 5699, 5702, 5710, 5715,
		5721, 5724, 5729, 5737, 5746, 5753, 5758, 5761, 5767, 5788, 5790, 5805,
		5809, 5818, 5822, 5839, 5848, 5858, 5863, 5891, 5895, 5906, 5914, 5919,
		5931, 5943, 5945, 5947, 5960, 5965, 5967, 5972, 5979, 5989, 5992, 5994,
		5999, 6004, 6024, 6028, 6031, 6034, 6047, 6058, 6065, 6069, 6074, 6077,
		6081, 6089, 6094, 6100, 6109, 6118, 6128, 6134, 6153, 6156, 6184, 6197,
		6201, 6203, 6237, 6244, 6251, 6259, 6264, 6270, 6282, 6291, 6294, 6301,
		6306, 6310, 6313,
	}
	deserializer := antlr.NewATNDeserializer(nil)
	staticData.atn = deserializer.Deserialize(staticData.serializedATN)
	atn := staticData.atn
	staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
	decisionToDFA := staticData.decisionToDFA
	for index, state := range atn.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(state, index)
	}
}

// DorisParserParserInit initializes any static state used to implement DorisParserParser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewDorisParserParser(). You can call this function if you wish to initialize the static state ahead
// of time.
func DorisParserParserInit() {
	staticData := &DorisParserParserStaticData
	staticData.once.Do(dorisparserParserInit)
}

// NewDorisParserParser produces a new parser instance for the optional input antlr.TokenStream.
func NewDorisParserParser(input antlr.TokenStream) *DorisParserParser {
	DorisParserParserInit()
	this := new(DorisParserParser)
	this.BaseParser = antlr.NewBaseParser(input)
	staticData := &DorisParserParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.PredictionContextCache)
	this.RuleNames = staticData.RuleNames
	this.LiteralNames = staticData.LiteralNames
	this.SymbolicNames = staticData.SymbolicNames
	this.GrammarFileName = "DorisParser.g4"

	return this
}

// Note that '@members' cannot be changed now, but this should have been 'globals'
// If you are looking to have variables for each instance, use '@structmembers'

var ansiSQLSyntax = false

// DorisParserParser tokens.
const (
	DorisParserParserEOF                     = antlr.TokenEOF
	DorisParserParserSEMICOLON               = 1
	DorisParserParserLEFT_PAREN              = 2
	DorisParserParserRIGHT_PAREN             = 3
	DorisParserParserCOMMA                   = 4
	DorisParserParserDOT                     = 5
	DorisParserParserDOTDOTDOT               = 6
	DorisParserParserLEFT_BRACKET            = 7
	DorisParserParserRIGHT_BRACKET           = 8
	DorisParserParserLEFT_BRACE              = 9
	DorisParserParserRIGHT_BRACE             = 10
	DorisParserParserACCOUNT_LOCK            = 11
	DorisParserParserACCOUNT_UNLOCK          = 12
	DorisParserParserACTIONS                 = 13
	DorisParserParserADD                     = 14
	DorisParserParserADMIN                   = 15
	DorisParserParserAFTER                   = 16
	DorisParserParserAGG_STATE               = 17
	DorisParserParserAGGREGATE               = 18
	DorisParserParserALIAS                   = 19
	DorisParserParserALL                     = 20
	DorisParserParserALTER                   = 21
	DorisParserParserANALYZE                 = 22
	DorisParserParserANALYZED                = 23
	DorisParserParserANALYZER                = 24
	DorisParserParserAND                     = 25
	DorisParserParserANTI                    = 26
	DorisParserParserAPPEND                  = 27
	DorisParserParserARRAY                   = 28
	DorisParserParserAS                      = 29
	DorisParserParserASC                     = 30
	DorisParserParserAT                      = 31
	DorisParserParserAUTHORS                 = 32
	DorisParserParserAUTO                    = 33
	DorisParserParserAUTO_INCREMENT          = 34
	DorisParserParserALWAYS                  = 35
	DorisParserParserBACKEND                 = 36
	DorisParserParserBACKENDS                = 37
	DorisParserParserBACKUP                  = 38
	DorisParserParserBEGIN                   = 39
	DorisParserParserBELONG                  = 40
	DorisParserParserBETWEEN                 = 41
	DorisParserParserBIGINT                  = 42
	DorisParserParserBIN                     = 43
	DorisParserParserBINARY                  = 44
	DorisParserParserBINLOG                  = 45
	DorisParserParserBITAND                  = 46
	DorisParserParserBITMAP                  = 47
	DorisParserParserBITMAP_EMPTY            = 48
	DorisParserParserBITMAP_UNION            = 49
	DorisParserParserBITOR                   = 50
	DorisParserParserBITXOR                  = 51
	DorisParserParserBLOB                    = 52
	DorisParserParserBOOLEAN                 = 53
	DorisParserParserBRANCH                  = 54
	DorisParserParserBRIEF                   = 55
	DorisParserParserBROKER                  = 56
	DorisParserParserBUCKETS                 = 57
	DorisParserParserBUILD                   = 58
	DorisParserParserBUILTIN                 = 59
	DorisParserParserBULK                    = 60
	DorisParserParserBY                      = 61
	DorisParserParserCACHE                   = 62
	DorisParserParserCACHED                  = 63
	DorisParserParserCALL                    = 64
	DorisParserParserCANCEL                  = 65
	DorisParserParserCASE                    = 66
	DorisParserParserCAST                    = 67
	DorisParserParserCATALOG                 = 68
	DorisParserParserCATALOGS                = 69
	DorisParserParserCHAIN                   = 70
	DorisParserParserCHAR                    = 71
	DorisParserParserCHARSET                 = 72
	DorisParserParserCHECK                   = 73
	DorisParserParserCLEAN                   = 74
	DorisParserParserCLUSTER                 = 75
	DorisParserParserCLUSTERS                = 76
	DorisParserParserCOLLATE                 = 77
	DorisParserParserCOLLATION               = 78
	DorisParserParserCOLLECT                 = 79
	DorisParserParserCOLOCATE                = 80
	DorisParserParserCOLUMN                  = 81
	DorisParserParserCOLUMNS                 = 82
	DorisParserParserCOMMENT                 = 83
	DorisParserParserCOMMIT                  = 84
	DorisParserParserCOMMITTED               = 85
	DorisParserParserCOMPACT                 = 86
	DorisParserParserCOMPLETE                = 87
	DorisParserParserCOMPRESS_TYPE           = 88
	DorisParserParserCOMPUTE                 = 89
	DorisParserParserCONDITIONS              = 90
	DorisParserParserCONFIG                  = 91
	DorisParserParserCONNECTION              = 92
	DorisParserParserCONNECTION_ID           = 93
	DorisParserParserCONSISTENT              = 94
	DorisParserParserCONSTRAINT              = 95
	DorisParserParserCONSTRAINTS             = 96
	DorisParserParserCONVERT                 = 97
	DorisParserParserCONVERT_LSC             = 98
	DorisParserParserCOPY                    = 99
	DorisParserParserCOUNT                   = 100
	DorisParserParserCREATE                  = 101
	DorisParserParserCREATION                = 102
	DorisParserParserCRON                    = 103
	DorisParserParserCROSS                   = 104
	DorisParserParserCUBE                    = 105
	DorisParserParserCURRENT                 = 106
	DorisParserParserCURRENT_CATALOG         = 107
	DorisParserParserCURRENT_DATE            = 108
	DorisParserParserCURRENT_TIME            = 109
	DorisParserParserCURRENT_TIMESTAMP       = 110
	DorisParserParserCURRENT_USER            = 111
	DorisParserParserDATA                    = 112
	DorisParserParserDATABASE                = 113
	DorisParserParserDATABASES               = 114
	DorisParserParserDATE                    = 115
	DorisParserParserDATETIME                = 116
	DorisParserParserDATETIMEV2              = 117
	DorisParserParserDATEV2                  = 118
	DorisParserParserDATETIMEV1              = 119
	DorisParserParserDATEV1                  = 120
	DorisParserParserDAY                     = 121
	DorisParserParserDAYS                    = 122
	DorisParserParserDECIMAL                 = 123
	DorisParserParserDECIMALV2               = 124
	DorisParserParserDECIMALV3               = 125
	DorisParserParserDECOMMISSION            = 126
	DorisParserParserDEFAULT                 = 127
	DorisParserParserDEFERRED                = 128
	DorisParserParserDELETE                  = 129
	DorisParserParserDEMAND                  = 130
	DorisParserParserDESC                    = 131
	DorisParserParserDESCRIBE                = 132
	DorisParserParserDIAGNOSE                = 133
	DorisParserParserDIAGNOSIS               = 134
	DorisParserParserDICTIONARIES            = 135
	DorisParserParserDICTIONARY              = 136
	DorisParserParserDISK                    = 137
	DorisParserParserDISTINCT                = 138
	DorisParserParserDISTINCTPC              = 139
	DorisParserParserDISTINCTPCSA            = 140
	DorisParserParserDISTRIBUTED             = 141
	DorisParserParserDISTRIBUTION            = 142
	DorisParserParserDIV                     = 143
	DorisParserParserDO                      = 144
	DorisParserParserDORIS_INTERNAL_TABLE_ID = 145
	DorisParserParserDOUBLE                  = 146
	DorisParserParserDROP                    = 147
	DorisParserParserDROPP                   = 148
	DorisParserParserDUAL                    = 149
	DorisParserParserDUMP                    = 150
	DorisParserParserDUPLICATE               = 151
	DorisParserParserDYNAMIC                 = 152
	DorisParserParserE                       = 153
	DorisParserParserELSE                    = 154
	DorisParserParserENABLE                  = 155
	DorisParserParserENCRYPTKEY              = 156
	DorisParserParserENCRYPTKEYS             = 157
	DorisParserParserEND                     = 158
	DorisParserParserENDS                    = 159
	DorisParserParserENGINE                  = 160
	DorisParserParserENGINES                 = 161
	DorisParserParserENTER                   = 162
	DorisParserParserERRORS                  = 163
	DorisParserParserESCAPE                  = 164
	DorisParserParserEVENTS                  = 165
	DorisParserParserEVERY                   = 166
	DorisParserParserEXCEPT                  = 167
	DorisParserParserEXCLUDE                 = 168
	DorisParserParserEXECUTE                 = 169
	DorisParserParserEXISTS                  = 170
	DorisParserParserEXPIRED                 = 171
	DorisParserParserEXPLAIN                 = 172
	DorisParserParserEXPORT                  = 173
	DorisParserParserEXTENDED                = 174
	DorisParserParserEXTERNAL                = 175
	DorisParserParserEXTRACT                 = 176
	DorisParserParserFAILED_LOGIN_ATTEMPTS   = 177
	DorisParserParserFALSE                   = 178
	DorisParserParserFAST                    = 179
	DorisParserParserFEATURE                 = 180
	DorisParserParserFIELDS                  = 181
	DorisParserParserFILE                    = 182
	DorisParserParserFILTER                  = 183
	DorisParserParserFIRST                   = 184
	DorisParserParserFLOAT                   = 185
	DorisParserParserFOLLOWER                = 186
	DorisParserParserFOLLOWING               = 187
	DorisParserParserFOR                     = 188
	DorisParserParserFOREIGN                 = 189
	DorisParserParserFORCE                   = 190
	DorisParserParserFORMAT                  = 191
	DorisParserParserFREE                    = 192
	DorisParserParserFROM                    = 193
	DorisParserParserFRONTEND                = 194
	DorisParserParserFRONTENDS               = 195
	DorisParserParserFULL                    = 196
	DorisParserParserFUNCTION                = 197
	DorisParserParserFUNCTIONS               = 198
	DorisParserParserGENERATED               = 199
	DorisParserParserGENERIC                 = 200
	DorisParserParserGLOBAL                  = 201
	DorisParserParserGRANT                   = 202
	DorisParserParserGRANTS                  = 203
	DorisParserParserGRAPH                   = 204
	DorisParserParserGROUP                   = 205
	DorisParserParserGROUPING                = 206
	DorisParserParserGROUPS                  = 207
	DorisParserParserHASH                    = 208
	DorisParserParserHASH_MAP                = 209
	DorisParserParserHAVING                  = 210
	DorisParserParserHDFS                    = 211
	DorisParserParserHELP                    = 212
	DorisParserParserHISTOGRAM               = 213
	DorisParserParserHLL                     = 214
	DorisParserParserHLL_UNION               = 215
	DorisParserParserHOSTNAME                = 216
	DorisParserParserHOTSPOT                 = 217
	DorisParserParserHOUR                    = 218
	DorisParserParserHOURS                   = 219
	DorisParserParserHUB                     = 220
	DorisParserParserIDENTIFIED              = 221
	DorisParserParserIF                      = 222
	DorisParserParserIGNORE                  = 223
	DorisParserParserIMMEDIATE               = 224
	DorisParserParserIN                      = 225
	DorisParserParserINCREMENTAL             = 226
	DorisParserParserINDEX                   = 227
	DorisParserParserINDEXES                 = 228
	DorisParserParserINFILE                  = 229
	DorisParserParserINNER                   = 230
	DorisParserParserINSERT                  = 231
	DorisParserParserINSTALL                 = 232
	DorisParserParserINT                     = 233
	DorisParserParserINTEGER                 = 234
	DorisParserParserINTERMEDIATE            = 235
	DorisParserParserINTERSECT               = 236
	DorisParserParserINTERVAL                = 237
	DorisParserParserINTO                    = 238
	DorisParserParserINVERTED                = 239
	DorisParserParserIP_TRIE                 = 240
	DorisParserParserIPV4                    = 241
	DorisParserParserIPV6                    = 242
	DorisParserParserIS                      = 243
	DorisParserParserIS_NOT_NULL_PRED        = 244
	DorisParserParserIS_NULL_PRED            = 245
	DorisParserParserISNULL                  = 246
	DorisParserParserISOLATION               = 247
	DorisParserParserJOB                     = 248
	DorisParserParserJOBS                    = 249
	DorisParserParserJOIN                    = 250
	DorisParserParserJSON                    = 251
	DorisParserParserJSONB                   = 252
	DorisParserParserKEY                     = 253
	DorisParserParserKEYS                    = 254
	DorisParserParserKILL                    = 255
	DorisParserParserLABEL                   = 256
	DorisParserParserLARGEINT                = 257
	DorisParserParserLAYOUT                  = 258
	DorisParserParserLAST                    = 259
	DorisParserParserLATERAL                 = 260
	DorisParserParserLDAP                    = 261
	DorisParserParserLDAP_ADMIN_PASSWORD     = 262
	DorisParserParserLEFT                    = 263
	DorisParserParserLESS                    = 264
	DorisParserParserLEVEL                   = 265
	DorisParserParserLIKE                    = 266
	DorisParserParserLIMIT                   = 267
	DorisParserParserLINES                   = 268
	DorisParserParserLINK                    = 269
	DorisParserParserLIST                    = 270
	DorisParserParserLOAD                    = 271
	DorisParserParserLOCAL                   = 272
	DorisParserParserLOCALTIME               = 273
	DorisParserParserLOCALTIMESTAMP          = 274
	DorisParserParserLOCATION                = 275
	DorisParserParserLOCK                    = 276
	DorisParserParserLOGICAL                 = 277
	DorisParserParserLOW_PRIORITY            = 278
	DorisParserParserMANUAL                  = 279
	DorisParserParserMAP                     = 280
	DorisParserParserMATCH                   = 281
	DorisParserParserMATCH_ALL               = 282
	DorisParserParserMATCH_ANY               = 283
	DorisParserParserMATCH_PHRASE            = 284
	DorisParserParserMATCH_PHRASE_EDGE       = 285
	DorisParserParserMATCH_PHRASE_PREFIX     = 286
	DorisParserParserMATCH_REGEXP            = 287
	DorisParserParserMATERIALIZED            = 288
	DorisParserParserMAX                     = 289
	DorisParserParserMAXVALUE                = 290
	DorisParserParserMEMO                    = 291
	DorisParserParserMERGE                   = 292
	DorisParserParserMIGRATE                 = 293
	DorisParserParserMIGRATIONS              = 294
	DorisParserParserMIN                     = 295
	DorisParserParserMINUS                   = 296
	DorisParserParserMINUTE                  = 297
	DorisParserParserMINUTES                 = 298
	DorisParserParserMODIFY                  = 299
	DorisParserParserMONTH                   = 300
	DorisParserParserMTMV                    = 301
	DorisParserParserNAME                    = 302
	DorisParserParserNAMES                   = 303
	DorisParserParserNATURAL                 = 304
	DorisParserParserNEGATIVE                = 305
	DorisParserParserNEVER                   = 306
	DorisParserParserNEXT                    = 307
	DorisParserParserNGRAM_BF                = 308
	DorisParserParserNO                      = 309
	DorisParserParserNO_USE_MV               = 310
	DorisParserParserNON_NULLABLE            = 311
	DorisParserParserNOT                     = 312
	DorisParserParserNULL                    = 313
	DorisParserParserNULLS                   = 314
	DorisParserParserOBSERVER                = 315
	DorisParserParserOF                      = 316
	DorisParserParserOFFSET                  = 317
	DorisParserParserON                      = 318
	DorisParserParserONLY                    = 319
	DorisParserParserOPEN                    = 320
	DorisParserParserOPTIMIZED               = 321
	DorisParserParserOR                      = 322
	DorisParserParserORDER                   = 323
	DorisParserParserOUTER                   = 324
	DorisParserParserOUTFILE                 = 325
	DorisParserParserOVER                    = 326
	DorisParserParserOVERWRITE               = 327
	DorisParserParserPARAMETER               = 328
	DorisParserParserPARSED                  = 329
	DorisParserParserPARTITION               = 330
	DorisParserParserPARTITIONS              = 331
	DorisParserParserPASSWORD                = 332
	DorisParserParserPASSWORD_EXPIRE         = 333
	DorisParserParserPASSWORD_HISTORY        = 334
	DorisParserParserPASSWORD_LOCK_TIME      = 335
	DorisParserParserPASSWORD_REUSE          = 336
	DorisParserParserPATH                    = 337
	DorisParserParserPAUSE                   = 338
	DorisParserParserPERCENT                 = 339
	DorisParserParserPERIOD                  = 340
	DorisParserParserPERMISSIVE              = 341
	DorisParserParserPHYSICAL                = 342
	DorisParserParserPI                      = 343
	DorisParserParserPLACEHOLDER             = 344
	DorisParserParserPLAN                    = 345
	DorisParserParserPLAY                    = 346
	DorisParserParserPRIVILEGES              = 347
	DorisParserParserPROCESS                 = 348
	DorisParserParserPLUGIN                  = 349
	DorisParserParserPLUGINS                 = 350
	DorisParserParserPOLICY                  = 351
	DorisParserParserPRECEDING               = 352
	DorisParserParserPREPARE                 = 353
	DorisParserParserPRIMARY                 = 354
	DorisParserParserPROC                    = 355
	DorisParserParserPROCEDURE               = 356
	DorisParserParserPROCESSLIST             = 357
	DorisParserParserPROFILE                 = 358
	DorisParserParserPROPERTIES              = 359
	DorisParserParserPROPERTY                = 360
	DorisParserParserQUANTILE_STATE          = 361
	DorisParserParserQUANTILE_UNION          = 362
	DorisParserParserQUERY                   = 363
	DorisParserParserQUEUED                  = 364
	DorisParserParserQUOTA                   = 365
	DorisParserParserQUALIFY                 = 366
	DorisParserParserQUARTER                 = 367
	DorisParserParserRANDOM                  = 368
	DorisParserParserRANGE                   = 369
	DorisParserParserREAD                    = 370
	DorisParserParserREAL                    = 371
	DorisParserParserREBALANCE               = 372
	DorisParserParserRECENT                  = 373
	DorisParserParserRECOVER                 = 374
	DorisParserParserRECYCLE                 = 375
	DorisParserParserREFRESH                 = 376
	DorisParserParserREFERENCES              = 377
	DorisParserParserREGEXP                  = 378
	DorisParserParserRELEASE                 = 379
	DorisParserParserRENAME                  = 380
	DorisParserParserREPAIR                  = 381
	DorisParserParserREPEATABLE              = 382
	DorisParserParserREPLACE                 = 383
	DorisParserParserREPLACE_IF_NOT_NULL     = 384
	DorisParserParserREPLAYER                = 385
	DorisParserParserREPLICA                 = 386
	DorisParserParserREPOSITORIES            = 387
	DorisParserParserREPOSITORY              = 388
	DorisParserParserRESOURCE                = 389
	DorisParserParserRESOURCES               = 390
	DorisParserParserRESTORE                 = 391
	DorisParserParserRESTRICTIVE             = 392
	DorisParserParserRESUME                  = 393
	DorisParserParserRETAIN                  = 394
	DorisParserParserRETENTION               = 395
	DorisParserParserRETURNS                 = 396
	DorisParserParserREVOKE                  = 397
	DorisParserParserREWRITTEN               = 398
	DorisParserParserRIGHT                   = 399
	DorisParserParserRLIKE                   = 400
	DorisParserParserROLE                    = 401
	DorisParserParserROLES                   = 402
	DorisParserParserROLLBACK                = 403
	DorisParserParserROLLUP                  = 404
	DorisParserParserROUTINE                 = 405
	DorisParserParserROW                     = 406
	DorisParserParserROWS                    = 407
	DorisParserParserS3                      = 408
	DorisParserParserSAMPLE                  = 409
	DorisParserParserSCHEDULE                = 410
	DorisParserParserSCHEDULER               = 411
	DorisParserParserSCHEMA                  = 412
	DorisParserParserSCHEMAS                 = 413
	DorisParserParserSECOND                  = 414
	DorisParserParserSELECT                  = 415
	DorisParserParserSEMI                    = 416
	DorisParserParserSERIALIZABLE            = 417
	DorisParserParserSESSION                 = 418
	DorisParserParserSESSION_USER            = 419
	DorisParserParserSET                     = 420
	DorisParserParserSETS                    = 421
	DorisParserParserSET_SESSION_VARIABLE    = 422
	DorisParserParserSHAPE                   = 423
	DorisParserParserSHOW                    = 424
	DorisParserParserSIGNED                  = 425
	DorisParserParserSKEW                    = 426
	DorisParserParserSMALLINT                = 427
	DorisParserParserSNAPSHOT                = 428
	DorisParserParserSNAPSHOTS               = 429
	DorisParserParserSONAME                  = 430
	DorisParserParserSPLIT                   = 431
	DorisParserParserSQL                     = 432
	DorisParserParserSQL_BLOCK_RULE          = 433
	DorisParserParserSTAGE                   = 434
	DorisParserParserSTAGES                  = 435
	DorisParserParserSTART                   = 436
	DorisParserParserSTARTS                  = 437
	DorisParserParserSTATS                   = 438
	DorisParserParserSTATUS                  = 439
	DorisParserParserSTOP                    = 440
	DorisParserParserSTORAGE                 = 441
	DorisParserParserSTREAM                  = 442
	DorisParserParserSTREAMING               = 443
	DorisParserParserSTRING                  = 444
	DorisParserParserSTRUCT                  = 445
	DorisParserParserSUM                     = 446
	DorisParserParserSUPERUSER               = 447
	DorisParserParserSWITCH                  = 448
	DorisParserParserSYNC                    = 449
	DorisParserParserSYSTEM                  = 450
	DorisParserParserTABLE                   = 451
	DorisParserParserTABLES                  = 452
	DorisParserParserTABLESAMPLE             = 453
	DorisParserParserTABLET                  = 454
	DorisParserParserTABLETS                 = 455
	DorisParserParserTAG                     = 456
	DorisParserParserTASK                    = 457
	DorisParserParserTASKS                   = 458
	DorisParserParserTEMPORARY               = 459
	DorisParserParserTERMINATED              = 460
	DorisParserParserTEXT                    = 461
	DorisParserParserTHAN                    = 462
	DorisParserParserTHEN                    = 463
	DorisParserParserTIME                    = 464
	DorisParserParserTIMESTAMP               = 465
	DorisParserParserTINYINT                 = 466
	DorisParserParserTO                      = 467
	DorisParserParserTOKENIZER               = 468
	DorisParserParserTOKEN_FILTER            = 469
	DorisParserParserTRANSACTION             = 470
	DorisParserParserTRASH                   = 471
	DorisParserParserTREE                    = 472
	DorisParserParserTRIGGERS                = 473
	DorisParserParserTRIM                    = 474
	DorisParserParserTRUE                    = 475
	DorisParserParserTRUNCATE                = 476
	DorisParserParserTYPE                    = 477
	DorisParserParserTYPECAST                = 478
	DorisParserParserTYPES                   = 479
	DorisParserParserUNBOUNDED               = 480
	DorisParserParserUNCOMMITTED             = 481
	DorisParserParserUNINSTALL               = 482
	DorisParserParserUNION                   = 483
	DorisParserParserUNIQUE                  = 484
	DorisParserParserUNLOCK                  = 485
	DorisParserParserUNSET                   = 486
	DorisParserParserUNSIGNED                = 487
	DorisParserParserUP                      = 488
	DorisParserParserUPDATE                  = 489
	DorisParserParserUSE                     = 490
	DorisParserParserUSER                    = 491
	DorisParserParserUSE_MV                  = 492
	DorisParserParserUSING                   = 493
	DorisParserParserVALUE                   = 494
	DorisParserParserVALUES                  = 495
	DorisParserParserVARCHAR                 = 496
	DorisParserParserVARIABLE                = 497
	DorisParserParserVARIABLES               = 498
	DorisParserParserVARIANT                 = 499
	DorisParserParserVAULT                   = 500
	DorisParserParserVAULTS                  = 501
	DorisParserParserVERBOSE                 = 502
	DorisParserParserVERSION                 = 503
	DorisParserParserVIEW                    = 504
	DorisParserParserVIEWS                   = 505
	DorisParserParserWARM                    = 506
	DorisParserParserWARNINGS                = 507
	DorisParserParserWEEK                    = 508
	DorisParserParserWHEN                    = 509
	DorisParserParserWHERE                   = 510
	DorisParserParserWHITELIST               = 511
	DorisParserParserWITH                    = 512
	DorisParserParserWORK                    = 513
	DorisParserParserWORKLOAD                = 514
	DorisParserParserWRITE                   = 515
	DorisParserParserXOR                     = 516
	DorisParserParserYEAR                    = 517
	DorisParserParserEQ                      = 518
	DorisParserParserNSEQ                    = 519
	DorisParserParserNEQ                     = 520
	DorisParserParserLT                      = 521
	DorisParserParserLTE                     = 522
	DorisParserParserGT                      = 523
	DorisParserParserGTE                     = 524
	DorisParserParserPLUS                    = 525
	DorisParserParserSUBTRACT                = 526
	DorisParserParserASTERISK                = 527
	DorisParserParserSLASH                   = 528
	DorisParserParserMOD                     = 529
	DorisParserParserTILDE                   = 530
	DorisParserParserAMPERSAND               = 531
	DorisParserParserLOGICALAND              = 532
	DorisParserParserLOGICALNOT              = 533
	DorisParserParserPIPE                    = 534
	DorisParserParserDOUBLEPIPES             = 535
	DorisParserParserHAT                     = 536
	DorisParserParserCOLON                   = 537
	DorisParserParserARROW                   = 538
	DorisParserParserHINT_START              = 539
	DorisParserParserHINT_END                = 540
	DorisParserParserCOMMENT_START           = 541
	DorisParserParserATSIGN                  = 542
	DorisParserParserDOUBLEATSIGN            = 543
	DorisParserParserSTRING_LITERAL          = 544
	DorisParserParserLEADING_STRING          = 545
	DorisParserParserBIGINT_LITERAL          = 546
	DorisParserParserSMALLINT_LITERAL        = 547
	DorisParserParserTINYINT_LITERAL         = 548
	DorisParserParserINTEGER_VALUE           = 549
	DorisParserParserEXPONENT_VALUE          = 550
	DorisParserParserDECIMAL_VALUE           = 551
	DorisParserParserBIGDECIMAL_LITERAL      = 552
	DorisParserParserIDENTIFIER              = 553
	DorisParserParserBACKQUOTED_IDENTIFIER   = 554
	DorisParserParserSIMPLE_COMMENT          = 555
	DorisParserParserBRACKETED_COMMENT       = 556
	DorisParserParserFROM_DUAL               = 557
	DorisParserParserWS                      = 558
	DorisParserParserUNRECOGNIZED            = 559
)

// DorisParserParser rules.
const (
	DorisParserParserRULE_multiStatements                = 0
	DorisParserParserRULE_singleStatement                = 1
	DorisParserParserRULE_statement                      = 2
	DorisParserParserRULE_statementBase                  = 3
	DorisParserParserRULE_unsupportedStatement           = 4
	DorisParserParserRULE_materializedViewStatement      = 5
	DorisParserParserRULE_supportedJobStatement          = 6
	DorisParserParserRULE_constraintStatement            = 7
	DorisParserParserRULE_supportedDmlStatement          = 8
	DorisParserParserRULE_supportedCreateStatement       = 9
	DorisParserParserRULE_dictionaryColumnDefs           = 10
	DorisParserParserRULE_dictionaryColumnDef            = 11
	DorisParserParserRULE_supportedAlterStatement        = 12
	DorisParserParserRULE_supportedDropStatement         = 13
	DorisParserParserRULE_supportedShowStatement         = 14
	DorisParserParserRULE_supportedLoadStatement         = 15
	DorisParserParserRULE_supportedKillStatement         = 16
	DorisParserParserRULE_supportedOtherStatement        = 17
	DorisParserParserRULE_unsupportedOtherStatement      = 18
	DorisParserParserRULE_warmUpItem                     = 19
	DorisParserParserRULE_lockTable                      = 20
	DorisParserParserRULE_createRoutineLoad              = 21
	DorisParserParserRULE_unsupportedLoadStatement       = 22
	DorisParserParserRULE_loadProperty                   = 23
	DorisParserParserRULE_importSequenceStatement        = 24
	DorisParserParserRULE_importDeleteOnStatement        = 25
	DorisParserParserRULE_importWhereStatement           = 26
	DorisParserParserRULE_importPrecedingFilterStatement = 27
	DorisParserParserRULE_importColumnsStatement         = 28
	DorisParserParserRULE_importColumnDesc               = 29
	DorisParserParserRULE_supportedRefreshStatement      = 30
	DorisParserParserRULE_supportedCleanStatement        = 31
	DorisParserParserRULE_supportedCancelStatement       = 32
	DorisParserParserRULE_supportedAdminStatement        = 33
	DorisParserParserRULE_supportedRecoverStatement      = 34
	DorisParserParserRULE_unsupportedAdminStatement      = 35
	DorisParserParserRULE_baseTableRef                   = 36
	DorisParserParserRULE_wildWhere                      = 37
	DorisParserParserRULE_supportedTransactionStatement  = 38
	DorisParserParserRULE_supportedGrantRevokeStatement  = 39
	DorisParserParserRULE_privilege                      = 40
	DorisParserParserRULE_privilegeList                  = 41
	DorisParserParserRULE_alterSystemClause              = 42
	DorisParserParserRULE_dropRollupClause               = 43
	DorisParserParserRULE_addRollupClause                = 44
	DorisParserParserRULE_alterTableClause               = 45
	DorisParserParserRULE_createOrReplaceTagClause       = 46
	DorisParserParserRULE_createOrReplaceBranchClause    = 47
	DorisParserParserRULE_tagOptions                     = 48
	DorisParserParserRULE_branchOptions                  = 49
	DorisParserParserRULE_retainTime                     = 50
	DorisParserParserRULE_retentionSnapshot              = 51
	DorisParserParserRULE_minSnapshotsToKeep             = 52
	DorisParserParserRULE_timeValueWithUnit              = 53
	DorisParserParserRULE_dropBranchClause               = 54
	DorisParserParserRULE_dropTagClause                  = 55
	DorisParserParserRULE_columnPosition                 = 56
	DorisParserParserRULE_toRollup                       = 57
	DorisParserParserRULE_fromRollup                     = 58
	DorisParserParserRULE_supportedStatsStatement        = 59
	DorisParserParserRULE_unsupportedStatsStatement      = 60
	DorisParserParserRULE_analyzeProperties              = 61
	DorisParserParserRULE_workloadPolicyActions          = 62
	DorisParserParserRULE_workloadPolicyAction           = 63
	DorisParserParserRULE_workloadPolicyConditions       = 64
	DorisParserParserRULE_workloadPolicyCondition        = 65
	DorisParserParserRULE_storageBackend                 = 66
	DorisParserParserRULE_passwordOption                 = 67
	DorisParserParserRULE_functionArguments              = 68
	DorisParserParserRULE_dataTypeList                   = 69
	DorisParserParserRULE_supportedSetStatement          = 70
	DorisParserParserRULE_optionWithType                 = 71
	DorisParserParserRULE_optionWithoutType              = 72
	DorisParserParserRULE_variable                       = 73
	DorisParserParserRULE_transactionAccessMode          = 74
	DorisParserParserRULE_isolationLevel                 = 75
	DorisParserParserRULE_supportedUnsetStatement        = 76
	DorisParserParserRULE_supportedUseStatement          = 77
	DorisParserParserRULE_stageAndPattern                = 78
	DorisParserParserRULE_supportedDescribeStatement     = 79
	DorisParserParserRULE_constraint                     = 80
	DorisParserParserRULE_partitionSpec                  = 81
	DorisParserParserRULE_partitionTable                 = 82
	DorisParserParserRULE_identityOrFunctionList         = 83
	DorisParserParserRULE_identityOrFunction             = 84
	DorisParserParserRULE_dataDesc                       = 85
	DorisParserParserRULE_statementScope                 = 86
	DorisParserParserRULE_buildMode                      = 87
	DorisParserParserRULE_refreshTrigger                 = 88
	DorisParserParserRULE_refreshSchedule                = 89
	DorisParserParserRULE_refreshMethod                  = 90
	DorisParserParserRULE_mvPartition                    = 91
	DorisParserParserRULE_identifierOrText               = 92
	DorisParserParserRULE_identifierOrTextOrAsterisk     = 93
	DorisParserParserRULE_multipartIdentifierOrAsterisk  = 94
	DorisParserParserRULE_identifierOrAsterisk           = 95
	DorisParserParserRULE_userIdentify                   = 96
	DorisParserParserRULE_grantUserIdentify              = 97
	DorisParserParserRULE_explain                        = 98
	DorisParserParserRULE_explainCommand                 = 99
	DorisParserParserRULE_planType                       = 100
	DorisParserParserRULE_replayCommand                  = 101
	DorisParserParserRULE_replayType                     = 102
	DorisParserParserRULE_mergeType                      = 103
	DorisParserParserRULE_preFilterClause                = 104
	DorisParserParserRULE_deleteOnClause                 = 105
	DorisParserParserRULE_sequenceColClause              = 106
	DorisParserParserRULE_colFromPath                    = 107
	DorisParserParserRULE_colMappingList                 = 108
	DorisParserParserRULE_mappingExpr                    = 109
	DorisParserParserRULE_withRemoteStorageSystem        = 110
	DorisParserParserRULE_resourceDesc                   = 111
	DorisParserParserRULE_mysqlDataDesc                  = 112
	DorisParserParserRULE_skipLines                      = 113
	DorisParserParserRULE_outFileClause                  = 114
	DorisParserParserRULE_query                          = 115
	DorisParserParserRULE_queryTerm                      = 116
	DorisParserParserRULE_setQuantifier                  = 117
	DorisParserParserRULE_queryPrimary                   = 118
	DorisParserParserRULE_querySpecification             = 119
	DorisParserParserRULE_cte                            = 120
	DorisParserParserRULE_aliasQuery                     = 121
	DorisParserParserRULE_columnAliases                  = 122
	DorisParserParserRULE_selectClause                   = 123
	DorisParserParserRULE_selectColumnClause             = 124
	DorisParserParserRULE_whereClause                    = 125
	DorisParserParserRULE_fromClause                     = 126
	DorisParserParserRULE_intoClause                     = 127
	DorisParserParserRULE_bulkCollectClause              = 128
	DorisParserParserRULE_tableRow                       = 129
	DorisParserParserRULE_relations                      = 130
	DorisParserParserRULE_relation                       = 131
	DorisParserParserRULE_joinRelation                   = 132
	DorisParserParserRULE_distributeType                 = 133
	DorisParserParserRULE_relationHint                   = 134
	DorisParserParserRULE_aggClause                      = 135
	DorisParserParserRULE_groupingElement                = 136
	DorisParserParserRULE_groupingSet                    = 137
	DorisParserParserRULE_havingClause                   = 138
	DorisParserParserRULE_qualifyClause                  = 139
	DorisParserParserRULE_selectHint                     = 140
	DorisParserParserRULE_hintStatement                  = 141
	DorisParserParserRULE_hintAssignment                 = 142
	DorisParserParserRULE_updateAssignment               = 143
	DorisParserParserRULE_updateAssignmentSeq            = 144
	DorisParserParserRULE_lateralView                    = 145
	DorisParserParserRULE_queryOrganization              = 146
	DorisParserParserRULE_sortClause                     = 147
	DorisParserParserRULE_sortItem                       = 148
	DorisParserParserRULE_limitClause                    = 149
	DorisParserParserRULE_partitionClause                = 150
	DorisParserParserRULE_joinType                       = 151
	DorisParserParserRULE_joinCriteria                   = 152
	DorisParserParserRULE_identifierList                 = 153
	DorisParserParserRULE_identifierSeq                  = 154
	DorisParserParserRULE_optScanParams                  = 155
	DorisParserParserRULE_relationPrimary                = 156
	DorisParserParserRULE_materializedViewName           = 157
	DorisParserParserRULE_propertyClause                 = 158
	DorisParserParserRULE_propertyItemList               = 159
	DorisParserParserRULE_propertyItem                   = 160
	DorisParserParserRULE_propertyKey                    = 161
	DorisParserParserRULE_propertyValue                  = 162
	DorisParserParserRULE_tableAlias                     = 163
	DorisParserParserRULE_multipartIdentifier            = 164
	DorisParserParserRULE_simpleColumnDefs               = 165
	DorisParserParserRULE_simpleColumnDef                = 166
	DorisParserParserRULE_columnDefs                     = 167
	DorisParserParserRULE_columnDef                      = 168
	DorisParserParserRULE_indexDefs                      = 169
	DorisParserParserRULE_indexDef                       = 170
	DorisParserParserRULE_partitionsDef                  = 171
	DorisParserParserRULE_partitionDef                   = 172
	DorisParserParserRULE_lessThanPartitionDef           = 173
	DorisParserParserRULE_fixedPartitionDef              = 174
	DorisParserParserRULE_stepPartitionDef               = 175
	DorisParserParserRULE_inPartitionDef                 = 176
	DorisParserParserRULE_partitionValueList             = 177
	DorisParserParserRULE_partitionValueDef              = 178
	DorisParserParserRULE_rollupDefs                     = 179
	DorisParserParserRULE_rollupDef                      = 180
	DorisParserParserRULE_aggTypeDef                     = 181
	DorisParserParserRULE_tabletList                     = 182
	DorisParserParserRULE_inlineTable                    = 183
	DorisParserParserRULE_namedExpression                = 184
	DorisParserParserRULE_namedExpressionSeq             = 185
	DorisParserParserRULE_expression                     = 186
	DorisParserParserRULE_lambdaExpression               = 187
	DorisParserParserRULE_booleanExpression              = 188
	DorisParserParserRULE_rowConstructor                 = 189
	DorisParserParserRULE_rowConstructorItem             = 190
	DorisParserParserRULE_predicate                      = 191
	DorisParserParserRULE_valueExpression                = 192
	DorisParserParserRULE_primaryExpression              = 193
	DorisParserParserRULE_exceptOrReplace                = 194
	DorisParserParserRULE_castDataType                   = 195
	DorisParserParserRULE_functionCallExpression         = 196
	DorisParserParserRULE_functionIdentifier             = 197
	DorisParserParserRULE_functionNameIdentifier         = 198
	DorisParserParserRULE_windowSpec                     = 199
	DorisParserParserRULE_windowFrame                    = 200
	DorisParserParserRULE_frameUnits                     = 201
	DorisParserParserRULE_frameBoundary                  = 202
	DorisParserParserRULE_qualifiedName                  = 203
	DorisParserParserRULE_specifiedPartition             = 204
	DorisParserParserRULE_constant                       = 205
	DorisParserParserRULE_comparisonOperator             = 206
	DorisParserParserRULE_booleanValue                   = 207
	DorisParserParserRULE_whenClause                     = 208
	DorisParserParserRULE_interval                       = 209
	DorisParserParserRULE_unitIdentifier                 = 210
	DorisParserParserRULE_dataTypeWithNullable           = 211
	DorisParserParserRULE_dataType                       = 212
	DorisParserParserRULE_primitiveColType               = 213
	DorisParserParserRULE_complexColTypeList             = 214
	DorisParserParserRULE_complexColType                 = 215
	DorisParserParserRULE_commentSpec                    = 216
	DorisParserParserRULE_sample                         = 217
	DorisParserParserRULE_sampleMethod                   = 218
	DorisParserParserRULE_tableSnapshot                  = 219
	DorisParserParserRULE_errorCapturingIdentifier       = 220
	DorisParserParserRULE_errorCapturingIdentifierExtra  = 221
	DorisParserParserRULE_identifier                     = 222
	DorisParserParserRULE_strictIdentifier               = 223
	DorisParserParserRULE_quotedIdentifier               = 224
	DorisParserParserRULE_number                         = 225
	DorisParserParserRULE_nonReserved                    = 226
)

// IMultiStatementsContext is an interface to support dynamic dispatch.
type IMultiStatementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EOF() antlr.TerminalNode
	AllSEMICOLON() []antlr.TerminalNode
	SEMICOLON(i int) antlr.TerminalNode
	AllStatement() []IStatementContext
	Statement(i int) IStatementContext

	// IsMultiStatementsContext differentiates from other interfaces.
	IsMultiStatementsContext()
}

type MultiStatementsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultiStatementsContext() *MultiStatementsContext {
	var p = new(MultiStatementsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_multiStatements
	return p
}

func InitEmptyMultiStatementsContext(p *MultiStatementsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_multiStatements
}

func (*MultiStatementsContext) IsMultiStatementsContext() {}

func NewMultiStatementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiStatementsContext {
	var p = new(MultiStatementsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_multiStatements

	return p
}

func (s *MultiStatementsContext) GetParser() antlr.Parser { return s.parser }

func (s *MultiStatementsContext) EOF() antlr.TerminalNode {
	return s.GetToken(DorisParserParserEOF, 0)
}

func (s *MultiStatementsContext) AllSEMICOLON() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserSEMICOLON)
}

func (s *MultiStatementsContext) SEMICOLON(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserSEMICOLON, i)
}

func (s *MultiStatementsContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *MultiStatementsContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *MultiStatementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiStatementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultiStatementsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitMultiStatements(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) MultiStatements() (localctx IMultiStatementsContext) {
	localctx = NewMultiStatementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, DorisParserParserRULE_multiStatements)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(457)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 0, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(454)
				p.Match(DorisParserParserSEMICOLON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(459)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 0, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(461)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&288231200791756804) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&171799741443) != 0) || ((int64((_la-129)) & ^0x3f) == 0 && ((int64(1)<<(_la-129))&26388279328781) != 0) || ((int64((_la-202)) & ^0x3f) == 0 && ((int64(1)<<(_la-202))&9007200865354753) != 0) || _la == DorisParserParserLOAD || _la == DorisParserParserLOCK || ((int64((_la-338)) & ^0x3f) == 0 && ((int64(1)<<(_la-338))&621532276546601089) != 0) || ((int64((_la-403)) & ^0x3f) == 0 && ((int64(1)<<(_la-403))&105699147386881) != 0) || ((int64((_la-476)) & ^0x3f) == 0 && ((int64(1)<<(_la-476))&69793769025) != 0) {
		{
			p.SetState(460)
			p.Statement()
		}

	}
	p.SetState(471)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 3, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(464)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for ok := true; ok; ok = _la == DorisParserParserSEMICOLON {
				{
					p.SetState(463)
					p.Match(DorisParserParserSEMICOLON)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

				p.SetState(466)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(468)
				p.Statement()
			}

		}
		p.SetState(473)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 3, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(477)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisParserParserSEMICOLON {
		{
			p.SetState(474)
			p.Match(DorisParserParserSEMICOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(479)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(480)
		p.Match(DorisParserParserEOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISingleStatementContext is an interface to support dynamic dispatch.
type ISingleStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EOF() antlr.TerminalNode
	AllSEMICOLON() []antlr.TerminalNode
	SEMICOLON(i int) antlr.TerminalNode
	Statement() IStatementContext

	// IsSingleStatementContext differentiates from other interfaces.
	IsSingleStatementContext()
}

type SingleStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySingleStatementContext() *SingleStatementContext {
	var p = new(SingleStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_singleStatement
	return p
}

func InitEmptySingleStatementContext(p *SingleStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_singleStatement
}

func (*SingleStatementContext) IsSingleStatementContext() {}

func NewSingleStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SingleStatementContext {
	var p = new(SingleStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_singleStatement

	return p
}

func (s *SingleStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SingleStatementContext) EOF() antlr.TerminalNode {
	return s.GetToken(DorisParserParserEOF, 0)
}

func (s *SingleStatementContext) AllSEMICOLON() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserSEMICOLON)
}

func (s *SingleStatementContext) SEMICOLON(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserSEMICOLON, i)
}

func (s *SingleStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *SingleStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SingleStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SingleStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitSingleStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) SingleStatement() (localctx ISingleStatementContext) {
	localctx = NewSingleStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, DorisParserParserRULE_singleStatement)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(485)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 5, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(482)
				p.Match(DorisParserParserSEMICOLON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(487)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 5, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(489)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&288231200791756804) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&171799741443) != 0) || ((int64((_la-129)) & ^0x3f) == 0 && ((int64(1)<<(_la-129))&26388279328781) != 0) || ((int64((_la-202)) & ^0x3f) == 0 && ((int64(1)<<(_la-202))&9007200865354753) != 0) || _la == DorisParserParserLOAD || _la == DorisParserParserLOCK || ((int64((_la-338)) & ^0x3f) == 0 && ((int64(1)<<(_la-338))&621532276546601089) != 0) || ((int64((_la-403)) & ^0x3f) == 0 && ((int64(1)<<(_la-403))&105699147386881) != 0) || ((int64((_la-476)) & ^0x3f) == 0 && ((int64(1)<<(_la-476))&69793769025) != 0) {
		{
			p.SetState(488)
			p.Statement()
		}

	}
	p.SetState(494)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisParserParserSEMICOLON {
		{
			p.SetState(491)
			p.Match(DorisParserParserSEMICOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(496)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(497)
		p.Match(DorisParserParserEOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStatementContext is an interface to support dynamic dispatch.
type IStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsStatementContext differentiates from other interfaces.
	IsStatementContext()
}

type StatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementContext() *StatementContext {
	var p = new(StatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_statement
	return p
}

func InitEmptyStatementContext(p *StatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_statement
}

func (*StatementContext) IsStatementContext() {}

func NewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementContext {
	var p = new(StatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_statement

	return p
}

func (s *StatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementContext) CopyAll(ctx *StatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *StatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ShowCreateProcedureContext struct {
	StatementContext
	name IMultipartIdentifierContext
}

func NewShowCreateProcedureContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowCreateProcedureContext {
	var p = new(ShowCreateProcedureContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *ShowCreateProcedureContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *ShowCreateProcedureContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *ShowCreateProcedureContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCreateProcedureContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSHOW, 0)
}

func (s *ShowCreateProcedureContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCREATE, 0)
}

func (s *ShowCreateProcedureContext) PROCEDURE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserPROCEDURE, 0)
}

func (s *ShowCreateProcedureContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowCreateProcedureContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitShowCreateProcedure(s)

	default:
		return t.VisitChildren(s)
	}
}

type StatementBaseAliasContext struct {
	StatementContext
}

func NewStatementBaseAliasContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StatementBaseAliasContext {
	var p = new(StatementBaseAliasContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *StatementBaseAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementBaseAliasContext) StatementBase() IStatementBaseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementBaseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementBaseContext)
}

func (s *StatementBaseAliasContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitStatementBaseAlias(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowProcedureStatusContext struct {
	StatementContext
	pattern IValueExpressionContext
}

func NewShowProcedureStatusContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowProcedureStatusContext {
	var p = new(ShowProcedureStatusContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *ShowProcedureStatusContext) GetPattern() IValueExpressionContext { return s.pattern }

func (s *ShowProcedureStatusContext) SetPattern(v IValueExpressionContext) { s.pattern = v }

func (s *ShowProcedureStatusContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowProcedureStatusContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSHOW, 0)
}

func (s *ShowProcedureStatusContext) STATUS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTATUS, 0)
}

func (s *ShowProcedureStatusContext) PROCEDURE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserPROCEDURE, 0)
}

func (s *ShowProcedureStatusContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFUNCTION, 0)
}

func (s *ShowProcedureStatusContext) LIKE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLIKE, 0)
}

func (s *ShowProcedureStatusContext) WhereClause() IWhereClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhereClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhereClauseContext)
}

func (s *ShowProcedureStatusContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ShowProcedureStatusContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitShowProcedureStatus(s)

	default:
		return t.VisitChildren(s)
	}
}

type CreateProcedureContext struct {
	StatementContext
	name IMultipartIdentifierContext
}

func NewCreateProcedureContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateProcedureContext {
	var p = new(CreateProcedureContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *CreateProcedureContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *CreateProcedureContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *CreateProcedureContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateProcedureContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLEFT_PAREN, 0)
}

func (s *CreateProcedureContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRIGHT_PAREN, 0)
}

func (s *CreateProcedureContext) PROCEDURE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserPROCEDURE, 0)
}

func (s *CreateProcedureContext) PROC() antlr.TerminalNode {
	return s.GetToken(DorisParserParserPROC, 0)
}

func (s *CreateProcedureContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *CreateProcedureContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserParserALTER, 0)
}

func (s *CreateProcedureContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCREATE, 0)
}

func (s *CreateProcedureContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserREPLACE, 0)
}

func (s *CreateProcedureContext) OR() antlr.TerminalNode {
	return s.GetToken(DorisParserParserOR, 0)
}

func (s *CreateProcedureContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitCreateProcedure(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowConfigContext struct {
	StatementContext
	type_     antlr.Token
	pattern   IValueExpressionContext
	backendId antlr.Token
}

func NewShowConfigContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowConfigContext {
	var p = new(ShowConfigContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *ShowConfigContext) GetType_() antlr.Token { return s.type_ }

func (s *ShowConfigContext) GetBackendId() antlr.Token { return s.backendId }

func (s *ShowConfigContext) SetType_(v antlr.Token) { s.type_ = v }

func (s *ShowConfigContext) SetBackendId(v antlr.Token) { s.backendId = v }

func (s *ShowConfigContext) GetPattern() IValueExpressionContext { return s.pattern }

func (s *ShowConfigContext) SetPattern(v IValueExpressionContext) { s.pattern = v }

func (s *ShowConfigContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowConfigContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSHOW, 0)
}

func (s *ShowConfigContext) CONFIG() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCONFIG, 0)
}

func (s *ShowConfigContext) FRONTEND() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFRONTEND, 0)
}

func (s *ShowConfigContext) BACKEND() antlr.TerminalNode {
	return s.GetToken(DorisParserParserBACKEND, 0)
}

func (s *ShowConfigContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserADMIN, 0)
}

func (s *ShowConfigContext) LIKE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLIKE, 0)
}

func (s *ShowConfigContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFROM, 0)
}

func (s *ShowConfigContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ShowConfigContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserINTEGER_VALUE, 0)
}

func (s *ShowConfigContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitShowConfig(s)

	default:
		return t.VisitChildren(s)
	}
}

type CallProcedureContext struct {
	StatementContext
	name IMultipartIdentifierContext
}

func NewCallProcedureContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CallProcedureContext {
	var p = new(CallProcedureContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *CallProcedureContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *CallProcedureContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *CallProcedureContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CallProcedureContext) CALL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCALL, 0)
}

func (s *CallProcedureContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLEFT_PAREN, 0)
}

func (s *CallProcedureContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRIGHT_PAREN, 0)
}

func (s *CallProcedureContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *CallProcedureContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *CallProcedureContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CallProcedureContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserCOMMA)
}

func (s *CallProcedureContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOMMA, i)
}

func (s *CallProcedureContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitCallProcedure(s)

	default:
		return t.VisitChildren(s)
	}
}

type DropProcedureContext struct {
	StatementContext
	name IMultipartIdentifierContext
}

func NewDropProcedureContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropProcedureContext {
	var p = new(DropProcedureContext)

	InitEmptyStatementContext(&p.StatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementContext))

	return p
}

func (s *DropProcedureContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *DropProcedureContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *DropProcedureContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropProcedureContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDROP, 0)
}

func (s *DropProcedureContext) PROCEDURE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserPROCEDURE, 0)
}

func (s *DropProcedureContext) PROC() antlr.TerminalNode {
	return s.GetToken(DorisParserParserPROC, 0)
}

func (s *DropProcedureContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *DropProcedureContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserParserIF, 0)
}

func (s *DropProcedureContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserEXISTS, 0)
}

func (s *DropProcedureContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitDropProcedure(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) Statement() (localctx IStatementContext) {
	localctx = NewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, DorisParserParserRULE_statement)
	var _la int

	var _alt int

	p.SetState(573)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 19, p.GetParserRuleContext()) {
	case 1:
		localctx = NewStatementBaseAliasContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(499)
			p.StatementBase()
		}

	case 2:
		localctx = NewCallProcedureContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(500)
			p.Match(DorisParserParserCALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(501)

			var _x = p.MultipartIdentifier()

			localctx.(*CallProcedureContext).name = _x
		}
		{
			p.SetState(502)
			p.Match(DorisParserParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(511)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-2305884869834611068) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&4610552282352573437) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-9079382760121755163) != 0) || ((int64((_la-192)) & ^0x3f) == 0 && ((int64(1)<<(_la-192))&4321098383830537129) != 0) || ((int64((_la-256)) & ^0x3f) == 0 && ((int64(1)<<(_la-256))&-5206443760946300951) != 0) || ((int64((_la-320)) & ^0x3f) == 0 && ((int64(1)<<(_la-320))&-4187784802352497917) != 0) || ((int64((_la-384)) & ^0x3f) == 0 && ((int64(1)<<(_la-384))&9222796779122712571) != 0) || ((int64((_la-452)) & ^0x3f) == 0 && ((int64(1)<<(_la-452))&2449945648132536049) != 0) || ((int64((_la-517)) & ^0x3f) == 0 && ((int64(1)<<(_la-517))&236487517953) != 0) {
			{
				p.SetState(503)
				p.Expression()
			}
			p.SetState(508)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == DorisParserParserCOMMA {
				{
					p.SetState(504)
					p.Match(DorisParserParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(505)
					p.Expression()
				}

				p.SetState(510)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(513)
			p.Match(DorisParserParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		localctx = NewCreateProcedureContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		p.SetState(522)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserParserALTER:
			{
				p.SetState(515)
				p.Match(DorisParserParserALTER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserParserCREATE:
			{
				p.SetState(516)
				p.Match(DorisParserParserCREATE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(519)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserParserOR {
				{
					p.SetState(517)
					p.Match(DorisParserParserOR)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(518)
					p.Match(DorisParserParserREPLACE)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}

		case DorisParserParserREPLACE:
			{
				p.SetState(521)
				p.Match(DorisParserParserREPLACE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(524)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserParserPROC || _la == DorisParserParserPROCEDURE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(525)

			var _x = p.MultipartIdentifier()

			localctx.(*CreateProcedureContext).name = _x
		}
		{
			p.SetState(526)
			p.Match(DorisParserParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(530)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 12, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 1 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1+1 {
				p.SetState(527)
				p.MatchWildcard()

			}
			p.SetState(532)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 12, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		{
			p.SetState(533)
			p.Match(DorisParserParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(537)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 13, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 1 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1+1 {
				p.SetState(534)
				p.MatchWildcard()

			}
			p.SetState(539)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 13, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case 4:
		localctx = NewDropProcedureContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(540)
			p.Match(DorisParserParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(541)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserParserPROC || _la == DorisParserParserPROCEDURE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(544)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserIF {
			{
				p.SetState(542)
				p.Match(DorisParserParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(543)
				p.Match(DorisParserParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(546)

			var _x = p.MultipartIdentifier()

			localctx.(*DropProcedureContext).name = _x
		}

	case 5:
		localctx = NewShowProcedureStatusContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(547)
			p.Match(DorisParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(548)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserParserFUNCTION || _la == DorisParserParserPROCEDURE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(549)
			p.Match(DorisParserParserSTATUS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(553)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		switch p.GetTokenStream().LA(1) {
		case DorisParserParserLIKE:
			{
				p.SetState(550)
				p.Match(DorisParserParserLIKE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(551)

				var _x = p.valueExpression(0)

				localctx.(*ShowProcedureStatusContext).pattern = _x
			}

		case DorisParserParserWHERE:
			{
				p.SetState(552)
				p.WhereClause()
			}

		case DorisParserParserEOF, DorisParserParserSEMICOLON:

		default:
		}

	case 6:
		localctx = NewShowCreateProcedureContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(555)
			p.Match(DorisParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(556)
			p.Match(DorisParserParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(557)
			p.Match(DorisParserParserPROCEDURE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(558)

			var _x = p.MultipartIdentifier()

			localctx.(*ShowCreateProcedureContext).name = _x
		}

	case 7:
		localctx = NewShowConfigContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		p.SetState(560)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserADMIN {
			{
				p.SetState(559)
				p.Match(DorisParserParserADMIN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(562)
			p.Match(DorisParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(563)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ShowConfigContext).type_ = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserParserBACKEND || _la == DorisParserParserFRONTEND) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ShowConfigContext).type_ = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(564)
			p.Match(DorisParserParserCONFIG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(567)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserLIKE {
			{
				p.SetState(565)
				p.Match(DorisParserParserLIKE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(566)

				var _x = p.valueExpression(0)

				localctx.(*ShowConfigContext).pattern = _x
			}

		}
		p.SetState(571)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserFROM {
			{
				p.SetState(569)
				p.Match(DorisParserParserFROM)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(570)

				var _m = p.Match(DorisParserParserINTEGER_VALUE)

				localctx.(*ShowConfigContext).backendId = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStatementBaseContext is an interface to support dynamic dispatch.
type IStatementBaseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsStatementBaseContext differentiates from other interfaces.
	IsStatementBaseContext()
}

type StatementBaseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementBaseContext() *StatementBaseContext {
	var p = new(StatementBaseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_statementBase
	return p
}

func InitEmptyStatementBaseContext(p *StatementBaseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_statementBase
}

func (*StatementBaseContext) IsStatementBaseContext() {}

func NewStatementBaseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementBaseContext {
	var p = new(StatementBaseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_statementBase

	return p
}

func (s *StatementBaseContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementBaseContext) CopyAll(ctx *StatementBaseContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *StatementBaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementBaseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SupportedSetStatementAliasContext struct {
	StatementBaseContext
}

func NewSupportedSetStatementAliasContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SupportedSetStatementAliasContext {
	var p = new(SupportedSetStatementAliasContext)

	InitEmptyStatementBaseContext(&p.StatementBaseContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementBaseContext))

	return p
}

func (s *SupportedSetStatementAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedSetStatementAliasContext) SupportedSetStatement() ISupportedSetStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISupportedSetStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISupportedSetStatementContext)
}

func (s *SupportedSetStatementAliasContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitSupportedSetStatementAlias(s)

	default:
		return t.VisitChildren(s)
	}
}

type ConstraintStatementAliasContext struct {
	StatementBaseContext
}

func NewConstraintStatementAliasContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ConstraintStatementAliasContext {
	var p = new(ConstraintStatementAliasContext)

	InitEmptyStatementBaseContext(&p.StatementBaseContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementBaseContext))

	return p
}

func (s *ConstraintStatementAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstraintStatementAliasContext) ConstraintStatement() IConstraintStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstraintStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstraintStatementContext)
}

func (s *ConstraintStatementAliasContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitConstraintStatementAlias(s)

	default:
		return t.VisitChildren(s)
	}
}

type SupportedKillStatementAliasContext struct {
	StatementBaseContext
}

func NewSupportedKillStatementAliasContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SupportedKillStatementAliasContext {
	var p = new(SupportedKillStatementAliasContext)

	InitEmptyStatementBaseContext(&p.StatementBaseContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementBaseContext))

	return p
}

func (s *SupportedKillStatementAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedKillStatementAliasContext) SupportedKillStatement() ISupportedKillStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISupportedKillStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISupportedKillStatementContext)
}

func (s *SupportedKillStatementAliasContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitSupportedKillStatementAlias(s)

	default:
		return t.VisitChildren(s)
	}
}

type SupportedRecoverStatementAliasContext struct {
	StatementBaseContext
}

func NewSupportedRecoverStatementAliasContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SupportedRecoverStatementAliasContext {
	var p = new(SupportedRecoverStatementAliasContext)

	InitEmptyStatementBaseContext(&p.StatementBaseContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementBaseContext))

	return p
}

func (s *SupportedRecoverStatementAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedRecoverStatementAliasContext) SupportedRecoverStatement() ISupportedRecoverStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISupportedRecoverStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISupportedRecoverStatementContext)
}

func (s *SupportedRecoverStatementAliasContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitSupportedRecoverStatementAlias(s)

	default:
		return t.VisitChildren(s)
	}
}

type SupportedJobStatementAliasContext struct {
	StatementBaseContext
}

func NewSupportedJobStatementAliasContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SupportedJobStatementAliasContext {
	var p = new(SupportedJobStatementAliasContext)

	InitEmptyStatementBaseContext(&p.StatementBaseContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementBaseContext))

	return p
}

func (s *SupportedJobStatementAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedJobStatementAliasContext) SupportedJobStatement() ISupportedJobStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISupportedJobStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISupportedJobStatementContext)
}

func (s *SupportedJobStatementAliasContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitSupportedJobStatementAlias(s)

	default:
		return t.VisitChildren(s)
	}
}

type UnsupportedContext struct {
	StatementBaseContext
}

func NewUnsupportedContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnsupportedContext {
	var p = new(UnsupportedContext)

	InitEmptyStatementBaseContext(&p.StatementBaseContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementBaseContext))

	return p
}

func (s *UnsupportedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnsupportedContext) UnsupportedStatement() IUnsupportedStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnsupportedStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnsupportedStatementContext)
}

func (s *UnsupportedContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitUnsupported(s)

	default:
		return t.VisitChildren(s)
	}
}

type StatementDefaultContext struct {
	StatementBaseContext
}

func NewStatementDefaultContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StatementDefaultContext {
	var p = new(StatementDefaultContext)

	InitEmptyStatementBaseContext(&p.StatementBaseContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementBaseContext))

	return p
}

func (s *StatementDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementDefaultContext) Query() IQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *StatementDefaultContext) Explain() IExplainContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExplainContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExplainContext)
}

func (s *StatementDefaultContext) OutFileClause() IOutFileClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOutFileClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOutFileClauseContext)
}

func (s *StatementDefaultContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitStatementDefault(s)

	default:
		return t.VisitChildren(s)
	}
}

type SupportedAdminStatementAliasContext struct {
	StatementBaseContext
}

func NewSupportedAdminStatementAliasContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SupportedAdminStatementAliasContext {
	var p = new(SupportedAdminStatementAliasContext)

	InitEmptyStatementBaseContext(&p.StatementBaseContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementBaseContext))

	return p
}

func (s *SupportedAdminStatementAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedAdminStatementAliasContext) SupportedAdminStatement() ISupportedAdminStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISupportedAdminStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISupportedAdminStatementContext)
}

func (s *SupportedAdminStatementAliasContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitSupportedAdminStatementAlias(s)

	default:
		return t.VisitChildren(s)
	}
}

type SupportedStatsStatementAliasContext struct {
	StatementBaseContext
}

func NewSupportedStatsStatementAliasContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SupportedStatsStatementAliasContext {
	var p = new(SupportedStatsStatementAliasContext)

	InitEmptyStatementBaseContext(&p.StatementBaseContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementBaseContext))

	return p
}

func (s *SupportedStatsStatementAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedStatsStatementAliasContext) SupportedStatsStatement() ISupportedStatsStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISupportedStatsStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISupportedStatsStatementContext)
}

func (s *SupportedStatsStatementAliasContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitSupportedStatsStatementAlias(s)

	default:
		return t.VisitChildren(s)
	}
}

type SupportedDescribeStatementAliasContext struct {
	StatementBaseContext
}

func NewSupportedDescribeStatementAliasContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SupportedDescribeStatementAliasContext {
	var p = new(SupportedDescribeStatementAliasContext)

	InitEmptyStatementBaseContext(&p.StatementBaseContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementBaseContext))

	return p
}

func (s *SupportedDescribeStatementAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedDescribeStatementAliasContext) SupportedDescribeStatement() ISupportedDescribeStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISupportedDescribeStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISupportedDescribeStatementContext)
}

func (s *SupportedDescribeStatementAliasContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitSupportedDescribeStatementAlias(s)

	default:
		return t.VisitChildren(s)
	}
}

type SupportedCancelStatementAliasContext struct {
	StatementBaseContext
}

func NewSupportedCancelStatementAliasContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SupportedCancelStatementAliasContext {
	var p = new(SupportedCancelStatementAliasContext)

	InitEmptyStatementBaseContext(&p.StatementBaseContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementBaseContext))

	return p
}

func (s *SupportedCancelStatementAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedCancelStatementAliasContext) SupportedCancelStatement() ISupportedCancelStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISupportedCancelStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISupportedCancelStatementContext)
}

func (s *SupportedCancelStatementAliasContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitSupportedCancelStatementAlias(s)

	default:
		return t.VisitChildren(s)
	}
}

type SupportedOtherStatementAliasContext struct {
	StatementBaseContext
}

func NewSupportedOtherStatementAliasContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SupportedOtherStatementAliasContext {
	var p = new(SupportedOtherStatementAliasContext)

	InitEmptyStatementBaseContext(&p.StatementBaseContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementBaseContext))

	return p
}

func (s *SupportedOtherStatementAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedOtherStatementAliasContext) SupportedOtherStatement() ISupportedOtherStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISupportedOtherStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISupportedOtherStatementContext)
}

func (s *SupportedOtherStatementAliasContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitSupportedOtherStatementAlias(s)

	default:
		return t.VisitChildren(s)
	}
}

type SupportedDmlStatementAliasContext struct {
	StatementBaseContext
}

func NewSupportedDmlStatementAliasContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SupportedDmlStatementAliasContext {
	var p = new(SupportedDmlStatementAliasContext)

	InitEmptyStatementBaseContext(&p.StatementBaseContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementBaseContext))

	return p
}

func (s *SupportedDmlStatementAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedDmlStatementAliasContext) SupportedDmlStatement() ISupportedDmlStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISupportedDmlStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISupportedDmlStatementContext)
}

func (s *SupportedDmlStatementAliasContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitSupportedDmlStatementAlias(s)

	default:
		return t.VisitChildren(s)
	}
}

type SupportedLoadStatementAliasContext struct {
	StatementBaseContext
}

func NewSupportedLoadStatementAliasContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SupportedLoadStatementAliasContext {
	var p = new(SupportedLoadStatementAliasContext)

	InitEmptyStatementBaseContext(&p.StatementBaseContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementBaseContext))

	return p
}

func (s *SupportedLoadStatementAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedLoadStatementAliasContext) SupportedLoadStatement() ISupportedLoadStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISupportedLoadStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISupportedLoadStatementContext)
}

func (s *SupportedLoadStatementAliasContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitSupportedLoadStatementAlias(s)

	default:
		return t.VisitChildren(s)
	}
}

type SupportedTransactionStatementAliasContext struct {
	StatementBaseContext
}

func NewSupportedTransactionStatementAliasContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SupportedTransactionStatementAliasContext {
	var p = new(SupportedTransactionStatementAliasContext)

	InitEmptyStatementBaseContext(&p.StatementBaseContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementBaseContext))

	return p
}

func (s *SupportedTransactionStatementAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedTransactionStatementAliasContext) SupportedTransactionStatement() ISupportedTransactionStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISupportedTransactionStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISupportedTransactionStatementContext)
}

func (s *SupportedTransactionStatementAliasContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitSupportedTransactionStatementAlias(s)

	default:
		return t.VisitChildren(s)
	}
}

type SupportedGrantRevokeStatementAliasContext struct {
	StatementBaseContext
}

func NewSupportedGrantRevokeStatementAliasContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SupportedGrantRevokeStatementAliasContext {
	var p = new(SupportedGrantRevokeStatementAliasContext)

	InitEmptyStatementBaseContext(&p.StatementBaseContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementBaseContext))

	return p
}

func (s *SupportedGrantRevokeStatementAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedGrantRevokeStatementAliasContext) SupportedGrantRevokeStatement() ISupportedGrantRevokeStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISupportedGrantRevokeStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISupportedGrantRevokeStatementContext)
}

func (s *SupportedGrantRevokeStatementAliasContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitSupportedGrantRevokeStatementAlias(s)

	default:
		return t.VisitChildren(s)
	}
}

type SupportedAlterStatementAliasContext struct {
	StatementBaseContext
}

func NewSupportedAlterStatementAliasContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SupportedAlterStatementAliasContext {
	var p = new(SupportedAlterStatementAliasContext)

	InitEmptyStatementBaseContext(&p.StatementBaseContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementBaseContext))

	return p
}

func (s *SupportedAlterStatementAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedAlterStatementAliasContext) SupportedAlterStatement() ISupportedAlterStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISupportedAlterStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISupportedAlterStatementContext)
}

func (s *SupportedAlterStatementAliasContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitSupportedAlterStatementAlias(s)

	default:
		return t.VisitChildren(s)
	}
}

type SupportedCleanStatementAliasContext struct {
	StatementBaseContext
}

func NewSupportedCleanStatementAliasContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SupportedCleanStatementAliasContext {
	var p = new(SupportedCleanStatementAliasContext)

	InitEmptyStatementBaseContext(&p.StatementBaseContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementBaseContext))

	return p
}

func (s *SupportedCleanStatementAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedCleanStatementAliasContext) SupportedCleanStatement() ISupportedCleanStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISupportedCleanStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISupportedCleanStatementContext)
}

func (s *SupportedCleanStatementAliasContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitSupportedCleanStatementAlias(s)

	default:
		return t.VisitChildren(s)
	}
}

type SupportedUnsetStatementAliasContext struct {
	StatementBaseContext
}

func NewSupportedUnsetStatementAliasContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SupportedUnsetStatementAliasContext {
	var p = new(SupportedUnsetStatementAliasContext)

	InitEmptyStatementBaseContext(&p.StatementBaseContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementBaseContext))

	return p
}

func (s *SupportedUnsetStatementAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedUnsetStatementAliasContext) SupportedUnsetStatement() ISupportedUnsetStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISupportedUnsetStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISupportedUnsetStatementContext)
}

func (s *SupportedUnsetStatementAliasContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitSupportedUnsetStatementAlias(s)

	default:
		return t.VisitChildren(s)
	}
}

type SupportedUseStatementAliasContext struct {
	StatementBaseContext
}

func NewSupportedUseStatementAliasContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SupportedUseStatementAliasContext {
	var p = new(SupportedUseStatementAliasContext)

	InitEmptyStatementBaseContext(&p.StatementBaseContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementBaseContext))

	return p
}

func (s *SupportedUseStatementAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedUseStatementAliasContext) SupportedUseStatement() ISupportedUseStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISupportedUseStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISupportedUseStatementContext)
}

func (s *SupportedUseStatementAliasContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitSupportedUseStatementAlias(s)

	default:
		return t.VisitChildren(s)
	}
}

type MaterializedViewStatementAliasContext struct {
	StatementBaseContext
}

func NewMaterializedViewStatementAliasContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MaterializedViewStatementAliasContext {
	var p = new(MaterializedViewStatementAliasContext)

	InitEmptyStatementBaseContext(&p.StatementBaseContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementBaseContext))

	return p
}

func (s *MaterializedViewStatementAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MaterializedViewStatementAliasContext) MaterializedViewStatement() IMaterializedViewStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMaterializedViewStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMaterializedViewStatementContext)
}

func (s *MaterializedViewStatementAliasContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitMaterializedViewStatementAlias(s)

	default:
		return t.VisitChildren(s)
	}
}

type SupportedDropStatementAliasContext struct {
	StatementBaseContext
}

func NewSupportedDropStatementAliasContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SupportedDropStatementAliasContext {
	var p = new(SupportedDropStatementAliasContext)

	InitEmptyStatementBaseContext(&p.StatementBaseContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementBaseContext))

	return p
}

func (s *SupportedDropStatementAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedDropStatementAliasContext) SupportedDropStatement() ISupportedDropStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISupportedDropStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISupportedDropStatementContext)
}

func (s *SupportedDropStatementAliasContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitSupportedDropStatementAlias(s)

	default:
		return t.VisitChildren(s)
	}
}

type SupportedCreateStatementAliasContext struct {
	StatementBaseContext
}

func NewSupportedCreateStatementAliasContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SupportedCreateStatementAliasContext {
	var p = new(SupportedCreateStatementAliasContext)

	InitEmptyStatementBaseContext(&p.StatementBaseContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementBaseContext))

	return p
}

func (s *SupportedCreateStatementAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedCreateStatementAliasContext) SupportedCreateStatement() ISupportedCreateStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISupportedCreateStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISupportedCreateStatementContext)
}

func (s *SupportedCreateStatementAliasContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitSupportedCreateStatementAlias(s)

	default:
		return t.VisitChildren(s)
	}
}

type SupportedShowStatementAliasContext struct {
	StatementBaseContext
}

func NewSupportedShowStatementAliasContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SupportedShowStatementAliasContext {
	var p = new(SupportedShowStatementAliasContext)

	InitEmptyStatementBaseContext(&p.StatementBaseContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementBaseContext))

	return p
}

func (s *SupportedShowStatementAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedShowStatementAliasContext) SupportedShowStatement() ISupportedShowStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISupportedShowStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISupportedShowStatementContext)
}

func (s *SupportedShowStatementAliasContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitSupportedShowStatementAlias(s)

	default:
		return t.VisitChildren(s)
	}
}

type SupportedRefreshStatementAliasContext struct {
	StatementBaseContext
}

func NewSupportedRefreshStatementAliasContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SupportedRefreshStatementAliasContext {
	var p = new(SupportedRefreshStatementAliasContext)

	InitEmptyStatementBaseContext(&p.StatementBaseContext)
	p.parser = parser
	p.CopyAll(ctx.(*StatementBaseContext))

	return p
}

func (s *SupportedRefreshStatementAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedRefreshStatementAliasContext) SupportedRefreshStatement() ISupportedRefreshStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISupportedRefreshStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISupportedRefreshStatementContext)
}

func (s *SupportedRefreshStatementAliasContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitSupportedRefreshStatementAlias(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) StatementBase() (localctx IStatementBaseContext) {
	localctx = NewStatementBaseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, DorisParserParserRULE_statementBase)
	var _la int

	p.SetState(606)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 22, p.GetParserRuleContext()) {
	case 1:
		localctx = NewStatementDefaultContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		p.SetState(576)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if (int64((_la-131)) & ^0x3f) == 0 && ((int64(1)<<(_la-131))&2199023255555) != 0 {
			{
				p.SetState(575)
				p.Explain()
			}

		}
		{
			p.SetState(578)
			p.Query()
		}
		p.SetState(580)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserINTO {
			{
				p.SetState(579)
				p.OutFileClause()
			}

		}

	case 2:
		localctx = NewSupportedDmlStatementAliasContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(582)
			p.SupportedDmlStatement()
		}

	case 3:
		localctx = NewSupportedCreateStatementAliasContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(583)
			p.SupportedCreateStatement()
		}

	case 4:
		localctx = NewSupportedAlterStatementAliasContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(584)
			p.SupportedAlterStatement()
		}

	case 5:
		localctx = NewMaterializedViewStatementAliasContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(585)
			p.MaterializedViewStatement()
		}

	case 6:
		localctx = NewSupportedJobStatementAliasContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(586)
			p.SupportedJobStatement()
		}

	case 7:
		localctx = NewConstraintStatementAliasContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(587)
			p.ConstraintStatement()
		}

	case 8:
		localctx = NewSupportedCleanStatementAliasContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(588)
			p.SupportedCleanStatement()
		}

	case 9:
		localctx = NewSupportedDescribeStatementAliasContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(589)
			p.SupportedDescribeStatement()
		}

	case 10:
		localctx = NewSupportedDropStatementAliasContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(590)
			p.SupportedDropStatement()
		}

	case 11:
		localctx = NewSupportedSetStatementAliasContext(p, localctx)
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(591)
			p.SupportedSetStatement()
		}

	case 12:
		localctx = NewSupportedUnsetStatementAliasContext(p, localctx)
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(592)
			p.SupportedUnsetStatement()
		}

	case 13:
		localctx = NewSupportedRefreshStatementAliasContext(p, localctx)
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(593)
			p.SupportedRefreshStatement()
		}

	case 14:
		localctx = NewSupportedShowStatementAliasContext(p, localctx)
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(594)
			p.SupportedShowStatement()
		}

	case 15:
		localctx = NewSupportedLoadStatementAliasContext(p, localctx)
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(595)
			p.SupportedLoadStatement()
		}

	case 16:
		localctx = NewSupportedCancelStatementAliasContext(p, localctx)
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(596)
			p.SupportedCancelStatement()
		}

	case 17:
		localctx = NewSupportedRecoverStatementAliasContext(p, localctx)
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(597)
			p.SupportedRecoverStatement()
		}

	case 18:
		localctx = NewSupportedAdminStatementAliasContext(p, localctx)
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(598)
			p.SupportedAdminStatement()
		}

	case 19:
		localctx = NewSupportedUseStatementAliasContext(p, localctx)
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(599)
			p.SupportedUseStatement()
		}

	case 20:
		localctx = NewSupportedOtherStatementAliasContext(p, localctx)
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(600)
			p.SupportedOtherStatement()
		}

	case 21:
		localctx = NewSupportedKillStatementAliasContext(p, localctx)
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(601)
			p.SupportedKillStatement()
		}

	case 22:
		localctx = NewSupportedStatsStatementAliasContext(p, localctx)
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(602)
			p.SupportedStatsStatement()
		}

	case 23:
		localctx = NewSupportedTransactionStatementAliasContext(p, localctx)
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(603)
			p.SupportedTransactionStatement()
		}

	case 24:
		localctx = NewSupportedGrantRevokeStatementAliasContext(p, localctx)
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(604)
			p.SupportedGrantRevokeStatement()
		}

	case 25:
		localctx = NewUnsupportedContext(p, localctx)
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(605)
			p.UnsupportedStatement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnsupportedStatementContext is an interface to support dynamic dispatch.
type IUnsupportedStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UnsupportedStatsStatement() IUnsupportedStatsStatementContext
	UnsupportedAdminStatement() IUnsupportedAdminStatementContext
	UnsupportedLoadStatement() IUnsupportedLoadStatementContext
	UnsupportedOtherStatement() IUnsupportedOtherStatementContext

	// IsUnsupportedStatementContext differentiates from other interfaces.
	IsUnsupportedStatementContext()
}

type UnsupportedStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnsupportedStatementContext() *UnsupportedStatementContext {
	var p = new(UnsupportedStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_unsupportedStatement
	return p
}

func InitEmptyUnsupportedStatementContext(p *UnsupportedStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_unsupportedStatement
}

func (*UnsupportedStatementContext) IsUnsupportedStatementContext() {}

func NewUnsupportedStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnsupportedStatementContext {
	var p = new(UnsupportedStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_unsupportedStatement

	return p
}

func (s *UnsupportedStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *UnsupportedStatementContext) UnsupportedStatsStatement() IUnsupportedStatsStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnsupportedStatsStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnsupportedStatsStatementContext)
}

func (s *UnsupportedStatementContext) UnsupportedAdminStatement() IUnsupportedAdminStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnsupportedAdminStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnsupportedAdminStatementContext)
}

func (s *UnsupportedStatementContext) UnsupportedLoadStatement() IUnsupportedLoadStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnsupportedLoadStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnsupportedLoadStatementContext)
}

func (s *UnsupportedStatementContext) UnsupportedOtherStatement() IUnsupportedOtherStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnsupportedOtherStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnsupportedOtherStatementContext)
}

func (s *UnsupportedStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnsupportedStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnsupportedStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitUnsupportedStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) UnsupportedStatement() (localctx IUnsupportedStatementContext) {
	localctx = NewUnsupportedStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, DorisParserParserRULE_unsupportedStatement)
	p.SetState(612)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 23, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(608)
			p.UnsupportedStatsStatement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(609)
			p.UnsupportedAdminStatement()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(610)
			p.UnsupportedLoadStatement()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(611)
			p.UnsupportedOtherStatement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMaterializedViewStatementContext is an interface to support dynamic dispatch.
type IMaterializedViewStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsMaterializedViewStatementContext differentiates from other interfaces.
	IsMaterializedViewStatementContext()
}

type MaterializedViewStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMaterializedViewStatementContext() *MaterializedViewStatementContext {
	var p = new(MaterializedViewStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_materializedViewStatement
	return p
}

func InitEmptyMaterializedViewStatementContext(p *MaterializedViewStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_materializedViewStatement
}

func (*MaterializedViewStatementContext) IsMaterializedViewStatementContext() {}

func NewMaterializedViewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MaterializedViewStatementContext {
	var p = new(MaterializedViewStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_materializedViewStatement

	return p
}

func (s *MaterializedViewStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *MaterializedViewStatementContext) CopyAll(ctx *MaterializedViewStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *MaterializedViewStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MaterializedViewStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type RefreshMTMVContext struct {
	MaterializedViewStatementContext
	mvName IMultipartIdentifierContext
}

func NewRefreshMTMVContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RefreshMTMVContext {
	var p = new(RefreshMTMVContext)

	InitEmptyMaterializedViewStatementContext(&p.MaterializedViewStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*MaterializedViewStatementContext))

	return p
}

func (s *RefreshMTMVContext) GetMvName() IMultipartIdentifierContext { return s.mvName }

func (s *RefreshMTMVContext) SetMvName(v IMultipartIdentifierContext) { s.mvName = v }

func (s *RefreshMTMVContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RefreshMTMVContext) REFRESH() antlr.TerminalNode {
	return s.GetToken(DorisParserParserREFRESH, 0)
}

func (s *RefreshMTMVContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(DorisParserParserMATERIALIZED, 0)
}

func (s *RefreshMTMVContext) VIEW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserVIEW, 0)
}

func (s *RefreshMTMVContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *RefreshMTMVContext) PartitionSpec() IPartitionSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionSpecContext)
}

func (s *RefreshMTMVContext) COMPLETE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOMPLETE, 0)
}

func (s *RefreshMTMVContext) AUTO() antlr.TerminalNode {
	return s.GetToken(DorisParserParserAUTO, 0)
}

func (s *RefreshMTMVContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitRefreshMTMV(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterMTMVContext struct {
	MaterializedViewStatementContext
	mvName         IMultipartIdentifierContext
	newName        IIdentifierContext
	fileProperties IPropertyItemListContext
}

func NewAlterMTMVContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterMTMVContext {
	var p = new(AlterMTMVContext)

	InitEmptyMaterializedViewStatementContext(&p.MaterializedViewStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*MaterializedViewStatementContext))

	return p
}

func (s *AlterMTMVContext) GetMvName() IMultipartIdentifierContext { return s.mvName }

func (s *AlterMTMVContext) GetNewName() IIdentifierContext { return s.newName }

func (s *AlterMTMVContext) GetFileProperties() IPropertyItemListContext { return s.fileProperties }

func (s *AlterMTMVContext) SetMvName(v IMultipartIdentifierContext) { s.mvName = v }

func (s *AlterMTMVContext) SetNewName(v IIdentifierContext) { s.newName = v }

func (s *AlterMTMVContext) SetFileProperties(v IPropertyItemListContext) { s.fileProperties = v }

func (s *AlterMTMVContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterMTMVContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserParserALTER, 0)
}

func (s *AlterMTMVContext) AllMATERIALIZED() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserMATERIALIZED)
}

func (s *AlterMTMVContext) MATERIALIZED(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserMATERIALIZED, i)
}

func (s *AlterMTMVContext) AllVIEW() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserVIEW)
}

func (s *AlterMTMVContext) VIEW(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserVIEW, i)
}

func (s *AlterMTMVContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *AlterMTMVContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserREPLACE, 0)
}

func (s *AlterMTMVContext) WITH() antlr.TerminalNode {
	return s.GetToken(DorisParserParserWITH, 0)
}

func (s *AlterMTMVContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AlterMTMVContext) RENAME() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRENAME, 0)
}

func (s *AlterMTMVContext) REFRESH() antlr.TerminalNode {
	return s.GetToken(DorisParserParserREFRESH, 0)
}

func (s *AlterMTMVContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSET, 0)
}

func (s *AlterMTMVContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLEFT_PAREN, 0)
}

func (s *AlterMTMVContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRIGHT_PAREN, 0)
}

func (s *AlterMTMVContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *AlterMTMVContext) PropertyItemList() IPropertyItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyItemListContext)
}

func (s *AlterMTMVContext) RefreshMethod() IRefreshMethodContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRefreshMethodContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRefreshMethodContext)
}

func (s *AlterMTMVContext) RefreshTrigger() IRefreshTriggerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRefreshTriggerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRefreshTriggerContext)
}

func (s *AlterMTMVContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitAlterMTMV(s)

	default:
		return t.VisitChildren(s)
	}
}

type CreateMTMVContext struct {
	MaterializedViewStatementContext
	mvName   IMultipartIdentifierContext
	cols     ISimpleColumnDefsContext
	keys     IIdentifierListContext
	hashKeys IIdentifierListContext
}

func NewCreateMTMVContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateMTMVContext {
	var p = new(CreateMTMVContext)

	InitEmptyMaterializedViewStatementContext(&p.MaterializedViewStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*MaterializedViewStatementContext))

	return p
}

func (s *CreateMTMVContext) GetMvName() IMultipartIdentifierContext { return s.mvName }

func (s *CreateMTMVContext) GetCols() ISimpleColumnDefsContext { return s.cols }

func (s *CreateMTMVContext) GetKeys() IIdentifierListContext { return s.keys }

func (s *CreateMTMVContext) GetHashKeys() IIdentifierListContext { return s.hashKeys }

func (s *CreateMTMVContext) SetMvName(v IMultipartIdentifierContext) { s.mvName = v }

func (s *CreateMTMVContext) SetCols(v ISimpleColumnDefsContext) { s.cols = v }

func (s *CreateMTMVContext) SetKeys(v IIdentifierListContext) { s.keys = v }

func (s *CreateMTMVContext) SetHashKeys(v IIdentifierListContext) { s.hashKeys = v }

func (s *CreateMTMVContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateMTMVContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCREATE, 0)
}

func (s *CreateMTMVContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(DorisParserParserMATERIALIZED, 0)
}

func (s *CreateMTMVContext) VIEW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserVIEW, 0)
}

func (s *CreateMTMVContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserAS, 0)
}

func (s *CreateMTMVContext) Query() IQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *CreateMTMVContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *CreateMTMVContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserParserIF, 0)
}

func (s *CreateMTMVContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserNOT, 0)
}

func (s *CreateMTMVContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserEXISTS, 0)
}

func (s *CreateMTMVContext) AllLEFT_PAREN() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserLEFT_PAREN)
}

func (s *CreateMTMVContext) LEFT_PAREN(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserLEFT_PAREN, i)
}

func (s *CreateMTMVContext) AllRIGHT_PAREN() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserRIGHT_PAREN)
}

func (s *CreateMTMVContext) RIGHT_PAREN(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserRIGHT_PAREN, i)
}

func (s *CreateMTMVContext) BuildMode() IBuildModeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBuildModeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBuildModeContext)
}

func (s *CreateMTMVContext) REFRESH() antlr.TerminalNode {
	return s.GetToken(DorisParserParserREFRESH, 0)
}

func (s *CreateMTMVContext) KEY() antlr.TerminalNode {
	return s.GetToken(DorisParserParserKEY, 0)
}

func (s *CreateMTMVContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOMMENT, 0)
}

func (s *CreateMTMVContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTRING_LITERAL, 0)
}

func (s *CreateMTMVContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(DorisParserParserPARTITION, 0)
}

func (s *CreateMTMVContext) AllBY() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserBY)
}

func (s *CreateMTMVContext) BY(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserBY, i)
}

func (s *CreateMTMVContext) MvPartition() IMvPartitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMvPartitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMvPartitionContext)
}

func (s *CreateMTMVContext) DISTRIBUTED() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDISTRIBUTED, 0)
}

func (s *CreateMTMVContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *CreateMTMVContext) SimpleColumnDefs() ISimpleColumnDefsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleColumnDefsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleColumnDefsContext)
}

func (s *CreateMTMVContext) AllIdentifierList() []IIdentifierListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierListContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierListContext); ok {
			tst[i] = t.(IIdentifierListContext)
			i++
		}
	}

	return tst
}

func (s *CreateMTMVContext) IdentifierList(i int) IIdentifierListContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *CreateMTMVContext) HASH() antlr.TerminalNode {
	return s.GetToken(DorisParserParserHASH, 0)
}

func (s *CreateMTMVContext) RANDOM() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRANDOM, 0)
}

func (s *CreateMTMVContext) RefreshMethod() IRefreshMethodContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRefreshMethodContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRefreshMethodContext)
}

func (s *CreateMTMVContext) RefreshTrigger() IRefreshTriggerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRefreshTriggerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRefreshTriggerContext)
}

func (s *CreateMTMVContext) DUPLICATE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDUPLICATE, 0)
}

func (s *CreateMTMVContext) BUCKETS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserBUCKETS, 0)
}

func (s *CreateMTMVContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserINTEGER_VALUE, 0)
}

func (s *CreateMTMVContext) AUTO() antlr.TerminalNode {
	return s.GetToken(DorisParserParserAUTO, 0)
}

func (s *CreateMTMVContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitCreateMTMV(s)

	default:
		return t.VisitChildren(s)
	}
}

type ResumeMTMVContext struct {
	MaterializedViewStatementContext
	mvName IMultipartIdentifierContext
}

func NewResumeMTMVContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ResumeMTMVContext {
	var p = new(ResumeMTMVContext)

	InitEmptyMaterializedViewStatementContext(&p.MaterializedViewStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*MaterializedViewStatementContext))

	return p
}

func (s *ResumeMTMVContext) GetMvName() IMultipartIdentifierContext { return s.mvName }

func (s *ResumeMTMVContext) SetMvName(v IMultipartIdentifierContext) { s.mvName = v }

func (s *ResumeMTMVContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResumeMTMVContext) RESUME() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRESUME, 0)
}

func (s *ResumeMTMVContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(DorisParserParserMATERIALIZED, 0)
}

func (s *ResumeMTMVContext) VIEW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserVIEW, 0)
}

func (s *ResumeMTMVContext) JOB() antlr.TerminalNode {
	return s.GetToken(DorisParserParserJOB, 0)
}

func (s *ResumeMTMVContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisParserParserON, 0)
}

func (s *ResumeMTMVContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ResumeMTMVContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitResumeMTMV(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowCreateMTMVContext struct {
	MaterializedViewStatementContext
	mvName IMultipartIdentifierContext
}

func NewShowCreateMTMVContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowCreateMTMVContext {
	var p = new(ShowCreateMTMVContext)

	InitEmptyMaterializedViewStatementContext(&p.MaterializedViewStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*MaterializedViewStatementContext))

	return p
}

func (s *ShowCreateMTMVContext) GetMvName() IMultipartIdentifierContext { return s.mvName }

func (s *ShowCreateMTMVContext) SetMvName(v IMultipartIdentifierContext) { s.mvName = v }

func (s *ShowCreateMTMVContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCreateMTMVContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSHOW, 0)
}

func (s *ShowCreateMTMVContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCREATE, 0)
}

func (s *ShowCreateMTMVContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(DorisParserParserMATERIALIZED, 0)
}

func (s *ShowCreateMTMVContext) VIEW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserVIEW, 0)
}

func (s *ShowCreateMTMVContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowCreateMTMVContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitShowCreateMTMV(s)

	default:
		return t.VisitChildren(s)
	}
}

type CancelMTMVTaskContext struct {
	MaterializedViewStatementContext
	taskId antlr.Token
	mvName IMultipartIdentifierContext
}

func NewCancelMTMVTaskContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CancelMTMVTaskContext {
	var p = new(CancelMTMVTaskContext)

	InitEmptyMaterializedViewStatementContext(&p.MaterializedViewStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*MaterializedViewStatementContext))

	return p
}

func (s *CancelMTMVTaskContext) GetTaskId() antlr.Token { return s.taskId }

func (s *CancelMTMVTaskContext) SetTaskId(v antlr.Token) { s.taskId = v }

func (s *CancelMTMVTaskContext) GetMvName() IMultipartIdentifierContext { return s.mvName }

func (s *CancelMTMVTaskContext) SetMvName(v IMultipartIdentifierContext) { s.mvName = v }

func (s *CancelMTMVTaskContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CancelMTMVTaskContext) CANCEL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCANCEL, 0)
}

func (s *CancelMTMVTaskContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(DorisParserParserMATERIALIZED, 0)
}

func (s *CancelMTMVTaskContext) VIEW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserVIEW, 0)
}

func (s *CancelMTMVTaskContext) TASK() antlr.TerminalNode {
	return s.GetToken(DorisParserParserTASK, 0)
}

func (s *CancelMTMVTaskContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisParserParserON, 0)
}

func (s *CancelMTMVTaskContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserINTEGER_VALUE, 0)
}

func (s *CancelMTMVTaskContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *CancelMTMVTaskContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitCancelMTMVTask(s)

	default:
		return t.VisitChildren(s)
	}
}

type PauseMTMVContext struct {
	MaterializedViewStatementContext
	mvName IMultipartIdentifierContext
}

func NewPauseMTMVContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PauseMTMVContext {
	var p = new(PauseMTMVContext)

	InitEmptyMaterializedViewStatementContext(&p.MaterializedViewStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*MaterializedViewStatementContext))

	return p
}

func (s *PauseMTMVContext) GetMvName() IMultipartIdentifierContext { return s.mvName }

func (s *PauseMTMVContext) SetMvName(v IMultipartIdentifierContext) { s.mvName = v }

func (s *PauseMTMVContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PauseMTMVContext) PAUSE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserPAUSE, 0)
}

func (s *PauseMTMVContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(DorisParserParserMATERIALIZED, 0)
}

func (s *PauseMTMVContext) VIEW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserVIEW, 0)
}

func (s *PauseMTMVContext) JOB() antlr.TerminalNode {
	return s.GetToken(DorisParserParserJOB, 0)
}

func (s *PauseMTMVContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisParserParserON, 0)
}

func (s *PauseMTMVContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *PauseMTMVContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitPauseMTMV(s)

	default:
		return t.VisitChildren(s)
	}
}

type DropMTMVContext struct {
	MaterializedViewStatementContext
	mvName    IMultipartIdentifierContext
	tableName IMultipartIdentifierContext
}

func NewDropMTMVContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropMTMVContext {
	var p = new(DropMTMVContext)

	InitEmptyMaterializedViewStatementContext(&p.MaterializedViewStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*MaterializedViewStatementContext))

	return p
}

func (s *DropMTMVContext) GetMvName() IMultipartIdentifierContext { return s.mvName }

func (s *DropMTMVContext) GetTableName() IMultipartIdentifierContext { return s.tableName }

func (s *DropMTMVContext) SetMvName(v IMultipartIdentifierContext) { s.mvName = v }

func (s *DropMTMVContext) SetTableName(v IMultipartIdentifierContext) { s.tableName = v }

func (s *DropMTMVContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropMTMVContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDROP, 0)
}

func (s *DropMTMVContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(DorisParserParserMATERIALIZED, 0)
}

func (s *DropMTMVContext) VIEW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserVIEW, 0)
}

func (s *DropMTMVContext) AllMultipartIdentifier() []IMultipartIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IMultipartIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMultipartIdentifierContext); ok {
			tst[i] = t.(IMultipartIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *DropMTMVContext) MultipartIdentifier(i int) IMultipartIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *DropMTMVContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserParserIF, 0)
}

func (s *DropMTMVContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserEXISTS, 0)
}

func (s *DropMTMVContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisParserParserON, 0)
}

func (s *DropMTMVContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitDropMTMV(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) MaterializedViewStatement() (localctx IMaterializedViewStatementContext) {
	localctx = NewMaterializedViewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, DorisParserParserRULE_materializedViewStatement)
	var _la int

	p.SetState(753)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserParserCREATE:
		localctx = NewCreateMTMVContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(614)
			p.Match(DorisParserParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(615)
			p.Match(DorisParserParserMATERIALIZED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(616)
			p.Match(DorisParserParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(620)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserIF {
			{
				p.SetState(617)
				p.Match(DorisParserParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(618)
				p.Match(DorisParserParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(619)
				p.Match(DorisParserParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(622)

			var _x = p.MultipartIdentifier()

			localctx.(*CreateMTMVContext).mvName = _x
		}
		p.SetState(627)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserLEFT_PAREN {
			{
				p.SetState(623)
				p.Match(DorisParserParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(624)

				var _x = p.SimpleColumnDefs()

				localctx.(*CreateMTMVContext).cols = _x
			}
			{
				p.SetState(625)
				p.Match(DorisParserParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(630)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserBUILD {
			{
				p.SetState(629)
				p.BuildMode()
			}

		}
		p.SetState(639)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserREFRESH {
			{
				p.SetState(632)
				p.Match(DorisParserParserREFRESH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(634)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserParserAUTO || _la == DorisParserParserCOMPLETE {
				{
					p.SetState(633)
					p.RefreshMethod()
				}

			}
			p.SetState(637)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserParserON {
				{
					p.SetState(636)
					p.RefreshTrigger()
				}

			}

		}
		p.SetState(646)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserDUPLICATE || _la == DorisParserParserKEY {
			p.SetState(642)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserParserDUPLICATE {
				{
					p.SetState(641)
					p.Match(DorisParserParserDUPLICATE)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(644)
				p.Match(DorisParserParserKEY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(645)

				var _x = p.IdentifierList()

				localctx.(*CreateMTMVContext).keys = _x
			}

		}
		p.SetState(650)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserCOMMENT {
			{
				p.SetState(648)
				p.Match(DorisParserParserCOMMENT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(649)
				p.Match(DorisParserParserSTRING_LITERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(658)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserPARTITION {
			{
				p.SetState(652)
				p.Match(DorisParserParserPARTITION)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(653)
				p.Match(DorisParserParserBY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(654)
				p.Match(DorisParserParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(655)
				p.MvPartition()
			}
			{
				p.SetState(656)
				p.Match(DorisParserParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(671)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserDISTRIBUTED {
			{
				p.SetState(660)
				p.Match(DorisParserParserDISTRIBUTED)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(661)
				p.Match(DorisParserParserBY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(665)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case DorisParserParserHASH:
				{
					p.SetState(662)
					p.Match(DorisParserParserHASH)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(663)

					var _x = p.IdentifierList()

					localctx.(*CreateMTMVContext).hashKeys = _x
				}

			case DorisParserParserRANDOM:
				{
					p.SetState(664)
					p.Match(DorisParserParserRANDOM)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}
			p.SetState(669)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserParserBUCKETS {
				{
					p.SetState(667)
					p.Match(DorisParserParserBUCKETS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(668)
					_la = p.GetTokenStream().LA(1)

					if !(_la == DorisParserParserAUTO || _la == DorisParserParserINTEGER_VALUE) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			}

		}
		p.SetState(674)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserPROPERTIES {
			{
				p.SetState(673)
				p.PropertyClause()
			}

		}
		{
			p.SetState(676)
			p.Match(DorisParserParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(677)
			p.Query()
		}

	case DorisParserParserREFRESH:
		localctx = NewRefreshMTMVContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(679)
			p.Match(DorisParserParserREFRESH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(680)
			p.Match(DorisParserParserMATERIALIZED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(681)
			p.Match(DorisParserParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(682)

			var _x = p.MultipartIdentifier()

			localctx.(*RefreshMTMVContext).mvName = _x
		}
		p.SetState(686)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserParserPARTITION, DorisParserParserPARTITIONS, DorisParserParserTEMPORARY:
			{
				p.SetState(683)
				p.PartitionSpec()
			}

		case DorisParserParserCOMPLETE:
			{
				p.SetState(684)
				p.Match(DorisParserParserCOMPLETE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserParserAUTO:
			{
				p.SetState(685)
				p.Match(DorisParserParserAUTO)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case DorisParserParserALTER:
		localctx = NewAlterMTMVContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(688)
			p.Match(DorisParserParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(689)
			p.Match(DorisParserParserMATERIALIZED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(690)
			p.Match(DorisParserParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(691)

			var _x = p.MultipartIdentifier()

			localctx.(*AlterMTMVContext).mvName = _x
		}
		p.SetState(715)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserParserRENAME:
			{
				p.SetState(692)
				p.Match(DorisParserParserRENAME)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(693)

				var _x = p.Identifier()

				localctx.(*AlterMTMVContext).newName = _x
			}

		case DorisParserParserREFRESH:
			{
				p.SetState(694)
				p.Match(DorisParserParserREFRESH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(700)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 39, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(695)
					p.RefreshMethod()
				}

			case 2:
				{
					p.SetState(696)
					p.RefreshTrigger()
				}

			case 3:
				{
					p.SetState(697)
					p.RefreshMethod()
				}
				{
					p.SetState(698)
					p.RefreshTrigger()
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		case DorisParserParserREPLACE:
			{
				p.SetState(702)
				p.Match(DorisParserParserREPLACE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(703)
				p.Match(DorisParserParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(704)
				p.Match(DorisParserParserMATERIALIZED)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(705)
				p.Match(DorisParserParserVIEW)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(706)

				var _x = p.Identifier()

				localctx.(*AlterMTMVContext).newName = _x
			}
			p.SetState(708)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserParserPROPERTIES {
				{
					p.SetState(707)
					p.PropertyClause()
				}

			}

		case DorisParserParserSET:
			{
				p.SetState(710)
				p.Match(DorisParserParserSET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(711)
				p.Match(DorisParserParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(712)

				var _x = p.PropertyItemList()

				localctx.(*AlterMTMVContext).fileProperties = _x
			}
			{
				p.SetState(713)
				p.Match(DorisParserParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case DorisParserParserDROP:
		localctx = NewDropMTMVContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(717)
			p.Match(DorisParserParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(718)
			p.Match(DorisParserParserMATERIALIZED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(719)
			p.Match(DorisParserParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(722)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserIF {
			{
				p.SetState(720)
				p.Match(DorisParserParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(721)
				p.Match(DorisParserParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(724)

			var _x = p.MultipartIdentifier()

			localctx.(*DropMTMVContext).mvName = _x
		}
		p.SetState(727)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserON {
			{
				p.SetState(725)
				p.Match(DorisParserParserON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(726)

				var _x = p.MultipartIdentifier()

				localctx.(*DropMTMVContext).tableName = _x
			}

		}

	case DorisParserParserPAUSE:
		localctx = NewPauseMTMVContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(729)
			p.Match(DorisParserParserPAUSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(730)
			p.Match(DorisParserParserMATERIALIZED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(731)
			p.Match(DorisParserParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(732)
			p.Match(DorisParserParserJOB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(733)
			p.Match(DorisParserParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(734)

			var _x = p.MultipartIdentifier()

			localctx.(*PauseMTMVContext).mvName = _x
		}

	case DorisParserParserRESUME:
		localctx = NewResumeMTMVContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(735)
			p.Match(DorisParserParserRESUME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(736)
			p.Match(DorisParserParserMATERIALIZED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(737)
			p.Match(DorisParserParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(738)
			p.Match(DorisParserParserJOB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(739)
			p.Match(DorisParserParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(740)

			var _x = p.MultipartIdentifier()

			localctx.(*ResumeMTMVContext).mvName = _x
		}

	case DorisParserParserCANCEL:
		localctx = NewCancelMTMVTaskContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(741)
			p.Match(DorisParserParserCANCEL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(742)
			p.Match(DorisParserParserMATERIALIZED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(743)
			p.Match(DorisParserParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(744)
			p.Match(DorisParserParserTASK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(745)

			var _m = p.Match(DorisParserParserINTEGER_VALUE)

			localctx.(*CancelMTMVTaskContext).taskId = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(746)
			p.Match(DorisParserParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(747)

			var _x = p.MultipartIdentifier()

			localctx.(*CancelMTMVTaskContext).mvName = _x
		}

	case DorisParserParserSHOW:
		localctx = NewShowCreateMTMVContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(748)
			p.Match(DorisParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(749)
			p.Match(DorisParserParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(750)
			p.Match(DorisParserParserMATERIALIZED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(751)
			p.Match(DorisParserParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(752)

			var _x = p.MultipartIdentifier()

			localctx.(*ShowCreateMTMVContext).mvName = _x
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISupportedJobStatementContext is an interface to support dynamic dispatch.
type ISupportedJobStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSupportedJobStatementContext differentiates from other interfaces.
	IsSupportedJobStatementContext()
}

type SupportedJobStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySupportedJobStatementContext() *SupportedJobStatementContext {
	var p = new(SupportedJobStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_supportedJobStatement
	return p
}

func InitEmptySupportedJobStatementContext(p *SupportedJobStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_supportedJobStatement
}

func (*SupportedJobStatementContext) IsSupportedJobStatementContext() {}

func NewSupportedJobStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SupportedJobStatementContext {
	var p = new(SupportedJobStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_supportedJobStatement

	return p
}

func (s *SupportedJobStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SupportedJobStatementContext) CopyAll(ctx *SupportedJobStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *SupportedJobStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedJobStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type CancelJobTaskContext struct {
	SupportedJobStatementContext
	jobNameKey   IIdentifierContext
	jobNameValue antlr.Token
	taskIdKey    IIdentifierContext
	taskIdValue  antlr.Token
}

func NewCancelJobTaskContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CancelJobTaskContext {
	var p = new(CancelJobTaskContext)

	InitEmptySupportedJobStatementContext(&p.SupportedJobStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedJobStatementContext))

	return p
}

func (s *CancelJobTaskContext) GetJobNameValue() antlr.Token { return s.jobNameValue }

func (s *CancelJobTaskContext) GetTaskIdValue() antlr.Token { return s.taskIdValue }

func (s *CancelJobTaskContext) SetJobNameValue(v antlr.Token) { s.jobNameValue = v }

func (s *CancelJobTaskContext) SetTaskIdValue(v antlr.Token) { s.taskIdValue = v }

func (s *CancelJobTaskContext) GetJobNameKey() IIdentifierContext { return s.jobNameKey }

func (s *CancelJobTaskContext) GetTaskIdKey() IIdentifierContext { return s.taskIdKey }

func (s *CancelJobTaskContext) SetJobNameKey(v IIdentifierContext) { s.jobNameKey = v }

func (s *CancelJobTaskContext) SetTaskIdKey(v IIdentifierContext) { s.taskIdKey = v }

func (s *CancelJobTaskContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CancelJobTaskContext) CANCEL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCANCEL, 0)
}

func (s *CancelJobTaskContext) TASK() antlr.TerminalNode {
	return s.GetToken(DorisParserParserTASK, 0)
}

func (s *CancelJobTaskContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserWHERE, 0)
}

func (s *CancelJobTaskContext) AllEQ() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserEQ)
}

func (s *CancelJobTaskContext) EQ(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserEQ, i)
}

func (s *CancelJobTaskContext) AND() antlr.TerminalNode {
	return s.GetToken(DorisParserParserAND, 0)
}

func (s *CancelJobTaskContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *CancelJobTaskContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CancelJobTaskContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTRING_LITERAL, 0)
}

func (s *CancelJobTaskContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserINTEGER_VALUE, 0)
}

func (s *CancelJobTaskContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitCancelJobTask(s)

	default:
		return t.VisitChildren(s)
	}
}

type ResumeJobContext struct {
	SupportedJobStatementContext
	jobNameKey   IIdentifierContext
	jobNameValue antlr.Token
}

func NewResumeJobContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ResumeJobContext {
	var p = new(ResumeJobContext)

	InitEmptySupportedJobStatementContext(&p.SupportedJobStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedJobStatementContext))

	return p
}

func (s *ResumeJobContext) GetJobNameValue() antlr.Token { return s.jobNameValue }

func (s *ResumeJobContext) SetJobNameValue(v antlr.Token) { s.jobNameValue = v }

func (s *ResumeJobContext) GetJobNameKey() IIdentifierContext { return s.jobNameKey }

func (s *ResumeJobContext) SetJobNameKey(v IIdentifierContext) { s.jobNameKey = v }

func (s *ResumeJobContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResumeJobContext) RESUME() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRESUME, 0)
}

func (s *ResumeJobContext) JOB() antlr.TerminalNode {
	return s.GetToken(DorisParserParserJOB, 0)
}

func (s *ResumeJobContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserWHERE, 0)
}

func (s *ResumeJobContext) EQ() antlr.TerminalNode {
	return s.GetToken(DorisParserParserEQ, 0)
}

func (s *ResumeJobContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ResumeJobContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTRING_LITERAL, 0)
}

func (s *ResumeJobContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitResumeJob(s)

	default:
		return t.VisitChildren(s)
	}
}

type DropJobContext struct {
	SupportedJobStatementContext
	jobNameKey   IIdentifierContext
	jobNameValue antlr.Token
}

func NewDropJobContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropJobContext {
	var p = new(DropJobContext)

	InitEmptySupportedJobStatementContext(&p.SupportedJobStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedJobStatementContext))

	return p
}

func (s *DropJobContext) GetJobNameValue() antlr.Token { return s.jobNameValue }

func (s *DropJobContext) SetJobNameValue(v antlr.Token) { s.jobNameValue = v }

func (s *DropJobContext) GetJobNameKey() IIdentifierContext { return s.jobNameKey }

func (s *DropJobContext) SetJobNameKey(v IIdentifierContext) { s.jobNameKey = v }

func (s *DropJobContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropJobContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDROP, 0)
}

func (s *DropJobContext) JOB() antlr.TerminalNode {
	return s.GetToken(DorisParserParserJOB, 0)
}

func (s *DropJobContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserWHERE, 0)
}

func (s *DropJobContext) EQ() antlr.TerminalNode {
	return s.GetToken(DorisParserParserEQ, 0)
}

func (s *DropJobContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserParserIF, 0)
}

func (s *DropJobContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserEXISTS, 0)
}

func (s *DropJobContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DropJobContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTRING_LITERAL, 0)
}

func (s *DropJobContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitDropJob(s)

	default:
		return t.VisitChildren(s)
	}
}

type CreateScheduledJobContext struct {
	SupportedJobStatementContext
	label        IMultipartIdentifierContext
	timeInterval antlr.Token
	timeUnit     IIdentifierContext
	startTime    antlr.Token
	endsTime     antlr.Token
	atTime       antlr.Token
}

func NewCreateScheduledJobContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateScheduledJobContext {
	var p = new(CreateScheduledJobContext)

	InitEmptySupportedJobStatementContext(&p.SupportedJobStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedJobStatementContext))

	return p
}

func (s *CreateScheduledJobContext) GetTimeInterval() antlr.Token { return s.timeInterval }

func (s *CreateScheduledJobContext) GetStartTime() antlr.Token { return s.startTime }

func (s *CreateScheduledJobContext) GetEndsTime() antlr.Token { return s.endsTime }

func (s *CreateScheduledJobContext) GetAtTime() antlr.Token { return s.atTime }

func (s *CreateScheduledJobContext) SetTimeInterval(v antlr.Token) { s.timeInterval = v }

func (s *CreateScheduledJobContext) SetStartTime(v antlr.Token) { s.startTime = v }

func (s *CreateScheduledJobContext) SetEndsTime(v antlr.Token) { s.endsTime = v }

func (s *CreateScheduledJobContext) SetAtTime(v antlr.Token) { s.atTime = v }

func (s *CreateScheduledJobContext) GetLabel() IMultipartIdentifierContext { return s.label }

func (s *CreateScheduledJobContext) GetTimeUnit() IIdentifierContext { return s.timeUnit }

func (s *CreateScheduledJobContext) SetLabel(v IMultipartIdentifierContext) { s.label = v }

func (s *CreateScheduledJobContext) SetTimeUnit(v IIdentifierContext) { s.timeUnit = v }

func (s *CreateScheduledJobContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateScheduledJobContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCREATE, 0)
}

func (s *CreateScheduledJobContext) JOB() antlr.TerminalNode {
	return s.GetToken(DorisParserParserJOB, 0)
}

func (s *CreateScheduledJobContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisParserParserON, 0)
}

func (s *CreateScheduledJobContext) SCHEDULE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSCHEDULE, 0)
}

func (s *CreateScheduledJobContext) DO() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDO, 0)
}

func (s *CreateScheduledJobContext) SupportedDmlStatement() ISupportedDmlStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISupportedDmlStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISupportedDmlStatementContext)
}

func (s *CreateScheduledJobContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *CreateScheduledJobContext) CommentSpec() ICommentSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentSpecContext)
}

func (s *CreateScheduledJobContext) EVERY() antlr.TerminalNode {
	return s.GetToken(DorisParserParserEVERY, 0)
}

func (s *CreateScheduledJobContext) AT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserAT, 0)
}

func (s *CreateScheduledJobContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserINTEGER_VALUE, 0)
}

func (s *CreateScheduledJobContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateScheduledJobContext) CURRENT_TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCURRENT_TIMESTAMP, 0)
}

func (s *CreateScheduledJobContext) STARTS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTARTS, 0)
}

func (s *CreateScheduledJobContext) ENDS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserENDS, 0)
}

func (s *CreateScheduledJobContext) AllSTRING_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserSTRING_LITERAL)
}

func (s *CreateScheduledJobContext) STRING_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTRING_LITERAL, i)
}

func (s *CreateScheduledJobContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitCreateScheduledJob(s)

	default:
		return t.VisitChildren(s)
	}
}

type PauseJobContext struct {
	SupportedJobStatementContext
	jobNameKey   IIdentifierContext
	jobNameValue antlr.Token
}

func NewPauseJobContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PauseJobContext {
	var p = new(PauseJobContext)

	InitEmptySupportedJobStatementContext(&p.SupportedJobStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedJobStatementContext))

	return p
}

func (s *PauseJobContext) GetJobNameValue() antlr.Token { return s.jobNameValue }

func (s *PauseJobContext) SetJobNameValue(v antlr.Token) { s.jobNameValue = v }

func (s *PauseJobContext) GetJobNameKey() IIdentifierContext { return s.jobNameKey }

func (s *PauseJobContext) SetJobNameKey(v IIdentifierContext) { s.jobNameKey = v }

func (s *PauseJobContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PauseJobContext) PAUSE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserPAUSE, 0)
}

func (s *PauseJobContext) JOB() antlr.TerminalNode {
	return s.GetToken(DorisParserParserJOB, 0)
}

func (s *PauseJobContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserWHERE, 0)
}

func (s *PauseJobContext) EQ() antlr.TerminalNode {
	return s.GetToken(DorisParserParserEQ, 0)
}

func (s *PauseJobContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PauseJobContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTRING_LITERAL, 0)
}

func (s *PauseJobContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitPauseJob(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) SupportedJobStatement() (localctx ISupportedJobStatementContext) {
	localctx = NewSupportedJobStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, DorisParserParserRULE_supportedJobStatement)
	var _la int

	p.SetState(823)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserParserCREATE:
		localctx = NewCreateScheduledJobContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(755)
			p.Match(DorisParserParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(756)
			p.Match(DorisParserParserJOB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(757)

			var _x = p.MultipartIdentifier()

			localctx.(*CreateScheduledJobContext).label = _x
		}
		{
			p.SetState(758)
			p.Match(DorisParserParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(759)
			p.Match(DorisParserParserSCHEDULE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(779)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserParserEVERY:
			{
				p.SetState(760)
				p.Match(DorisParserParserEVERY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(761)

				var _m = p.Match(DorisParserParserINTEGER_VALUE)

				localctx.(*CreateScheduledJobContext).timeInterval = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(762)

				var _x = p.Identifier()

				localctx.(*CreateScheduledJobContext).timeUnit = _x
			}
			p.SetState(768)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserParserSTARTS {
				{
					p.SetState(763)
					p.Match(DorisParserParserSTARTS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(766)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}

				switch p.GetTokenStream().LA(1) {
				case DorisParserParserSTRING_LITERAL:
					{
						p.SetState(764)

						var _m = p.Match(DorisParserParserSTRING_LITERAL)

						localctx.(*CreateScheduledJobContext).startTime = _m
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				case DorisParserParserCURRENT_TIMESTAMP:
					{
						p.SetState(765)
						p.Match(DorisParserParserCURRENT_TIMESTAMP)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				default:
					p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
					goto errorExit
				}

			}
			p.SetState(772)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserParserENDS {
				{
					p.SetState(770)
					p.Match(DorisParserParserENDS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(771)

					var _m = p.Match(DorisParserParserSTRING_LITERAL)

					localctx.(*CreateScheduledJobContext).endsTime = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}

		case DorisParserParserAT:
			{
				p.SetState(774)
				p.Match(DorisParserParserAT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(777)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case DorisParserParserSTRING_LITERAL:
				{
					p.SetState(775)

					var _m = p.Match(DorisParserParserSTRING_LITERAL)

					localctx.(*CreateScheduledJobContext).atTime = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case DorisParserParserCURRENT_TIMESTAMP:
				{
					p.SetState(776)
					p.Match(DorisParserParserCURRENT_TIMESTAMP)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		p.SetState(782)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserCOMMENT {
			{
				p.SetState(781)
				p.CommentSpec()
			}

		}
		{
			p.SetState(784)
			p.Match(DorisParserParserDO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(785)
			p.SupportedDmlStatement()
		}

	case DorisParserParserPAUSE:
		localctx = NewPauseJobContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(787)
			p.Match(DorisParserParserPAUSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(788)
			p.Match(DorisParserParserJOB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(789)
			p.Match(DorisParserParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		{
			p.SetState(790)

			var _x = p.Identifier()

			localctx.(*PauseJobContext).jobNameKey = _x
		}

		{
			p.SetState(791)
			p.Match(DorisParserParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		{
			p.SetState(792)

			var _m = p.Match(DorisParserParserSTRING_LITERAL)

			localctx.(*PauseJobContext).jobNameValue = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserParserDROP:
		localctx = NewDropJobContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(794)
			p.Match(DorisParserParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(795)
			p.Match(DorisParserParserJOB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(798)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserIF {
			{
				p.SetState(796)
				p.Match(DorisParserParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(797)
				p.Match(DorisParserParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(800)
			p.Match(DorisParserParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		{
			p.SetState(801)

			var _x = p.Identifier()

			localctx.(*DropJobContext).jobNameKey = _x
		}

		{
			p.SetState(802)
			p.Match(DorisParserParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		{
			p.SetState(803)

			var _m = p.Match(DorisParserParserSTRING_LITERAL)

			localctx.(*DropJobContext).jobNameValue = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserParserRESUME:
		localctx = NewResumeJobContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(805)
			p.Match(DorisParserParserRESUME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(806)
			p.Match(DorisParserParserJOB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(807)
			p.Match(DorisParserParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		{
			p.SetState(808)

			var _x = p.Identifier()

			localctx.(*ResumeJobContext).jobNameKey = _x
		}

		{
			p.SetState(809)
			p.Match(DorisParserParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		{
			p.SetState(810)

			var _m = p.Match(DorisParserParserSTRING_LITERAL)

			localctx.(*ResumeJobContext).jobNameValue = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserParserCANCEL:
		localctx = NewCancelJobTaskContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(812)
			p.Match(DorisParserParserCANCEL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(813)
			p.Match(DorisParserParserTASK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(814)
			p.Match(DorisParserParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		{
			p.SetState(815)

			var _x = p.Identifier()

			localctx.(*CancelJobTaskContext).jobNameKey = _x
		}

		{
			p.SetState(816)
			p.Match(DorisParserParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		{
			p.SetState(817)

			var _m = p.Match(DorisParserParserSTRING_LITERAL)

			localctx.(*CancelJobTaskContext).jobNameValue = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		{
			p.SetState(818)
			p.Match(DorisParserParserAND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		{
			p.SetState(819)

			var _x = p.Identifier()

			localctx.(*CancelJobTaskContext).taskIdKey = _x
		}

		{
			p.SetState(820)
			p.Match(DorisParserParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		{
			p.SetState(821)

			var _m = p.Match(DorisParserParserINTEGER_VALUE)

			localctx.(*CancelJobTaskContext).taskIdValue = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConstraintStatementContext is an interface to support dynamic dispatch.
type IConstraintStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsConstraintStatementContext differentiates from other interfaces.
	IsConstraintStatementContext()
}

type ConstraintStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstraintStatementContext() *ConstraintStatementContext {
	var p = new(ConstraintStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_constraintStatement
	return p
}

func InitEmptyConstraintStatementContext(p *ConstraintStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_constraintStatement
}

func (*ConstraintStatementContext) IsConstraintStatementContext() {}

func NewConstraintStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstraintStatementContext {
	var p = new(ConstraintStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_constraintStatement

	return p
}

func (s *ConstraintStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstraintStatementContext) CopyAll(ctx *ConstraintStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ConstraintStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstraintStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ShowConstraintContext struct {
	ConstraintStatementContext
	table IMultipartIdentifierContext
}

func NewShowConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowConstraintContext {
	var p = new(ShowConstraintContext)

	InitEmptyConstraintStatementContext(&p.ConstraintStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*ConstraintStatementContext))

	return p
}

func (s *ShowConstraintContext) GetTable() IMultipartIdentifierContext { return s.table }

func (s *ShowConstraintContext) SetTable(v IMultipartIdentifierContext) { s.table = v }

func (s *ShowConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowConstraintContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSHOW, 0)
}

func (s *ShowConstraintContext) CONSTRAINTS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCONSTRAINTS, 0)
}

func (s *ShowConstraintContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFROM, 0)
}

func (s *ShowConstraintContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitShowConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}

type DropConstraintContext struct {
	ConstraintStatementContext
	table          IMultipartIdentifierContext
	constraintName IErrorCapturingIdentifierContext
}

func NewDropConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropConstraintContext {
	var p = new(DropConstraintContext)

	InitEmptyConstraintStatementContext(&p.ConstraintStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*ConstraintStatementContext))

	return p
}

func (s *DropConstraintContext) GetTable() IMultipartIdentifierContext { return s.table }

func (s *DropConstraintContext) GetConstraintName() IErrorCapturingIdentifierContext {
	return s.constraintName
}

func (s *DropConstraintContext) SetTable(v IMultipartIdentifierContext) { s.table = v }

func (s *DropConstraintContext) SetConstraintName(v IErrorCapturingIdentifierContext) {
	s.constraintName = v
}

func (s *DropConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropConstraintContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserParserALTER, 0)
}

func (s *DropConstraintContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserTABLE, 0)
}

func (s *DropConstraintContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDROP, 0)
}

func (s *DropConstraintContext) CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCONSTRAINT, 0)
}

func (s *DropConstraintContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *DropConstraintContext) ErrorCapturingIdentifier() IErrorCapturingIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IErrorCapturingIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IErrorCapturingIdentifierContext)
}

func (s *DropConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitDropConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}

type AddConstraintContext struct {
	ConstraintStatementContext
	table          IMultipartIdentifierContext
	constraintName IErrorCapturingIdentifierContext
}

func NewAddConstraintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AddConstraintContext {
	var p = new(AddConstraintContext)

	InitEmptyConstraintStatementContext(&p.ConstraintStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*ConstraintStatementContext))

	return p
}

func (s *AddConstraintContext) GetTable() IMultipartIdentifierContext { return s.table }

func (s *AddConstraintContext) GetConstraintName() IErrorCapturingIdentifierContext {
	return s.constraintName
}

func (s *AddConstraintContext) SetTable(v IMultipartIdentifierContext) { s.table = v }

func (s *AddConstraintContext) SetConstraintName(v IErrorCapturingIdentifierContext) {
	s.constraintName = v
}

func (s *AddConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddConstraintContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserParserALTER, 0)
}

func (s *AddConstraintContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserTABLE, 0)
}

func (s *AddConstraintContext) ADD() antlr.TerminalNode {
	return s.GetToken(DorisParserParserADD, 0)
}

func (s *AddConstraintContext) CONSTRAINT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCONSTRAINT, 0)
}

func (s *AddConstraintContext) Constraint() IConstraintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstraintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstraintContext)
}

func (s *AddConstraintContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *AddConstraintContext) ErrorCapturingIdentifier() IErrorCapturingIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IErrorCapturingIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IErrorCapturingIdentifierContext)
}

func (s *AddConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitAddConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) ConstraintStatement() (localctx IConstraintStatementContext) {
	localctx = NewConstraintStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, DorisParserParserRULE_constraintStatement)
	p.SetState(844)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 53, p.GetParserRuleContext()) {
	case 1:
		localctx = NewAddConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(825)
			p.Match(DorisParserParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(826)
			p.Match(DorisParserParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(827)

			var _x = p.MultipartIdentifier()

			localctx.(*AddConstraintContext).table = _x
		}
		{
			p.SetState(828)
			p.Match(DorisParserParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(829)
			p.Match(DorisParserParserCONSTRAINT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(830)

			var _x = p.ErrorCapturingIdentifier()

			localctx.(*AddConstraintContext).constraintName = _x
		}
		{
			p.SetState(831)
			p.Constraint()
		}

	case 2:
		localctx = NewDropConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(833)
			p.Match(DorisParserParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(834)
			p.Match(DorisParserParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(835)

			var _x = p.MultipartIdentifier()

			localctx.(*DropConstraintContext).table = _x
		}
		{
			p.SetState(836)
			p.Match(DorisParserParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(837)
			p.Match(DorisParserParserCONSTRAINT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(838)

			var _x = p.ErrorCapturingIdentifier()

			localctx.(*DropConstraintContext).constraintName = _x
		}

	case 3:
		localctx = NewShowConstraintContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(840)
			p.Match(DorisParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(841)
			p.Match(DorisParserParserCONSTRAINTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(842)
			p.Match(DorisParserParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(843)

			var _x = p.MultipartIdentifier()

			localctx.(*ShowConstraintContext).table = _x
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISupportedDmlStatementContext is an interface to support dynamic dispatch.
type ISupportedDmlStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSupportedDmlStatementContext differentiates from other interfaces.
	IsSupportedDmlStatementContext()
}

type SupportedDmlStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySupportedDmlStatementContext() *SupportedDmlStatementContext {
	var p = new(SupportedDmlStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_supportedDmlStatement
	return p
}

func InitEmptySupportedDmlStatementContext(p *SupportedDmlStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_supportedDmlStatement
}

func (*SupportedDmlStatementContext) IsSupportedDmlStatementContext() {}

func NewSupportedDmlStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SupportedDmlStatementContext {
	var p = new(SupportedDmlStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_supportedDmlStatement

	return p
}

func (s *SupportedDmlStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SupportedDmlStatementContext) CopyAll(ctx *SupportedDmlStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *SupportedDmlStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedDmlStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type InsertTableContext struct {
	SupportedDmlStatementContext
	tableName IMultipartIdentifierContext
	tableId   antlr.Token
	labelName IIdentifierContext
	cols      IIdentifierListContext
	hints     IIdentifierSeqContext
}

func NewInsertTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InsertTableContext {
	var p = new(InsertTableContext)

	InitEmptySupportedDmlStatementContext(&p.SupportedDmlStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedDmlStatementContext))

	return p
}

func (s *InsertTableContext) GetTableId() antlr.Token { return s.tableId }

func (s *InsertTableContext) SetTableId(v antlr.Token) { s.tableId = v }

func (s *InsertTableContext) GetTableName() IMultipartIdentifierContext { return s.tableName }

func (s *InsertTableContext) GetLabelName() IIdentifierContext { return s.labelName }

func (s *InsertTableContext) GetCols() IIdentifierListContext { return s.cols }

func (s *InsertTableContext) GetHints() IIdentifierSeqContext { return s.hints }

func (s *InsertTableContext) SetTableName(v IMultipartIdentifierContext) { s.tableName = v }

func (s *InsertTableContext) SetLabelName(v IIdentifierContext) { s.labelName = v }

func (s *InsertTableContext) SetCols(v IIdentifierListContext) { s.cols = v }

func (s *InsertTableContext) SetHints(v IIdentifierSeqContext) { s.hints = v }

func (s *InsertTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InsertTableContext) INSERT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserINSERT, 0)
}

func (s *InsertTableContext) Query() IQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *InsertTableContext) INTO() antlr.TerminalNode {
	return s.GetToken(DorisParserParserINTO, 0)
}

func (s *InsertTableContext) OVERWRITE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserOVERWRITE, 0)
}

func (s *InsertTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserTABLE, 0)
}

func (s *InsertTableContext) DORIS_INTERNAL_TABLE_ID() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDORIS_INTERNAL_TABLE_ID, 0)
}

func (s *InsertTableContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLEFT_PAREN, 0)
}

func (s *InsertTableContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRIGHT_PAREN, 0)
}

func (s *InsertTableContext) Explain() IExplainContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExplainContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExplainContext)
}

func (s *InsertTableContext) Cte() ICteContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICteContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICteContext)
}

func (s *InsertTableContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *InsertTableContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserINTEGER_VALUE, 0)
}

func (s *InsertTableContext) PartitionSpec() IPartitionSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionSpecContext)
}

func (s *InsertTableContext) WITH() antlr.TerminalNode {
	return s.GetToken(DorisParserParserWITH, 0)
}

func (s *InsertTableContext) LABEL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLABEL, 0)
}

func (s *InsertTableContext) LEFT_BRACKET() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLEFT_BRACKET, 0)
}

func (s *InsertTableContext) RIGHT_BRACKET() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRIGHT_BRACKET, 0)
}

func (s *InsertTableContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *InsertTableContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *InsertTableContext) IdentifierSeq() IIdentifierSeqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierSeqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierSeqContext)
}

func (s *InsertTableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitInsertTable(s)

	default:
		return t.VisitChildren(s)
	}
}

type LoadContext struct {
	SupportedDmlStatementContext
	lableName IMultipartIdentifierContext
	_dataDesc IDataDescContext
	dataDescs []IDataDescContext
}

func NewLoadContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LoadContext {
	var p = new(LoadContext)

	InitEmptySupportedDmlStatementContext(&p.SupportedDmlStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedDmlStatementContext))

	return p
}

func (s *LoadContext) GetLableName() IMultipartIdentifierContext { return s.lableName }

func (s *LoadContext) Get_dataDesc() IDataDescContext { return s._dataDesc }

func (s *LoadContext) SetLableName(v IMultipartIdentifierContext) { s.lableName = v }

func (s *LoadContext) Set_dataDesc(v IDataDescContext) { s._dataDesc = v }

func (s *LoadContext) GetDataDescs() []IDataDescContext { return s.dataDescs }

func (s *LoadContext) SetDataDescs(v []IDataDescContext) { s.dataDescs = v }

func (s *LoadContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LoadContext) LOAD() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLOAD, 0)
}

func (s *LoadContext) LABEL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLABEL, 0)
}

func (s *LoadContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLEFT_PAREN, 0)
}

func (s *LoadContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRIGHT_PAREN, 0)
}

func (s *LoadContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *LoadContext) AllDataDesc() []IDataDescContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDataDescContext); ok {
			len++
		}
	}

	tst := make([]IDataDescContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDataDescContext); ok {
			tst[i] = t.(IDataDescContext)
			i++
		}
	}

	return tst
}

func (s *LoadContext) DataDesc(i int) IDataDescContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataDescContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataDescContext)
}

func (s *LoadContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserCOMMA)
}

func (s *LoadContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOMMA, i)
}

func (s *LoadContext) WithRemoteStorageSystem() IWithRemoteStorageSystemContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWithRemoteStorageSystemContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWithRemoteStorageSystemContext)
}

func (s *LoadContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *LoadContext) CommentSpec() ICommentSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentSpecContext)
}

func (s *LoadContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitLoad(s)

	default:
		return t.VisitChildren(s)
	}
}

type CopyIntoContext struct {
	SupportedDmlStatementContext
	name       IMultipartIdentifierContext
	columns    IIdentifierListContext
	properties IPropertyClauseContext
}

func NewCopyIntoContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CopyIntoContext {
	var p = new(CopyIntoContext)

	InitEmptySupportedDmlStatementContext(&p.SupportedDmlStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedDmlStatementContext))

	return p
}

func (s *CopyIntoContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *CopyIntoContext) GetColumns() IIdentifierListContext { return s.columns }

func (s *CopyIntoContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *CopyIntoContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *CopyIntoContext) SetColumns(v IIdentifierListContext) { s.columns = v }

func (s *CopyIntoContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *CopyIntoContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CopyIntoContext) COPY() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOPY, 0)
}

func (s *CopyIntoContext) INTO() antlr.TerminalNode {
	return s.GetToken(DorisParserParserINTO, 0)
}

func (s *CopyIntoContext) AllFROM() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserFROM)
}

func (s *CopyIntoContext) FROM(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserFROM, i)
}

func (s *CopyIntoContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *CopyIntoContext) StageAndPattern() IStageAndPatternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStageAndPatternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStageAndPatternContext)
}

func (s *CopyIntoContext) SelectHint() ISelectHintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectHintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectHintContext)
}

func (s *CopyIntoContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *CopyIntoContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLEFT_PAREN, 0)
}

func (s *CopyIntoContext) SELECT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSELECT, 0)
}

func (s *CopyIntoContext) SelectColumnClause() ISelectColumnClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectColumnClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectColumnClauseContext)
}

func (s *CopyIntoContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRIGHT_PAREN, 0)
}

func (s *CopyIntoContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *CopyIntoContext) WhereClause() IWhereClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhereClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhereClauseContext)
}

func (s *CopyIntoContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitCopyInto(s)

	default:
		return t.VisitChildren(s)
	}
}

type UpdateContext struct {
	SupportedDmlStatementContext
	tableName IMultipartIdentifierContext
}

func NewUpdateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UpdateContext {
	var p = new(UpdateContext)

	InitEmptySupportedDmlStatementContext(&p.SupportedDmlStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedDmlStatementContext))

	return p
}

func (s *UpdateContext) GetTableName() IMultipartIdentifierContext { return s.tableName }

func (s *UpdateContext) SetTableName(v IMultipartIdentifierContext) { s.tableName = v }

func (s *UpdateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UpdateContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserUPDATE, 0)
}

func (s *UpdateContext) TableAlias() ITableAliasContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableAliasContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableAliasContext)
}

func (s *UpdateContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSET, 0)
}

func (s *UpdateContext) UpdateAssignmentSeq() IUpdateAssignmentSeqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpdateAssignmentSeqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpdateAssignmentSeqContext)
}

func (s *UpdateContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *UpdateContext) Explain() IExplainContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExplainContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExplainContext)
}

func (s *UpdateContext) Cte() ICteContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICteContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICteContext)
}

func (s *UpdateContext) FromClause() IFromClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFromClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFromClauseContext)
}

func (s *UpdateContext) WhereClause() IWhereClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhereClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhereClauseContext)
}

func (s *UpdateContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitUpdate(s)

	default:
		return t.VisitChildren(s)
	}
}

type TruncateTableContext struct {
	SupportedDmlStatementContext
}

func NewTruncateTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TruncateTableContext {
	var p = new(TruncateTableContext)

	InitEmptySupportedDmlStatementContext(&p.SupportedDmlStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedDmlStatementContext))

	return p
}

func (s *TruncateTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TruncateTableContext) TRUNCATE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserTRUNCATE, 0)
}

func (s *TruncateTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserTABLE, 0)
}

func (s *TruncateTableContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *TruncateTableContext) SpecifiedPartition() ISpecifiedPartitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISpecifiedPartitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISpecifiedPartitionContext)
}

func (s *TruncateTableContext) FORCE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFORCE, 0)
}

func (s *TruncateTableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitTruncateTable(s)

	default:
		return t.VisitChildren(s)
	}
}

type ReplayContext struct {
	SupportedDmlStatementContext
}

func NewReplayContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ReplayContext {
	var p = new(ReplayContext)

	InitEmptySupportedDmlStatementContext(&p.SupportedDmlStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedDmlStatementContext))

	return p
}

func (s *ReplayContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReplayContext) ReplayCommand() IReplayCommandContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReplayCommandContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReplayCommandContext)
}

func (s *ReplayContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitReplay(s)

	default:
		return t.VisitChildren(s)
	}
}

type DeleteContext struct {
	SupportedDmlStatementContext
	tableName IMultipartIdentifierContext
}

func NewDeleteContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DeleteContext {
	var p = new(DeleteContext)

	InitEmptySupportedDmlStatementContext(&p.SupportedDmlStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedDmlStatementContext))

	return p
}

func (s *DeleteContext) GetTableName() IMultipartIdentifierContext { return s.tableName }

func (s *DeleteContext) SetTableName(v IMultipartIdentifierContext) { s.tableName = v }

func (s *DeleteContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeleteContext) DELETE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDELETE, 0)
}

func (s *DeleteContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFROM, 0)
}

func (s *DeleteContext) TableAlias() ITableAliasContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableAliasContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableAliasContext)
}

func (s *DeleteContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *DeleteContext) Explain() IExplainContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExplainContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExplainContext)
}

func (s *DeleteContext) Cte() ICteContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICteContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICteContext)
}

func (s *DeleteContext) PartitionSpec() IPartitionSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionSpecContext)
}

func (s *DeleteContext) USING() antlr.TerminalNode {
	return s.GetToken(DorisParserParserUSING, 0)
}

func (s *DeleteContext) Relations() IRelationsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationsContext)
}

func (s *DeleteContext) WhereClause() IWhereClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhereClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhereClauseContext)
}

func (s *DeleteContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitDelete(s)

	default:
		return t.VisitChildren(s)
	}
}

type ExportContext struct {
	SupportedDmlStatementContext
	tableName IMultipartIdentifierContext
	partition IIdentifierListContext
	filePath  antlr.Token
}

func NewExportContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExportContext {
	var p = new(ExportContext)

	InitEmptySupportedDmlStatementContext(&p.SupportedDmlStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedDmlStatementContext))

	return p
}

func (s *ExportContext) GetFilePath() antlr.Token { return s.filePath }

func (s *ExportContext) SetFilePath(v antlr.Token) { s.filePath = v }

func (s *ExportContext) GetTableName() IMultipartIdentifierContext { return s.tableName }

func (s *ExportContext) GetPartition() IIdentifierListContext { return s.partition }

func (s *ExportContext) SetTableName(v IMultipartIdentifierContext) { s.tableName = v }

func (s *ExportContext) SetPartition(v IIdentifierListContext) { s.partition = v }

func (s *ExportContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExportContext) EXPORT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserEXPORT, 0)
}

func (s *ExportContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserTABLE, 0)
}

func (s *ExportContext) TO() antlr.TerminalNode {
	return s.GetToken(DorisParserParserTO, 0)
}

func (s *ExportContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ExportContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTRING_LITERAL, 0)
}

func (s *ExportContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(DorisParserParserPARTITION, 0)
}

func (s *ExportContext) WhereClause() IWhereClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhereClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhereClauseContext)
}

func (s *ExportContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *ExportContext) WithRemoteStorageSystem() IWithRemoteStorageSystemContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWithRemoteStorageSystemContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWithRemoteStorageSystemContext)
}

func (s *ExportContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *ExportContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitExport(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) SupportedDmlStatement() (localctx ISupportedDmlStatementContext) {
	localctx = NewSupportedDmlStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, DorisParserParserRULE_supportedDmlStatement)
	var _la int

	p.SetState(996)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 86, p.GetParserRuleContext()) {
	case 1:
		localctx = NewInsertTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		p.SetState(847)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if (int64((_la-131)) & ^0x3f) == 0 && ((int64(1)<<(_la-131))&2199023255555) != 0 {
			{
				p.SetState(846)
				p.Explain()
			}

		}
		p.SetState(850)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserWITH {
			{
				p.SetState(849)
				p.Cte()
			}

		}
		{
			p.SetState(852)
			p.Match(DorisParserParserINSERT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(856)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserParserINTO:
			{
				p.SetState(853)
				p.Match(DorisParserParserINTO)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserParserOVERWRITE:
			{
				p.SetState(854)
				p.Match(DorisParserParserOVERWRITE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(855)
				p.Match(DorisParserParserTABLE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		p.SetState(863)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 57, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(858)

				var _x = p.MultipartIdentifier()

				localctx.(*InsertTableContext).tableName = _x
			}

		case 2:
			{
				p.SetState(859)
				p.Match(DorisParserParserDORIS_INTERNAL_TABLE_ID)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(860)
				p.Match(DorisParserParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(861)

				var _m = p.Match(DorisParserParserINTEGER_VALUE)

				localctx.(*InsertTableContext).tableId = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(862)
				p.Match(DorisParserParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		p.SetState(866)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserPARTITION || _la == DorisParserParserPARTITIONS || _la == DorisParserParserTEMPORARY {
			{
				p.SetState(865)
				p.PartitionSpec()
			}

		}
		p.SetState(871)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 59, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(868)
				p.Match(DorisParserParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(869)
				p.Match(DorisParserParserLABEL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(870)

				var _x = p.Identifier()

				localctx.(*InsertTableContext).labelName = _x
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(874)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 60, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(873)

				var _x = p.IdentifierList()

				localctx.(*InsertTableContext).cols = _x
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(880)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserLEFT_BRACKET {
			{
				p.SetState(876)
				p.Match(DorisParserParserLEFT_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(877)

				var _x = p.IdentifierSeq()

				localctx.(*InsertTableContext).hints = _x
			}
			{
				p.SetState(878)
				p.Match(DorisParserParserRIGHT_BRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(882)
			p.Query()
		}

	case 2:
		localctx = NewUpdateContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		p.SetState(884)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if (int64((_la-131)) & ^0x3f) == 0 && ((int64(1)<<(_la-131))&2199023255555) != 0 {
			{
				p.SetState(883)
				p.Explain()
			}

		}
		p.SetState(887)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserWITH {
			{
				p.SetState(886)
				p.Cte()
			}

		}
		{
			p.SetState(889)
			p.Match(DorisParserParserUPDATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(890)

			var _x = p.MultipartIdentifier()

			localctx.(*UpdateContext).tableName = _x
		}
		{
			p.SetState(891)
			p.TableAlias()
		}
		{
			p.SetState(892)
			p.Match(DorisParserParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(893)
			p.UpdateAssignmentSeq()
		}
		p.SetState(895)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserFROM {
			{
				p.SetState(894)
				p.FromClause()
			}

		}
		p.SetState(898)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserWHERE {
			{
				p.SetState(897)
				p.WhereClause()
			}

		}

	case 3:
		localctx = NewDeleteContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		p.SetState(901)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if (int64((_la-131)) & ^0x3f) == 0 && ((int64(1)<<(_la-131))&2199023255555) != 0 {
			{
				p.SetState(900)
				p.Explain()
			}

		}
		p.SetState(904)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserWITH {
			{
				p.SetState(903)
				p.Cte()
			}

		}
		{
			p.SetState(906)
			p.Match(DorisParserParserDELETE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(907)
			p.Match(DorisParserParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(908)

			var _x = p.MultipartIdentifier()

			localctx.(*DeleteContext).tableName = _x
		}
		p.SetState(910)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 68, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(909)
				p.PartitionSpec()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(912)
			p.TableAlias()
		}
		p.SetState(915)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserUSING {
			{
				p.SetState(913)
				p.Match(DorisParserParserUSING)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(914)
				p.Relations()
			}

		}
		p.SetState(918)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserWHERE {
			{
				p.SetState(917)
				p.WhereClause()
			}

		}

	case 4:
		localctx = NewLoadContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(920)
			p.Match(DorisParserParserLOAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(921)
			p.Match(DorisParserParserLABEL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(922)

			var _x = p.MultipartIdentifier()

			localctx.(*LoadContext).lableName = _x
		}
		{
			p.SetState(923)
			p.Match(DorisParserParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(924)

			var _x = p.DataDesc()

			localctx.(*LoadContext)._dataDesc = _x
		}
		localctx.(*LoadContext).dataDescs = append(localctx.(*LoadContext).dataDescs, localctx.(*LoadContext)._dataDesc)
		p.SetState(929)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserParserCOMMA {
			{
				p.SetState(925)
				p.Match(DorisParserParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(926)

				var _x = p.DataDesc()

				localctx.(*LoadContext)._dataDesc = _x
			}
			localctx.(*LoadContext).dataDescs = append(localctx.(*LoadContext).dataDescs, localctx.(*LoadContext)._dataDesc)

			p.SetState(931)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(932)
			p.Match(DorisParserParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(934)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserWITH {
			{
				p.SetState(933)
				p.WithRemoteStorageSystem()
			}

		}
		p.SetState(937)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserPROPERTIES {
			{
				p.SetState(936)
				p.PropertyClause()
			}

		}
		p.SetState(940)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserCOMMENT {
			{
				p.SetState(939)
				p.CommentSpec()
			}

		}

	case 5:
		localctx = NewExportContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(942)
			p.Match(DorisParserParserEXPORT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(943)
			p.Match(DorisParserParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(944)

			var _x = p.MultipartIdentifier()

			localctx.(*ExportContext).tableName = _x
		}
		p.SetState(947)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserPARTITION {
			{
				p.SetState(945)
				p.Match(DorisParserParserPARTITION)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(946)

				var _x = p.IdentifierList()

				localctx.(*ExportContext).partition = _x
			}

		}
		p.SetState(950)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserWHERE {
			{
				p.SetState(949)
				p.WhereClause()
			}

		}
		{
			p.SetState(952)
			p.Match(DorisParserParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(953)

			var _m = p.Match(DorisParserParserSTRING_LITERAL)

			localctx.(*ExportContext).filePath = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(955)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserPROPERTIES {
			{
				p.SetState(954)
				p.PropertyClause()
			}

		}
		p.SetState(958)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserWITH {
			{
				p.SetState(957)
				p.WithRemoteStorageSystem()
			}

		}

	case 6:
		localctx = NewReplayContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(960)
			p.ReplayCommand()
		}

	case 7:
		localctx = NewCopyIntoContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(961)
			p.Match(DorisParserParserCOPY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(962)
			p.Match(DorisParserParserINTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(964)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 79, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(963)
				p.SelectHint()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(966)

			var _x = p.MultipartIdentifier()

			localctx.(*CopyIntoContext).name = _x
		}
		p.SetState(968)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserLEFT_PAREN {
			{
				p.SetState(967)

				var _x = p.IdentifierList()

				localctx.(*CopyIntoContext).columns = _x
			}

		}
		{
			p.SetState(970)
			p.Match(DorisParserParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(982)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserParserATSIGN:
			{
				p.SetState(971)
				p.StageAndPattern()
			}

		case DorisParserParserLEFT_PAREN:
			{
				p.SetState(972)
				p.Match(DorisParserParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(973)
				p.Match(DorisParserParserSELECT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(974)
				p.SelectColumnClause()
			}
			{
				p.SetState(975)
				p.Match(DorisParserParserFROM)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(976)
				p.StageAndPattern()
			}
			p.SetState(978)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserParserWHERE {
				{
					p.SetState(977)
					p.WhereClause()
				}

			}
			{
				p.SetState(980)
				p.Match(DorisParserParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		p.SetState(985)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserPROPERTIES {
			{
				p.SetState(984)

				var _x = p.PropertyClause()

				localctx.(*CopyIntoContext).properties = _x
			}

		}

	case 8:
		localctx = NewTruncateTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(987)
			p.Match(DorisParserParserTRUNCATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(988)
			p.Match(DorisParserParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(989)
			p.MultipartIdentifier()
		}
		p.SetState(991)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserPARTITION || _la == DorisParserParserPARTITIONS || _la == DorisParserParserTEMPORARY {
			{
				p.SetState(990)
				p.SpecifiedPartition()
			}

		}
		p.SetState(994)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserFORCE {
			{
				p.SetState(993)
				p.Match(DorisParserParserFORCE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISupportedCreateStatementContext is an interface to support dynamic dispatch.
type ISupportedCreateStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSupportedCreateStatementContext differentiates from other interfaces.
	IsSupportedCreateStatementContext()
}

type SupportedCreateStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySupportedCreateStatementContext() *SupportedCreateStatementContext {
	var p = new(SupportedCreateStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_supportedCreateStatement
	return p
}

func InitEmptySupportedCreateStatementContext(p *SupportedCreateStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_supportedCreateStatement
}

func (*SupportedCreateStatementContext) IsSupportedCreateStatementContext() {}

func NewSupportedCreateStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SupportedCreateStatementContext {
	var p = new(SupportedCreateStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_supportedCreateStatement

	return p
}

func (s *SupportedCreateStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SupportedCreateStatementContext) CopyAll(ctx *SupportedCreateStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *SupportedCreateStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedCreateStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type CreateTableContext struct {
	SupportedCreateStatementContext
	name          IMultipartIdentifierContext
	ctasCols      IIdentifierListContext
	engine        IIdentifierContext
	keys          IIdentifierListContext
	clusterKeys   IIdentifierListContext
	partition     IPartitionTableContext
	hashKeys      IIdentifierListContext
	autoBucket    antlr.Token
	properties    IPropertyClauseContext
	extProperties IPropertyClauseContext
}

func NewCreateTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateTableContext {
	var p = new(CreateTableContext)

	InitEmptySupportedCreateStatementContext(&p.SupportedCreateStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedCreateStatementContext))

	return p
}

func (s *CreateTableContext) GetAutoBucket() antlr.Token { return s.autoBucket }

func (s *CreateTableContext) SetAutoBucket(v antlr.Token) { s.autoBucket = v }

func (s *CreateTableContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *CreateTableContext) GetCtasCols() IIdentifierListContext { return s.ctasCols }

func (s *CreateTableContext) GetEngine() IIdentifierContext { return s.engine }

func (s *CreateTableContext) GetKeys() IIdentifierListContext { return s.keys }

func (s *CreateTableContext) GetClusterKeys() IIdentifierListContext { return s.clusterKeys }

func (s *CreateTableContext) GetPartition() IPartitionTableContext { return s.partition }

func (s *CreateTableContext) GetHashKeys() IIdentifierListContext { return s.hashKeys }

func (s *CreateTableContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *CreateTableContext) GetExtProperties() IPropertyClauseContext { return s.extProperties }

func (s *CreateTableContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *CreateTableContext) SetCtasCols(v IIdentifierListContext) { s.ctasCols = v }

func (s *CreateTableContext) SetEngine(v IIdentifierContext) { s.engine = v }

func (s *CreateTableContext) SetKeys(v IIdentifierListContext) { s.keys = v }

func (s *CreateTableContext) SetClusterKeys(v IIdentifierListContext) { s.clusterKeys = v }

func (s *CreateTableContext) SetPartition(v IPartitionTableContext) { s.partition = v }

func (s *CreateTableContext) SetHashKeys(v IIdentifierListContext) { s.hashKeys = v }

func (s *CreateTableContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *CreateTableContext) SetExtProperties(v IPropertyClauseContext) { s.extProperties = v }

func (s *CreateTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateTableContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCREATE, 0)
}

func (s *CreateTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserTABLE, 0)
}

func (s *CreateTableContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *CreateTableContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserParserIF, 0)
}

func (s *CreateTableContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserNOT, 0)
}

func (s *CreateTableContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserEXISTS, 0)
}

func (s *CreateTableContext) ENGINE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserENGINE, 0)
}

func (s *CreateTableContext) EQ() antlr.TerminalNode {
	return s.GetToken(DorisParserParserEQ, 0)
}

func (s *CreateTableContext) KEY() antlr.TerminalNode {
	return s.GetToken(DorisParserParserKEY, 0)
}

func (s *CreateTableContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOMMENT, 0)
}

func (s *CreateTableContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTRING_LITERAL, 0)
}

func (s *CreateTableContext) DISTRIBUTED() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDISTRIBUTED, 0)
}

func (s *CreateTableContext) AllBY() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserBY)
}

func (s *CreateTableContext) BY(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserBY, i)
}

func (s *CreateTableContext) ROLLUP() antlr.TerminalNode {
	return s.GetToken(DorisParserParserROLLUP, 0)
}

func (s *CreateTableContext) AllLEFT_PAREN() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserLEFT_PAREN)
}

func (s *CreateTableContext) LEFT_PAREN(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserLEFT_PAREN, i)
}

func (s *CreateTableContext) RollupDefs() IRollupDefsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRollupDefsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRollupDefsContext)
}

func (s *CreateTableContext) AllRIGHT_PAREN() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserRIGHT_PAREN)
}

func (s *CreateTableContext) RIGHT_PAREN(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserRIGHT_PAREN, i)
}

func (s *CreateTableContext) BROKER() antlr.TerminalNode {
	return s.GetToken(DorisParserParserBROKER, 0)
}

func (s *CreateTableContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserAS, 0)
}

func (s *CreateTableContext) Query() IQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *CreateTableContext) EXTERNAL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserEXTERNAL, 0)
}

func (s *CreateTableContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(DorisParserParserTEMPORARY, 0)
}

func (s *CreateTableContext) ColumnDefs() IColumnDefsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnDefsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnDefsContext)
}

func (s *CreateTableContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateTableContext) AGGREGATE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserAGGREGATE, 0)
}

func (s *CreateTableContext) UNIQUE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserUNIQUE, 0)
}

func (s *CreateTableContext) DUPLICATE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDUPLICATE, 0)
}

func (s *CreateTableContext) AllIdentifierList() []IIdentifierListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierListContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierListContext); ok {
			tst[i] = t.(IIdentifierListContext)
			i++
		}
	}

	return tst
}

func (s *CreateTableContext) IdentifierList(i int) IIdentifierListContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *CreateTableContext) PartitionTable() IPartitionTableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionTableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionTableContext)
}

func (s *CreateTableContext) AllPropertyClause() []IPropertyClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			len++
		}
	}

	tst := make([]IPropertyClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPropertyClauseContext); ok {
			tst[i] = t.(IPropertyClauseContext)
			i++
		}
	}

	return tst
}

func (s *CreateTableContext) PropertyClause(i int) IPropertyClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *CreateTableContext) HASH() antlr.TerminalNode {
	return s.GetToken(DorisParserParserHASH, 0)
}

func (s *CreateTableContext) RANDOM() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRANDOM, 0)
}

func (s *CreateTableContext) CLUSTER() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCLUSTER, 0)
}

func (s *CreateTableContext) BUCKETS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserBUCKETS, 0)
}

func (s *CreateTableContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserCOMMA)
}

func (s *CreateTableContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOMMA, i)
}

func (s *CreateTableContext) IndexDefs() IIndexDefsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexDefsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexDefsContext)
}

func (s *CreateTableContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserINTEGER_VALUE, 0)
}

func (s *CreateTableContext) AUTO() antlr.TerminalNode {
	return s.GetToken(DorisParserParserAUTO, 0)
}

func (s *CreateTableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitCreateTable(s)

	default:
		return t.VisitChildren(s)
	}
}

type CreateWorkloadPolicyContext struct {
	SupportedCreateStatementContext
	name       IIdentifierOrTextContext
	properties IPropertyClauseContext
}

func NewCreateWorkloadPolicyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateWorkloadPolicyContext {
	var p = new(CreateWorkloadPolicyContext)

	InitEmptySupportedCreateStatementContext(&p.SupportedCreateStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedCreateStatementContext))

	return p
}

func (s *CreateWorkloadPolicyContext) GetName() IIdentifierOrTextContext { return s.name }

func (s *CreateWorkloadPolicyContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *CreateWorkloadPolicyContext) SetName(v IIdentifierOrTextContext) { s.name = v }

func (s *CreateWorkloadPolicyContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *CreateWorkloadPolicyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateWorkloadPolicyContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCREATE, 0)
}

func (s *CreateWorkloadPolicyContext) WORKLOAD() antlr.TerminalNode {
	return s.GetToken(DorisParserParserWORKLOAD, 0)
}

func (s *CreateWorkloadPolicyContext) POLICY() antlr.TerminalNode {
	return s.GetToken(DorisParserParserPOLICY, 0)
}

func (s *CreateWorkloadPolicyContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *CreateWorkloadPolicyContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserParserIF, 0)
}

func (s *CreateWorkloadPolicyContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserNOT, 0)
}

func (s *CreateWorkloadPolicyContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserEXISTS, 0)
}

func (s *CreateWorkloadPolicyContext) CONDITIONS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCONDITIONS, 0)
}

func (s *CreateWorkloadPolicyContext) AllLEFT_PAREN() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserLEFT_PAREN)
}

func (s *CreateWorkloadPolicyContext) LEFT_PAREN(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserLEFT_PAREN, i)
}

func (s *CreateWorkloadPolicyContext) WorkloadPolicyConditions() IWorkloadPolicyConditionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWorkloadPolicyConditionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWorkloadPolicyConditionsContext)
}

func (s *CreateWorkloadPolicyContext) AllRIGHT_PAREN() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserRIGHT_PAREN)
}

func (s *CreateWorkloadPolicyContext) RIGHT_PAREN(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserRIGHT_PAREN, i)
}

func (s *CreateWorkloadPolicyContext) ACTIONS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserACTIONS, 0)
}

func (s *CreateWorkloadPolicyContext) WorkloadPolicyActions() IWorkloadPolicyActionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWorkloadPolicyActionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWorkloadPolicyActionsContext)
}

func (s *CreateWorkloadPolicyContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *CreateWorkloadPolicyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitCreateWorkloadPolicy(s)

	default:
		return t.VisitChildren(s)
	}
}

type CreateResourceContext struct {
	SupportedCreateStatementContext
	name       IIdentifierOrTextContext
	properties IPropertyClauseContext
}

func NewCreateResourceContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateResourceContext {
	var p = new(CreateResourceContext)

	InitEmptySupportedCreateStatementContext(&p.SupportedCreateStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedCreateStatementContext))

	return p
}

func (s *CreateResourceContext) GetName() IIdentifierOrTextContext { return s.name }

func (s *CreateResourceContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *CreateResourceContext) SetName(v IIdentifierOrTextContext) { s.name = v }

func (s *CreateResourceContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *CreateResourceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateResourceContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCREATE, 0)
}

func (s *CreateResourceContext) RESOURCE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRESOURCE, 0)
}

func (s *CreateResourceContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *CreateResourceContext) EXTERNAL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserEXTERNAL, 0)
}

func (s *CreateResourceContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserParserIF, 0)
}

func (s *CreateResourceContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserNOT, 0)
}

func (s *CreateResourceContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserEXISTS, 0)
}

func (s *CreateResourceContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *CreateResourceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitCreateResource(s)

	default:
		return t.VisitChildren(s)
	}
}

type CreateWorkloadGroupContext struct {
	SupportedCreateStatementContext
	name         IIdentifierOrTextContext
	computeGroup IIdentifierOrTextContext
	properties   IPropertyClauseContext
}

func NewCreateWorkloadGroupContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateWorkloadGroupContext {
	var p = new(CreateWorkloadGroupContext)

	InitEmptySupportedCreateStatementContext(&p.SupportedCreateStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedCreateStatementContext))

	return p
}

func (s *CreateWorkloadGroupContext) GetName() IIdentifierOrTextContext { return s.name }

func (s *CreateWorkloadGroupContext) GetComputeGroup() IIdentifierOrTextContext {
	return s.computeGroup
}

func (s *CreateWorkloadGroupContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *CreateWorkloadGroupContext) SetName(v IIdentifierOrTextContext) { s.name = v }

func (s *CreateWorkloadGroupContext) SetComputeGroup(v IIdentifierOrTextContext) { s.computeGroup = v }

func (s *CreateWorkloadGroupContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *CreateWorkloadGroupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateWorkloadGroupContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCREATE, 0)
}

func (s *CreateWorkloadGroupContext) WORKLOAD() antlr.TerminalNode {
	return s.GetToken(DorisParserParserWORKLOAD, 0)
}

func (s *CreateWorkloadGroupContext) GROUP() antlr.TerminalNode {
	return s.GetToken(DorisParserParserGROUP, 0)
}

func (s *CreateWorkloadGroupContext) AllIdentifierOrText() []IIdentifierOrTextContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierOrTextContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierOrTextContext); ok {
			tst[i] = t.(IIdentifierOrTextContext)
			i++
		}
	}

	return tst
}

func (s *CreateWorkloadGroupContext) IdentifierOrText(i int) IIdentifierOrTextContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *CreateWorkloadGroupContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserParserIF, 0)
}

func (s *CreateWorkloadGroupContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserNOT, 0)
}

func (s *CreateWorkloadGroupContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserEXISTS, 0)
}

func (s *CreateWorkloadGroupContext) FOR() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFOR, 0)
}

func (s *CreateWorkloadGroupContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *CreateWorkloadGroupContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitCreateWorkloadGroup(s)

	default:
		return t.VisitChildren(s)
	}
}

type CreateDictionaryContext struct {
	SupportedCreateStatementContext
	name       IMultipartIdentifierContext
	source     IMultipartIdentifierContext
	layoutType IIdentifierContext
	properties IPropertyClauseContext
}

func NewCreateDictionaryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateDictionaryContext {
	var p = new(CreateDictionaryContext)

	InitEmptySupportedCreateStatementContext(&p.SupportedCreateStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedCreateStatementContext))

	return p
}

func (s *CreateDictionaryContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *CreateDictionaryContext) GetSource() IMultipartIdentifierContext { return s.source }

func (s *CreateDictionaryContext) GetLayoutType() IIdentifierContext { return s.layoutType }

func (s *CreateDictionaryContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *CreateDictionaryContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *CreateDictionaryContext) SetSource(v IMultipartIdentifierContext) { s.source = v }

func (s *CreateDictionaryContext) SetLayoutType(v IIdentifierContext) { s.layoutType = v }

func (s *CreateDictionaryContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *CreateDictionaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateDictionaryContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCREATE, 0)
}

func (s *CreateDictionaryContext) DICTIONARY() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDICTIONARY, 0)
}

func (s *CreateDictionaryContext) USING() antlr.TerminalNode {
	return s.GetToken(DorisParserParserUSING, 0)
}

func (s *CreateDictionaryContext) AllLEFT_PAREN() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserLEFT_PAREN)
}

func (s *CreateDictionaryContext) LEFT_PAREN(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserLEFT_PAREN, i)
}

func (s *CreateDictionaryContext) DictionaryColumnDefs() IDictionaryColumnDefsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDictionaryColumnDefsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDictionaryColumnDefsContext)
}

func (s *CreateDictionaryContext) AllRIGHT_PAREN() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserRIGHT_PAREN)
}

func (s *CreateDictionaryContext) RIGHT_PAREN(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserRIGHT_PAREN, i)
}

func (s *CreateDictionaryContext) LAYOUT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLAYOUT, 0)
}

func (s *CreateDictionaryContext) AllMultipartIdentifier() []IMultipartIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IMultipartIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMultipartIdentifierContext); ok {
			tst[i] = t.(IMultipartIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *CreateDictionaryContext) MultipartIdentifier(i int) IMultipartIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *CreateDictionaryContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateDictionaryContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserParserIF, 0)
}

func (s *CreateDictionaryContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserNOT, 0)
}

func (s *CreateDictionaryContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserEXISTS, 0)
}

func (s *CreateDictionaryContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *CreateDictionaryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitCreateDictionary(s)

	default:
		return t.VisitChildren(s)
	}
}

type CreateTableLikeContext struct {
	SupportedCreateStatementContext
	name         IMultipartIdentifierContext
	existedTable IMultipartIdentifierContext
	rollupNames  IIdentifierListContext
}

func NewCreateTableLikeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateTableLikeContext {
	var p = new(CreateTableLikeContext)

	InitEmptySupportedCreateStatementContext(&p.SupportedCreateStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedCreateStatementContext))

	return p
}

func (s *CreateTableLikeContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *CreateTableLikeContext) GetExistedTable() IMultipartIdentifierContext { return s.existedTable }

func (s *CreateTableLikeContext) GetRollupNames() IIdentifierListContext { return s.rollupNames }

func (s *CreateTableLikeContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *CreateTableLikeContext) SetExistedTable(v IMultipartIdentifierContext) { s.existedTable = v }

func (s *CreateTableLikeContext) SetRollupNames(v IIdentifierListContext) { s.rollupNames = v }

func (s *CreateTableLikeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateTableLikeContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCREATE, 0)
}

func (s *CreateTableLikeContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserTABLE, 0)
}

func (s *CreateTableLikeContext) LIKE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLIKE, 0)
}

func (s *CreateTableLikeContext) AllMultipartIdentifier() []IMultipartIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IMultipartIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMultipartIdentifierContext); ok {
			tst[i] = t.(IMultipartIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *CreateTableLikeContext) MultipartIdentifier(i int) IMultipartIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *CreateTableLikeContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserParserIF, 0)
}

func (s *CreateTableLikeContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserNOT, 0)
}

func (s *CreateTableLikeContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserEXISTS, 0)
}

func (s *CreateTableLikeContext) WITH() antlr.TerminalNode {
	return s.GetToken(DorisParserParserWITH, 0)
}

func (s *CreateTableLikeContext) ROLLUP() antlr.TerminalNode {
	return s.GetToken(DorisParserParserROLLUP, 0)
}

func (s *CreateTableLikeContext) EXTERNAL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserEXTERNAL, 0)
}

func (s *CreateTableLikeContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(DorisParserParserTEMPORARY, 0)
}

func (s *CreateTableLikeContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *CreateTableLikeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitCreateTableLike(s)

	default:
		return t.VisitChildren(s)
	}
}

type CreateRoleContext struct {
	SupportedCreateStatementContext
	name IIdentifierOrTextContext
}

func NewCreateRoleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateRoleContext {
	var p = new(CreateRoleContext)

	InitEmptySupportedCreateStatementContext(&p.SupportedCreateStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedCreateStatementContext))

	return p
}

func (s *CreateRoleContext) GetName() IIdentifierOrTextContext { return s.name }

func (s *CreateRoleContext) SetName(v IIdentifierOrTextContext) { s.name = v }

func (s *CreateRoleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateRoleContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCREATE, 0)
}

func (s *CreateRoleContext) ROLE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserROLE, 0)
}

func (s *CreateRoleContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *CreateRoleContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserParserIF, 0)
}

func (s *CreateRoleContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserNOT, 0)
}

func (s *CreateRoleContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserEXISTS, 0)
}

func (s *CreateRoleContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOMMENT, 0)
}

func (s *CreateRoleContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTRING_LITERAL, 0)
}

func (s *CreateRoleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitCreateRole(s)

	default:
		return t.VisitChildren(s)
	}
}

type CreateStageContext struct {
	SupportedCreateStatementContext
	name       IIdentifierContext
	properties IPropertyClauseContext
}

func NewCreateStageContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateStageContext {
	var p = new(CreateStageContext)

	InitEmptySupportedCreateStatementContext(&p.SupportedCreateStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedCreateStatementContext))

	return p
}

func (s *CreateStageContext) GetName() IIdentifierContext { return s.name }

func (s *CreateStageContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *CreateStageContext) SetName(v IIdentifierContext) { s.name = v }

func (s *CreateStageContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *CreateStageContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateStageContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCREATE, 0)
}

func (s *CreateStageContext) STAGE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTAGE, 0)
}

func (s *CreateStageContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateStageContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserParserIF, 0)
}

func (s *CreateStageContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserNOT, 0)
}

func (s *CreateStageContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserEXISTS, 0)
}

func (s *CreateStageContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *CreateStageContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitCreateStage(s)

	default:
		return t.VisitChildren(s)
	}
}

type CreateIndexAnalyzerContext struct {
	SupportedCreateStatementContext
	name       IIdentifierContext
	properties IPropertyClauseContext
}

func NewCreateIndexAnalyzerContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateIndexAnalyzerContext {
	var p = new(CreateIndexAnalyzerContext)

	InitEmptySupportedCreateStatementContext(&p.SupportedCreateStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedCreateStatementContext))

	return p
}

func (s *CreateIndexAnalyzerContext) GetName() IIdentifierContext { return s.name }

func (s *CreateIndexAnalyzerContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *CreateIndexAnalyzerContext) SetName(v IIdentifierContext) { s.name = v }

func (s *CreateIndexAnalyzerContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *CreateIndexAnalyzerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateIndexAnalyzerContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCREATE, 0)
}

func (s *CreateIndexAnalyzerContext) INVERTED() antlr.TerminalNode {
	return s.GetToken(DorisParserParserINVERTED, 0)
}

func (s *CreateIndexAnalyzerContext) INDEX() antlr.TerminalNode {
	return s.GetToken(DorisParserParserINDEX, 0)
}

func (s *CreateIndexAnalyzerContext) ANALYZER() antlr.TerminalNode {
	return s.GetToken(DorisParserParserANALYZER, 0)
}

func (s *CreateIndexAnalyzerContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateIndexAnalyzerContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserParserIF, 0)
}

func (s *CreateIndexAnalyzerContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserNOT, 0)
}

func (s *CreateIndexAnalyzerContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserEXISTS, 0)
}

func (s *CreateIndexAnalyzerContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *CreateIndexAnalyzerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitCreateIndexAnalyzer(s)

	default:
		return t.VisitChildren(s)
	}
}

type CreateIndexTokenizerContext struct {
	SupportedCreateStatementContext
	name       IIdentifierContext
	properties IPropertyClauseContext
}

func NewCreateIndexTokenizerContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateIndexTokenizerContext {
	var p = new(CreateIndexTokenizerContext)

	InitEmptySupportedCreateStatementContext(&p.SupportedCreateStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedCreateStatementContext))

	return p
}

func (s *CreateIndexTokenizerContext) GetName() IIdentifierContext { return s.name }

func (s *CreateIndexTokenizerContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *CreateIndexTokenizerContext) SetName(v IIdentifierContext) { s.name = v }

func (s *CreateIndexTokenizerContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *CreateIndexTokenizerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateIndexTokenizerContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCREATE, 0)
}

func (s *CreateIndexTokenizerContext) INVERTED() antlr.TerminalNode {
	return s.GetToken(DorisParserParserINVERTED, 0)
}

func (s *CreateIndexTokenizerContext) INDEX() antlr.TerminalNode {
	return s.GetToken(DorisParserParserINDEX, 0)
}

func (s *CreateIndexTokenizerContext) TOKENIZER() antlr.TerminalNode {
	return s.GetToken(DorisParserParserTOKENIZER, 0)
}

func (s *CreateIndexTokenizerContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateIndexTokenizerContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserParserIF, 0)
}

func (s *CreateIndexTokenizerContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserNOT, 0)
}

func (s *CreateIndexTokenizerContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserEXISTS, 0)
}

func (s *CreateIndexTokenizerContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *CreateIndexTokenizerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitCreateIndexTokenizer(s)

	default:
		return t.VisitChildren(s)
	}
}

type CreateFileContext struct {
	SupportedCreateStatementContext
	name       antlr.Token
	database   IIdentifierContext
	properties IPropertyClauseContext
}

func NewCreateFileContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateFileContext {
	var p = new(CreateFileContext)

	InitEmptySupportedCreateStatementContext(&p.SupportedCreateStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedCreateStatementContext))

	return p
}

func (s *CreateFileContext) GetName() antlr.Token { return s.name }

func (s *CreateFileContext) SetName(v antlr.Token) { s.name = v }

func (s *CreateFileContext) GetDatabase() IIdentifierContext { return s.database }

func (s *CreateFileContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *CreateFileContext) SetDatabase(v IIdentifierContext) { s.database = v }

func (s *CreateFileContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *CreateFileContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateFileContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCREATE, 0)
}

func (s *CreateFileContext) FILE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFILE, 0)
}

func (s *CreateFileContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTRING_LITERAL, 0)
}

func (s *CreateFileContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *CreateFileContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFROM, 0)
}

func (s *CreateFileContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserIN, 0)
}

func (s *CreateFileContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateFileContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitCreateFile(s)

	default:
		return t.VisitChildren(s)
	}
}

type CreateRowPolicyContext struct {
	SupportedCreateStatementContext
	name     IIdentifierContext
	table    IMultipartIdentifierContext
	type_    antlr.Token
	user     IUserIdentifyContext
	roleName IIdentifierOrTextContext
}

func NewCreateRowPolicyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateRowPolicyContext {
	var p = new(CreateRowPolicyContext)

	InitEmptySupportedCreateStatementContext(&p.SupportedCreateStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedCreateStatementContext))

	return p
}

func (s *CreateRowPolicyContext) GetType_() antlr.Token { return s.type_ }

func (s *CreateRowPolicyContext) SetType_(v antlr.Token) { s.type_ = v }

func (s *CreateRowPolicyContext) GetName() IIdentifierContext { return s.name }

func (s *CreateRowPolicyContext) GetTable() IMultipartIdentifierContext { return s.table }

func (s *CreateRowPolicyContext) GetUser() IUserIdentifyContext { return s.user }

func (s *CreateRowPolicyContext) GetRoleName() IIdentifierOrTextContext { return s.roleName }

func (s *CreateRowPolicyContext) SetName(v IIdentifierContext) { s.name = v }

func (s *CreateRowPolicyContext) SetTable(v IMultipartIdentifierContext) { s.table = v }

func (s *CreateRowPolicyContext) SetUser(v IUserIdentifyContext) { s.user = v }

func (s *CreateRowPolicyContext) SetRoleName(v IIdentifierOrTextContext) { s.roleName = v }

func (s *CreateRowPolicyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateRowPolicyContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCREATE, 0)
}

func (s *CreateRowPolicyContext) ROW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserROW, 0)
}

func (s *CreateRowPolicyContext) POLICY() antlr.TerminalNode {
	return s.GetToken(DorisParserParserPOLICY, 0)
}

func (s *CreateRowPolicyContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisParserParserON, 0)
}

func (s *CreateRowPolicyContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserAS, 0)
}

func (s *CreateRowPolicyContext) TO() antlr.TerminalNode {
	return s.GetToken(DorisParserParserTO, 0)
}

func (s *CreateRowPolicyContext) USING() antlr.TerminalNode {
	return s.GetToken(DorisParserParserUSING, 0)
}

func (s *CreateRowPolicyContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLEFT_PAREN, 0)
}

func (s *CreateRowPolicyContext) BooleanExpression() IBooleanExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *CreateRowPolicyContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRIGHT_PAREN, 0)
}

func (s *CreateRowPolicyContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateRowPolicyContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *CreateRowPolicyContext) RESTRICTIVE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRESTRICTIVE, 0)
}

func (s *CreateRowPolicyContext) PERMISSIVE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserPERMISSIVE, 0)
}

func (s *CreateRowPolicyContext) ROLE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserROLE, 0)
}

func (s *CreateRowPolicyContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserParserIF, 0)
}

func (s *CreateRowPolicyContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserNOT, 0)
}

func (s *CreateRowPolicyContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserEXISTS, 0)
}

func (s *CreateRowPolicyContext) UserIdentify() IUserIdentifyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserIdentifyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserIdentifyContext)
}

func (s *CreateRowPolicyContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *CreateRowPolicyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitCreateRowPolicy(s)

	default:
		return t.VisitChildren(s)
	}
}

type CreateEncryptkeyContext struct {
	SupportedCreateStatementContext
}

func NewCreateEncryptkeyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateEncryptkeyContext {
	var p = new(CreateEncryptkeyContext)

	InitEmptySupportedCreateStatementContext(&p.SupportedCreateStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedCreateStatementContext))

	return p
}

func (s *CreateEncryptkeyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateEncryptkeyContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCREATE, 0)
}

func (s *CreateEncryptkeyContext) ENCRYPTKEY() antlr.TerminalNode {
	return s.GetToken(DorisParserParserENCRYPTKEY, 0)
}

func (s *CreateEncryptkeyContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *CreateEncryptkeyContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserAS, 0)
}

func (s *CreateEncryptkeyContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTRING_LITERAL, 0)
}

func (s *CreateEncryptkeyContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserParserIF, 0)
}

func (s *CreateEncryptkeyContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserNOT, 0)
}

func (s *CreateEncryptkeyContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserEXISTS, 0)
}

func (s *CreateEncryptkeyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitCreateEncryptkey(s)

	default:
		return t.VisitChildren(s)
	}
}

type CreateViewContext struct {
	SupportedCreateStatementContext
	name IMultipartIdentifierContext
	cols ISimpleColumnDefsContext
}

func NewCreateViewContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateViewContext {
	var p = new(CreateViewContext)

	InitEmptySupportedCreateStatementContext(&p.SupportedCreateStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedCreateStatementContext))

	return p
}

func (s *CreateViewContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *CreateViewContext) GetCols() ISimpleColumnDefsContext { return s.cols }

func (s *CreateViewContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *CreateViewContext) SetCols(v ISimpleColumnDefsContext) { s.cols = v }

func (s *CreateViewContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateViewContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCREATE, 0)
}

func (s *CreateViewContext) VIEW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserVIEW, 0)
}

func (s *CreateViewContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserAS, 0)
}

func (s *CreateViewContext) Query() IQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *CreateViewContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *CreateViewContext) OR() antlr.TerminalNode {
	return s.GetToken(DorisParserParserOR, 0)
}

func (s *CreateViewContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserREPLACE, 0)
}

func (s *CreateViewContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserParserIF, 0)
}

func (s *CreateViewContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserNOT, 0)
}

func (s *CreateViewContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserEXISTS, 0)
}

func (s *CreateViewContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLEFT_PAREN, 0)
}

func (s *CreateViewContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRIGHT_PAREN, 0)
}

func (s *CreateViewContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOMMENT, 0)
}

func (s *CreateViewContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTRING_LITERAL, 0)
}

func (s *CreateViewContext) SimpleColumnDefs() ISimpleColumnDefsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleColumnDefsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleColumnDefsContext)
}

func (s *CreateViewContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitCreateView(s)

	default:
		return t.VisitChildren(s)
	}
}

type CreateStorageVaultContext struct {
	SupportedCreateStatementContext
	name       IIdentifierOrTextContext
	properties IPropertyClauseContext
}

func NewCreateStorageVaultContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateStorageVaultContext {
	var p = new(CreateStorageVaultContext)

	InitEmptySupportedCreateStatementContext(&p.SupportedCreateStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedCreateStatementContext))

	return p
}

func (s *CreateStorageVaultContext) GetName() IIdentifierOrTextContext { return s.name }

func (s *CreateStorageVaultContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *CreateStorageVaultContext) SetName(v IIdentifierOrTextContext) { s.name = v }

func (s *CreateStorageVaultContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *CreateStorageVaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateStorageVaultContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCREATE, 0)
}

func (s *CreateStorageVaultContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTORAGE, 0)
}

func (s *CreateStorageVaultContext) VAULT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserVAULT, 0)
}

func (s *CreateStorageVaultContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *CreateStorageVaultContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserParserIF, 0)
}

func (s *CreateStorageVaultContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserNOT, 0)
}

func (s *CreateStorageVaultContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserEXISTS, 0)
}

func (s *CreateStorageVaultContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *CreateStorageVaultContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitCreateStorageVault(s)

	default:
		return t.VisitChildren(s)
	}
}

type CreateUserDefineFunctionContext struct {
	SupportedCreateStatementContext
	returnType       IDataTypeContext
	intermediateType IDataTypeContext
	properties       IPropertyClauseContext
}

func NewCreateUserDefineFunctionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateUserDefineFunctionContext {
	var p = new(CreateUserDefineFunctionContext)

	InitEmptySupportedCreateStatementContext(&p.SupportedCreateStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedCreateStatementContext))

	return p
}

func (s *CreateUserDefineFunctionContext) GetReturnType() IDataTypeContext { return s.returnType }

func (s *CreateUserDefineFunctionContext) GetIntermediateType() IDataTypeContext {
	return s.intermediateType
}

func (s *CreateUserDefineFunctionContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *CreateUserDefineFunctionContext) SetReturnType(v IDataTypeContext) { s.returnType = v }

func (s *CreateUserDefineFunctionContext) SetIntermediateType(v IDataTypeContext) {
	s.intermediateType = v
}

func (s *CreateUserDefineFunctionContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *CreateUserDefineFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateUserDefineFunctionContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCREATE, 0)
}

func (s *CreateUserDefineFunctionContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFUNCTION, 0)
}

func (s *CreateUserDefineFunctionContext) FunctionIdentifier() IFunctionIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionIdentifierContext)
}

func (s *CreateUserDefineFunctionContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLEFT_PAREN, 0)
}

func (s *CreateUserDefineFunctionContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRIGHT_PAREN, 0)
}

func (s *CreateUserDefineFunctionContext) RETURNS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRETURNS, 0)
}

func (s *CreateUserDefineFunctionContext) AllDataType() []IDataTypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDataTypeContext); ok {
			len++
		}
	}

	tst := make([]IDataTypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDataTypeContext); ok {
			tst[i] = t.(IDataTypeContext)
			i++
		}
	}

	return tst
}

func (s *CreateUserDefineFunctionContext) DataType(i int) IDataTypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *CreateUserDefineFunctionContext) StatementScope() IStatementScopeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementScopeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementScopeContext)
}

func (s *CreateUserDefineFunctionContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserParserIF, 0)
}

func (s *CreateUserDefineFunctionContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserNOT, 0)
}

func (s *CreateUserDefineFunctionContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserEXISTS, 0)
}

func (s *CreateUserDefineFunctionContext) FunctionArguments() IFunctionArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionArgumentsContext)
}

func (s *CreateUserDefineFunctionContext) INTERMEDIATE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserINTERMEDIATE, 0)
}

func (s *CreateUserDefineFunctionContext) TABLES() antlr.TerminalNode {
	return s.GetToken(DorisParserParserTABLES, 0)
}

func (s *CreateUserDefineFunctionContext) AGGREGATE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserAGGREGATE, 0)
}

func (s *CreateUserDefineFunctionContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *CreateUserDefineFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitCreateUserDefineFunction(s)

	default:
		return t.VisitChildren(s)
	}
}

type CreateStoragePolicyContext struct {
	SupportedCreateStatementContext
	name       IIdentifierContext
	properties IPropertyClauseContext
}

func NewCreateStoragePolicyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateStoragePolicyContext {
	var p = new(CreateStoragePolicyContext)

	InitEmptySupportedCreateStatementContext(&p.SupportedCreateStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedCreateStatementContext))

	return p
}

func (s *CreateStoragePolicyContext) GetName() IIdentifierContext { return s.name }

func (s *CreateStoragePolicyContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *CreateStoragePolicyContext) SetName(v IIdentifierContext) { s.name = v }

func (s *CreateStoragePolicyContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *CreateStoragePolicyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateStoragePolicyContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCREATE, 0)
}

func (s *CreateStoragePolicyContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTORAGE, 0)
}

func (s *CreateStoragePolicyContext) POLICY() antlr.TerminalNode {
	return s.GetToken(DorisParserParserPOLICY, 0)
}

func (s *CreateStoragePolicyContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateStoragePolicyContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserParserIF, 0)
}

func (s *CreateStoragePolicyContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserNOT, 0)
}

func (s *CreateStoragePolicyContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserEXISTS, 0)
}

func (s *CreateStoragePolicyContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *CreateStoragePolicyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitCreateStoragePolicy(s)

	default:
		return t.VisitChildren(s)
	}
}

type CreateIndexContext struct {
	SupportedCreateStatementContext
	name       IIdentifierContext
	tableName  IMultipartIdentifierContext
	properties IPropertyClauseContext
}

func NewCreateIndexContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateIndexContext {
	var p = new(CreateIndexContext)

	InitEmptySupportedCreateStatementContext(&p.SupportedCreateStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedCreateStatementContext))

	return p
}

func (s *CreateIndexContext) GetName() IIdentifierContext { return s.name }

func (s *CreateIndexContext) GetTableName() IMultipartIdentifierContext { return s.tableName }

func (s *CreateIndexContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *CreateIndexContext) SetName(v IIdentifierContext) { s.name = v }

func (s *CreateIndexContext) SetTableName(v IMultipartIdentifierContext) { s.tableName = v }

func (s *CreateIndexContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *CreateIndexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateIndexContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCREATE, 0)
}

func (s *CreateIndexContext) INDEX() antlr.TerminalNode {
	return s.GetToken(DorisParserParserINDEX, 0)
}

func (s *CreateIndexContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisParserParserON, 0)
}

func (s *CreateIndexContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *CreateIndexContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateIndexContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *CreateIndexContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserParserIF, 0)
}

func (s *CreateIndexContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserNOT, 0)
}

func (s *CreateIndexContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserEXISTS, 0)
}

func (s *CreateIndexContext) USING() antlr.TerminalNode {
	return s.GetToken(DorisParserParserUSING, 0)
}

func (s *CreateIndexContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOMMENT, 0)
}

func (s *CreateIndexContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTRING_LITERAL, 0)
}

func (s *CreateIndexContext) BITMAP() antlr.TerminalNode {
	return s.GetToken(DorisParserParserBITMAP, 0)
}

func (s *CreateIndexContext) NGRAM_BF() antlr.TerminalNode {
	return s.GetToken(DorisParserParserNGRAM_BF, 0)
}

func (s *CreateIndexContext) INVERTED() antlr.TerminalNode {
	return s.GetToken(DorisParserParserINVERTED, 0)
}

func (s *CreateIndexContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *CreateIndexContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitCreateIndex(s)

	default:
		return t.VisitChildren(s)
	}
}

type CreateRepositoryContext struct {
	SupportedCreateStatementContext
	name IIdentifierContext
}

func NewCreateRepositoryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateRepositoryContext {
	var p = new(CreateRepositoryContext)

	InitEmptySupportedCreateStatementContext(&p.SupportedCreateStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedCreateStatementContext))

	return p
}

func (s *CreateRepositoryContext) GetName() IIdentifierContext { return s.name }

func (s *CreateRepositoryContext) SetName(v IIdentifierContext) { s.name = v }

func (s *CreateRepositoryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateRepositoryContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCREATE, 0)
}

func (s *CreateRepositoryContext) REPOSITORY() antlr.TerminalNode {
	return s.GetToken(DorisParserParserREPOSITORY, 0)
}

func (s *CreateRepositoryContext) WITH() antlr.TerminalNode {
	return s.GetToken(DorisParserParserWITH, 0)
}

func (s *CreateRepositoryContext) StorageBackend() IStorageBackendContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStorageBackendContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStorageBackendContext)
}

func (s *CreateRepositoryContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateRepositoryContext) READ() antlr.TerminalNode {
	return s.GetToken(DorisParserParserREAD, 0)
}

func (s *CreateRepositoryContext) ONLY() antlr.TerminalNode {
	return s.GetToken(DorisParserParserONLY, 0)
}

func (s *CreateRepositoryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitCreateRepository(s)

	default:
		return t.VisitChildren(s)
	}
}

type CreateDatabaseContext struct {
	SupportedCreateStatementContext
	name       IMultipartIdentifierContext
	properties IPropertyClauseContext
}

func NewCreateDatabaseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateDatabaseContext {
	var p = new(CreateDatabaseContext)

	InitEmptySupportedCreateStatementContext(&p.SupportedCreateStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedCreateStatementContext))

	return p
}

func (s *CreateDatabaseContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *CreateDatabaseContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *CreateDatabaseContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *CreateDatabaseContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *CreateDatabaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateDatabaseContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCREATE, 0)
}

func (s *CreateDatabaseContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDATABASE, 0)
}

func (s *CreateDatabaseContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSCHEMA, 0)
}

func (s *CreateDatabaseContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *CreateDatabaseContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserParserIF, 0)
}

func (s *CreateDatabaseContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserNOT, 0)
}

func (s *CreateDatabaseContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserEXISTS, 0)
}

func (s *CreateDatabaseContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *CreateDatabaseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitCreateDatabase(s)

	default:
		return t.VisitChildren(s)
	}
}

type BuildIndexContext struct {
	SupportedCreateStatementContext
	name      IIdentifierContext
	tableName IMultipartIdentifierContext
}

func NewBuildIndexContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BuildIndexContext {
	var p = new(BuildIndexContext)

	InitEmptySupportedCreateStatementContext(&p.SupportedCreateStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedCreateStatementContext))

	return p
}

func (s *BuildIndexContext) GetName() IIdentifierContext { return s.name }

func (s *BuildIndexContext) GetTableName() IMultipartIdentifierContext { return s.tableName }

func (s *BuildIndexContext) SetName(v IIdentifierContext) { s.name = v }

func (s *BuildIndexContext) SetTableName(v IMultipartIdentifierContext) { s.tableName = v }

func (s *BuildIndexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BuildIndexContext) BUILD() antlr.TerminalNode {
	return s.GetToken(DorisParserParserBUILD, 0)
}

func (s *BuildIndexContext) INDEX() antlr.TerminalNode {
	return s.GetToken(DorisParserParserINDEX, 0)
}

func (s *BuildIndexContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisParserParserON, 0)
}

func (s *BuildIndexContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *BuildIndexContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *BuildIndexContext) PartitionSpec() IPartitionSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionSpecContext)
}

func (s *BuildIndexContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitBuildIndex(s)

	default:
		return t.VisitChildren(s)
	}
}

type CreateUserContext struct {
	SupportedCreateStatementContext
	role antlr.Token
}

func NewCreateUserContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateUserContext {
	var p = new(CreateUserContext)

	InitEmptySupportedCreateStatementContext(&p.SupportedCreateStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedCreateStatementContext))

	return p
}

func (s *CreateUserContext) GetRole() antlr.Token { return s.role }

func (s *CreateUserContext) SetRole(v antlr.Token) { s.role = v }

func (s *CreateUserContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateUserContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCREATE, 0)
}

func (s *CreateUserContext) USER() antlr.TerminalNode {
	return s.GetToken(DorisParserParserUSER, 0)
}

func (s *CreateUserContext) GrantUserIdentify() IGrantUserIdentifyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrantUserIdentifyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrantUserIdentifyContext)
}

func (s *CreateUserContext) PasswordOption() IPasswordOptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPasswordOptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPasswordOptionContext)
}

func (s *CreateUserContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserParserIF, 0)
}

func (s *CreateUserContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserNOT, 0)
}

func (s *CreateUserContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserEXISTS, 0)
}

func (s *CreateUserContext) SUPERUSER() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSUPERUSER, 0)
}

func (s *CreateUserContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDEFAULT, 0)
}

func (s *CreateUserContext) ROLE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserROLE, 0)
}

func (s *CreateUserContext) CommentSpec() ICommentSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentSpecContext)
}

func (s *CreateUserContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTRING_LITERAL, 0)
}

func (s *CreateUserContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitCreateUser(s)

	default:
		return t.VisitChildren(s)
	}
}

type CreateCatalogContext struct {
	SupportedCreateStatementContext
	catalogName  IIdentifierContext
	resourceName IIdentifierContext
	properties   IPropertyClauseContext
}

func NewCreateCatalogContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateCatalogContext {
	var p = new(CreateCatalogContext)

	InitEmptySupportedCreateStatementContext(&p.SupportedCreateStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedCreateStatementContext))

	return p
}

func (s *CreateCatalogContext) GetCatalogName() IIdentifierContext { return s.catalogName }

func (s *CreateCatalogContext) GetResourceName() IIdentifierContext { return s.resourceName }

func (s *CreateCatalogContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *CreateCatalogContext) SetCatalogName(v IIdentifierContext) { s.catalogName = v }

func (s *CreateCatalogContext) SetResourceName(v IIdentifierContext) { s.resourceName = v }

func (s *CreateCatalogContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *CreateCatalogContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateCatalogContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCREATE, 0)
}

func (s *CreateCatalogContext) CATALOG() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCATALOG, 0)
}

func (s *CreateCatalogContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *CreateCatalogContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateCatalogContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserParserIF, 0)
}

func (s *CreateCatalogContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserNOT, 0)
}

func (s *CreateCatalogContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserEXISTS, 0)
}

func (s *CreateCatalogContext) WITH() antlr.TerminalNode {
	return s.GetToken(DorisParserParserWITH, 0)
}

func (s *CreateCatalogContext) RESOURCE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRESOURCE, 0)
}

func (s *CreateCatalogContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOMMENT, 0)
}

func (s *CreateCatalogContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTRING_LITERAL, 0)
}

func (s *CreateCatalogContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *CreateCatalogContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitCreateCatalog(s)

	default:
		return t.VisitChildren(s)
	}
}

type CreateAliasFunctionContext struct {
	SupportedCreateStatementContext
	parameters IIdentifierSeqContext
}

func NewCreateAliasFunctionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateAliasFunctionContext {
	var p = new(CreateAliasFunctionContext)

	InitEmptySupportedCreateStatementContext(&p.SupportedCreateStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedCreateStatementContext))

	return p
}

func (s *CreateAliasFunctionContext) GetParameters() IIdentifierSeqContext { return s.parameters }

func (s *CreateAliasFunctionContext) SetParameters(v IIdentifierSeqContext) { s.parameters = v }

func (s *CreateAliasFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateAliasFunctionContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCREATE, 0)
}

func (s *CreateAliasFunctionContext) ALIAS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserALIAS, 0)
}

func (s *CreateAliasFunctionContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFUNCTION, 0)
}

func (s *CreateAliasFunctionContext) FunctionIdentifier() IFunctionIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionIdentifierContext)
}

func (s *CreateAliasFunctionContext) AllLEFT_PAREN() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserLEFT_PAREN)
}

func (s *CreateAliasFunctionContext) LEFT_PAREN(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserLEFT_PAREN, i)
}

func (s *CreateAliasFunctionContext) AllRIGHT_PAREN() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserRIGHT_PAREN)
}

func (s *CreateAliasFunctionContext) RIGHT_PAREN(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserRIGHT_PAREN, i)
}

func (s *CreateAliasFunctionContext) WITH() antlr.TerminalNode {
	return s.GetToken(DorisParserParserWITH, 0)
}

func (s *CreateAliasFunctionContext) PARAMETER() antlr.TerminalNode {
	return s.GetToken(DorisParserParserPARAMETER, 0)
}

func (s *CreateAliasFunctionContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserAS, 0)
}

func (s *CreateAliasFunctionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CreateAliasFunctionContext) StatementScope() IStatementScopeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementScopeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementScopeContext)
}

func (s *CreateAliasFunctionContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserParserIF, 0)
}

func (s *CreateAliasFunctionContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserNOT, 0)
}

func (s *CreateAliasFunctionContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserEXISTS, 0)
}

func (s *CreateAliasFunctionContext) FunctionArguments() IFunctionArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionArgumentsContext)
}

func (s *CreateAliasFunctionContext) IdentifierSeq() IIdentifierSeqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierSeqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierSeqContext)
}

func (s *CreateAliasFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitCreateAliasFunction(s)

	default:
		return t.VisitChildren(s)
	}
}

type CreateSqlBlockRuleContext struct {
	SupportedCreateStatementContext
	name       IIdentifierContext
	properties IPropertyClauseContext
}

func NewCreateSqlBlockRuleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateSqlBlockRuleContext {
	var p = new(CreateSqlBlockRuleContext)

	InitEmptySupportedCreateStatementContext(&p.SupportedCreateStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedCreateStatementContext))

	return p
}

func (s *CreateSqlBlockRuleContext) GetName() IIdentifierContext { return s.name }

func (s *CreateSqlBlockRuleContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *CreateSqlBlockRuleContext) SetName(v IIdentifierContext) { s.name = v }

func (s *CreateSqlBlockRuleContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *CreateSqlBlockRuleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateSqlBlockRuleContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCREATE, 0)
}

func (s *CreateSqlBlockRuleContext) SQL_BLOCK_RULE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSQL_BLOCK_RULE, 0)
}

func (s *CreateSqlBlockRuleContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateSqlBlockRuleContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserParserIF, 0)
}

func (s *CreateSqlBlockRuleContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserNOT, 0)
}

func (s *CreateSqlBlockRuleContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserEXISTS, 0)
}

func (s *CreateSqlBlockRuleContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *CreateSqlBlockRuleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitCreateSqlBlockRule(s)

	default:
		return t.VisitChildren(s)
	}
}

type CreateIndexTokenFilterContext struct {
	SupportedCreateStatementContext
	name       IIdentifierContext
	properties IPropertyClauseContext
}

func NewCreateIndexTokenFilterContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateIndexTokenFilterContext {
	var p = new(CreateIndexTokenFilterContext)

	InitEmptySupportedCreateStatementContext(&p.SupportedCreateStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedCreateStatementContext))

	return p
}

func (s *CreateIndexTokenFilterContext) GetName() IIdentifierContext { return s.name }

func (s *CreateIndexTokenFilterContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *CreateIndexTokenFilterContext) SetName(v IIdentifierContext) { s.name = v }

func (s *CreateIndexTokenFilterContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *CreateIndexTokenFilterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateIndexTokenFilterContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCREATE, 0)
}

func (s *CreateIndexTokenFilterContext) INVERTED() antlr.TerminalNode {
	return s.GetToken(DorisParserParserINVERTED, 0)
}

func (s *CreateIndexTokenFilterContext) INDEX() antlr.TerminalNode {
	return s.GetToken(DorisParserParserINDEX, 0)
}

func (s *CreateIndexTokenFilterContext) TOKEN_FILTER() antlr.TerminalNode {
	return s.GetToken(DorisParserParserTOKEN_FILTER, 0)
}

func (s *CreateIndexTokenFilterContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateIndexTokenFilterContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserParserIF, 0)
}

func (s *CreateIndexTokenFilterContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserNOT, 0)
}

func (s *CreateIndexTokenFilterContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserEXISTS, 0)
}

func (s *CreateIndexTokenFilterContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *CreateIndexTokenFilterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitCreateIndexTokenFilter(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) SupportedCreateStatement() (localctx ISupportedCreateStatementContext) {
	localctx = NewSupportedCreateStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, DorisParserParserRULE_supportedCreateStatement)
	var _la int

	p.SetState(1486)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 171, p.GetParserRuleContext()) {
	case 1:
		localctx = NewCreateTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(998)
			p.Match(DorisParserParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1000)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserEXTERNAL || _la == DorisParserParserTEMPORARY {
			{
				p.SetState(999)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserParserEXTERNAL || _la == DorisParserParserTEMPORARY) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(1002)
			p.Match(DorisParserParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1006)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserIF {
			{
				p.SetState(1003)
				p.Match(DorisParserParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1004)
				p.Match(DorisParserParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1005)
				p.Match(DorisParserParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1008)

			var _x = p.MultipartIdentifier()

			localctx.(*CreateTableContext).name = _x
		}
		p.SetState(1023)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 92, p.GetParserRuleContext()) {
		case 1:
			p.SetState(1010)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserParserLEFT_PAREN {
				{
					p.SetState(1009)

					var _x = p.IdentifierList()

					localctx.(*CreateTableContext).ctasCols = _x
				}

			}

		case 2:
			{
				p.SetState(1012)
				p.Match(DorisParserParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1013)
				p.ColumnDefs()
			}
			p.SetState(1016)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 90, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(1014)
					p.Match(DorisParserParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1015)
					p.IndexDefs()
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}
			p.SetState(1019)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserParserCOMMA {
				{
					p.SetState(1018)
					p.Match(DorisParserParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(1021)
				p.Match(DorisParserParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		p.SetState(1028)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserENGINE {
			{
				p.SetState(1025)
				p.Match(DorisParserParserENGINE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1026)
				p.Match(DorisParserParserEQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1027)

				var _x = p.Identifier()

				localctx.(*CreateTableContext).engine = _x
			}

		}
		p.SetState(1038)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserAGGREGATE || _la == DorisParserParserDUPLICATE || _la == DorisParserParserUNIQUE {
			{
				p.SetState(1030)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserParserAGGREGATE || _la == DorisParserParserDUPLICATE || _la == DorisParserParserUNIQUE) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(1031)
				p.Match(DorisParserParserKEY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1032)

				var _x = p.IdentifierList()

				localctx.(*CreateTableContext).keys = _x
			}
			p.SetState(1036)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserParserCLUSTER {
				{
					p.SetState(1033)
					p.Match(DorisParserParserCLUSTER)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1034)
					p.Match(DorisParserParserBY)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1035)

					var _x = p.IdentifierList()

					localctx.(*CreateTableContext).clusterKeys = _x
				}

			}

		}
		p.SetState(1042)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserCOMMENT {
			{
				p.SetState(1040)
				p.Match(DorisParserParserCOMMENT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1041)
				p.Match(DorisParserParserSTRING_LITERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1045)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserAUTO || _la == DorisParserParserPARTITION {
			{
				p.SetState(1044)

				var _x = p.PartitionTable()

				localctx.(*CreateTableContext).partition = _x
			}

		}
		p.SetState(1061)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserDISTRIBUTED {
			{
				p.SetState(1047)
				p.Match(DorisParserParserDISTRIBUTED)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1048)
				p.Match(DorisParserParserBY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(1052)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case DorisParserParserHASH:
				{
					p.SetState(1049)
					p.Match(DorisParserParserHASH)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1050)

					var _x = p.IdentifierList()

					localctx.(*CreateTableContext).hashKeys = _x
				}

			case DorisParserParserRANDOM:
				{
					p.SetState(1051)
					p.Match(DorisParserParserRANDOM)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}
			p.SetState(1059)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserParserBUCKETS {
				{
					p.SetState(1054)
					p.Match(DorisParserParserBUCKETS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(1057)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}

				switch p.GetTokenStream().LA(1) {
				case DorisParserParserINTEGER_VALUE:
					{
						p.SetState(1055)
						p.Match(DorisParserParserINTEGER_VALUE)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				case DorisParserParserAUTO:
					{
						p.SetState(1056)

						var _m = p.Match(DorisParserParserAUTO)

						localctx.(*CreateTableContext).autoBucket = _m
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				default:
					p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
					goto errorExit
				}

			}

		}
		p.SetState(1068)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserROLLUP {
			{
				p.SetState(1063)
				p.Match(DorisParserParserROLLUP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1064)
				p.Match(DorisParserParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1065)
				p.RollupDefs()
			}
			{
				p.SetState(1066)
				p.Match(DorisParserParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1071)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserPROPERTIES {
			{
				p.SetState(1070)

				var _x = p.PropertyClause()

				localctx.(*CreateTableContext).properties = _x
			}

		}
		p.SetState(1075)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserBROKER {
			{
				p.SetState(1073)
				p.Match(DorisParserParserBROKER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1074)

				var _x = p.PropertyClause()

				localctx.(*CreateTableContext).extProperties = _x
			}

		}
		p.SetState(1079)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserAS {
			{
				p.SetState(1077)
				p.Match(DorisParserParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1078)
				p.Query()
			}

		}

	case 2:
		localctx = NewCreateViewContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1081)
			p.Match(DorisParserParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1084)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserOR {
			{
				p.SetState(1082)
				p.Match(DorisParserParserOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1083)
				p.Match(DorisParserParserREPLACE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1086)
			p.Match(DorisParserParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1090)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserIF {
			{
				p.SetState(1087)
				p.Match(DorisParserParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1088)
				p.Match(DorisParserParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1089)
				p.Match(DorisParserParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1092)

			var _x = p.MultipartIdentifier()

			localctx.(*CreateViewContext).name = _x
		}
		p.SetState(1097)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserLEFT_PAREN {
			{
				p.SetState(1093)
				p.Match(DorisParserParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1094)

				var _x = p.SimpleColumnDefs()

				localctx.(*CreateViewContext).cols = _x
			}
			{
				p.SetState(1095)
				p.Match(DorisParserParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1101)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserCOMMENT {
			{
				p.SetState(1099)
				p.Match(DorisParserParserCOMMENT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1100)
				p.Match(DorisParserParserSTRING_LITERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1103)
			p.Match(DorisParserParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1104)
			p.Query()
		}

	case 3:
		localctx = NewCreateFileContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1106)
			p.Match(DorisParserParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1107)
			p.Match(DorisParserParserFILE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1108)

			var _m = p.Match(DorisParserParserSTRING_LITERAL)

			localctx.(*CreateFileContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1111)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserFROM || _la == DorisParserParserIN {
			{
				p.SetState(1109)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserParserFROM || _la == DorisParserParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(1110)

				var _x = p.Identifier()

				localctx.(*CreateFileContext).database = _x
			}

		}
		{
			p.SetState(1113)

			var _x = p.PropertyClause()

			localctx.(*CreateFileContext).properties = _x
		}

	case 4:
		localctx = NewCreateTableLikeContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1114)
			p.Match(DorisParserParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1116)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserEXTERNAL || _la == DorisParserParserTEMPORARY {
			{
				p.SetState(1115)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserParserEXTERNAL || _la == DorisParserParserTEMPORARY) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(1118)
			p.Match(DorisParserParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1122)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserIF {
			{
				p.SetState(1119)
				p.Match(DorisParserParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1120)
				p.Match(DorisParserParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1121)
				p.Match(DorisParserParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1124)

			var _x = p.MultipartIdentifier()

			localctx.(*CreateTableLikeContext).name = _x
		}
		{
			p.SetState(1125)
			p.Match(DorisParserParserLIKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1126)

			var _x = p.MultipartIdentifier()

			localctx.(*CreateTableLikeContext).existedTable = _x
		}
		p.SetState(1132)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserWITH {
			{
				p.SetState(1127)
				p.Match(DorisParserParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1128)
				p.Match(DorisParserParserROLLUP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(1130)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserParserLEFT_PAREN {
				{
					p.SetState(1129)

					var _x = p.IdentifierList()

					localctx.(*CreateTableLikeContext).rollupNames = _x
				}

			}

		}

	case 5:
		localctx = NewCreateRoleContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1134)
			p.Match(DorisParserParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1135)
			p.Match(DorisParserParserROLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1139)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserIF {
			{
				p.SetState(1136)
				p.Match(DorisParserParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1137)
				p.Match(DorisParserParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1138)
				p.Match(DorisParserParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1141)

			var _x = p.IdentifierOrText()

			localctx.(*CreateRoleContext).name = _x
		}
		p.SetState(1144)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserCOMMENT {
			{
				p.SetState(1142)
				p.Match(DorisParserParserCOMMENT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1143)
				p.Match(DorisParserParserSTRING_LITERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 6:
		localctx = NewCreateWorkloadGroupContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1146)
			p.Match(DorisParserParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1147)
			p.Match(DorisParserParserWORKLOAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1148)
			p.Match(DorisParserParserGROUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1152)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserIF {
			{
				p.SetState(1149)
				p.Match(DorisParserParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1150)
				p.Match(DorisParserParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1151)
				p.Match(DorisParserParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1154)

			var _x = p.IdentifierOrText()

			localctx.(*CreateWorkloadGroupContext).name = _x
		}
		p.SetState(1157)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserFOR {
			{
				p.SetState(1155)
				p.Match(DorisParserParserFOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1156)

				var _x = p.IdentifierOrText()

				localctx.(*CreateWorkloadGroupContext).computeGroup = _x
			}

		}
		p.SetState(1160)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserPROPERTIES {
			{
				p.SetState(1159)

				var _x = p.PropertyClause()

				localctx.(*CreateWorkloadGroupContext).properties = _x
			}

		}

	case 7:
		localctx = NewCreateCatalogContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1162)
			p.Match(DorisParserParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1163)
			p.Match(DorisParserParserCATALOG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1167)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserIF {
			{
				p.SetState(1164)
				p.Match(DorisParserParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1165)
				p.Match(DorisParserParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1166)
				p.Match(DorisParserParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1169)

			var _x = p.Identifier()

			localctx.(*CreateCatalogContext).catalogName = _x
		}
		p.SetState(1173)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserWITH {
			{
				p.SetState(1170)
				p.Match(DorisParserParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1171)
				p.Match(DorisParserParserRESOURCE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1172)

				var _x = p.Identifier()

				localctx.(*CreateCatalogContext).resourceName = _x
			}

		}
		p.SetState(1177)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserCOMMENT {
			{
				p.SetState(1175)
				p.Match(DorisParserParserCOMMENT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1176)
				p.Match(DorisParserParserSTRING_LITERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1180)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserPROPERTIES {
			{
				p.SetState(1179)

				var _x = p.PropertyClause()

				localctx.(*CreateCatalogContext).properties = _x
			}

		}

	case 8:
		localctx = NewCreateRowPolicyContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1182)
			p.Match(DorisParserParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1183)
			p.Match(DorisParserParserROW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1184)
			p.Match(DorisParserParserPOLICY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1188)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserIF {
			{
				p.SetState(1185)
				p.Match(DorisParserParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1186)
				p.Match(DorisParserParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1187)
				p.Match(DorisParserParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1190)

			var _x = p.Identifier()

			localctx.(*CreateRowPolicyContext).name = _x
		}
		{
			p.SetState(1191)
			p.Match(DorisParserParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1192)

			var _x = p.MultipartIdentifier()

			localctx.(*CreateRowPolicyContext).table = _x
		}
		{
			p.SetState(1193)
			p.Match(DorisParserParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1194)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*CreateRowPolicyContext).type_ = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserParserPERMISSIVE || _la == DorisParserParserRESTRICTIVE) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*CreateRowPolicyContext).type_ = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1195)
			p.Match(DorisParserParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1199)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserParserLEFT_BRACE, DorisParserParserRIGHT_BRACE, DorisParserParserACTIONS, DorisParserParserAFTER, DorisParserParserAGG_STATE, DorisParserParserAGGREGATE, DorisParserParserALIAS, DorisParserParserANALYZED, DorisParserParserARRAY, DorisParserParserAT, DorisParserParserAUTHORS, DorisParserParserAUTO_INCREMENT, DorisParserParserALWAYS, DorisParserParserBACKENDS, DorisParserParserBACKUP, DorisParserParserBEGIN, DorisParserParserBELONG, DorisParserParserBIN, DorisParserParserBITAND, DorisParserParserBITMAP, DorisParserParserBITMAP_EMPTY, DorisParserParserBITMAP_UNION, DorisParserParserBITOR, DorisParserParserBITXOR, DorisParserParserBLOB, DorisParserParserBOOLEAN, DorisParserParserBRANCH, DorisParserParserBRIEF, DorisParserParserBROKER, DorisParserParserBUCKETS, DorisParserParserBUILD, DorisParserParserBUILTIN, DorisParserParserBULK, DorisParserParserCACHE, DorisParserParserCACHED, DorisParserParserCALL, DorisParserParserCATALOG, DorisParserParserCATALOGS, DorisParserParserCHAIN, DorisParserParserCHAR, DorisParserParserCHARSET, DorisParserParserCHECK, DorisParserParserCLUSTER, DorisParserParserCLUSTERS, DorisParserParserCOLLATION, DorisParserParserCOLLECT, DorisParserParserCOLOCATE, DorisParserParserCOLUMNS, DorisParserParserCOMMENT, DorisParserParserCOMMIT, DorisParserParserCOMMITTED, DorisParserParserCOMPACT, DorisParserParserCOMPLETE, DorisParserParserCOMPRESS_TYPE, DorisParserParserCOMPUTE, DorisParserParserCONDITIONS, DorisParserParserCONFIG, DorisParserParserCONNECTION, DorisParserParserCONNECTION_ID, DorisParserParserCONSISTENT, DorisParserParserCONSTRAINTS, DorisParserParserCONVERT, DorisParserParserCONVERT_LSC, DorisParserParserCOPY, DorisParserParserCOUNT, DorisParserParserCREATION, DorisParserParserCRON, DorisParserParserCURRENT_CATALOG, DorisParserParserCURRENT_DATE, DorisParserParserCURRENT_TIME, DorisParserParserCURRENT_TIMESTAMP, DorisParserParserCURRENT_USER, DorisParserParserDATA, DorisParserParserDATE, DorisParserParserDATETIME, DorisParserParserDATETIMEV2, DorisParserParserDATEV2, DorisParserParserDATETIMEV1, DorisParserParserDATEV1, DorisParserParserDAY, DorisParserParserDAYS, DorisParserParserDECIMAL, DorisParserParserDECIMALV2, DorisParserParserDECIMALV3, DorisParserParserDEFERRED, DorisParserParserDEMAND, DorisParserParserDIAGNOSE, DorisParserParserDIAGNOSIS, DorisParserParserDICTIONARIES, DorisParserParserDICTIONARY, DorisParserParserDISTINCTPC, DorisParserParserDISTINCTPCSA, DorisParserParserDO, DorisParserParserDORIS_INTERNAL_TABLE_ID, DorisParserParserDUAL, DorisParserParserDYNAMIC, DorisParserParserE, DorisParserParserENABLE, DorisParserParserENCRYPTKEY, DorisParserParserENCRYPTKEYS, DorisParserParserEND, DorisParserParserENDS, DorisParserParserENGINE, DorisParserParserENGINES, DorisParserParserERRORS, DorisParserParserESCAPE, DorisParserParserEVENTS, DorisParserParserEVERY, DorisParserParserEXCLUDE, DorisParserParserEXPIRED, DorisParserParserEXTERNAL, DorisParserParserFAILED_LOGIN_ATTEMPTS, DorisParserParserFAST, DorisParserParserFEATURE, DorisParserParserFIELDS, DorisParserParserFILE, DorisParserParserFILTER, DorisParserParserFIRST, DorisParserParserFORMAT, DorisParserParserFREE, DorisParserParserFRONTENDS, DorisParserParserFUNCTION, DorisParserParserGENERATED, DorisParserParserGENERIC, DorisParserParserGLOBAL, DorisParserParserGRAPH, DorisParserParserGROUPING, DorisParserParserGROUPS, DorisParserParserHASH, DorisParserParserHASH_MAP, DorisParserParserHDFS, DorisParserParserHELP, DorisParserParserHISTOGRAM, DorisParserParserHLL_UNION, DorisParserParserHOSTNAME, DorisParserParserHOTSPOT, DorisParserParserHOUR, DorisParserParserHOURS, DorisParserParserHUB, DorisParserParserIDENTIFIED, DorisParserParserIGNORE, DorisParserParserIMMEDIATE, DorisParserParserINCREMENTAL, DorisParserParserINDEXES, DorisParserParserINVERTED, DorisParserParserIP_TRIE, DorisParserParserIPV4, DorisParserParserIPV6, DorisParserParserIS_NOT_NULL_PRED, DorisParserParserIS_NULL_PRED, DorisParserParserISNULL, DorisParserParserISOLATION, DorisParserParserJOB, DorisParserParserJOBS, DorisParserParserJSON, DorisParserParserJSONB, DorisParserParserLABEL, DorisParserParserLAST, DorisParserParserLDAP, DorisParserParserLDAP_ADMIN_PASSWORD, DorisParserParserLESS, DorisParserParserLEVEL, DorisParserParserLINES, DorisParserParserLINK, DorisParserParserLOCAL, DorisParserParserLOCALTIME, DorisParserParserLOCALTIMESTAMP, DorisParserParserLOCATION, DorisParserParserLOCK, DorisParserParserLOGICAL, DorisParserParserMANUAL, DorisParserParserMAP, DorisParserParserMATCH_ALL, DorisParserParserMATCH_ANY, DorisParserParserMATCH_PHRASE, DorisParserParserMATCH_PHRASE_EDGE, DorisParserParserMATCH_PHRASE_PREFIX, DorisParserParserMATCH_REGEXP, DorisParserParserMATERIALIZED, DorisParserParserMAX, DorisParserParserMEMO, DorisParserParserMERGE, DorisParserParserMIGRATE, DorisParserParserMIGRATIONS, DorisParserParserMIN, DorisParserParserMINUTE, DorisParserParserMINUTES, DorisParserParserMODIFY, DorisParserParserMONTH, DorisParserParserMTMV, DorisParserParserNAME, DorisParserParserNAMES, DorisParserParserNEGATIVE, DorisParserParserNEVER, DorisParserParserNEXT, DorisParserParserNGRAM_BF, DorisParserParserNO, DorisParserParserNON_NULLABLE, DorisParserParserNULLS, DorisParserParserOF, DorisParserParserOFFSET, DorisParserParserONLY, DorisParserParserOPEN, DorisParserParserOPTIMIZED, DorisParserParserPARAMETER, DorisParserParserPARSED, DorisParserParserPARTITIONS, DorisParserParserPASSWORD, DorisParserParserPASSWORD_EXPIRE, DorisParserParserPASSWORD_HISTORY, DorisParserParserPASSWORD_LOCK_TIME, DorisParserParserPASSWORD_REUSE, DorisParserParserPATH, DorisParserParserPAUSE, DorisParserParserPERCENT, DorisParserParserPERIOD, DorisParserParserPERMISSIVE, DorisParserParserPHYSICAL, DorisParserParserPI, DorisParserParserPLAN, DorisParserParserPRIVILEGES, DorisParserParserPROCESS, DorisParserParserPLUGIN, DorisParserParserPLUGINS, DorisParserParserPOLICY, DorisParserParserPROC, DorisParserParserPROCESSLIST, DorisParserParserPROFILE, DorisParserParserPROPERTIES, DorisParserParserPROPERTY, DorisParserParserQUANTILE_STATE, DorisParserParserQUANTILE_UNION, DorisParserParserQUERY, DorisParserParserQUEUED, DorisParserParserQUOTA, DorisParserParserQUALIFY, DorisParserParserQUARTER, DorisParserParserRANDOM, DorisParserParserRECENT, DorisParserParserRECOVER, DorisParserParserRECYCLE, DorisParserParserREFRESH, DorisParserParserREPEATABLE, DorisParserParserREPLACE, DorisParserParserREPLACE_IF_NOT_NULL, DorisParserParserREPLAYER, DorisParserParserREPOSITORIES, DorisParserParserREPOSITORY, DorisParserParserRESOURCE, DorisParserParserRESOURCES, DorisParserParserRESTORE, DorisParserParserRESTRICTIVE, DorisParserParserRESUME, DorisParserParserRETAIN, DorisParserParserRETENTION, DorisParserParserRETURNS, DorisParserParserREWRITTEN, DorisParserParserRLIKE, DorisParserParserROLLBACK, DorisParserParserROLLUP, DorisParserParserROUTINE, DorisParserParserS3, DorisParserParserSAMPLE, DorisParserParserSCHEDULE, DorisParserParserSCHEDULER, DorisParserParserSCHEMA, DorisParserParserSECOND, DorisParserParserSERIALIZABLE, DorisParserParserSESSION, DorisParserParserSESSION_USER, DorisParserParserSET_SESSION_VARIABLE, DorisParserParserSHAPE, DorisParserParserSKEW, DorisParserParserSNAPSHOT, DorisParserParserSNAPSHOTS, DorisParserParserSONAME, DorisParserParserSPLIT, DorisParserParserSQL, DorisParserParserSTAGE, DorisParserParserSTAGES, DorisParserParserSTART, DorisParserParserSTARTS, DorisParserParserSTATS, DorisParserParserSTATUS, DorisParserParserSTOP, DorisParserParserSTORAGE, DorisParserParserSTREAM, DorisParserParserSTREAMING, DorisParserParserSTRING, DorisParserParserSTRUCT, DorisParserParserSUM, DorisParserParserTABLES, DorisParserParserTAG, DorisParserParserTASK, DorisParserParserTASKS, DorisParserParserTEMPORARY, DorisParserParserTEXT, DorisParserParserTHAN, DorisParserParserTIME, DorisParserParserTIMESTAMP, DorisParserParserTRANSACTION, DorisParserParserTREE, DorisParserParserTRIGGERS, DorisParserParserTRUNCATE, DorisParserParserTYPE, DorisParserParserTYPES, DorisParserParserUNCOMMITTED, DorisParserParserUNLOCK, DorisParserParserUNSET, DorisParserParserUP, DorisParserParserUSER, DorisParserParserVALUE, DorisParserParserVARCHAR, DorisParserParserVARIABLE, DorisParserParserVARIABLES, DorisParserParserVARIANT, DorisParserParserVAULT, DorisParserParserVAULTS, DorisParserParserVERBOSE, DorisParserParserVERSION, DorisParserParserVIEW, DorisParserParserVIEWS, DorisParserParserWARM, DorisParserParserWARNINGS, DorisParserParserWEEK, DorisParserParserWORK, DorisParserParserYEAR, DorisParserParserHINT_START, DorisParserParserHINT_END, DorisParserParserCOMMENT_START, DorisParserParserSTRING_LITERAL, DorisParserParserIDENTIFIER, DorisParserParserBACKQUOTED_IDENTIFIER:
			{
				p.SetState(1196)

				var _x = p.UserIdentify()

				localctx.(*CreateRowPolicyContext).user = _x
			}

		case DorisParserParserROLE:
			{
				p.SetState(1197)
				p.Match(DorisParserParserROLE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1198)

				var _x = p.IdentifierOrText()

				localctx.(*CreateRowPolicyContext).roleName = _x
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(1201)
			p.Match(DorisParserParserUSING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1202)
			p.Match(DorisParserParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1203)
			p.booleanExpression(0)
		}
		{
			p.SetState(1204)
			p.Match(DorisParserParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 9:
		localctx = NewCreateStoragePolicyContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1206)
			p.Match(DorisParserParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1207)
			p.Match(DorisParserParserSTORAGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1208)
			p.Match(DorisParserParserPOLICY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1212)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserIF {
			{
				p.SetState(1209)
				p.Match(DorisParserParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1210)
				p.Match(DorisParserParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1211)
				p.Match(DorisParserParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1214)

			var _x = p.Identifier()

			localctx.(*CreateStoragePolicyContext).name = _x
		}
		p.SetState(1216)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserPROPERTIES {
			{
				p.SetState(1215)

				var _x = p.PropertyClause()

				localctx.(*CreateStoragePolicyContext).properties = _x
			}

		}

	case 10:
		localctx = NewBuildIndexContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1218)
			p.Match(DorisParserParserBUILD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1219)
			p.Match(DorisParserParserINDEX)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1220)

			var _x = p.Identifier()

			localctx.(*BuildIndexContext).name = _x
		}
		{
			p.SetState(1221)
			p.Match(DorisParserParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1222)

			var _x = p.MultipartIdentifier()

			localctx.(*BuildIndexContext).tableName = _x
		}
		p.SetState(1224)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserPARTITION || _la == DorisParserParserPARTITIONS || _la == DorisParserParserTEMPORARY {
			{
				p.SetState(1223)
				p.PartitionSpec()
			}

		}

	case 11:
		localctx = NewCreateIndexContext(p, localctx)
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1226)
			p.Match(DorisParserParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1227)
			p.Match(DorisParserParserINDEX)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1231)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserIF {
			{
				p.SetState(1228)
				p.Match(DorisParserParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1229)
				p.Match(DorisParserParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1230)
				p.Match(DorisParserParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1233)

			var _x = p.Identifier()

			localctx.(*CreateIndexContext).name = _x
		}
		{
			p.SetState(1234)
			p.Match(DorisParserParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1235)

			var _x = p.MultipartIdentifier()

			localctx.(*CreateIndexContext).tableName = _x
		}
		{
			p.SetState(1236)
			p.IdentifierList()
		}
		p.SetState(1239)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserUSING {
			{
				p.SetState(1237)
				p.Match(DorisParserParserUSING)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1238)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserParserBITMAP || _la == DorisParserParserINVERTED || _la == DorisParserParserNGRAM_BF) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		p.SetState(1242)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserPROPERTIES {
			{
				p.SetState(1241)

				var _x = p.PropertyClause()

				localctx.(*CreateIndexContext).properties = _x
			}

		}
		p.SetState(1246)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserCOMMENT {
			{
				p.SetState(1244)
				p.Match(DorisParserParserCOMMENT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1245)
				p.Match(DorisParserParserSTRING_LITERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 12:
		localctx = NewCreateWorkloadPolicyContext(p, localctx)
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(1248)
			p.Match(DorisParserParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1249)
			p.Match(DorisParserParserWORKLOAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1250)
			p.Match(DorisParserParserPOLICY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1254)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserIF {
			{
				p.SetState(1251)
				p.Match(DorisParserParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1252)
				p.Match(DorisParserParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1253)
				p.Match(DorisParserParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1256)

			var _x = p.IdentifierOrText()

			localctx.(*CreateWorkloadPolicyContext).name = _x
		}
		p.SetState(1262)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserCONDITIONS {
			{
				p.SetState(1257)
				p.Match(DorisParserParserCONDITIONS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1258)
				p.Match(DorisParserParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1259)
				p.WorkloadPolicyConditions()
			}
			{
				p.SetState(1260)
				p.Match(DorisParserParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1269)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserACTIONS {
			{
				p.SetState(1264)
				p.Match(DorisParserParserACTIONS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1265)
				p.Match(DorisParserParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1266)
				p.WorkloadPolicyActions()
			}
			{
				p.SetState(1267)
				p.Match(DorisParserParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1272)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserPROPERTIES {
			{
				p.SetState(1271)

				var _x = p.PropertyClause()

				localctx.(*CreateWorkloadPolicyContext).properties = _x
			}

		}

	case 13:
		localctx = NewCreateSqlBlockRuleContext(p, localctx)
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(1274)
			p.Match(DorisParserParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1275)
			p.Match(DorisParserParserSQL_BLOCK_RULE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1279)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserIF {
			{
				p.SetState(1276)
				p.Match(DorisParserParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1277)
				p.Match(DorisParserParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1278)
				p.Match(DorisParserParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1281)

			var _x = p.Identifier()

			localctx.(*CreateSqlBlockRuleContext).name = _x
		}
		p.SetState(1283)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserPROPERTIES {
			{
				p.SetState(1282)

				var _x = p.PropertyClause()

				localctx.(*CreateSqlBlockRuleContext).properties = _x
			}

		}

	case 14:
		localctx = NewCreateEncryptkeyContext(p, localctx)
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(1285)
			p.Match(DorisParserParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1286)
			p.Match(DorisParserParserENCRYPTKEY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1290)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserIF {
			{
				p.SetState(1287)
				p.Match(DorisParserParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1288)
				p.Match(DorisParserParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1289)
				p.Match(DorisParserParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1292)
			p.MultipartIdentifier()
		}
		{
			p.SetState(1293)
			p.Match(DorisParserParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1294)
			p.Match(DorisParserParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 15:
		localctx = NewCreateUserDefineFunctionContext(p, localctx)
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(1296)
			p.Match(DorisParserParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1298)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserGLOBAL || _la == DorisParserParserLOCAL || _la == DorisParserParserSESSION {
			{
				p.SetState(1297)
				p.StatementScope()
			}

		}
		p.SetState(1301)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserAGGREGATE || _la == DorisParserParserTABLES {
			{
				p.SetState(1300)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserParserAGGREGATE || _la == DorisParserParserTABLES) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(1303)
			p.Match(DorisParserParserFUNCTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1307)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 142, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1304)
				p.Match(DorisParserParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1305)
				p.Match(DorisParserParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1306)
				p.Match(DorisParserParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(1309)
			p.FunctionIdentifier()
		}
		{
			p.SetState(1310)
			p.Match(DorisParserParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1312)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&9152335059222592) != 0) || ((int64((_la-71)) & ^0x3f) == 0 && ((int64(1)<<(_la-71))&32633505112391681) != 0) || _la == DorisParserParserDOUBLE || _la == DorisParserParserFLOAT || ((int64((_la-214)) & ^0x3f) == 0 && ((int64(1)<<(_la-214))&9208814108673) != 0) || _la == DorisParserParserMAP || _la == DorisParserParserQUANTILE_STATE || ((int64((_la-427)) & ^0x3f) == 0 && ((int64(1)<<(_la-427))&704375029761) != 0) || _la == DorisParserParserVARCHAR || _la == DorisParserParserVARIANT {
			{
				p.SetState(1311)
				p.FunctionArguments()
			}

		}
		{
			p.SetState(1314)
			p.Match(DorisParserParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1315)
			p.Match(DorisParserParserRETURNS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1316)

			var _x = p.DataType()

			localctx.(*CreateUserDefineFunctionContext).returnType = _x
		}
		p.SetState(1319)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserINTERMEDIATE {
			{
				p.SetState(1317)
				p.Match(DorisParserParserINTERMEDIATE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1318)

				var _x = p.DataType()

				localctx.(*CreateUserDefineFunctionContext).intermediateType = _x
			}

		}
		p.SetState(1322)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserPROPERTIES {
			{
				p.SetState(1321)

				var _x = p.PropertyClause()

				localctx.(*CreateUserDefineFunctionContext).properties = _x
			}

		}

	case 16:
		localctx = NewCreateAliasFunctionContext(p, localctx)
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(1324)
			p.Match(DorisParserParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1326)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserGLOBAL || _la == DorisParserParserLOCAL || _la == DorisParserParserSESSION {
			{
				p.SetState(1325)
				p.StatementScope()
			}

		}
		{
			p.SetState(1328)
			p.Match(DorisParserParserALIAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1329)
			p.Match(DorisParserParserFUNCTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1333)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 147, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1330)
				p.Match(DorisParserParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1331)
				p.Match(DorisParserParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1332)
				p.Match(DorisParserParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(1335)
			p.FunctionIdentifier()
		}
		{
			p.SetState(1336)
			p.Match(DorisParserParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1338)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&9152335059222592) != 0) || ((int64((_la-71)) & ^0x3f) == 0 && ((int64(1)<<(_la-71))&32633505112391681) != 0) || _la == DorisParserParserDOUBLE || _la == DorisParserParserFLOAT || ((int64((_la-214)) & ^0x3f) == 0 && ((int64(1)<<(_la-214))&9208814108673) != 0) || _la == DorisParserParserMAP || _la == DorisParserParserQUANTILE_STATE || ((int64((_la-427)) & ^0x3f) == 0 && ((int64(1)<<(_la-427))&704375029761) != 0) || _la == DorisParserParserVARCHAR || _la == DorisParserParserVARIANT {
			{
				p.SetState(1337)
				p.FunctionArguments()
			}

		}
		{
			p.SetState(1340)
			p.Match(DorisParserParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1341)
			p.Match(DorisParserParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1342)
			p.Match(DorisParserParserPARAMETER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1343)
			p.Match(DorisParserParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1345)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-2305902462020672000) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&4609989332399152113) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-9080794533051819547) != 0) || ((int64((_la-192)) & ^0x3f) == 0 && ((int64(1)<<(_la-192))&2015220189171012521) != 0) || ((int64((_la-256)) & ^0x3f) == 0 && ((int64(1)<<(_la-256))&-5422616543060085911) != 0) || ((int64((_la-320)) & ^0x3f) == 0 && ((int64(1)<<(_la-320))&-4476015178520986877) != 0) || ((int64((_la-384)) & ^0x3f) == 0 && ((int64(1)<<(_la-384))&9222796779122679803) != 0) || ((int64((_la-452)) & ^0x3f) == 0 && ((int64(1)<<(_la-452))&2449945648119953137) != 0) || ((int64((_la-517)) & ^0x3f) == 0 && ((int64(1)<<(_la-517))&206187790337) != 0) {
			{
				p.SetState(1344)

				var _x = p.IdentifierSeq()

				localctx.(*CreateAliasFunctionContext).parameters = _x
			}

		}
		{
			p.SetState(1347)
			p.Match(DorisParserParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1348)
			p.Match(DorisParserParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1349)
			p.Expression()
		}

	case 17:
		localctx = NewCreateUserContext(p, localctx)
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(1351)
			p.Match(DorisParserParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1352)
			p.Match(DorisParserParserUSER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1356)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserIF {
			{
				p.SetState(1353)
				p.Match(DorisParserParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1354)
				p.Match(DorisParserParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1355)
				p.Match(DorisParserParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1358)
			p.GrantUserIdentify()
		}
		p.SetState(1363)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		switch p.GetTokenStream().LA(1) {
		case DorisParserParserSUPERUSER:
			{
				p.SetState(1359)
				p.Match(DorisParserParserSUPERUSER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserParserDEFAULT:
			{
				p.SetState(1360)
				p.Match(DorisParserParserDEFAULT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1361)
				p.Match(DorisParserParserROLE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1362)

				var _m = p.Match(DorisParserParserSTRING_LITERAL)

				localctx.(*CreateUserContext).role = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserParserEOF, DorisParserParserSEMICOLON, DorisParserParserACCOUNT_LOCK, DorisParserParserACCOUNT_UNLOCK, DorisParserParserCOMMENT, DorisParserParserFAILED_LOGIN_ATTEMPTS, DorisParserParserPASSWORD_EXPIRE, DorisParserParserPASSWORD_HISTORY, DorisParserParserPASSWORD_LOCK_TIME, DorisParserParserPASSWORD_REUSE:

		default:
		}
		{
			p.SetState(1365)
			p.PasswordOption()
		}
		p.SetState(1367)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserCOMMENT {
			{
				p.SetState(1366)
				p.CommentSpec()
			}

		}

	case 18:
		localctx = NewCreateDatabaseContext(p, localctx)
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(1369)
			p.Match(DorisParserParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1370)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserParserDATABASE || _la == DorisParserParserSCHEMA) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(1374)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserIF {
			{
				p.SetState(1371)
				p.Match(DorisParserParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1372)
				p.Match(DorisParserParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1373)
				p.Match(DorisParserParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1376)

			var _x = p.MultipartIdentifier()

			localctx.(*CreateDatabaseContext).name = _x
		}
		p.SetState(1378)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserPROPERTIES {
			{
				p.SetState(1377)

				var _x = p.PropertyClause()

				localctx.(*CreateDatabaseContext).properties = _x
			}

		}

	case 19:
		localctx = NewCreateRepositoryContext(p, localctx)
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(1380)
			p.Match(DorisParserParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1383)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserREAD {
			{
				p.SetState(1381)
				p.Match(DorisParserParserREAD)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1382)
				p.Match(DorisParserParserONLY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1385)
			p.Match(DorisParserParserREPOSITORY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1386)

			var _x = p.Identifier()

			localctx.(*CreateRepositoryContext).name = _x
		}
		{
			p.SetState(1387)
			p.Match(DorisParserParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1388)
			p.StorageBackend()
		}

	case 20:
		localctx = NewCreateResourceContext(p, localctx)
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(1390)
			p.Match(DorisParserParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1392)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserEXTERNAL {
			{
				p.SetState(1391)
				p.Match(DorisParserParserEXTERNAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1394)
			p.Match(DorisParserParserRESOURCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1398)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserIF {
			{
				p.SetState(1395)
				p.Match(DorisParserParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1396)
				p.Match(DorisParserParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1397)
				p.Match(DorisParserParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1400)

			var _x = p.IdentifierOrText()

			localctx.(*CreateResourceContext).name = _x
		}
		p.SetState(1402)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserPROPERTIES {
			{
				p.SetState(1401)

				var _x = p.PropertyClause()

				localctx.(*CreateResourceContext).properties = _x
			}

		}

	case 21:
		localctx = NewCreateDictionaryContext(p, localctx)
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(1404)
			p.Match(DorisParserParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1405)
			p.Match(DorisParserParserDICTIONARY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1409)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserIF {
			{
				p.SetState(1406)
				p.Match(DorisParserParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1407)
				p.Match(DorisParserParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1408)
				p.Match(DorisParserParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1411)

			var _x = p.MultipartIdentifier()

			localctx.(*CreateDictionaryContext).name = _x
		}
		{
			p.SetState(1412)
			p.Match(DorisParserParserUSING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1413)

			var _x = p.MultipartIdentifier()

			localctx.(*CreateDictionaryContext).source = _x
		}
		{
			p.SetState(1414)
			p.Match(DorisParserParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1415)
			p.DictionaryColumnDefs()
		}
		{
			p.SetState(1416)
			p.Match(DorisParserParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1417)
			p.Match(DorisParserParserLAYOUT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1418)
			p.Match(DorisParserParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1419)

			var _x = p.Identifier()

			localctx.(*CreateDictionaryContext).layoutType = _x
		}
		{
			p.SetState(1420)
			p.Match(DorisParserParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1422)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserPROPERTIES {
			{
				p.SetState(1421)

				var _x = p.PropertyClause()

				localctx.(*CreateDictionaryContext).properties = _x
			}

		}

	case 22:
		localctx = NewCreateStageContext(p, localctx)
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(1424)
			p.Match(DorisParserParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1425)
			p.Match(DorisParserParserSTAGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1429)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserIF {
			{
				p.SetState(1426)
				p.Match(DorisParserParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1427)
				p.Match(DorisParserParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1428)
				p.Match(DorisParserParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1431)

			var _x = p.Identifier()

			localctx.(*CreateStageContext).name = _x
		}
		p.SetState(1433)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserPROPERTIES {
			{
				p.SetState(1432)

				var _x = p.PropertyClause()

				localctx.(*CreateStageContext).properties = _x
			}

		}

	case 23:
		localctx = NewCreateStorageVaultContext(p, localctx)
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(1435)
			p.Match(DorisParserParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1436)
			p.Match(DorisParserParserSTORAGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1437)
			p.Match(DorisParserParserVAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1441)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserIF {
			{
				p.SetState(1438)
				p.Match(DorisParserParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1439)
				p.Match(DorisParserParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1440)
				p.Match(DorisParserParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1443)

			var _x = p.IdentifierOrText()

			localctx.(*CreateStorageVaultContext).name = _x
		}
		p.SetState(1445)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserPROPERTIES {
			{
				p.SetState(1444)

				var _x = p.PropertyClause()

				localctx.(*CreateStorageVaultContext).properties = _x
			}

		}

	case 24:
		localctx = NewCreateIndexAnalyzerContext(p, localctx)
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(1447)
			p.Match(DorisParserParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1448)
			p.Match(DorisParserParserINVERTED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1449)
			p.Match(DorisParserParserINDEX)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1450)
			p.Match(DorisParserParserANALYZER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1454)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserIF {
			{
				p.SetState(1451)
				p.Match(DorisParserParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1452)
				p.Match(DorisParserParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1453)
				p.Match(DorisParserParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1456)

			var _x = p.Identifier()

			localctx.(*CreateIndexAnalyzerContext).name = _x
		}
		p.SetState(1458)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserPROPERTIES {
			{
				p.SetState(1457)

				var _x = p.PropertyClause()

				localctx.(*CreateIndexAnalyzerContext).properties = _x
			}

		}

	case 25:
		localctx = NewCreateIndexTokenizerContext(p, localctx)
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(1460)
			p.Match(DorisParserParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1461)
			p.Match(DorisParserParserINVERTED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1462)
			p.Match(DorisParserParserINDEX)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1463)
			p.Match(DorisParserParserTOKENIZER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1467)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserIF {
			{
				p.SetState(1464)
				p.Match(DorisParserParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1465)
				p.Match(DorisParserParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1466)
				p.Match(DorisParserParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1469)

			var _x = p.Identifier()

			localctx.(*CreateIndexTokenizerContext).name = _x
		}
		p.SetState(1471)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserPROPERTIES {
			{
				p.SetState(1470)

				var _x = p.PropertyClause()

				localctx.(*CreateIndexTokenizerContext).properties = _x
			}

		}

	case 26:
		localctx = NewCreateIndexTokenFilterContext(p, localctx)
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(1473)
			p.Match(DorisParserParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1474)
			p.Match(DorisParserParserINVERTED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1475)
			p.Match(DorisParserParserINDEX)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1476)
			p.Match(DorisParserParserTOKEN_FILTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1480)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserIF {
			{
				p.SetState(1477)
				p.Match(DorisParserParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1478)
				p.Match(DorisParserParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1479)
				p.Match(DorisParserParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1482)

			var _x = p.Identifier()

			localctx.(*CreateIndexTokenFilterContext).name = _x
		}
		p.SetState(1484)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserPROPERTIES {
			{
				p.SetState(1483)

				var _x = p.PropertyClause()

				localctx.(*CreateIndexTokenFilterContext).properties = _x
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDictionaryColumnDefsContext is an interface to support dynamic dispatch.
type IDictionaryColumnDefsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllDictionaryColumnDef() []IDictionaryColumnDefContext
	DictionaryColumnDef(i int) IDictionaryColumnDefContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsDictionaryColumnDefsContext differentiates from other interfaces.
	IsDictionaryColumnDefsContext()
}

type DictionaryColumnDefsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDictionaryColumnDefsContext() *DictionaryColumnDefsContext {
	var p = new(DictionaryColumnDefsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_dictionaryColumnDefs
	return p
}

func InitEmptyDictionaryColumnDefsContext(p *DictionaryColumnDefsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_dictionaryColumnDefs
}

func (*DictionaryColumnDefsContext) IsDictionaryColumnDefsContext() {}

func NewDictionaryColumnDefsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DictionaryColumnDefsContext {
	var p = new(DictionaryColumnDefsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_dictionaryColumnDefs

	return p
}

func (s *DictionaryColumnDefsContext) GetParser() antlr.Parser { return s.parser }

func (s *DictionaryColumnDefsContext) AllDictionaryColumnDef() []IDictionaryColumnDefContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDictionaryColumnDefContext); ok {
			len++
		}
	}

	tst := make([]IDictionaryColumnDefContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDictionaryColumnDefContext); ok {
			tst[i] = t.(IDictionaryColumnDefContext)
			i++
		}
	}

	return tst
}

func (s *DictionaryColumnDefsContext) DictionaryColumnDef(i int) IDictionaryColumnDefContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDictionaryColumnDefContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDictionaryColumnDefContext)
}

func (s *DictionaryColumnDefsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserCOMMA)
}

func (s *DictionaryColumnDefsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOMMA, i)
}

func (s *DictionaryColumnDefsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DictionaryColumnDefsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DictionaryColumnDefsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitDictionaryColumnDefs(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) DictionaryColumnDefs() (localctx IDictionaryColumnDefsContext) {
	localctx = NewDictionaryColumnDefsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, DorisParserParserRULE_dictionaryColumnDefs)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1488)
		p.DictionaryColumnDef()
	}
	p.SetState(1493)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisParserParserCOMMA {
		{
			p.SetState(1489)
			p.Match(DorisParserParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1490)
			p.DictionaryColumnDef()
		}

		p.SetState(1495)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDictionaryColumnDefContext is an interface to support dynamic dispatch.
type IDictionaryColumnDefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetColumnType returns the columnType token.
	GetColumnType() antlr.Token

	// SetColumnType sets the columnType token.
	SetColumnType(antlr.Token)

	// GetColName returns the colName rule contexts.
	GetColName() IIdentifierContext

	// SetColName sets the colName rule contexts.
	SetColName(IIdentifierContext)

	// Getter signatures
	Identifier() IIdentifierContext
	KEY() antlr.TerminalNode
	VALUE() antlr.TerminalNode

	// IsDictionaryColumnDefContext differentiates from other interfaces.
	IsDictionaryColumnDefContext()
}

type DictionaryColumnDefContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	colName    IIdentifierContext
	columnType antlr.Token
}

func NewEmptyDictionaryColumnDefContext() *DictionaryColumnDefContext {
	var p = new(DictionaryColumnDefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_dictionaryColumnDef
	return p
}

func InitEmptyDictionaryColumnDefContext(p *DictionaryColumnDefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_dictionaryColumnDef
}

func (*DictionaryColumnDefContext) IsDictionaryColumnDefContext() {}

func NewDictionaryColumnDefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DictionaryColumnDefContext {
	var p = new(DictionaryColumnDefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_dictionaryColumnDef

	return p
}

func (s *DictionaryColumnDefContext) GetParser() antlr.Parser { return s.parser }

func (s *DictionaryColumnDefContext) GetColumnType() antlr.Token { return s.columnType }

func (s *DictionaryColumnDefContext) SetColumnType(v antlr.Token) { s.columnType = v }

func (s *DictionaryColumnDefContext) GetColName() IIdentifierContext { return s.colName }

func (s *DictionaryColumnDefContext) SetColName(v IIdentifierContext) { s.colName = v }

func (s *DictionaryColumnDefContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DictionaryColumnDefContext) KEY() antlr.TerminalNode {
	return s.GetToken(DorisParserParserKEY, 0)
}

func (s *DictionaryColumnDefContext) VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserVALUE, 0)
}

func (s *DictionaryColumnDefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DictionaryColumnDefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DictionaryColumnDefContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitDictionaryColumnDef(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) DictionaryColumnDef() (localctx IDictionaryColumnDefContext) {
	localctx = NewDictionaryColumnDefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, DorisParserParserRULE_dictionaryColumnDef)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1496)

		var _x = p.Identifier()

		localctx.(*DictionaryColumnDefContext).colName = _x
	}
	{
		p.SetState(1497)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*DictionaryColumnDefContext).columnType = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisParserParserKEY || _la == DorisParserParserVALUE) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*DictionaryColumnDefContext).columnType = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISupportedAlterStatementContext is an interface to support dynamic dispatch.
type ISupportedAlterStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSupportedAlterStatementContext differentiates from other interfaces.
	IsSupportedAlterStatementContext()
}

type SupportedAlterStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySupportedAlterStatementContext() *SupportedAlterStatementContext {
	var p = new(SupportedAlterStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_supportedAlterStatement
	return p
}

func InitEmptySupportedAlterStatementContext(p *SupportedAlterStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_supportedAlterStatement
}

func (*SupportedAlterStatementContext) IsSupportedAlterStatementContext() {}

func NewSupportedAlterStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SupportedAlterStatementContext {
	var p = new(SupportedAlterStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_supportedAlterStatement

	return p
}

func (s *SupportedAlterStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SupportedAlterStatementContext) CopyAll(ctx *SupportedAlterStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *SupportedAlterStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedAlterStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type AlterSystemRenameComputeGroupContext struct {
	SupportedAlterStatementContext
	name    IIdentifierContext
	newName IIdentifierContext
}

func NewAlterSystemRenameComputeGroupContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterSystemRenameComputeGroupContext {
	var p = new(AlterSystemRenameComputeGroupContext)

	InitEmptySupportedAlterStatementContext(&p.SupportedAlterStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedAlterStatementContext))

	return p
}

func (s *AlterSystemRenameComputeGroupContext) GetName() IIdentifierContext { return s.name }

func (s *AlterSystemRenameComputeGroupContext) GetNewName() IIdentifierContext { return s.newName }

func (s *AlterSystemRenameComputeGroupContext) SetName(v IIdentifierContext) { s.name = v }

func (s *AlterSystemRenameComputeGroupContext) SetNewName(v IIdentifierContext) { s.newName = v }

func (s *AlterSystemRenameComputeGroupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterSystemRenameComputeGroupContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserParserALTER, 0)
}

func (s *AlterSystemRenameComputeGroupContext) SYSTEM() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSYSTEM, 0)
}

func (s *AlterSystemRenameComputeGroupContext) RENAME() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRENAME, 0)
}

func (s *AlterSystemRenameComputeGroupContext) COMPUTE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOMPUTE, 0)
}

func (s *AlterSystemRenameComputeGroupContext) GROUP() antlr.TerminalNode {
	return s.GetToken(DorisParserParserGROUP, 0)
}

func (s *AlterSystemRenameComputeGroupContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *AlterSystemRenameComputeGroupContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AlterSystemRenameComputeGroupContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitAlterSystemRenameComputeGroup(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterSystemContext struct {
	SupportedAlterStatementContext
}

func NewAlterSystemContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterSystemContext {
	var p = new(AlterSystemContext)

	InitEmptySupportedAlterStatementContext(&p.SupportedAlterStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedAlterStatementContext))

	return p
}

func (s *AlterSystemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterSystemContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserParserALTER, 0)
}

func (s *AlterSystemContext) SYSTEM() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSYSTEM, 0)
}

func (s *AlterSystemContext) AlterSystemClause() IAlterSystemClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterSystemClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterSystemClauseContext)
}

func (s *AlterSystemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitAlterSystem(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterCatalogRenameContext struct {
	SupportedAlterStatementContext
	name    IIdentifierContext
	newName IIdentifierContext
}

func NewAlterCatalogRenameContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterCatalogRenameContext {
	var p = new(AlterCatalogRenameContext)

	InitEmptySupportedAlterStatementContext(&p.SupportedAlterStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedAlterStatementContext))

	return p
}

func (s *AlterCatalogRenameContext) GetName() IIdentifierContext { return s.name }

func (s *AlterCatalogRenameContext) GetNewName() IIdentifierContext { return s.newName }

func (s *AlterCatalogRenameContext) SetName(v IIdentifierContext) { s.name = v }

func (s *AlterCatalogRenameContext) SetNewName(v IIdentifierContext) { s.newName = v }

func (s *AlterCatalogRenameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterCatalogRenameContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserParserALTER, 0)
}

func (s *AlterCatalogRenameContext) CATALOG() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCATALOG, 0)
}

func (s *AlterCatalogRenameContext) RENAME() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRENAME, 0)
}

func (s *AlterCatalogRenameContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *AlterCatalogRenameContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AlterCatalogRenameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitAlterCatalogRename(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterDatabaseSetQuotaContext struct {
	SupportedAlterStatementContext
	name  IIdentifierContext
	quota IIdentifierContext
}

func NewAlterDatabaseSetQuotaContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterDatabaseSetQuotaContext {
	var p = new(AlterDatabaseSetQuotaContext)

	InitEmptySupportedAlterStatementContext(&p.SupportedAlterStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedAlterStatementContext))

	return p
}

func (s *AlterDatabaseSetQuotaContext) GetName() IIdentifierContext { return s.name }

func (s *AlterDatabaseSetQuotaContext) GetQuota() IIdentifierContext { return s.quota }

func (s *AlterDatabaseSetQuotaContext) SetName(v IIdentifierContext) { s.name = v }

func (s *AlterDatabaseSetQuotaContext) SetQuota(v IIdentifierContext) { s.quota = v }

func (s *AlterDatabaseSetQuotaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterDatabaseSetQuotaContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserParserALTER, 0)
}

func (s *AlterDatabaseSetQuotaContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDATABASE, 0)
}

func (s *AlterDatabaseSetQuotaContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSET, 0)
}

func (s *AlterDatabaseSetQuotaContext) QUOTA() antlr.TerminalNode {
	return s.GetToken(DorisParserParserQUOTA, 0)
}

func (s *AlterDatabaseSetQuotaContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *AlterDatabaseSetQuotaContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AlterDatabaseSetQuotaContext) DATA() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDATA, 0)
}

func (s *AlterDatabaseSetQuotaContext) REPLICA() antlr.TerminalNode {
	return s.GetToken(DorisParserParserREPLICA, 0)
}

func (s *AlterDatabaseSetQuotaContext) TRANSACTION() antlr.TerminalNode {
	return s.GetToken(DorisParserParserTRANSACTION, 0)
}

func (s *AlterDatabaseSetQuotaContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserINTEGER_VALUE, 0)
}

func (s *AlterDatabaseSetQuotaContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitAlterDatabaseSetQuota(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterStorageVaultContext struct {
	SupportedAlterStatementContext
	name       IMultipartIdentifierContext
	properties IPropertyClauseContext
}

func NewAlterStorageVaultContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterStorageVaultContext {
	var p = new(AlterStorageVaultContext)

	InitEmptySupportedAlterStatementContext(&p.SupportedAlterStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedAlterStatementContext))

	return p
}

func (s *AlterStorageVaultContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *AlterStorageVaultContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *AlterStorageVaultContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *AlterStorageVaultContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *AlterStorageVaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterStorageVaultContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserParserALTER, 0)
}

func (s *AlterStorageVaultContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTORAGE, 0)
}

func (s *AlterStorageVaultContext) VAULT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserVAULT, 0)
}

func (s *AlterStorageVaultContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *AlterStorageVaultContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *AlterStorageVaultContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitAlterStorageVault(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterWorkloadGroupContext struct {
	SupportedAlterStatementContext
	name         IIdentifierOrTextContext
	computeGroup IIdentifierOrTextContext
	properties   IPropertyClauseContext
}

func NewAlterWorkloadGroupContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterWorkloadGroupContext {
	var p = new(AlterWorkloadGroupContext)

	InitEmptySupportedAlterStatementContext(&p.SupportedAlterStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedAlterStatementContext))

	return p
}

func (s *AlterWorkloadGroupContext) GetName() IIdentifierOrTextContext { return s.name }

func (s *AlterWorkloadGroupContext) GetComputeGroup() IIdentifierOrTextContext { return s.computeGroup }

func (s *AlterWorkloadGroupContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *AlterWorkloadGroupContext) SetName(v IIdentifierOrTextContext) { s.name = v }

func (s *AlterWorkloadGroupContext) SetComputeGroup(v IIdentifierOrTextContext) { s.computeGroup = v }

func (s *AlterWorkloadGroupContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *AlterWorkloadGroupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterWorkloadGroupContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserParserALTER, 0)
}

func (s *AlterWorkloadGroupContext) WORKLOAD() antlr.TerminalNode {
	return s.GetToken(DorisParserParserWORKLOAD, 0)
}

func (s *AlterWorkloadGroupContext) GROUP() antlr.TerminalNode {
	return s.GetToken(DorisParserParserGROUP, 0)
}

func (s *AlterWorkloadGroupContext) AllIdentifierOrText() []IIdentifierOrTextContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierOrTextContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierOrTextContext); ok {
			tst[i] = t.(IIdentifierOrTextContext)
			i++
		}
	}

	return tst
}

func (s *AlterWorkloadGroupContext) IdentifierOrText(i int) IIdentifierOrTextContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *AlterWorkloadGroupContext) FOR() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFOR, 0)
}

func (s *AlterWorkloadGroupContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *AlterWorkloadGroupContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitAlterWorkloadGroup(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterTableDropRollupContext struct {
	SupportedAlterStatementContext
	tableName IMultipartIdentifierContext
}

func NewAlterTableDropRollupContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterTableDropRollupContext {
	var p = new(AlterTableDropRollupContext)

	InitEmptySupportedAlterStatementContext(&p.SupportedAlterStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedAlterStatementContext))

	return p
}

func (s *AlterTableDropRollupContext) GetTableName() IMultipartIdentifierContext { return s.tableName }

func (s *AlterTableDropRollupContext) SetTableName(v IMultipartIdentifierContext) { s.tableName = v }

func (s *AlterTableDropRollupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableDropRollupContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserParserALTER, 0)
}

func (s *AlterTableDropRollupContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserTABLE, 0)
}

func (s *AlterTableDropRollupContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDROP, 0)
}

func (s *AlterTableDropRollupContext) ROLLUP() antlr.TerminalNode {
	return s.GetToken(DorisParserParserROLLUP, 0)
}

func (s *AlterTableDropRollupContext) AllDropRollupClause() []IDropRollupClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDropRollupClauseContext); ok {
			len++
		}
	}

	tst := make([]IDropRollupClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDropRollupClauseContext); ok {
			tst[i] = t.(IDropRollupClauseContext)
			i++
		}
	}

	return tst
}

func (s *AlterTableDropRollupContext) DropRollupClause(i int) IDropRollupClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropRollupClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropRollupClauseContext)
}

func (s *AlterTableDropRollupContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *AlterTableDropRollupContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserCOMMA)
}

func (s *AlterTableDropRollupContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOMMA, i)
}

func (s *AlterTableDropRollupContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitAlterTableDropRollup(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterTablePropertiesContext struct {
	SupportedAlterStatementContext
	name IMultipartIdentifierContext
}

func NewAlterTablePropertiesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterTablePropertiesContext {
	var p = new(AlterTablePropertiesContext)

	InitEmptySupportedAlterStatementContext(&p.SupportedAlterStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedAlterStatementContext))

	return p
}

func (s *AlterTablePropertiesContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *AlterTablePropertiesContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *AlterTablePropertiesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTablePropertiesContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserParserALTER, 0)
}

func (s *AlterTablePropertiesContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserTABLE, 0)
}

func (s *AlterTablePropertiesContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSET, 0)
}

func (s *AlterTablePropertiesContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLEFT_PAREN, 0)
}

func (s *AlterTablePropertiesContext) PropertyItemList() IPropertyItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyItemListContext)
}

func (s *AlterTablePropertiesContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRIGHT_PAREN, 0)
}

func (s *AlterTablePropertiesContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *AlterTablePropertiesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitAlterTableProperties(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterUserContext struct {
	SupportedAlterStatementContext
}

func NewAlterUserContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterUserContext {
	var p = new(AlterUserContext)

	InitEmptySupportedAlterStatementContext(&p.SupportedAlterStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedAlterStatementContext))

	return p
}

func (s *AlterUserContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterUserContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserParserALTER, 0)
}

func (s *AlterUserContext) USER() antlr.TerminalNode {
	return s.GetToken(DorisParserParserUSER, 0)
}

func (s *AlterUserContext) GrantUserIdentify() IGrantUserIdentifyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrantUserIdentifyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrantUserIdentifyContext)
}

func (s *AlterUserContext) PasswordOption() IPasswordOptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPasswordOptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPasswordOptionContext)
}

func (s *AlterUserContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserParserIF, 0)
}

func (s *AlterUserContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserEXISTS, 0)
}

func (s *AlterUserContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOMMENT, 0)
}

func (s *AlterUserContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTRING_LITERAL, 0)
}

func (s *AlterUserContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitAlterUser(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterRoleContext struct {
	SupportedAlterStatementContext
	role IIdentifierOrTextContext
}

func NewAlterRoleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterRoleContext {
	var p = new(AlterRoleContext)

	InitEmptySupportedAlterStatementContext(&p.SupportedAlterStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedAlterStatementContext))

	return p
}

func (s *AlterRoleContext) GetRole() IIdentifierOrTextContext { return s.role }

func (s *AlterRoleContext) SetRole(v IIdentifierOrTextContext) { s.role = v }

func (s *AlterRoleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterRoleContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserParserALTER, 0)
}

func (s *AlterRoleContext) ROLE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserROLE, 0)
}

func (s *AlterRoleContext) CommentSpec() ICommentSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentSpecContext)
}

func (s *AlterRoleContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *AlterRoleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitAlterRole(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterWorkloadPolicyContext struct {
	SupportedAlterStatementContext
	name       IIdentifierOrTextContext
	properties IPropertyClauseContext
}

func NewAlterWorkloadPolicyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterWorkloadPolicyContext {
	var p = new(AlterWorkloadPolicyContext)

	InitEmptySupportedAlterStatementContext(&p.SupportedAlterStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedAlterStatementContext))

	return p
}

func (s *AlterWorkloadPolicyContext) GetName() IIdentifierOrTextContext { return s.name }

func (s *AlterWorkloadPolicyContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *AlterWorkloadPolicyContext) SetName(v IIdentifierOrTextContext) { s.name = v }

func (s *AlterWorkloadPolicyContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *AlterWorkloadPolicyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterWorkloadPolicyContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserParserALTER, 0)
}

func (s *AlterWorkloadPolicyContext) WORKLOAD() antlr.TerminalNode {
	return s.GetToken(DorisParserParserWORKLOAD, 0)
}

func (s *AlterWorkloadPolicyContext) POLICY() antlr.TerminalNode {
	return s.GetToken(DorisParserParserPOLICY, 0)
}

func (s *AlterWorkloadPolicyContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *AlterWorkloadPolicyContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *AlterWorkloadPolicyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitAlterWorkloadPolicy(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterDatabaseRenameContext struct {
	SupportedAlterStatementContext
	name    IIdentifierContext
	newName IIdentifierContext
}

func NewAlterDatabaseRenameContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterDatabaseRenameContext {
	var p = new(AlterDatabaseRenameContext)

	InitEmptySupportedAlterStatementContext(&p.SupportedAlterStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedAlterStatementContext))

	return p
}

func (s *AlterDatabaseRenameContext) GetName() IIdentifierContext { return s.name }

func (s *AlterDatabaseRenameContext) GetNewName() IIdentifierContext { return s.newName }

func (s *AlterDatabaseRenameContext) SetName(v IIdentifierContext) { s.name = v }

func (s *AlterDatabaseRenameContext) SetNewName(v IIdentifierContext) { s.newName = v }

func (s *AlterDatabaseRenameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterDatabaseRenameContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserParserALTER, 0)
}

func (s *AlterDatabaseRenameContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDATABASE, 0)
}

func (s *AlterDatabaseRenameContext) RENAME() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRENAME, 0)
}

func (s *AlterDatabaseRenameContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *AlterDatabaseRenameContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AlterDatabaseRenameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitAlterDatabaseRename(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterCatalogPropertiesContext struct {
	SupportedAlterStatementContext
	name IIdentifierContext
}

func NewAlterCatalogPropertiesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterCatalogPropertiesContext {
	var p = new(AlterCatalogPropertiesContext)

	InitEmptySupportedAlterStatementContext(&p.SupportedAlterStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedAlterStatementContext))

	return p
}

func (s *AlterCatalogPropertiesContext) GetName() IIdentifierContext { return s.name }

func (s *AlterCatalogPropertiesContext) SetName(v IIdentifierContext) { s.name = v }

func (s *AlterCatalogPropertiesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterCatalogPropertiesContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserParserALTER, 0)
}

func (s *AlterCatalogPropertiesContext) CATALOG() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCATALOG, 0)
}

func (s *AlterCatalogPropertiesContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSET, 0)
}

func (s *AlterCatalogPropertiesContext) PROPERTIES() antlr.TerminalNode {
	return s.GetToken(DorisParserParserPROPERTIES, 0)
}

func (s *AlterCatalogPropertiesContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLEFT_PAREN, 0)
}

func (s *AlterCatalogPropertiesContext) PropertyItemList() IPropertyItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyItemListContext)
}

func (s *AlterCatalogPropertiesContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRIGHT_PAREN, 0)
}

func (s *AlterCatalogPropertiesContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AlterCatalogPropertiesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitAlterCatalogProperties(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterDatabasePropertiesContext struct {
	SupportedAlterStatementContext
	name IIdentifierContext
}

func NewAlterDatabasePropertiesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterDatabasePropertiesContext {
	var p = new(AlterDatabasePropertiesContext)

	InitEmptySupportedAlterStatementContext(&p.SupportedAlterStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedAlterStatementContext))

	return p
}

func (s *AlterDatabasePropertiesContext) GetName() IIdentifierContext { return s.name }

func (s *AlterDatabasePropertiesContext) SetName(v IIdentifierContext) { s.name = v }

func (s *AlterDatabasePropertiesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterDatabasePropertiesContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserParserALTER, 0)
}

func (s *AlterDatabasePropertiesContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDATABASE, 0)
}

func (s *AlterDatabasePropertiesContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSET, 0)
}

func (s *AlterDatabasePropertiesContext) PROPERTIES() antlr.TerminalNode {
	return s.GetToken(DorisParserParserPROPERTIES, 0)
}

func (s *AlterDatabasePropertiesContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLEFT_PAREN, 0)
}

func (s *AlterDatabasePropertiesContext) PropertyItemList() IPropertyItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyItemListContext)
}

func (s *AlterDatabasePropertiesContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRIGHT_PAREN, 0)
}

func (s *AlterDatabasePropertiesContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AlterDatabasePropertiesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitAlterDatabaseProperties(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterCatalogCommentContext struct {
	SupportedAlterStatementContext
	name    IIdentifierContext
	comment antlr.Token
}

func NewAlterCatalogCommentContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterCatalogCommentContext {
	var p = new(AlterCatalogCommentContext)

	InitEmptySupportedAlterStatementContext(&p.SupportedAlterStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedAlterStatementContext))

	return p
}

func (s *AlterCatalogCommentContext) GetComment() antlr.Token { return s.comment }

func (s *AlterCatalogCommentContext) SetComment(v antlr.Token) { s.comment = v }

func (s *AlterCatalogCommentContext) GetName() IIdentifierContext { return s.name }

func (s *AlterCatalogCommentContext) SetName(v IIdentifierContext) { s.name = v }

func (s *AlterCatalogCommentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterCatalogCommentContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserParserALTER, 0)
}

func (s *AlterCatalogCommentContext) CATALOG() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCATALOG, 0)
}

func (s *AlterCatalogCommentContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(DorisParserParserMODIFY, 0)
}

func (s *AlterCatalogCommentContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOMMENT, 0)
}

func (s *AlterCatalogCommentContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AlterCatalogCommentContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTRING_LITERAL, 0)
}

func (s *AlterCatalogCommentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitAlterCatalogComment(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterViewContext struct {
	SupportedAlterStatementContext
	name IMultipartIdentifierContext
	cols ISimpleColumnDefsContext
}

func NewAlterViewContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterViewContext {
	var p = new(AlterViewContext)

	InitEmptySupportedAlterStatementContext(&p.SupportedAlterStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedAlterStatementContext))

	return p
}

func (s *AlterViewContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *AlterViewContext) GetCols() ISimpleColumnDefsContext { return s.cols }

func (s *AlterViewContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *AlterViewContext) SetCols(v ISimpleColumnDefsContext) { s.cols = v }

func (s *AlterViewContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterViewContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserParserALTER, 0)
}

func (s *AlterViewContext) VIEW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserVIEW, 0)
}

func (s *AlterViewContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *AlterViewContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(DorisParserParserMODIFY, 0)
}

func (s *AlterViewContext) CommentSpec() ICommentSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentSpecContext)
}

func (s *AlterViewContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserAS, 0)
}

func (s *AlterViewContext) Query() IQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *AlterViewContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLEFT_PAREN, 0)
}

func (s *AlterViewContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRIGHT_PAREN, 0)
}

func (s *AlterViewContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOMMENT, 0)
}

func (s *AlterViewContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTRING_LITERAL, 0)
}

func (s *AlterViewContext) SimpleColumnDefs() ISimpleColumnDefsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleColumnDefsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleColumnDefsContext)
}

func (s *AlterViewContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitAlterView(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterStoragePolicyContext struct {
	SupportedAlterStatementContext
	name       IIdentifierOrTextContext
	properties IPropertyClauseContext
}

func NewAlterStoragePolicyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterStoragePolicyContext {
	var p = new(AlterStoragePolicyContext)

	InitEmptySupportedAlterStatementContext(&p.SupportedAlterStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedAlterStatementContext))

	return p
}

func (s *AlterStoragePolicyContext) GetName() IIdentifierOrTextContext { return s.name }

func (s *AlterStoragePolicyContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *AlterStoragePolicyContext) SetName(v IIdentifierOrTextContext) { s.name = v }

func (s *AlterStoragePolicyContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *AlterStoragePolicyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterStoragePolicyContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserParserALTER, 0)
}

func (s *AlterStoragePolicyContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTORAGE, 0)
}

func (s *AlterStoragePolicyContext) POLICY() antlr.TerminalNode {
	return s.GetToken(DorisParserParserPOLICY, 0)
}

func (s *AlterStoragePolicyContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *AlterStoragePolicyContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *AlterStoragePolicyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitAlterStoragePolicy(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterSqlBlockRuleContext struct {
	SupportedAlterStatementContext
	name       IIdentifierContext
	properties IPropertyClauseContext
}

func NewAlterSqlBlockRuleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterSqlBlockRuleContext {
	var p = new(AlterSqlBlockRuleContext)

	InitEmptySupportedAlterStatementContext(&p.SupportedAlterStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedAlterStatementContext))

	return p
}

func (s *AlterSqlBlockRuleContext) GetName() IIdentifierContext { return s.name }

func (s *AlterSqlBlockRuleContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *AlterSqlBlockRuleContext) SetName(v IIdentifierContext) { s.name = v }

func (s *AlterSqlBlockRuleContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *AlterSqlBlockRuleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterSqlBlockRuleContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserParserALTER, 0)
}

func (s *AlterSqlBlockRuleContext) SQL_BLOCK_RULE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSQL_BLOCK_RULE, 0)
}

func (s *AlterSqlBlockRuleContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AlterSqlBlockRuleContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *AlterSqlBlockRuleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitAlterSqlBlockRule(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterResourceContext struct {
	SupportedAlterStatementContext
	name       IIdentifierOrTextContext
	properties IPropertyClauseContext
}

func NewAlterResourceContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterResourceContext {
	var p = new(AlterResourceContext)

	InitEmptySupportedAlterStatementContext(&p.SupportedAlterStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedAlterStatementContext))

	return p
}

func (s *AlterResourceContext) GetName() IIdentifierOrTextContext { return s.name }

func (s *AlterResourceContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *AlterResourceContext) SetName(v IIdentifierOrTextContext) { s.name = v }

func (s *AlterResourceContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *AlterResourceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterResourceContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserParserALTER, 0)
}

func (s *AlterResourceContext) RESOURCE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRESOURCE, 0)
}

func (s *AlterResourceContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *AlterResourceContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *AlterResourceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitAlterResource(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterRoutineLoadContext struct {
	SupportedAlterStatementContext
	name       IMultipartIdentifierContext
	properties IPropertyClauseContext
	type_      IIdentifierContext
}

func NewAlterRoutineLoadContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterRoutineLoadContext {
	var p = new(AlterRoutineLoadContext)

	InitEmptySupportedAlterStatementContext(&p.SupportedAlterStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedAlterStatementContext))

	return p
}

func (s *AlterRoutineLoadContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *AlterRoutineLoadContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *AlterRoutineLoadContext) GetType_() IIdentifierContext { return s.type_ }

func (s *AlterRoutineLoadContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *AlterRoutineLoadContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *AlterRoutineLoadContext) SetType_(v IIdentifierContext) { s.type_ = v }

func (s *AlterRoutineLoadContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterRoutineLoadContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserParserALTER, 0)
}

func (s *AlterRoutineLoadContext) ROUTINE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserROUTINE, 0)
}

func (s *AlterRoutineLoadContext) LOAD() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLOAD, 0)
}

func (s *AlterRoutineLoadContext) FOR() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFOR, 0)
}

func (s *AlterRoutineLoadContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *AlterRoutineLoadContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFROM, 0)
}

func (s *AlterRoutineLoadContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLEFT_PAREN, 0)
}

func (s *AlterRoutineLoadContext) PropertyItemList() IPropertyItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyItemListContext)
}

func (s *AlterRoutineLoadContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRIGHT_PAREN, 0)
}

func (s *AlterRoutineLoadContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *AlterRoutineLoadContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AlterRoutineLoadContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitAlterRoutineLoad(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterTableAddRollupContext struct {
	SupportedAlterStatementContext
	tableName IMultipartIdentifierContext
}

func NewAlterTableAddRollupContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterTableAddRollupContext {
	var p = new(AlterTableAddRollupContext)

	InitEmptySupportedAlterStatementContext(&p.SupportedAlterStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedAlterStatementContext))

	return p
}

func (s *AlterTableAddRollupContext) GetTableName() IMultipartIdentifierContext { return s.tableName }

func (s *AlterTableAddRollupContext) SetTableName(v IMultipartIdentifierContext) { s.tableName = v }

func (s *AlterTableAddRollupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableAddRollupContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserParserALTER, 0)
}

func (s *AlterTableAddRollupContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserTABLE, 0)
}

func (s *AlterTableAddRollupContext) ADD() antlr.TerminalNode {
	return s.GetToken(DorisParserParserADD, 0)
}

func (s *AlterTableAddRollupContext) ROLLUP() antlr.TerminalNode {
	return s.GetToken(DorisParserParserROLLUP, 0)
}

func (s *AlterTableAddRollupContext) AllAddRollupClause() []IAddRollupClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAddRollupClauseContext); ok {
			len++
		}
	}

	tst := make([]IAddRollupClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAddRollupClauseContext); ok {
			tst[i] = t.(IAddRollupClauseContext)
			i++
		}
	}

	return tst
}

func (s *AlterTableAddRollupContext) AddRollupClause(i int) IAddRollupClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAddRollupClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAddRollupClauseContext)
}

func (s *AlterTableAddRollupContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *AlterTableAddRollupContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserCOMMA)
}

func (s *AlterTableAddRollupContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOMMA, i)
}

func (s *AlterTableAddRollupContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitAlterTableAddRollup(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterRepositoryContext struct {
	SupportedAlterStatementContext
	name       IIdentifierContext
	properties IPropertyClauseContext
}

func NewAlterRepositoryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterRepositoryContext {
	var p = new(AlterRepositoryContext)

	InitEmptySupportedAlterStatementContext(&p.SupportedAlterStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedAlterStatementContext))

	return p
}

func (s *AlterRepositoryContext) GetName() IIdentifierContext { return s.name }

func (s *AlterRepositoryContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *AlterRepositoryContext) SetName(v IIdentifierContext) { s.name = v }

func (s *AlterRepositoryContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *AlterRepositoryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterRepositoryContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserParserALTER, 0)
}

func (s *AlterRepositoryContext) REPOSITORY() antlr.TerminalNode {
	return s.GetToken(DorisParserParserREPOSITORY, 0)
}

func (s *AlterRepositoryContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AlterRepositoryContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *AlterRepositoryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitAlterRepository(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterTableContext struct {
	SupportedAlterStatementContext
	tableName IMultipartIdentifierContext
}

func NewAlterTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterTableContext {
	var p = new(AlterTableContext)

	InitEmptySupportedAlterStatementContext(&p.SupportedAlterStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedAlterStatementContext))

	return p
}

func (s *AlterTableContext) GetTableName() IMultipartIdentifierContext { return s.tableName }

func (s *AlterTableContext) SetTableName(v IMultipartIdentifierContext) { s.tableName = v }

func (s *AlterTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserParserALTER, 0)
}

func (s *AlterTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserTABLE, 0)
}

func (s *AlterTableContext) AllAlterTableClause() []IAlterTableClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAlterTableClauseContext); ok {
			len++
		}
	}

	tst := make([]IAlterTableClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAlterTableClauseContext); ok {
			tst[i] = t.(IAlterTableClauseContext)
			i++
		}
	}

	return tst
}

func (s *AlterTableContext) AlterTableClause(i int) IAlterTableClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterTableClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterTableClauseContext)
}

func (s *AlterTableContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *AlterTableContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserCOMMA)
}

func (s *AlterTableContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOMMA, i)
}

func (s *AlterTableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitAlterTable(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterColocateGroupContext struct {
	SupportedAlterStatementContext
	name IMultipartIdentifierContext
}

func NewAlterColocateGroupContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterColocateGroupContext {
	var p = new(AlterColocateGroupContext)

	InitEmptySupportedAlterStatementContext(&p.SupportedAlterStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedAlterStatementContext))

	return p
}

func (s *AlterColocateGroupContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *AlterColocateGroupContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *AlterColocateGroupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterColocateGroupContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserParserALTER, 0)
}

func (s *AlterColocateGroupContext) COLOCATE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOLOCATE, 0)
}

func (s *AlterColocateGroupContext) GROUP() antlr.TerminalNode {
	return s.GetToken(DorisParserParserGROUP, 0)
}

func (s *AlterColocateGroupContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSET, 0)
}

func (s *AlterColocateGroupContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLEFT_PAREN, 0)
}

func (s *AlterColocateGroupContext) PropertyItemList() IPropertyItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyItemListContext)
}

func (s *AlterColocateGroupContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRIGHT_PAREN, 0)
}

func (s *AlterColocateGroupContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *AlterColocateGroupContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitAlterColocateGroup(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) SupportedAlterStatement() (localctx ISupportedAlterStatementContext) {
	localctx = NewSupportedAlterStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, DorisParserParserRULE_supportedAlterStatement)
	var _la int

	p.SetState(1711)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 190, p.GetParserRuleContext()) {
	case 1:
		localctx = NewAlterSystemContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1499)
			p.Match(DorisParserParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1500)
			p.Match(DorisParserParserSYSTEM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1501)
			p.AlterSystemClause()
		}

	case 2:
		localctx = NewAlterViewContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1502)
			p.Match(DorisParserParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1503)
			p.Match(DorisParserParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1504)

			var _x = p.MultipartIdentifier()

			localctx.(*AlterViewContext).name = _x
		}
		p.SetState(1519)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserParserMODIFY:
			{
				p.SetState(1505)
				p.Match(DorisParserParserMODIFY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1506)
				p.CommentSpec()
			}

		case DorisParserParserLEFT_PAREN, DorisParserParserAS, DorisParserParserCOMMENT:
			p.SetState(1511)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserParserLEFT_PAREN {
				{
					p.SetState(1507)
					p.Match(DorisParserParserLEFT_PAREN)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1508)

					var _x = p.SimpleColumnDefs()

					localctx.(*AlterViewContext).cols = _x
				}
				{
					p.SetState(1509)
					p.Match(DorisParserParserRIGHT_PAREN)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			p.SetState(1515)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserParserCOMMENT {
				{
					p.SetState(1513)
					p.Match(DorisParserParserCOMMENT)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1514)
					p.Match(DorisParserParserSTRING_LITERAL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(1517)
				p.Match(DorisParserParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1518)
				p.Query()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 3:
		localctx = NewAlterCatalogRenameContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1521)
			p.Match(DorisParserParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1522)
			p.Match(DorisParserParserCATALOG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1523)

			var _x = p.Identifier()

			localctx.(*AlterCatalogRenameContext).name = _x
		}
		{
			p.SetState(1524)
			p.Match(DorisParserParserRENAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1525)

			var _x = p.Identifier()

			localctx.(*AlterCatalogRenameContext).newName = _x
		}

	case 4:
		localctx = NewAlterRoleContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1527)
			p.Match(DorisParserParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1528)
			p.Match(DorisParserParserROLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1529)

			var _x = p.IdentifierOrText()

			localctx.(*AlterRoleContext).role = _x
		}
		{
			p.SetState(1530)
			p.CommentSpec()
		}

	case 5:
		localctx = NewAlterStorageVaultContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1532)
			p.Match(DorisParserParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1533)
			p.Match(DorisParserParserSTORAGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1534)
			p.Match(DorisParserParserVAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1535)

			var _x = p.MultipartIdentifier()

			localctx.(*AlterStorageVaultContext).name = _x
		}
		{
			p.SetState(1536)

			var _x = p.PropertyClause()

			localctx.(*AlterStorageVaultContext).properties = _x
		}

	case 6:
		localctx = NewAlterWorkloadGroupContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1538)
			p.Match(DorisParserParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1539)
			p.Match(DorisParserParserWORKLOAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1540)
			p.Match(DorisParserParserGROUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1541)

			var _x = p.IdentifierOrText()

			localctx.(*AlterWorkloadGroupContext).name = _x
		}
		p.SetState(1544)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserFOR {
			{
				p.SetState(1542)
				p.Match(DorisParserParserFOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1543)

				var _x = p.IdentifierOrText()

				localctx.(*AlterWorkloadGroupContext).computeGroup = _x
			}

		}
		p.SetState(1547)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserPROPERTIES {
			{
				p.SetState(1546)

				var _x = p.PropertyClause()

				localctx.(*AlterWorkloadGroupContext).properties = _x
			}

		}

	case 7:
		localctx = NewAlterCatalogPropertiesContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1549)
			p.Match(DorisParserParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1550)
			p.Match(DorisParserParserCATALOG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1551)

			var _x = p.Identifier()

			localctx.(*AlterCatalogPropertiesContext).name = _x
		}
		{
			p.SetState(1552)
			p.Match(DorisParserParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1553)
			p.Match(DorisParserParserPROPERTIES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1554)
			p.Match(DorisParserParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1555)
			p.PropertyItemList()
		}
		{
			p.SetState(1556)
			p.Match(DorisParserParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 8:
		localctx = NewAlterWorkloadPolicyContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1558)
			p.Match(DorisParserParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1559)
			p.Match(DorisParserParserWORKLOAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1560)
			p.Match(DorisParserParserPOLICY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1561)

			var _x = p.IdentifierOrText()

			localctx.(*AlterWorkloadPolicyContext).name = _x
		}
		p.SetState(1563)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserPROPERTIES {
			{
				p.SetState(1562)

				var _x = p.PropertyClause()

				localctx.(*AlterWorkloadPolicyContext).properties = _x
			}

		}

	case 9:
		localctx = NewAlterSqlBlockRuleContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1565)
			p.Match(DorisParserParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1566)
			p.Match(DorisParserParserSQL_BLOCK_RULE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1567)

			var _x = p.Identifier()

			localctx.(*AlterSqlBlockRuleContext).name = _x
		}
		p.SetState(1569)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserPROPERTIES {
			{
				p.SetState(1568)

				var _x = p.PropertyClause()

				localctx.(*AlterSqlBlockRuleContext).properties = _x
			}

		}

	case 10:
		localctx = NewAlterCatalogCommentContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1571)
			p.Match(DorisParserParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1572)
			p.Match(DorisParserParserCATALOG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1573)

			var _x = p.Identifier()

			localctx.(*AlterCatalogCommentContext).name = _x
		}
		{
			p.SetState(1574)
			p.Match(DorisParserParserMODIFY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1575)
			p.Match(DorisParserParserCOMMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1576)

			var _m = p.Match(DorisParserParserSTRING_LITERAL)

			localctx.(*AlterCatalogCommentContext).comment = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 11:
		localctx = NewAlterDatabaseRenameContext(p, localctx)
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1578)
			p.Match(DorisParserParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1579)
			p.Match(DorisParserParserDATABASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1580)

			var _x = p.Identifier()

			localctx.(*AlterDatabaseRenameContext).name = _x
		}
		{
			p.SetState(1581)
			p.Match(DorisParserParserRENAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1582)

			var _x = p.Identifier()

			localctx.(*AlterDatabaseRenameContext).newName = _x
		}

	case 12:
		localctx = NewAlterStoragePolicyContext(p, localctx)
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(1584)
			p.Match(DorisParserParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1585)
			p.Match(DorisParserParserSTORAGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1586)
			p.Match(DorisParserParserPOLICY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1587)

			var _x = p.IdentifierOrText()

			localctx.(*AlterStoragePolicyContext).name = _x
		}
		{
			p.SetState(1588)

			var _x = p.PropertyClause()

			localctx.(*AlterStoragePolicyContext).properties = _x
		}

	case 13:
		localctx = NewAlterTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(1590)
			p.Match(DorisParserParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1591)
			p.Match(DorisParserParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1592)

			var _x = p.MultipartIdentifier()

			localctx.(*AlterTableContext).tableName = _x
		}
		{
			p.SetState(1593)
			p.AlterTableClause()
		}
		p.SetState(1598)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserParserCOMMA {
			{
				p.SetState(1594)
				p.Match(DorisParserParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1595)
				p.AlterTableClause()
			}

			p.SetState(1600)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 14:
		localctx = NewAlterTableAddRollupContext(p, localctx)
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(1601)
			p.Match(DorisParserParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1602)
			p.Match(DorisParserParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1603)

			var _x = p.MultipartIdentifier()

			localctx.(*AlterTableAddRollupContext).tableName = _x
		}
		{
			p.SetState(1604)
			p.Match(DorisParserParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1605)
			p.Match(DorisParserParserROLLUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1606)
			p.AddRollupClause()
		}
		p.SetState(1611)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserParserCOMMA {
			{
				p.SetState(1607)
				p.Match(DorisParserParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1608)
				p.AddRollupClause()
			}

			p.SetState(1613)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 15:
		localctx = NewAlterTableDropRollupContext(p, localctx)
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(1614)
			p.Match(DorisParserParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1615)
			p.Match(DorisParserParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1616)

			var _x = p.MultipartIdentifier()

			localctx.(*AlterTableDropRollupContext).tableName = _x
		}
		{
			p.SetState(1617)
			p.Match(DorisParserParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1618)
			p.Match(DorisParserParserROLLUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1619)
			p.DropRollupClause()
		}
		p.SetState(1624)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserParserCOMMA {
			{
				p.SetState(1620)
				p.Match(DorisParserParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1621)
				p.DropRollupClause()
			}

			p.SetState(1626)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 16:
		localctx = NewAlterTablePropertiesContext(p, localctx)
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(1627)
			p.Match(DorisParserParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1628)
			p.Match(DorisParserParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1629)

			var _x = p.MultipartIdentifier()

			localctx.(*AlterTablePropertiesContext).name = _x
		}
		{
			p.SetState(1630)
			p.Match(DorisParserParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1631)
			p.Match(DorisParserParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1632)
			p.PropertyItemList()
		}
		{
			p.SetState(1633)
			p.Match(DorisParserParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 17:
		localctx = NewAlterDatabaseSetQuotaContext(p, localctx)
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(1635)
			p.Match(DorisParserParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1636)
			p.Match(DorisParserParserDATABASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1637)

			var _x = p.Identifier()

			localctx.(*AlterDatabaseSetQuotaContext).name = _x
		}
		{
			p.SetState(1638)
			p.Match(DorisParserParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1639)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserParserDATA || _la == DorisParserParserREPLICA || _la == DorisParserParserTRANSACTION) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1640)
			p.Match(DorisParserParserQUOTA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1643)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserParserLEFT_BRACE, DorisParserParserRIGHT_BRACE, DorisParserParserACTIONS, DorisParserParserAFTER, DorisParserParserAGG_STATE, DorisParserParserAGGREGATE, DorisParserParserALIAS, DorisParserParserANALYZED, DorisParserParserARRAY, DorisParserParserAT, DorisParserParserAUTHORS, DorisParserParserAUTO_INCREMENT, DorisParserParserALWAYS, DorisParserParserBACKENDS, DorisParserParserBACKUP, DorisParserParserBEGIN, DorisParserParserBELONG, DorisParserParserBIN, DorisParserParserBITAND, DorisParserParserBITMAP, DorisParserParserBITMAP_EMPTY, DorisParserParserBITMAP_UNION, DorisParserParserBITOR, DorisParserParserBITXOR, DorisParserParserBLOB, DorisParserParserBOOLEAN, DorisParserParserBRANCH, DorisParserParserBRIEF, DorisParserParserBROKER, DorisParserParserBUCKETS, DorisParserParserBUILD, DorisParserParserBUILTIN, DorisParserParserBULK, DorisParserParserCACHE, DorisParserParserCACHED, DorisParserParserCALL, DorisParserParserCATALOG, DorisParserParserCATALOGS, DorisParserParserCHAIN, DorisParserParserCHAR, DorisParserParserCHARSET, DorisParserParserCHECK, DorisParserParserCLUSTER, DorisParserParserCLUSTERS, DorisParserParserCOLLATION, DorisParserParserCOLLECT, DorisParserParserCOLOCATE, DorisParserParserCOLUMNS, DorisParserParserCOMMENT, DorisParserParserCOMMIT, DorisParserParserCOMMITTED, DorisParserParserCOMPACT, DorisParserParserCOMPLETE, DorisParserParserCOMPRESS_TYPE, DorisParserParserCOMPUTE, DorisParserParserCONDITIONS, DorisParserParserCONFIG, DorisParserParserCONNECTION, DorisParserParserCONNECTION_ID, DorisParserParserCONSISTENT, DorisParserParserCONSTRAINTS, DorisParserParserCONVERT, DorisParserParserCONVERT_LSC, DorisParserParserCOPY, DorisParserParserCOUNT, DorisParserParserCREATION, DorisParserParserCRON, DorisParserParserCURRENT_CATALOG, DorisParserParserCURRENT_DATE, DorisParserParserCURRENT_TIME, DorisParserParserCURRENT_TIMESTAMP, DorisParserParserCURRENT_USER, DorisParserParserDATA, DorisParserParserDATE, DorisParserParserDATETIME, DorisParserParserDATETIMEV2, DorisParserParserDATEV2, DorisParserParserDATETIMEV1, DorisParserParserDATEV1, DorisParserParserDAY, DorisParserParserDAYS, DorisParserParserDECIMAL, DorisParserParserDECIMALV2, DorisParserParserDECIMALV3, DorisParserParserDEFERRED, DorisParserParserDEMAND, DorisParserParserDIAGNOSE, DorisParserParserDIAGNOSIS, DorisParserParserDICTIONARIES, DorisParserParserDICTIONARY, DorisParserParserDISTINCTPC, DorisParserParserDISTINCTPCSA, DorisParserParserDO, DorisParserParserDORIS_INTERNAL_TABLE_ID, DorisParserParserDUAL, DorisParserParserDYNAMIC, DorisParserParserE, DorisParserParserENABLE, DorisParserParserENCRYPTKEY, DorisParserParserENCRYPTKEYS, DorisParserParserEND, DorisParserParserENDS, DorisParserParserENGINE, DorisParserParserENGINES, DorisParserParserERRORS, DorisParserParserESCAPE, DorisParserParserEVENTS, DorisParserParserEVERY, DorisParserParserEXCLUDE, DorisParserParserEXPIRED, DorisParserParserEXTERNAL, DorisParserParserFAILED_LOGIN_ATTEMPTS, DorisParserParserFAST, DorisParserParserFEATURE, DorisParserParserFIELDS, DorisParserParserFILE, DorisParserParserFILTER, DorisParserParserFIRST, DorisParserParserFORMAT, DorisParserParserFREE, DorisParserParserFRONTENDS, DorisParserParserFUNCTION, DorisParserParserGENERATED, DorisParserParserGENERIC, DorisParserParserGLOBAL, DorisParserParserGRAPH, DorisParserParserGROUPING, DorisParserParserGROUPS, DorisParserParserHASH, DorisParserParserHASH_MAP, DorisParserParserHDFS, DorisParserParserHELP, DorisParserParserHISTOGRAM, DorisParserParserHLL_UNION, DorisParserParserHOSTNAME, DorisParserParserHOTSPOT, DorisParserParserHOUR, DorisParserParserHOURS, DorisParserParserHUB, DorisParserParserIDENTIFIED, DorisParserParserIGNORE, DorisParserParserIMMEDIATE, DorisParserParserINCREMENTAL, DorisParserParserINDEXES, DorisParserParserINVERTED, DorisParserParserIP_TRIE, DorisParserParserIPV4, DorisParserParserIPV6, DorisParserParserIS_NOT_NULL_PRED, DorisParserParserIS_NULL_PRED, DorisParserParserISNULL, DorisParserParserISOLATION, DorisParserParserJOB, DorisParserParserJOBS, DorisParserParserJSON, DorisParserParserJSONB, DorisParserParserLABEL, DorisParserParserLAST, DorisParserParserLDAP, DorisParserParserLDAP_ADMIN_PASSWORD, DorisParserParserLESS, DorisParserParserLEVEL, DorisParserParserLINES, DorisParserParserLINK, DorisParserParserLOCAL, DorisParserParserLOCALTIME, DorisParserParserLOCALTIMESTAMP, DorisParserParserLOCATION, DorisParserParserLOCK, DorisParserParserLOGICAL, DorisParserParserMANUAL, DorisParserParserMAP, DorisParserParserMATCH_ALL, DorisParserParserMATCH_ANY, DorisParserParserMATCH_PHRASE, DorisParserParserMATCH_PHRASE_EDGE, DorisParserParserMATCH_PHRASE_PREFIX, DorisParserParserMATCH_REGEXP, DorisParserParserMATERIALIZED, DorisParserParserMAX, DorisParserParserMEMO, DorisParserParserMERGE, DorisParserParserMIGRATE, DorisParserParserMIGRATIONS, DorisParserParserMIN, DorisParserParserMINUTE, DorisParserParserMINUTES, DorisParserParserMODIFY, DorisParserParserMONTH, DorisParserParserMTMV, DorisParserParserNAME, DorisParserParserNAMES, DorisParserParserNEGATIVE, DorisParserParserNEVER, DorisParserParserNEXT, DorisParserParserNGRAM_BF, DorisParserParserNO, DorisParserParserNON_NULLABLE, DorisParserParserNULLS, DorisParserParserOF, DorisParserParserOFFSET, DorisParserParserONLY, DorisParserParserOPEN, DorisParserParserOPTIMIZED, DorisParserParserPARAMETER, DorisParserParserPARSED, DorisParserParserPARTITIONS, DorisParserParserPASSWORD, DorisParserParserPASSWORD_EXPIRE, DorisParserParserPASSWORD_HISTORY, DorisParserParserPASSWORD_LOCK_TIME, DorisParserParserPASSWORD_REUSE, DorisParserParserPATH, DorisParserParserPAUSE, DorisParserParserPERCENT, DorisParserParserPERIOD, DorisParserParserPERMISSIVE, DorisParserParserPHYSICAL, DorisParserParserPI, DorisParserParserPLAN, DorisParserParserPRIVILEGES, DorisParserParserPROCESS, DorisParserParserPLUGIN, DorisParserParserPLUGINS, DorisParserParserPOLICY, DorisParserParserPROC, DorisParserParserPROCESSLIST, DorisParserParserPROFILE, DorisParserParserPROPERTIES, DorisParserParserPROPERTY, DorisParserParserQUANTILE_STATE, DorisParserParserQUANTILE_UNION, DorisParserParserQUERY, DorisParserParserQUEUED, DorisParserParserQUOTA, DorisParserParserQUALIFY, DorisParserParserQUARTER, DorisParserParserRANDOM, DorisParserParserRECENT, DorisParserParserRECOVER, DorisParserParserRECYCLE, DorisParserParserREFRESH, DorisParserParserREPEATABLE, DorisParserParserREPLACE, DorisParserParserREPLACE_IF_NOT_NULL, DorisParserParserREPLAYER, DorisParserParserREPOSITORIES, DorisParserParserREPOSITORY, DorisParserParserRESOURCE, DorisParserParserRESOURCES, DorisParserParserRESTORE, DorisParserParserRESTRICTIVE, DorisParserParserRESUME, DorisParserParserRETAIN, DorisParserParserRETENTION, DorisParserParserRETURNS, DorisParserParserREWRITTEN, DorisParserParserRLIKE, DorisParserParserROLLBACK, DorisParserParserROLLUP, DorisParserParserROUTINE, DorisParserParserS3, DorisParserParserSAMPLE, DorisParserParserSCHEDULE, DorisParserParserSCHEDULER, DorisParserParserSCHEMA, DorisParserParserSECOND, DorisParserParserSERIALIZABLE, DorisParserParserSESSION, DorisParserParserSESSION_USER, DorisParserParserSET_SESSION_VARIABLE, DorisParserParserSHAPE, DorisParserParserSKEW, DorisParserParserSNAPSHOT, DorisParserParserSNAPSHOTS, DorisParserParserSONAME, DorisParserParserSPLIT, DorisParserParserSQL, DorisParserParserSTAGE, DorisParserParserSTAGES, DorisParserParserSTART, DorisParserParserSTARTS, DorisParserParserSTATS, DorisParserParserSTATUS, DorisParserParserSTOP, DorisParserParserSTORAGE, DorisParserParserSTREAM, DorisParserParserSTREAMING, DorisParserParserSTRING, DorisParserParserSTRUCT, DorisParserParserSUM, DorisParserParserTABLES, DorisParserParserTAG, DorisParserParserTASK, DorisParserParserTASKS, DorisParserParserTEMPORARY, DorisParserParserTEXT, DorisParserParserTHAN, DorisParserParserTIME, DorisParserParserTIMESTAMP, DorisParserParserTRANSACTION, DorisParserParserTREE, DorisParserParserTRIGGERS, DorisParserParserTRUNCATE, DorisParserParserTYPE, DorisParserParserTYPES, DorisParserParserUNCOMMITTED, DorisParserParserUNLOCK, DorisParserParserUNSET, DorisParserParserUP, DorisParserParserUSER, DorisParserParserVALUE, DorisParserParserVARCHAR, DorisParserParserVARIABLE, DorisParserParserVARIABLES, DorisParserParserVARIANT, DorisParserParserVAULT, DorisParserParserVAULTS, DorisParserParserVERBOSE, DorisParserParserVERSION, DorisParserParserVIEW, DorisParserParserVIEWS, DorisParserParserWARM, DorisParserParserWARNINGS, DorisParserParserWEEK, DorisParserParserWORK, DorisParserParserYEAR, DorisParserParserHINT_START, DorisParserParserHINT_END, DorisParserParserCOMMENT_START, DorisParserParserIDENTIFIER, DorisParserParserBACKQUOTED_IDENTIFIER:
			{
				p.SetState(1641)

				var _x = p.Identifier()

				localctx.(*AlterDatabaseSetQuotaContext).quota = _x
			}

		case DorisParserParserINTEGER_VALUE:
			{
				p.SetState(1642)
				p.Match(DorisParserParserINTEGER_VALUE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 18:
		localctx = NewAlterDatabasePropertiesContext(p, localctx)
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(1645)
			p.Match(DorisParserParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1646)
			p.Match(DorisParserParserDATABASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1647)

			var _x = p.Identifier()

			localctx.(*AlterDatabasePropertiesContext).name = _x
		}
		{
			p.SetState(1648)
			p.Match(DorisParserParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1649)
			p.Match(DorisParserParserPROPERTIES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1650)
			p.Match(DorisParserParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1651)
			p.PropertyItemList()
		}
		{
			p.SetState(1652)
			p.Match(DorisParserParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 19:
		localctx = NewAlterSystemRenameComputeGroupContext(p, localctx)
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(1654)
			p.Match(DorisParserParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1655)
			p.Match(DorisParserParserSYSTEM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1656)
			p.Match(DorisParserParserRENAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1657)
			p.Match(DorisParserParserCOMPUTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1658)
			p.Match(DorisParserParserGROUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1659)

			var _x = p.Identifier()

			localctx.(*AlterSystemRenameComputeGroupContext).name = _x
		}
		{
			p.SetState(1660)

			var _x = p.Identifier()

			localctx.(*AlterSystemRenameComputeGroupContext).newName = _x
		}

	case 20:
		localctx = NewAlterResourceContext(p, localctx)
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(1662)
			p.Match(DorisParserParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1663)
			p.Match(DorisParserParserRESOURCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1664)

			var _x = p.IdentifierOrText()

			localctx.(*AlterResourceContext).name = _x
		}
		p.SetState(1666)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserPROPERTIES {
			{
				p.SetState(1665)

				var _x = p.PropertyClause()

				localctx.(*AlterResourceContext).properties = _x
			}

		}

	case 21:
		localctx = NewAlterRepositoryContext(p, localctx)
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(1668)
			p.Match(DorisParserParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1669)
			p.Match(DorisParserParserREPOSITORY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1670)

			var _x = p.Identifier()

			localctx.(*AlterRepositoryContext).name = _x
		}
		p.SetState(1672)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserPROPERTIES {
			{
				p.SetState(1671)

				var _x = p.PropertyClause()

				localctx.(*AlterRepositoryContext).properties = _x
			}

		}

	case 22:
		localctx = NewAlterRoutineLoadContext(p, localctx)
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(1674)
			p.Match(DorisParserParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1675)
			p.Match(DorisParserParserROUTINE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1676)
			p.Match(DorisParserParserLOAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1677)
			p.Match(DorisParserParserFOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1678)

			var _x = p.MultipartIdentifier()

			localctx.(*AlterRoutineLoadContext).name = _x
		}
		p.SetState(1680)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserPROPERTIES {
			{
				p.SetState(1679)

				var _x = p.PropertyClause()

				localctx.(*AlterRoutineLoadContext).properties = _x
			}

		}
		p.SetState(1688)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserFROM {
			{
				p.SetState(1682)
				p.Match(DorisParserParserFROM)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1683)

				var _x = p.Identifier()

				localctx.(*AlterRoutineLoadContext).type_ = _x
			}
			{
				p.SetState(1684)
				p.Match(DorisParserParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1685)
				p.PropertyItemList()
			}
			{
				p.SetState(1686)
				p.Match(DorisParserParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 23:
		localctx = NewAlterColocateGroupContext(p, localctx)
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(1690)
			p.Match(DorisParserParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1691)
			p.Match(DorisParserParserCOLOCATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1692)
			p.Match(DorisParserParserGROUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1693)

			var _x = p.MultipartIdentifier()

			localctx.(*AlterColocateGroupContext).name = _x
		}
		{
			p.SetState(1694)
			p.Match(DorisParserParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1695)
			p.Match(DorisParserParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1696)
			p.PropertyItemList()
		}
		{
			p.SetState(1697)
			p.Match(DorisParserParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 24:
		localctx = NewAlterUserContext(p, localctx)
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(1699)
			p.Match(DorisParserParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1700)
			p.Match(DorisParserParserUSER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1703)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserIF {
			{
				p.SetState(1701)
				p.Match(DorisParserParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1702)
				p.Match(DorisParserParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1705)
			p.GrantUserIdentify()
		}
		{
			p.SetState(1706)
			p.PasswordOption()
		}
		p.SetState(1709)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserCOMMENT {
			{
				p.SetState(1707)
				p.Match(DorisParserParserCOMMENT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1708)
				p.Match(DorisParserParserSTRING_LITERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISupportedDropStatementContext is an interface to support dynamic dispatch.
type ISupportedDropStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSupportedDropStatementContext differentiates from other interfaces.
	IsSupportedDropStatementContext()
}

type SupportedDropStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySupportedDropStatementContext() *SupportedDropStatementContext {
	var p = new(SupportedDropStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_supportedDropStatement
	return p
}

func InitEmptySupportedDropStatementContext(p *SupportedDropStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_supportedDropStatement
}

func (*SupportedDropStatementContext) IsSupportedDropStatementContext() {}

func NewSupportedDropStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SupportedDropStatementContext {
	var p = new(SupportedDropStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_supportedDropStatement

	return p
}

func (s *SupportedDropStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SupportedDropStatementContext) CopyAll(ctx *SupportedDropStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *SupportedDropStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedDropStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type DropUserContext struct {
	SupportedDropStatementContext
}

func NewDropUserContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropUserContext {
	var p = new(DropUserContext)

	InitEmptySupportedDropStatementContext(&p.SupportedDropStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedDropStatementContext))

	return p
}

func (s *DropUserContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropUserContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDROP, 0)
}

func (s *DropUserContext) USER() antlr.TerminalNode {
	return s.GetToken(DorisParserParserUSER, 0)
}

func (s *DropUserContext) UserIdentify() IUserIdentifyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserIdentifyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserIdentifyContext)
}

func (s *DropUserContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserParserIF, 0)
}

func (s *DropUserContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserEXISTS, 0)
}

func (s *DropUserContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitDropUser(s)

	default:
		return t.VisitChildren(s)
	}
}

type DropDatabaseContext struct {
	SupportedDropStatementContext
	name IMultipartIdentifierContext
}

func NewDropDatabaseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropDatabaseContext {
	var p = new(DropDatabaseContext)

	InitEmptySupportedDropStatementContext(&p.SupportedDropStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedDropStatementContext))

	return p
}

func (s *DropDatabaseContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *DropDatabaseContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *DropDatabaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropDatabaseContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDROP, 0)
}

func (s *DropDatabaseContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDATABASE, 0)
}

func (s *DropDatabaseContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSCHEMA, 0)
}

func (s *DropDatabaseContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *DropDatabaseContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserParserIF, 0)
}

func (s *DropDatabaseContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserEXISTS, 0)
}

func (s *DropDatabaseContext) FORCE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFORCE, 0)
}

func (s *DropDatabaseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitDropDatabase(s)

	default:
		return t.VisitChildren(s)
	}
}

type DropDictionaryContext struct {
	SupportedDropStatementContext
	name IMultipartIdentifierContext
}

func NewDropDictionaryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropDictionaryContext {
	var p = new(DropDictionaryContext)

	InitEmptySupportedDropStatementContext(&p.SupportedDropStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedDropStatementContext))

	return p
}

func (s *DropDictionaryContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *DropDictionaryContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *DropDictionaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropDictionaryContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDROP, 0)
}

func (s *DropDictionaryContext) DICTIONARY() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDICTIONARY, 0)
}

func (s *DropDictionaryContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *DropDictionaryContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserParserIF, 0)
}

func (s *DropDictionaryContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserEXISTS, 0)
}

func (s *DropDictionaryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitDropDictionary(s)

	default:
		return t.VisitChildren(s)
	}
}

type DropWorkloadPolicyContext struct {
	SupportedDropStatementContext
	name IIdentifierOrTextContext
}

func NewDropWorkloadPolicyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropWorkloadPolicyContext {
	var p = new(DropWorkloadPolicyContext)

	InitEmptySupportedDropStatementContext(&p.SupportedDropStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedDropStatementContext))

	return p
}

func (s *DropWorkloadPolicyContext) GetName() IIdentifierOrTextContext { return s.name }

func (s *DropWorkloadPolicyContext) SetName(v IIdentifierOrTextContext) { s.name = v }

func (s *DropWorkloadPolicyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropWorkloadPolicyContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDROP, 0)
}

func (s *DropWorkloadPolicyContext) WORKLOAD() antlr.TerminalNode {
	return s.GetToken(DorisParserParserWORKLOAD, 0)
}

func (s *DropWorkloadPolicyContext) POLICY() antlr.TerminalNode {
	return s.GetToken(DorisParserParserPOLICY, 0)
}

func (s *DropWorkloadPolicyContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *DropWorkloadPolicyContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserParserIF, 0)
}

func (s *DropWorkloadPolicyContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserEXISTS, 0)
}

func (s *DropWorkloadPolicyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitDropWorkloadPolicy(s)

	default:
		return t.VisitChildren(s)
	}
}

type DropRowPolicyContext struct {
	SupportedDropStatementContext
	policyName IIdentifierContext
	tableName  IMultipartIdentifierContext
	roleName   IIdentifierContext
}

func NewDropRowPolicyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropRowPolicyContext {
	var p = new(DropRowPolicyContext)

	InitEmptySupportedDropStatementContext(&p.SupportedDropStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedDropStatementContext))

	return p
}

func (s *DropRowPolicyContext) GetPolicyName() IIdentifierContext { return s.policyName }

func (s *DropRowPolicyContext) GetTableName() IMultipartIdentifierContext { return s.tableName }

func (s *DropRowPolicyContext) GetRoleName() IIdentifierContext { return s.roleName }

func (s *DropRowPolicyContext) SetPolicyName(v IIdentifierContext) { s.policyName = v }

func (s *DropRowPolicyContext) SetTableName(v IMultipartIdentifierContext) { s.tableName = v }

func (s *DropRowPolicyContext) SetRoleName(v IIdentifierContext) { s.roleName = v }

func (s *DropRowPolicyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropRowPolicyContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDROP, 0)
}

func (s *DropRowPolicyContext) ROW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserROW, 0)
}

func (s *DropRowPolicyContext) POLICY() antlr.TerminalNode {
	return s.GetToken(DorisParserParserPOLICY, 0)
}

func (s *DropRowPolicyContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisParserParserON, 0)
}

func (s *DropRowPolicyContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *DropRowPolicyContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DropRowPolicyContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *DropRowPolicyContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserParserIF, 0)
}

func (s *DropRowPolicyContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserEXISTS, 0)
}

func (s *DropRowPolicyContext) FOR() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFOR, 0)
}

func (s *DropRowPolicyContext) UserIdentify() IUserIdentifyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserIdentifyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserIdentifyContext)
}

func (s *DropRowPolicyContext) ROLE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserROLE, 0)
}

func (s *DropRowPolicyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitDropRowPolicy(s)

	default:
		return t.VisitChildren(s)
	}
}

type DropFunctionContext struct {
	SupportedDropStatementContext
}

func NewDropFunctionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropFunctionContext {
	var p = new(DropFunctionContext)

	InitEmptySupportedDropStatementContext(&p.SupportedDropStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedDropStatementContext))

	return p
}

func (s *DropFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropFunctionContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDROP, 0)
}

func (s *DropFunctionContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFUNCTION, 0)
}

func (s *DropFunctionContext) FunctionIdentifier() IFunctionIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionIdentifierContext)
}

func (s *DropFunctionContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLEFT_PAREN, 0)
}

func (s *DropFunctionContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRIGHT_PAREN, 0)
}

func (s *DropFunctionContext) StatementScope() IStatementScopeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementScopeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementScopeContext)
}

func (s *DropFunctionContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserParserIF, 0)
}

func (s *DropFunctionContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserEXISTS, 0)
}

func (s *DropFunctionContext) FunctionArguments() IFunctionArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionArgumentsContext)
}

func (s *DropFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitDropFunction(s)

	default:
		return t.VisitChildren(s)
	}
}

type DropWorkloadGroupContext struct {
	SupportedDropStatementContext
	name         IIdentifierOrTextContext
	computeGroup IIdentifierOrTextContext
}

func NewDropWorkloadGroupContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropWorkloadGroupContext {
	var p = new(DropWorkloadGroupContext)

	InitEmptySupportedDropStatementContext(&p.SupportedDropStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedDropStatementContext))

	return p
}

func (s *DropWorkloadGroupContext) GetName() IIdentifierOrTextContext { return s.name }

func (s *DropWorkloadGroupContext) GetComputeGroup() IIdentifierOrTextContext { return s.computeGroup }

func (s *DropWorkloadGroupContext) SetName(v IIdentifierOrTextContext) { s.name = v }

func (s *DropWorkloadGroupContext) SetComputeGroup(v IIdentifierOrTextContext) { s.computeGroup = v }

func (s *DropWorkloadGroupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropWorkloadGroupContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDROP, 0)
}

func (s *DropWorkloadGroupContext) WORKLOAD() antlr.TerminalNode {
	return s.GetToken(DorisParserParserWORKLOAD, 0)
}

func (s *DropWorkloadGroupContext) GROUP() antlr.TerminalNode {
	return s.GetToken(DorisParserParserGROUP, 0)
}

func (s *DropWorkloadGroupContext) AllIdentifierOrText() []IIdentifierOrTextContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierOrTextContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierOrTextContext); ok {
			tst[i] = t.(IIdentifierOrTextContext)
			i++
		}
	}

	return tst
}

func (s *DropWorkloadGroupContext) IdentifierOrText(i int) IIdentifierOrTextContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *DropWorkloadGroupContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserParserIF, 0)
}

func (s *DropWorkloadGroupContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserEXISTS, 0)
}

func (s *DropWorkloadGroupContext) FOR() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFOR, 0)
}

func (s *DropWorkloadGroupContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitDropWorkloadGroup(s)

	default:
		return t.VisitChildren(s)
	}
}

type DropSqlBlockRuleContext struct {
	SupportedDropStatementContext
}

func NewDropSqlBlockRuleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropSqlBlockRuleContext {
	var p = new(DropSqlBlockRuleContext)

	InitEmptySupportedDropStatementContext(&p.SupportedDropStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedDropStatementContext))

	return p
}

func (s *DropSqlBlockRuleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropSqlBlockRuleContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDROP, 0)
}

func (s *DropSqlBlockRuleContext) SQL_BLOCK_RULE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSQL_BLOCK_RULE, 0)
}

func (s *DropSqlBlockRuleContext) IdentifierSeq() IIdentifierSeqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierSeqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierSeqContext)
}

func (s *DropSqlBlockRuleContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserParserIF, 0)
}

func (s *DropSqlBlockRuleContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserEXISTS, 0)
}

func (s *DropSqlBlockRuleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitDropSqlBlockRule(s)

	default:
		return t.VisitChildren(s)
	}
}

type DropViewContext struct {
	SupportedDropStatementContext
	name IMultipartIdentifierContext
}

func NewDropViewContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropViewContext {
	var p = new(DropViewContext)

	InitEmptySupportedDropStatementContext(&p.SupportedDropStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedDropStatementContext))

	return p
}

func (s *DropViewContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *DropViewContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *DropViewContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropViewContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDROP, 0)
}

func (s *DropViewContext) VIEW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserVIEW, 0)
}

func (s *DropViewContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *DropViewContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserParserIF, 0)
}

func (s *DropViewContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserEXISTS, 0)
}

func (s *DropViewContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitDropView(s)

	default:
		return t.VisitChildren(s)
	}
}

type DropIndexContext struct {
	SupportedDropStatementContext
	name      IIdentifierContext
	tableName IMultipartIdentifierContext
}

func NewDropIndexContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropIndexContext {
	var p = new(DropIndexContext)

	InitEmptySupportedDropStatementContext(&p.SupportedDropStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedDropStatementContext))

	return p
}

func (s *DropIndexContext) GetName() IIdentifierContext { return s.name }

func (s *DropIndexContext) GetTableName() IMultipartIdentifierContext { return s.tableName }

func (s *DropIndexContext) SetName(v IIdentifierContext) { s.name = v }

func (s *DropIndexContext) SetTableName(v IMultipartIdentifierContext) { s.tableName = v }

func (s *DropIndexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropIndexContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDROP, 0)
}

func (s *DropIndexContext) INDEX() antlr.TerminalNode {
	return s.GetToken(DorisParserParserINDEX, 0)
}

func (s *DropIndexContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisParserParserON, 0)
}

func (s *DropIndexContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DropIndexContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *DropIndexContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserParserIF, 0)
}

func (s *DropIndexContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserEXISTS, 0)
}

func (s *DropIndexContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitDropIndex(s)

	default:
		return t.VisitChildren(s)
	}
}

type DropEncryptkeyContext struct {
	SupportedDropStatementContext
	name IMultipartIdentifierContext
}

func NewDropEncryptkeyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropEncryptkeyContext {
	var p = new(DropEncryptkeyContext)

	InitEmptySupportedDropStatementContext(&p.SupportedDropStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedDropStatementContext))

	return p
}

func (s *DropEncryptkeyContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *DropEncryptkeyContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *DropEncryptkeyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropEncryptkeyContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDROP, 0)
}

func (s *DropEncryptkeyContext) ENCRYPTKEY() antlr.TerminalNode {
	return s.GetToken(DorisParserParserENCRYPTKEY, 0)
}

func (s *DropEncryptkeyContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *DropEncryptkeyContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserParserIF, 0)
}

func (s *DropEncryptkeyContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserEXISTS, 0)
}

func (s *DropEncryptkeyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitDropEncryptkey(s)

	default:
		return t.VisitChildren(s)
	}
}

type DropRepositoryContext struct {
	SupportedDropStatementContext
	name IIdentifierContext
}

func NewDropRepositoryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropRepositoryContext {
	var p = new(DropRepositoryContext)

	InitEmptySupportedDropStatementContext(&p.SupportedDropStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedDropStatementContext))

	return p
}

func (s *DropRepositoryContext) GetName() IIdentifierContext { return s.name }

func (s *DropRepositoryContext) SetName(v IIdentifierContext) { s.name = v }

func (s *DropRepositoryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropRepositoryContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDROP, 0)
}

func (s *DropRepositoryContext) REPOSITORY() antlr.TerminalNode {
	return s.GetToken(DorisParserParserREPOSITORY, 0)
}

func (s *DropRepositoryContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DropRepositoryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitDropRepository(s)

	default:
		return t.VisitChildren(s)
	}
}

type DropRoleContext struct {
	SupportedDropStatementContext
	name IIdentifierOrTextContext
}

func NewDropRoleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropRoleContext {
	var p = new(DropRoleContext)

	InitEmptySupportedDropStatementContext(&p.SupportedDropStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedDropStatementContext))

	return p
}

func (s *DropRoleContext) GetName() IIdentifierOrTextContext { return s.name }

func (s *DropRoleContext) SetName(v IIdentifierOrTextContext) { s.name = v }

func (s *DropRoleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropRoleContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDROP, 0)
}

func (s *DropRoleContext) ROLE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserROLE, 0)
}

func (s *DropRoleContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *DropRoleContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserParserIF, 0)
}

func (s *DropRoleContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserEXISTS, 0)
}

func (s *DropRoleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitDropRole(s)

	default:
		return t.VisitChildren(s)
	}
}

type DropIndexAnalyzerContext struct {
	SupportedDropStatementContext
	name IIdentifierContext
}

func NewDropIndexAnalyzerContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropIndexAnalyzerContext {
	var p = new(DropIndexAnalyzerContext)

	InitEmptySupportedDropStatementContext(&p.SupportedDropStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedDropStatementContext))

	return p
}

func (s *DropIndexAnalyzerContext) GetName() IIdentifierContext { return s.name }

func (s *DropIndexAnalyzerContext) SetName(v IIdentifierContext) { s.name = v }

func (s *DropIndexAnalyzerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropIndexAnalyzerContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDROP, 0)
}

func (s *DropIndexAnalyzerContext) INVERTED() antlr.TerminalNode {
	return s.GetToken(DorisParserParserINVERTED, 0)
}

func (s *DropIndexAnalyzerContext) INDEX() antlr.TerminalNode {
	return s.GetToken(DorisParserParserINDEX, 0)
}

func (s *DropIndexAnalyzerContext) ANALYZER() antlr.TerminalNode {
	return s.GetToken(DorisParserParserANALYZER, 0)
}

func (s *DropIndexAnalyzerContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DropIndexAnalyzerContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserParserIF, 0)
}

func (s *DropIndexAnalyzerContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserEXISTS, 0)
}

func (s *DropIndexAnalyzerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitDropIndexAnalyzer(s)

	default:
		return t.VisitChildren(s)
	}
}

type DropStageContext struct {
	SupportedDropStatementContext
	name IIdentifierContext
}

func NewDropStageContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropStageContext {
	var p = new(DropStageContext)

	InitEmptySupportedDropStatementContext(&p.SupportedDropStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedDropStatementContext))

	return p
}

func (s *DropStageContext) GetName() IIdentifierContext { return s.name }

func (s *DropStageContext) SetName(v IIdentifierContext) { s.name = v }

func (s *DropStageContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropStageContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDROP, 0)
}

func (s *DropStageContext) STAGE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTAGE, 0)
}

func (s *DropStageContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DropStageContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserParserIF, 0)
}

func (s *DropStageContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserEXISTS, 0)
}

func (s *DropStageContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitDropStage(s)

	default:
		return t.VisitChildren(s)
	}
}

type DropIndexTokenizerContext struct {
	SupportedDropStatementContext
	name IIdentifierContext
}

func NewDropIndexTokenizerContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropIndexTokenizerContext {
	var p = new(DropIndexTokenizerContext)

	InitEmptySupportedDropStatementContext(&p.SupportedDropStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedDropStatementContext))

	return p
}

func (s *DropIndexTokenizerContext) GetName() IIdentifierContext { return s.name }

func (s *DropIndexTokenizerContext) SetName(v IIdentifierContext) { s.name = v }

func (s *DropIndexTokenizerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropIndexTokenizerContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDROP, 0)
}

func (s *DropIndexTokenizerContext) INVERTED() antlr.TerminalNode {
	return s.GetToken(DorisParserParserINVERTED, 0)
}

func (s *DropIndexTokenizerContext) INDEX() antlr.TerminalNode {
	return s.GetToken(DorisParserParserINDEX, 0)
}

func (s *DropIndexTokenizerContext) TOKENIZER() antlr.TerminalNode {
	return s.GetToken(DorisParserParserTOKENIZER, 0)
}

func (s *DropIndexTokenizerContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DropIndexTokenizerContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserParserIF, 0)
}

func (s *DropIndexTokenizerContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserEXISTS, 0)
}

func (s *DropIndexTokenizerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitDropIndexTokenizer(s)

	default:
		return t.VisitChildren(s)
	}
}

type DropResourceContext struct {
	SupportedDropStatementContext
	name IIdentifierOrTextContext
}

func NewDropResourceContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropResourceContext {
	var p = new(DropResourceContext)

	InitEmptySupportedDropStatementContext(&p.SupportedDropStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedDropStatementContext))

	return p
}

func (s *DropResourceContext) GetName() IIdentifierOrTextContext { return s.name }

func (s *DropResourceContext) SetName(v IIdentifierOrTextContext) { s.name = v }

func (s *DropResourceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropResourceContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDROP, 0)
}

func (s *DropResourceContext) RESOURCE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRESOURCE, 0)
}

func (s *DropResourceContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *DropResourceContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserParserIF, 0)
}

func (s *DropResourceContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserEXISTS, 0)
}

func (s *DropResourceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitDropResource(s)

	default:
		return t.VisitChildren(s)
	}
}

type DropFileContext struct {
	SupportedDropStatementContext
	name       antlr.Token
	database   IIdentifierContext
	properties IPropertyClauseContext
}

func NewDropFileContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropFileContext {
	var p = new(DropFileContext)

	InitEmptySupportedDropStatementContext(&p.SupportedDropStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedDropStatementContext))

	return p
}

func (s *DropFileContext) GetName() antlr.Token { return s.name }

func (s *DropFileContext) SetName(v antlr.Token) { s.name = v }

func (s *DropFileContext) GetDatabase() IIdentifierContext { return s.database }

func (s *DropFileContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *DropFileContext) SetDatabase(v IIdentifierContext) { s.database = v }

func (s *DropFileContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *DropFileContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropFileContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDROP, 0)
}

func (s *DropFileContext) FILE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFILE, 0)
}

func (s *DropFileContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTRING_LITERAL, 0)
}

func (s *DropFileContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *DropFileContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFROM, 0)
}

func (s *DropFileContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserIN, 0)
}

func (s *DropFileContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DropFileContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitDropFile(s)

	default:
		return t.VisitChildren(s)
	}
}

type DropCatalogContext struct {
	SupportedDropStatementContext
	name IIdentifierContext
}

func NewDropCatalogContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropCatalogContext {
	var p = new(DropCatalogContext)

	InitEmptySupportedDropStatementContext(&p.SupportedDropStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedDropStatementContext))

	return p
}

func (s *DropCatalogContext) GetName() IIdentifierContext { return s.name }

func (s *DropCatalogContext) SetName(v IIdentifierContext) { s.name = v }

func (s *DropCatalogContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropCatalogContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDROP, 0)
}

func (s *DropCatalogContext) CATALOG() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCATALOG, 0)
}

func (s *DropCatalogContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DropCatalogContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserParserIF, 0)
}

func (s *DropCatalogContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserEXISTS, 0)
}

func (s *DropCatalogContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitDropCatalog(s)

	default:
		return t.VisitChildren(s)
	}
}

type DropCatalogRecycleBinContext struct {
	SupportedDropStatementContext
	idType antlr.Token
	id     antlr.Token
}

func NewDropCatalogRecycleBinContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropCatalogRecycleBinContext {
	var p = new(DropCatalogRecycleBinContext)

	InitEmptySupportedDropStatementContext(&p.SupportedDropStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedDropStatementContext))

	return p
}

func (s *DropCatalogRecycleBinContext) GetIdType() antlr.Token { return s.idType }

func (s *DropCatalogRecycleBinContext) GetId() antlr.Token { return s.id }

func (s *DropCatalogRecycleBinContext) SetIdType(v antlr.Token) { s.idType = v }

func (s *DropCatalogRecycleBinContext) SetId(v antlr.Token) { s.id = v }

func (s *DropCatalogRecycleBinContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropCatalogRecycleBinContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDROP, 0)
}

func (s *DropCatalogRecycleBinContext) CATALOG() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCATALOG, 0)
}

func (s *DropCatalogRecycleBinContext) RECYCLE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRECYCLE, 0)
}

func (s *DropCatalogRecycleBinContext) BIN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserBIN, 0)
}

func (s *DropCatalogRecycleBinContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserWHERE, 0)
}

func (s *DropCatalogRecycleBinContext) EQ() antlr.TerminalNode {
	return s.GetToken(DorisParserParserEQ, 0)
}

func (s *DropCatalogRecycleBinContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTRING_LITERAL, 0)
}

func (s *DropCatalogRecycleBinContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserINTEGER_VALUE, 0)
}

func (s *DropCatalogRecycleBinContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitDropCatalogRecycleBin(s)

	default:
		return t.VisitChildren(s)
	}
}

type DropIndexTokenFilterContext struct {
	SupportedDropStatementContext
	name IIdentifierContext
}

func NewDropIndexTokenFilterContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropIndexTokenFilterContext {
	var p = new(DropIndexTokenFilterContext)

	InitEmptySupportedDropStatementContext(&p.SupportedDropStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedDropStatementContext))

	return p
}

func (s *DropIndexTokenFilterContext) GetName() IIdentifierContext { return s.name }

func (s *DropIndexTokenFilterContext) SetName(v IIdentifierContext) { s.name = v }

func (s *DropIndexTokenFilterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropIndexTokenFilterContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDROP, 0)
}

func (s *DropIndexTokenFilterContext) INVERTED() antlr.TerminalNode {
	return s.GetToken(DorisParserParserINVERTED, 0)
}

func (s *DropIndexTokenFilterContext) INDEX() antlr.TerminalNode {
	return s.GetToken(DorisParserParserINDEX, 0)
}

func (s *DropIndexTokenFilterContext) TOKEN_FILTER() antlr.TerminalNode {
	return s.GetToken(DorisParserParserTOKEN_FILTER, 0)
}

func (s *DropIndexTokenFilterContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DropIndexTokenFilterContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserParserIF, 0)
}

func (s *DropIndexTokenFilterContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserEXISTS, 0)
}

func (s *DropIndexTokenFilterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitDropIndexTokenFilter(s)

	default:
		return t.VisitChildren(s)
	}
}

type DropTableContext struct {
	SupportedDropStatementContext
	name IMultipartIdentifierContext
}

func NewDropTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropTableContext {
	var p = new(DropTableContext)

	InitEmptySupportedDropStatementContext(&p.SupportedDropStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedDropStatementContext))

	return p
}

func (s *DropTableContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *DropTableContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *DropTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropTableContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDROP, 0)
}

func (s *DropTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserTABLE, 0)
}

func (s *DropTableContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *DropTableContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserParserIF, 0)
}

func (s *DropTableContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserEXISTS, 0)
}

func (s *DropTableContext) FORCE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFORCE, 0)
}

func (s *DropTableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitDropTable(s)

	default:
		return t.VisitChildren(s)
	}
}

type DropStoragePolicyContext struct {
	SupportedDropStatementContext
	name IIdentifierContext
}

func NewDropStoragePolicyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropStoragePolicyContext {
	var p = new(DropStoragePolicyContext)

	InitEmptySupportedDropStatementContext(&p.SupportedDropStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedDropStatementContext))

	return p
}

func (s *DropStoragePolicyContext) GetName() IIdentifierContext { return s.name }

func (s *DropStoragePolicyContext) SetName(v IIdentifierContext) { s.name = v }

func (s *DropStoragePolicyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropStoragePolicyContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDROP, 0)
}

func (s *DropStoragePolicyContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTORAGE, 0)
}

func (s *DropStoragePolicyContext) POLICY() antlr.TerminalNode {
	return s.GetToken(DorisParserParserPOLICY, 0)
}

func (s *DropStoragePolicyContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DropStoragePolicyContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserParserIF, 0)
}

func (s *DropStoragePolicyContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserEXISTS, 0)
}

func (s *DropStoragePolicyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitDropStoragePolicy(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) SupportedDropStatement() (localctx ISupportedDropStatementContext) {
	localctx = NewSupportedDropStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, DorisParserParserRULE_supportedDropStatement)
	var _la int

	p.SetState(1914)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 219, p.GetParserRuleContext()) {
	case 1:
		localctx = NewDropCatalogRecycleBinContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1713)
			p.Match(DorisParserParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1714)
			p.Match(DorisParserParserCATALOG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1715)
			p.Match(DorisParserParserRECYCLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1716)
			p.Match(DorisParserParserBIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1717)
			p.Match(DorisParserParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1718)

			var _m = p.Match(DorisParserParserSTRING_LITERAL)

			localctx.(*DropCatalogRecycleBinContext).idType = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1719)
			p.Match(DorisParserParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1720)

			var _m = p.Match(DorisParserParserINTEGER_VALUE)

			localctx.(*DropCatalogRecycleBinContext).id = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewDropEncryptkeyContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1721)
			p.Match(DorisParserParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1722)
			p.Match(DorisParserParserENCRYPTKEY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1725)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserIF {
			{
				p.SetState(1723)
				p.Match(DorisParserParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1724)
				p.Match(DorisParserParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1727)

			var _x = p.MultipartIdentifier()

			localctx.(*DropEncryptkeyContext).name = _x
		}

	case 3:
		localctx = NewDropRoleContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1728)
			p.Match(DorisParserParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1729)
			p.Match(DorisParserParserROLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1732)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserIF {
			{
				p.SetState(1730)
				p.Match(DorisParserParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1731)
				p.Match(DorisParserParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1734)

			var _x = p.IdentifierOrText()

			localctx.(*DropRoleContext).name = _x
		}

	case 4:
		localctx = NewDropSqlBlockRuleContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1735)
			p.Match(DorisParserParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1736)
			p.Match(DorisParserParserSQL_BLOCK_RULE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1739)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserIF {
			{
				p.SetState(1737)
				p.Match(DorisParserParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1738)
				p.Match(DorisParserParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1741)
			p.IdentifierSeq()
		}

	case 5:
		localctx = NewDropUserContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1742)
			p.Match(DorisParserParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1743)
			p.Match(DorisParserParserUSER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1746)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserIF {
			{
				p.SetState(1744)
				p.Match(DorisParserParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1745)
				p.Match(DorisParserParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1748)
			p.UserIdentify()
		}

	case 6:
		localctx = NewDropStoragePolicyContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1749)
			p.Match(DorisParserParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1750)
			p.Match(DorisParserParserSTORAGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1751)
			p.Match(DorisParserParserPOLICY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1754)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserIF {
			{
				p.SetState(1752)
				p.Match(DorisParserParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1753)
				p.Match(DorisParserParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1756)

			var _x = p.Identifier()

			localctx.(*DropStoragePolicyContext).name = _x
		}

	case 7:
		localctx = NewDropWorkloadGroupContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1757)
			p.Match(DorisParserParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1758)
			p.Match(DorisParserParserWORKLOAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1759)
			p.Match(DorisParserParserGROUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1762)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserIF {
			{
				p.SetState(1760)
				p.Match(DorisParserParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1761)
				p.Match(DorisParserParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1764)

			var _x = p.IdentifierOrText()

			localctx.(*DropWorkloadGroupContext).name = _x
		}
		p.SetState(1767)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserFOR {
			{
				p.SetState(1765)
				p.Match(DorisParserParserFOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1766)

				var _x = p.IdentifierOrText()

				localctx.(*DropWorkloadGroupContext).computeGroup = _x
			}

		}

	case 8:
		localctx = NewDropCatalogContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1769)
			p.Match(DorisParserParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1770)
			p.Match(DorisParserParserCATALOG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1773)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserIF {
			{
				p.SetState(1771)
				p.Match(DorisParserParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1772)
				p.Match(DorisParserParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1775)

			var _x = p.Identifier()

			localctx.(*DropCatalogContext).name = _x
		}

	case 9:
		localctx = NewDropFileContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1776)
			p.Match(DorisParserParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1777)
			p.Match(DorisParserParserFILE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1778)

			var _m = p.Match(DorisParserParserSTRING_LITERAL)

			localctx.(*DropFileContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1781)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserFROM || _la == DorisParserParserIN {
			{
				p.SetState(1779)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserParserFROM || _la == DorisParserParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(1780)

				var _x = p.Identifier()

				localctx.(*DropFileContext).database = _x
			}

		}
		{
			p.SetState(1783)

			var _x = p.PropertyClause()

			localctx.(*DropFileContext).properties = _x
		}

	case 10:
		localctx = NewDropWorkloadPolicyContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1784)
			p.Match(DorisParserParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1785)
			p.Match(DorisParserParserWORKLOAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1786)
			p.Match(DorisParserParserPOLICY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1789)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserIF {
			{
				p.SetState(1787)
				p.Match(DorisParserParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1788)
				p.Match(DorisParserParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1791)

			var _x = p.IdentifierOrText()

			localctx.(*DropWorkloadPolicyContext).name = _x
		}

	case 11:
		localctx = NewDropRepositoryContext(p, localctx)
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1792)
			p.Match(DorisParserParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1793)
			p.Match(DorisParserParserREPOSITORY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1794)

			var _x = p.Identifier()

			localctx.(*DropRepositoryContext).name = _x
		}

	case 12:
		localctx = NewDropTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(1795)
			p.Match(DorisParserParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1796)
			p.Match(DorisParserParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1799)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserIF {
			{
				p.SetState(1797)
				p.Match(DorisParserParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1798)
				p.Match(DorisParserParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1801)

			var _x = p.MultipartIdentifier()

			localctx.(*DropTableContext).name = _x
		}
		p.SetState(1803)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserFORCE {
			{
				p.SetState(1802)
				p.Match(DorisParserParserFORCE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 13:
		localctx = NewDropDatabaseContext(p, localctx)
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(1805)
			p.Match(DorisParserParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1806)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserParserDATABASE || _la == DorisParserParserSCHEMA) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(1809)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserIF {
			{
				p.SetState(1807)
				p.Match(DorisParserParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1808)
				p.Match(DorisParserParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1811)

			var _x = p.MultipartIdentifier()

			localctx.(*DropDatabaseContext).name = _x
		}
		p.SetState(1813)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserFORCE {
			{
				p.SetState(1812)
				p.Match(DorisParserParserFORCE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 14:
		localctx = NewDropFunctionContext(p, localctx)
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(1815)
			p.Match(DorisParserParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1817)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserGLOBAL || _la == DorisParserParserLOCAL || _la == DorisParserParserSESSION {
			{
				p.SetState(1816)
				p.StatementScope()
			}

		}
		{
			p.SetState(1819)
			p.Match(DorisParserParserFUNCTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1822)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 206, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1820)
				p.Match(DorisParserParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1821)
				p.Match(DorisParserParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(1824)
			p.FunctionIdentifier()
		}
		{
			p.SetState(1825)
			p.Match(DorisParserParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1827)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&9152335059222592) != 0) || ((int64((_la-71)) & ^0x3f) == 0 && ((int64(1)<<(_la-71))&32633505112391681) != 0) || _la == DorisParserParserDOUBLE || _la == DorisParserParserFLOAT || ((int64((_la-214)) & ^0x3f) == 0 && ((int64(1)<<(_la-214))&9208814108673) != 0) || _la == DorisParserParserMAP || _la == DorisParserParserQUANTILE_STATE || ((int64((_la-427)) & ^0x3f) == 0 && ((int64(1)<<(_la-427))&704375029761) != 0) || _la == DorisParserParserVARCHAR || _la == DorisParserParserVARIANT {
			{
				p.SetState(1826)
				p.FunctionArguments()
			}

		}
		{
			p.SetState(1829)
			p.Match(DorisParserParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 15:
		localctx = NewDropIndexContext(p, localctx)
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(1831)
			p.Match(DorisParserParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1832)
			p.Match(DorisParserParserINDEX)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1835)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserIF {
			{
				p.SetState(1833)
				p.Match(DorisParserParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1834)
				p.Match(DorisParserParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1837)

			var _x = p.Identifier()

			localctx.(*DropIndexContext).name = _x
		}
		{
			p.SetState(1838)
			p.Match(DorisParserParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1839)

			var _x = p.MultipartIdentifier()

			localctx.(*DropIndexContext).tableName = _x
		}

	case 16:
		localctx = NewDropResourceContext(p, localctx)
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(1841)
			p.Match(DorisParserParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1842)
			p.Match(DorisParserParserRESOURCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1845)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserIF {
			{
				p.SetState(1843)
				p.Match(DorisParserParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1844)
				p.Match(DorisParserParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1847)

			var _x = p.IdentifierOrText()

			localctx.(*DropResourceContext).name = _x
		}

	case 17:
		localctx = NewDropRowPolicyContext(p, localctx)
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(1848)
			p.Match(DorisParserParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1849)
			p.Match(DorisParserParserROW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1850)
			p.Match(DorisParserParserPOLICY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1853)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserIF {
			{
				p.SetState(1851)
				p.Match(DorisParserParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1852)
				p.Match(DorisParserParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1855)

			var _x = p.Identifier()

			localctx.(*DropRowPolicyContext).policyName = _x
		}
		{
			p.SetState(1856)
			p.Match(DorisParserParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1857)

			var _x = p.MultipartIdentifier()

			localctx.(*DropRowPolicyContext).tableName = _x
		}
		p.SetState(1864)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserFOR {
			{
				p.SetState(1858)
				p.Match(DorisParserParserFOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(1862)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case DorisParserParserLEFT_BRACE, DorisParserParserRIGHT_BRACE, DorisParserParserACTIONS, DorisParserParserAFTER, DorisParserParserAGG_STATE, DorisParserParserAGGREGATE, DorisParserParserALIAS, DorisParserParserANALYZED, DorisParserParserARRAY, DorisParserParserAT, DorisParserParserAUTHORS, DorisParserParserAUTO_INCREMENT, DorisParserParserALWAYS, DorisParserParserBACKENDS, DorisParserParserBACKUP, DorisParserParserBEGIN, DorisParserParserBELONG, DorisParserParserBIN, DorisParserParserBITAND, DorisParserParserBITMAP, DorisParserParserBITMAP_EMPTY, DorisParserParserBITMAP_UNION, DorisParserParserBITOR, DorisParserParserBITXOR, DorisParserParserBLOB, DorisParserParserBOOLEAN, DorisParserParserBRANCH, DorisParserParserBRIEF, DorisParserParserBROKER, DorisParserParserBUCKETS, DorisParserParserBUILD, DorisParserParserBUILTIN, DorisParserParserBULK, DorisParserParserCACHE, DorisParserParserCACHED, DorisParserParserCALL, DorisParserParserCATALOG, DorisParserParserCATALOGS, DorisParserParserCHAIN, DorisParserParserCHAR, DorisParserParserCHARSET, DorisParserParserCHECK, DorisParserParserCLUSTER, DorisParserParserCLUSTERS, DorisParserParserCOLLATION, DorisParserParserCOLLECT, DorisParserParserCOLOCATE, DorisParserParserCOLUMNS, DorisParserParserCOMMENT, DorisParserParserCOMMIT, DorisParserParserCOMMITTED, DorisParserParserCOMPACT, DorisParserParserCOMPLETE, DorisParserParserCOMPRESS_TYPE, DorisParserParserCOMPUTE, DorisParserParserCONDITIONS, DorisParserParserCONFIG, DorisParserParserCONNECTION, DorisParserParserCONNECTION_ID, DorisParserParserCONSISTENT, DorisParserParserCONSTRAINTS, DorisParserParserCONVERT, DorisParserParserCONVERT_LSC, DorisParserParserCOPY, DorisParserParserCOUNT, DorisParserParserCREATION, DorisParserParserCRON, DorisParserParserCURRENT_CATALOG, DorisParserParserCURRENT_DATE, DorisParserParserCURRENT_TIME, DorisParserParserCURRENT_TIMESTAMP, DorisParserParserCURRENT_USER, DorisParserParserDATA, DorisParserParserDATE, DorisParserParserDATETIME, DorisParserParserDATETIMEV2, DorisParserParserDATEV2, DorisParserParserDATETIMEV1, DorisParserParserDATEV1, DorisParserParserDAY, DorisParserParserDAYS, DorisParserParserDECIMAL, DorisParserParserDECIMALV2, DorisParserParserDECIMALV3, DorisParserParserDEFERRED, DorisParserParserDEMAND, DorisParserParserDIAGNOSE, DorisParserParserDIAGNOSIS, DorisParserParserDICTIONARIES, DorisParserParserDICTIONARY, DorisParserParserDISTINCTPC, DorisParserParserDISTINCTPCSA, DorisParserParserDO, DorisParserParserDORIS_INTERNAL_TABLE_ID, DorisParserParserDUAL, DorisParserParserDYNAMIC, DorisParserParserE, DorisParserParserENABLE, DorisParserParserENCRYPTKEY, DorisParserParserENCRYPTKEYS, DorisParserParserEND, DorisParserParserENDS, DorisParserParserENGINE, DorisParserParserENGINES, DorisParserParserERRORS, DorisParserParserESCAPE, DorisParserParserEVENTS, DorisParserParserEVERY, DorisParserParserEXCLUDE, DorisParserParserEXPIRED, DorisParserParserEXTERNAL, DorisParserParserFAILED_LOGIN_ATTEMPTS, DorisParserParserFAST, DorisParserParserFEATURE, DorisParserParserFIELDS, DorisParserParserFILE, DorisParserParserFILTER, DorisParserParserFIRST, DorisParserParserFORMAT, DorisParserParserFREE, DorisParserParserFRONTENDS, DorisParserParserFUNCTION, DorisParserParserGENERATED, DorisParserParserGENERIC, DorisParserParserGLOBAL, DorisParserParserGRAPH, DorisParserParserGROUPING, DorisParserParserGROUPS, DorisParserParserHASH, DorisParserParserHASH_MAP, DorisParserParserHDFS, DorisParserParserHELP, DorisParserParserHISTOGRAM, DorisParserParserHLL_UNION, DorisParserParserHOSTNAME, DorisParserParserHOTSPOT, DorisParserParserHOUR, DorisParserParserHOURS, DorisParserParserHUB, DorisParserParserIDENTIFIED, DorisParserParserIGNORE, DorisParserParserIMMEDIATE, DorisParserParserINCREMENTAL, DorisParserParserINDEXES, DorisParserParserINVERTED, DorisParserParserIP_TRIE, DorisParserParserIPV4, DorisParserParserIPV6, DorisParserParserIS_NOT_NULL_PRED, DorisParserParserIS_NULL_PRED, DorisParserParserISNULL, DorisParserParserISOLATION, DorisParserParserJOB, DorisParserParserJOBS, DorisParserParserJSON, DorisParserParserJSONB, DorisParserParserLABEL, DorisParserParserLAST, DorisParserParserLDAP, DorisParserParserLDAP_ADMIN_PASSWORD, DorisParserParserLESS, DorisParserParserLEVEL, DorisParserParserLINES, DorisParserParserLINK, DorisParserParserLOCAL, DorisParserParserLOCALTIME, DorisParserParserLOCALTIMESTAMP, DorisParserParserLOCATION, DorisParserParserLOCK, DorisParserParserLOGICAL, DorisParserParserMANUAL, DorisParserParserMAP, DorisParserParserMATCH_ALL, DorisParserParserMATCH_ANY, DorisParserParserMATCH_PHRASE, DorisParserParserMATCH_PHRASE_EDGE, DorisParserParserMATCH_PHRASE_PREFIX, DorisParserParserMATCH_REGEXP, DorisParserParserMATERIALIZED, DorisParserParserMAX, DorisParserParserMEMO, DorisParserParserMERGE, DorisParserParserMIGRATE, DorisParserParserMIGRATIONS, DorisParserParserMIN, DorisParserParserMINUTE, DorisParserParserMINUTES, DorisParserParserMODIFY, DorisParserParserMONTH, DorisParserParserMTMV, DorisParserParserNAME, DorisParserParserNAMES, DorisParserParserNEGATIVE, DorisParserParserNEVER, DorisParserParserNEXT, DorisParserParserNGRAM_BF, DorisParserParserNO, DorisParserParserNON_NULLABLE, DorisParserParserNULLS, DorisParserParserOF, DorisParserParserOFFSET, DorisParserParserONLY, DorisParserParserOPEN, DorisParserParserOPTIMIZED, DorisParserParserPARAMETER, DorisParserParserPARSED, DorisParserParserPARTITIONS, DorisParserParserPASSWORD, DorisParserParserPASSWORD_EXPIRE, DorisParserParserPASSWORD_HISTORY, DorisParserParserPASSWORD_LOCK_TIME, DorisParserParserPASSWORD_REUSE, DorisParserParserPATH, DorisParserParserPAUSE, DorisParserParserPERCENT, DorisParserParserPERIOD, DorisParserParserPERMISSIVE, DorisParserParserPHYSICAL, DorisParserParserPI, DorisParserParserPLAN, DorisParserParserPRIVILEGES, DorisParserParserPROCESS, DorisParserParserPLUGIN, DorisParserParserPLUGINS, DorisParserParserPOLICY, DorisParserParserPROC, DorisParserParserPROCESSLIST, DorisParserParserPROFILE, DorisParserParserPROPERTIES, DorisParserParserPROPERTY, DorisParserParserQUANTILE_STATE, DorisParserParserQUANTILE_UNION, DorisParserParserQUERY, DorisParserParserQUEUED, DorisParserParserQUOTA, DorisParserParserQUALIFY, DorisParserParserQUARTER, DorisParserParserRANDOM, DorisParserParserRECENT, DorisParserParserRECOVER, DorisParserParserRECYCLE, DorisParserParserREFRESH, DorisParserParserREPEATABLE, DorisParserParserREPLACE, DorisParserParserREPLACE_IF_NOT_NULL, DorisParserParserREPLAYER, DorisParserParserREPOSITORIES, DorisParserParserREPOSITORY, DorisParserParserRESOURCE, DorisParserParserRESOURCES, DorisParserParserRESTORE, DorisParserParserRESTRICTIVE, DorisParserParserRESUME, DorisParserParserRETAIN, DorisParserParserRETENTION, DorisParserParserRETURNS, DorisParserParserREWRITTEN, DorisParserParserRLIKE, DorisParserParserROLLBACK, DorisParserParserROLLUP, DorisParserParserROUTINE, DorisParserParserS3, DorisParserParserSAMPLE, DorisParserParserSCHEDULE, DorisParserParserSCHEDULER, DorisParserParserSCHEMA, DorisParserParserSECOND, DorisParserParserSERIALIZABLE, DorisParserParserSESSION, DorisParserParserSESSION_USER, DorisParserParserSET_SESSION_VARIABLE, DorisParserParserSHAPE, DorisParserParserSKEW, DorisParserParserSNAPSHOT, DorisParserParserSNAPSHOTS, DorisParserParserSONAME, DorisParserParserSPLIT, DorisParserParserSQL, DorisParserParserSTAGE, DorisParserParserSTAGES, DorisParserParserSTART, DorisParserParserSTARTS, DorisParserParserSTATS, DorisParserParserSTATUS, DorisParserParserSTOP, DorisParserParserSTORAGE, DorisParserParserSTREAM, DorisParserParserSTREAMING, DorisParserParserSTRING, DorisParserParserSTRUCT, DorisParserParserSUM, DorisParserParserTABLES, DorisParserParserTAG, DorisParserParserTASK, DorisParserParserTASKS, DorisParserParserTEMPORARY, DorisParserParserTEXT, DorisParserParserTHAN, DorisParserParserTIME, DorisParserParserTIMESTAMP, DorisParserParserTRANSACTION, DorisParserParserTREE, DorisParserParserTRIGGERS, DorisParserParserTRUNCATE, DorisParserParserTYPE, DorisParserParserTYPES, DorisParserParserUNCOMMITTED, DorisParserParserUNLOCK, DorisParserParserUNSET, DorisParserParserUP, DorisParserParserUSER, DorisParserParserVALUE, DorisParserParserVARCHAR, DorisParserParserVARIABLE, DorisParserParserVARIABLES, DorisParserParserVARIANT, DorisParserParserVAULT, DorisParserParserVAULTS, DorisParserParserVERBOSE, DorisParserParserVERSION, DorisParserParserVIEW, DorisParserParserVIEWS, DorisParserParserWARM, DorisParserParserWARNINGS, DorisParserParserWEEK, DorisParserParserWORK, DorisParserParserYEAR, DorisParserParserHINT_START, DorisParserParserHINT_END, DorisParserParserCOMMENT_START, DorisParserParserSTRING_LITERAL, DorisParserParserIDENTIFIER, DorisParserParserBACKQUOTED_IDENTIFIER:
				{
					p.SetState(1859)
					p.UserIdentify()
				}

			case DorisParserParserROLE:
				{
					p.SetState(1860)
					p.Match(DorisParserParserROLE)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1861)

					var _x = p.Identifier()

					localctx.(*DropRowPolicyContext).roleName = _x
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

		}

	case 18:
		localctx = NewDropDictionaryContext(p, localctx)
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(1866)
			p.Match(DorisParserParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1867)
			p.Match(DorisParserParserDICTIONARY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1870)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserIF {
			{
				p.SetState(1868)
				p.Match(DorisParserParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1869)
				p.Match(DorisParserParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1872)

			var _x = p.MultipartIdentifier()

			localctx.(*DropDictionaryContext).name = _x
		}

	case 19:
		localctx = NewDropStageContext(p, localctx)
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(1873)
			p.Match(DorisParserParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1874)
			p.Match(DorisParserParserSTAGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1877)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserIF {
			{
				p.SetState(1875)
				p.Match(DorisParserParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1876)
				p.Match(DorisParserParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1879)

			var _x = p.Identifier()

			localctx.(*DropStageContext).name = _x
		}

	case 20:
		localctx = NewDropViewContext(p, localctx)
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(1880)
			p.Match(DorisParserParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1881)
			p.Match(DorisParserParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1884)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserIF {
			{
				p.SetState(1882)
				p.Match(DorisParserParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1883)
				p.Match(DorisParserParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1886)

			var _x = p.MultipartIdentifier()

			localctx.(*DropViewContext).name = _x
		}

	case 21:
		localctx = NewDropIndexAnalyzerContext(p, localctx)
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(1887)
			p.Match(DorisParserParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1888)
			p.Match(DorisParserParserINVERTED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1889)
			p.Match(DorisParserParserINDEX)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1890)
			p.Match(DorisParserParserANALYZER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1893)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserIF {
			{
				p.SetState(1891)
				p.Match(DorisParserParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1892)
				p.Match(DorisParserParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1895)

			var _x = p.Identifier()

			localctx.(*DropIndexAnalyzerContext).name = _x
		}

	case 22:
		localctx = NewDropIndexTokenizerContext(p, localctx)
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(1896)
			p.Match(DorisParserParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1897)
			p.Match(DorisParserParserINVERTED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1898)
			p.Match(DorisParserParserINDEX)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1899)
			p.Match(DorisParserParserTOKENIZER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1902)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserIF {
			{
				p.SetState(1900)
				p.Match(DorisParserParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1901)
				p.Match(DorisParserParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1904)

			var _x = p.Identifier()

			localctx.(*DropIndexTokenizerContext).name = _x
		}

	case 23:
		localctx = NewDropIndexTokenFilterContext(p, localctx)
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(1905)
			p.Match(DorisParserParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1906)
			p.Match(DorisParserParserINVERTED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1907)
			p.Match(DorisParserParserINDEX)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1908)
			p.Match(DorisParserParserTOKEN_FILTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1911)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserIF {
			{
				p.SetState(1909)
				p.Match(DorisParserParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1910)
				p.Match(DorisParserParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1913)

			var _x = p.Identifier()

			localctx.(*DropIndexTokenFilterContext).name = _x
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISupportedShowStatementContext is an interface to support dynamic dispatch.
type ISupportedShowStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSupportedShowStatementContext differentiates from other interfaces.
	IsSupportedShowStatementContext()
}

type SupportedShowStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySupportedShowStatementContext() *SupportedShowStatementContext {
	var p = new(SupportedShowStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_supportedShowStatement
	return p
}

func InitEmptySupportedShowStatementContext(p *SupportedShowStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_supportedShowStatement
}

func (*SupportedShowStatementContext) IsSupportedShowStatementContext() {}

func NewSupportedShowStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SupportedShowStatementContext {
	var p = new(SupportedShowStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_supportedShowStatement

	return p
}

func (s *SupportedShowStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SupportedShowStatementContext) CopyAll(ctx *SupportedShowStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *SupportedShowStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedShowStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ShowRepositoriesContext struct {
	SupportedShowStatementContext
}

func NewShowRepositoriesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowRepositoriesContext {
	var p = new(ShowRepositoriesContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowRepositoriesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowRepositoriesContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSHOW, 0)
}

func (s *ShowRepositoriesContext) REPOSITORIES() antlr.TerminalNode {
	return s.GetToken(DorisParserParserREPOSITORIES, 0)
}

func (s *ShowRepositoriesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitShowRepositories(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowDataContext struct {
	SupportedShowStatementContext
	tableName IMultipartIdentifierContext
}

func NewShowDataContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowDataContext {
	var p = new(ShowDataContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowDataContext) GetTableName() IMultipartIdentifierContext { return s.tableName }

func (s *ShowDataContext) SetTableName(v IMultipartIdentifierContext) { s.tableName = v }

func (s *ShowDataContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowDataContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSHOW, 0)
}

func (s *ShowDataContext) DATA() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDATA, 0)
}

func (s *ShowDataContext) ALL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserALL, 0)
}

func (s *ShowDataContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFROM, 0)
}

func (s *ShowDataContext) SortClause() ISortClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortClauseContext)
}

func (s *ShowDataContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *ShowDataContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowDataContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitShowData(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowIndexContext struct {
	SupportedShowStatementContext
	tableName IMultipartIdentifierContext
	database  IMultipartIdentifierContext
}

func NewShowIndexContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowIndexContext {
	var p = new(ShowIndexContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowIndexContext) GetTableName() IMultipartIdentifierContext { return s.tableName }

func (s *ShowIndexContext) GetDatabase() IMultipartIdentifierContext { return s.database }

func (s *ShowIndexContext) SetTableName(v IMultipartIdentifierContext) { s.tableName = v }

func (s *ShowIndexContext) SetDatabase(v IMultipartIdentifierContext) { s.database = v }

func (s *ShowIndexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowIndexContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSHOW, 0)
}

func (s *ShowIndexContext) KEY() antlr.TerminalNode {
	return s.GetToken(DorisParserParserKEY, 0)
}

func (s *ShowIndexContext) KEYS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserKEYS, 0)
}

func (s *ShowIndexContext) INDEX() antlr.TerminalNode {
	return s.GetToken(DorisParserParserINDEX, 0)
}

func (s *ShowIndexContext) INDEXES() antlr.TerminalNode {
	return s.GetToken(DorisParserParserINDEXES, 0)
}

func (s *ShowIndexContext) AllFROM() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserFROM)
}

func (s *ShowIndexContext) FROM(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserFROM, i)
}

func (s *ShowIndexContext) AllIN() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserIN)
}

func (s *ShowIndexContext) IN(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserIN, i)
}

func (s *ShowIndexContext) AllMultipartIdentifier() []IMultipartIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IMultipartIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMultipartIdentifierContext); ok {
			tst[i] = t.(IMultipartIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *ShowIndexContext) MultipartIdentifier(i int) IMultipartIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowIndexContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitShowIndex(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowDynamicPartitionContext struct {
	SupportedShowStatementContext
	database IMultipartIdentifierContext
}

func NewShowDynamicPartitionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowDynamicPartitionContext {
	var p = new(ShowDynamicPartitionContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowDynamicPartitionContext) GetDatabase() IMultipartIdentifierContext { return s.database }

func (s *ShowDynamicPartitionContext) SetDatabase(v IMultipartIdentifierContext) { s.database = v }

func (s *ShowDynamicPartitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowDynamicPartitionContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSHOW, 0)
}

func (s *ShowDynamicPartitionContext) DYNAMIC() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDYNAMIC, 0)
}

func (s *ShowDynamicPartitionContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(DorisParserParserPARTITION, 0)
}

func (s *ShowDynamicPartitionContext) TABLES() antlr.TerminalNode {
	return s.GetToken(DorisParserParserTABLES, 0)
}

func (s *ShowDynamicPartitionContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFROM, 0)
}

func (s *ShowDynamicPartitionContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserIN, 0)
}

func (s *ShowDynamicPartitionContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowDynamicPartitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitShowDynamicPartition(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowTableStatusContext struct {
	SupportedShowStatementContext
	database IMultipartIdentifierContext
}

func NewShowTableStatusContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowTableStatusContext {
	var p = new(ShowTableStatusContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowTableStatusContext) GetDatabase() IMultipartIdentifierContext { return s.database }

func (s *ShowTableStatusContext) SetDatabase(v IMultipartIdentifierContext) { s.database = v }

func (s *ShowTableStatusContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowTableStatusContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSHOW, 0)
}

func (s *ShowTableStatusContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserTABLE, 0)
}

func (s *ShowTableStatusContext) STATUS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTATUS, 0)
}

func (s *ShowTableStatusContext) WildWhere() IWildWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWildWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWildWhereContext)
}

func (s *ShowTableStatusContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFROM, 0)
}

func (s *ShowTableStatusContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserIN, 0)
}

func (s *ShowTableStatusContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowTableStatusContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitShowTableStatus(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowBackupContext struct {
	SupportedShowStatementContext
	database IIdentifierContext
}

func NewShowBackupContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowBackupContext {
	var p = new(ShowBackupContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowBackupContext) GetDatabase() IIdentifierContext { return s.database }

func (s *ShowBackupContext) SetDatabase(v IIdentifierContext) { s.database = v }

func (s *ShowBackupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowBackupContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSHOW, 0)
}

func (s *ShowBackupContext) BACKUP() antlr.TerminalNode {
	return s.GetToken(DorisParserParserBACKUP, 0)
}

func (s *ShowBackupContext) WildWhere() IWildWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWildWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWildWhereContext)
}

func (s *ShowBackupContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFROM, 0)
}

func (s *ShowBackupContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserIN, 0)
}

func (s *ShowBackupContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowBackupContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitShowBackup(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowCreateFunctionContext struct {
	SupportedShowStatementContext
	database IMultipartIdentifierContext
}

func NewShowCreateFunctionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowCreateFunctionContext {
	var p = new(ShowCreateFunctionContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowCreateFunctionContext) GetDatabase() IMultipartIdentifierContext { return s.database }

func (s *ShowCreateFunctionContext) SetDatabase(v IMultipartIdentifierContext) { s.database = v }

func (s *ShowCreateFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCreateFunctionContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSHOW, 0)
}

func (s *ShowCreateFunctionContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCREATE, 0)
}

func (s *ShowCreateFunctionContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFUNCTION, 0)
}

func (s *ShowCreateFunctionContext) FunctionIdentifier() IFunctionIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionIdentifierContext)
}

func (s *ShowCreateFunctionContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLEFT_PAREN, 0)
}

func (s *ShowCreateFunctionContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRIGHT_PAREN, 0)
}

func (s *ShowCreateFunctionContext) StatementScope() IStatementScopeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementScopeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementScopeContext)
}

func (s *ShowCreateFunctionContext) FunctionArguments() IFunctionArgumentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionArgumentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionArgumentsContext)
}

func (s *ShowCreateFunctionContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFROM, 0)
}

func (s *ShowCreateFunctionContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserIN, 0)
}

func (s *ShowCreateFunctionContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowCreateFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitShowCreateFunction(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowGrantsForUserContext struct {
	SupportedShowStatementContext
}

func NewShowGrantsForUserContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowGrantsForUserContext {
	var p = new(ShowGrantsForUserContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowGrantsForUserContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowGrantsForUserContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSHOW, 0)
}

func (s *ShowGrantsForUserContext) GRANTS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserGRANTS, 0)
}

func (s *ShowGrantsForUserContext) FOR() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFOR, 0)
}

func (s *ShowGrantsForUserContext) UserIdentify() IUserIdentifyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserIdentifyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserIdentifyContext)
}

func (s *ShowGrantsForUserContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitShowGrantsForUser(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowViewContext struct {
	SupportedShowStatementContext
	tableName IMultipartIdentifierContext
	database  IIdentifierContext
}

func NewShowViewContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowViewContext {
	var p = new(ShowViewContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowViewContext) GetTableName() IMultipartIdentifierContext { return s.tableName }

func (s *ShowViewContext) GetDatabase() IIdentifierContext { return s.database }

func (s *ShowViewContext) SetTableName(v IMultipartIdentifierContext) { s.tableName = v }

func (s *ShowViewContext) SetDatabase(v IIdentifierContext) { s.database = v }

func (s *ShowViewContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowViewContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSHOW, 0)
}

func (s *ShowViewContext) VIEW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserVIEW, 0)
}

func (s *ShowViewContext) AllFROM() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserFROM)
}

func (s *ShowViewContext) FROM(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserFROM, i)
}

func (s *ShowViewContext) AllIN() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserIN)
}

func (s *ShowViewContext) IN(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserIN, i)
}

func (s *ShowViewContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowViewContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowViewContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitShowView(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowTablesContext struct {
	SupportedShowStatementContext
	database IMultipartIdentifierContext
}

func NewShowTablesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowTablesContext {
	var p = new(ShowTablesContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowTablesContext) GetDatabase() IMultipartIdentifierContext { return s.database }

func (s *ShowTablesContext) SetDatabase(v IMultipartIdentifierContext) { s.database = v }

func (s *ShowTablesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowTablesContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSHOW, 0)
}

func (s *ShowTablesContext) TABLES() antlr.TerminalNode {
	return s.GetToken(DorisParserParserTABLES, 0)
}

func (s *ShowTablesContext) FULL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFULL, 0)
}

func (s *ShowTablesContext) WildWhere() IWildWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWildWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWildWhereContext)
}

func (s *ShowTablesContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFROM, 0)
}

func (s *ShowTablesContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserIN, 0)
}

func (s *ShowTablesContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowTablesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitShowTables(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowExportContext struct {
	SupportedShowStatementContext
	database IMultipartIdentifierContext
}

func NewShowExportContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowExportContext {
	var p = new(ShowExportContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowExportContext) GetDatabase() IMultipartIdentifierContext { return s.database }

func (s *ShowExportContext) SetDatabase(v IMultipartIdentifierContext) { s.database = v }

func (s *ShowExportContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowExportContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSHOW, 0)
}

func (s *ShowExportContext) EXPORT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserEXPORT, 0)
}

func (s *ShowExportContext) WildWhere() IWildWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWildWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWildWhereContext)
}

func (s *ShowExportContext) SortClause() ISortClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortClauseContext)
}

func (s *ShowExportContext) LimitClause() ILimitClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitClauseContext)
}

func (s *ShowExportContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFROM, 0)
}

func (s *ShowExportContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserIN, 0)
}

func (s *ShowExportContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowExportContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitShowExport(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowAuthorsContext struct {
	SupportedShowStatementContext
}

func NewShowAuthorsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowAuthorsContext {
	var p = new(ShowAuthorsContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowAuthorsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowAuthorsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSHOW, 0)
}

func (s *ShowAuthorsContext) AUTHORS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserAUTHORS, 0)
}

func (s *ShowAuthorsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitShowAuthors(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowStorageEnginesContext struct {
	SupportedShowStatementContext
}

func NewShowStorageEnginesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowStorageEnginesContext {
	var p = new(ShowStorageEnginesContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowStorageEnginesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowStorageEnginesContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSHOW, 0)
}

func (s *ShowStorageEnginesContext) ENGINES() antlr.TerminalNode {
	return s.GetToken(DorisParserParserENGINES, 0)
}

func (s *ShowStorageEnginesContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTORAGE, 0)
}

func (s *ShowStorageEnginesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitShowStorageEngines(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowWarningErrorsContext struct {
	SupportedShowStatementContext
}

func NewShowWarningErrorsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowWarningErrorsContext {
	var p = new(ShowWarningErrorsContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowWarningErrorsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowWarningErrorsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSHOW, 0)
}

func (s *ShowWarningErrorsContext) WARNINGS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserWARNINGS, 0)
}

func (s *ShowWarningErrorsContext) ERRORS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserERRORS, 0)
}

func (s *ShowWarningErrorsContext) LimitClause() ILimitClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitClauseContext)
}

func (s *ShowWarningErrorsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitShowWarningErrors(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowCatalogsContext struct {
	SupportedShowStatementContext
}

func NewShowCatalogsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowCatalogsContext {
	var p = new(ShowCatalogsContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowCatalogsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCatalogsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSHOW, 0)
}

func (s *ShowCatalogsContext) CATALOGS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCATALOGS, 0)
}

func (s *ShowCatalogsContext) WildWhere() IWildWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWildWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWildWhereContext)
}

func (s *ShowCatalogsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitShowCatalogs(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowRolesContext struct {
	SupportedShowStatementContext
}

func NewShowRolesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowRolesContext {
	var p = new(ShowRolesContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowRolesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowRolesContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSHOW, 0)
}

func (s *ShowRolesContext) ROLES() antlr.TerminalNode {
	return s.GetToken(DorisParserParserROLES, 0)
}

func (s *ShowRolesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitShowRoles(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowRowPolicyContext struct {
	SupportedShowStatementContext
	role IIdentifierContext
}

func NewShowRowPolicyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowRowPolicyContext {
	var p = new(ShowRowPolicyContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowRowPolicyContext) GetRole() IIdentifierContext { return s.role }

func (s *ShowRowPolicyContext) SetRole(v IIdentifierContext) { s.role = v }

func (s *ShowRowPolicyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowRowPolicyContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSHOW, 0)
}

func (s *ShowRowPolicyContext) ROW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserROW, 0)
}

func (s *ShowRowPolicyContext) POLICY() antlr.TerminalNode {
	return s.GetToken(DorisParserParserPOLICY, 0)
}

func (s *ShowRowPolicyContext) FOR() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFOR, 0)
}

func (s *ShowRowPolicyContext) UserIdentify() IUserIdentifyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserIdentifyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserIdentifyContext)
}

func (s *ShowRowPolicyContext) ROLE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserROLE, 0)
}

func (s *ShowRowPolicyContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowRowPolicyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitShowRowPolicy(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowTabletsBelongContext struct {
	SupportedShowStatementContext
	_INTEGER_VALUE antlr.Token
	tabletIds      []antlr.Token
}

func NewShowTabletsBelongContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowTabletsBelongContext {
	var p = new(ShowTabletsBelongContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowTabletsBelongContext) Get_INTEGER_VALUE() antlr.Token { return s._INTEGER_VALUE }

func (s *ShowTabletsBelongContext) Set_INTEGER_VALUE(v antlr.Token) { s._INTEGER_VALUE = v }

func (s *ShowTabletsBelongContext) GetTabletIds() []antlr.Token { return s.tabletIds }

func (s *ShowTabletsBelongContext) SetTabletIds(v []antlr.Token) { s.tabletIds = v }

func (s *ShowTabletsBelongContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowTabletsBelongContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSHOW, 0)
}

func (s *ShowTabletsBelongContext) TABLETS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserTABLETS, 0)
}

func (s *ShowTabletsBelongContext) BELONG() antlr.TerminalNode {
	return s.GetToken(DorisParserParserBELONG, 0)
}

func (s *ShowTabletsBelongContext) AllINTEGER_VALUE() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserINTEGER_VALUE)
}

func (s *ShowTabletsBelongContext) INTEGER_VALUE(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserINTEGER_VALUE, i)
}

func (s *ShowTabletsBelongContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserCOMMA)
}

func (s *ShowTabletsBelongContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOMMA, i)
}

func (s *ShowTabletsBelongContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitShowTabletsBelong(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowTriggersContext struct {
	SupportedShowStatementContext
	database IMultipartIdentifierContext
}

func NewShowTriggersContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowTriggersContext {
	var p = new(ShowTriggersContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowTriggersContext) GetDatabase() IMultipartIdentifierContext { return s.database }

func (s *ShowTriggersContext) SetDatabase(v IMultipartIdentifierContext) { s.database = v }

func (s *ShowTriggersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowTriggersContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSHOW, 0)
}

func (s *ShowTriggersContext) TRIGGERS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserTRIGGERS, 0)
}

func (s *ShowTriggersContext) FULL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFULL, 0)
}

func (s *ShowTriggersContext) WildWhere() IWildWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWildWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWildWhereContext)
}

func (s *ShowTriggersContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFROM, 0)
}

func (s *ShowTriggersContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserIN, 0)
}

func (s *ShowTriggersContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowTriggersContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitShowTriggers(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowCreateTableContext struct {
	SupportedShowStatementContext
	name IMultipartIdentifierContext
}

func NewShowCreateTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowCreateTableContext {
	var p = new(ShowCreateTableContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowCreateTableContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *ShowCreateTableContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *ShowCreateTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCreateTableContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSHOW, 0)
}

func (s *ShowCreateTableContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCREATE, 0)
}

func (s *ShowCreateTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserTABLE, 0)
}

func (s *ShowCreateTableContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowCreateTableContext) BRIEF() antlr.TerminalNode {
	return s.GetToken(DorisParserParserBRIEF, 0)
}

func (s *ShowCreateTableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitShowCreateTable(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowCatalogContext struct {
	SupportedShowStatementContext
	name IIdentifierContext
}

func NewShowCatalogContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowCatalogContext {
	var p = new(ShowCatalogContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowCatalogContext) GetName() IIdentifierContext { return s.name }

func (s *ShowCatalogContext) SetName(v IIdentifierContext) { s.name = v }

func (s *ShowCatalogContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCatalogContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSHOW, 0)
}

func (s *ShowCatalogContext) CATALOG() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCATALOG, 0)
}

func (s *ShowCatalogContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowCatalogContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitShowCatalog(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowColumnsContext struct {
	SupportedShowStatementContext
	tableName IMultipartIdentifierContext
	database  IMultipartIdentifierContext
}

func NewShowColumnsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowColumnsContext {
	var p = new(ShowColumnsContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowColumnsContext) GetTableName() IMultipartIdentifierContext { return s.tableName }

func (s *ShowColumnsContext) GetDatabase() IMultipartIdentifierContext { return s.database }

func (s *ShowColumnsContext) SetTableName(v IMultipartIdentifierContext) { s.tableName = v }

func (s *ShowColumnsContext) SetDatabase(v IMultipartIdentifierContext) { s.database = v }

func (s *ShowColumnsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowColumnsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSHOW, 0)
}

func (s *ShowColumnsContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOLUMNS, 0)
}

func (s *ShowColumnsContext) FIELDS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFIELDS, 0)
}

func (s *ShowColumnsContext) AllFROM() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserFROM)
}

func (s *ShowColumnsContext) FROM(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserFROM, i)
}

func (s *ShowColumnsContext) AllIN() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserIN)
}

func (s *ShowColumnsContext) IN(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserIN, i)
}

func (s *ShowColumnsContext) AllMultipartIdentifier() []IMultipartIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IMultipartIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMultipartIdentifierContext); ok {
			tst[i] = t.(IMultipartIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *ShowColumnsContext) MultipartIdentifier(i int) IMultipartIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowColumnsContext) FULL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFULL, 0)
}

func (s *ShowColumnsContext) WildWhere() IWildWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWildWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWildWhereContext)
}

func (s *ShowColumnsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitShowColumns(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowBuildIndexContext struct {
	SupportedShowStatementContext
	database IIdentifierContext
}

func NewShowBuildIndexContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowBuildIndexContext {
	var p = new(ShowBuildIndexContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowBuildIndexContext) GetDatabase() IIdentifierContext { return s.database }

func (s *ShowBuildIndexContext) SetDatabase(v IIdentifierContext) { s.database = v }

func (s *ShowBuildIndexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowBuildIndexContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSHOW, 0)
}

func (s *ShowBuildIndexContext) BUILD() antlr.TerminalNode {
	return s.GetToken(DorisParserParserBUILD, 0)
}

func (s *ShowBuildIndexContext) INDEX() antlr.TerminalNode {
	return s.GetToken(DorisParserParserINDEX, 0)
}

func (s *ShowBuildIndexContext) WildWhere() IWildWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWildWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWildWhereContext)
}

func (s *ShowBuildIndexContext) SortClause() ISortClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortClauseContext)
}

func (s *ShowBuildIndexContext) LimitClause() ILimitClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitClauseContext)
}

func (s *ShowBuildIndexContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFROM, 0)
}

func (s *ShowBuildIndexContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserIN, 0)
}

func (s *ShowBuildIndexContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowBuildIndexContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitShowBuildIndex(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowVariablesContext struct {
	SupportedShowStatementContext
}

func NewShowVariablesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowVariablesContext {
	var p = new(ShowVariablesContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowVariablesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowVariablesContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSHOW, 0)
}

func (s *ShowVariablesContext) VARIABLES() antlr.TerminalNode {
	return s.GetToken(DorisParserParserVARIABLES, 0)
}

func (s *ShowVariablesContext) StatementScope() IStatementScopeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementScopeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementScopeContext)
}

func (s *ShowVariablesContext) WildWhere() IWildWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWildWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWildWhereContext)
}

func (s *ShowVariablesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitShowVariables(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowEventsContext struct {
	SupportedShowStatementContext
	database IMultipartIdentifierContext
}

func NewShowEventsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowEventsContext {
	var p = new(ShowEventsContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowEventsContext) GetDatabase() IMultipartIdentifierContext { return s.database }

func (s *ShowEventsContext) SetDatabase(v IMultipartIdentifierContext) { s.database = v }

func (s *ShowEventsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowEventsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSHOW, 0)
}

func (s *ShowEventsContext) EVENTS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserEVENTS, 0)
}

func (s *ShowEventsContext) WildWhere() IWildWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWildWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWildWhereContext)
}

func (s *ShowEventsContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFROM, 0)
}

func (s *ShowEventsContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserIN, 0)
}

func (s *ShowEventsContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowEventsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitShowEvents(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowPluginsContext struct {
	SupportedShowStatementContext
}

func NewShowPluginsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowPluginsContext {
	var p = new(ShowPluginsContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowPluginsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowPluginsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSHOW, 0)
}

func (s *ShowPluginsContext) PLUGINS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserPLUGINS, 0)
}

func (s *ShowPluginsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitShowPlugins(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowAllPropertiesContext struct {
	SupportedShowStatementContext
}

func NewShowAllPropertiesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowAllPropertiesContext {
	var p = new(ShowAllPropertiesContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowAllPropertiesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowAllPropertiesContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSHOW, 0)
}

func (s *ShowAllPropertiesContext) ALL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserALL, 0)
}

func (s *ShowAllPropertiesContext) PROPERTIES() antlr.TerminalNode {
	return s.GetToken(DorisParserParserPROPERTIES, 0)
}

func (s *ShowAllPropertiesContext) LIKE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLIKE, 0)
}

func (s *ShowAllPropertiesContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTRING_LITERAL, 0)
}

func (s *ShowAllPropertiesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitShowAllProperties(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowDataSkewContext struct {
	SupportedShowStatementContext
}

func NewShowDataSkewContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowDataSkewContext {
	var p = new(ShowDataSkewContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowDataSkewContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowDataSkewContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSHOW, 0)
}

func (s *ShowDataSkewContext) DATA() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDATA, 0)
}

func (s *ShowDataSkewContext) SKEW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSKEW, 0)
}

func (s *ShowDataSkewContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFROM, 0)
}

func (s *ShowDataSkewContext) BaseTableRef() IBaseTableRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBaseTableRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBaseTableRefContext)
}

func (s *ShowDataSkewContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitShowDataSkew(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowConvertLscContext struct {
	SupportedShowStatementContext
	database IMultipartIdentifierContext
}

func NewShowConvertLscContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowConvertLscContext {
	var p = new(ShowConvertLscContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowConvertLscContext) GetDatabase() IMultipartIdentifierContext { return s.database }

func (s *ShowConvertLscContext) SetDatabase(v IMultipartIdentifierContext) { s.database = v }

func (s *ShowConvertLscContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowConvertLscContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSHOW, 0)
}

func (s *ShowConvertLscContext) CONVERT_LSC() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCONVERT_LSC, 0)
}

func (s *ShowConvertLscContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFROM, 0)
}

func (s *ShowConvertLscContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserIN, 0)
}

func (s *ShowConvertLscContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowConvertLscContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitShowConvertLsc(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowSqlBlockRuleContext struct {
	SupportedShowStatementContext
	ruleName IIdentifierContext
}

func NewShowSqlBlockRuleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowSqlBlockRuleContext {
	var p = new(ShowSqlBlockRuleContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowSqlBlockRuleContext) GetRuleName() IIdentifierContext { return s.ruleName }

func (s *ShowSqlBlockRuleContext) SetRuleName(v IIdentifierContext) { s.ruleName = v }

func (s *ShowSqlBlockRuleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowSqlBlockRuleContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSHOW, 0)
}

func (s *ShowSqlBlockRuleContext) SQL_BLOCK_RULE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSQL_BLOCK_RULE, 0)
}

func (s *ShowSqlBlockRuleContext) FOR() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFOR, 0)
}

func (s *ShowSqlBlockRuleContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowSqlBlockRuleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitShowSqlBlockRule(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowTableCreationContext struct {
	SupportedShowStatementContext
	database IMultipartIdentifierContext
}

func NewShowTableCreationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowTableCreationContext {
	var p = new(ShowTableCreationContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowTableCreationContext) GetDatabase() IMultipartIdentifierContext { return s.database }

func (s *ShowTableCreationContext) SetDatabase(v IMultipartIdentifierContext) { s.database = v }

func (s *ShowTableCreationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowTableCreationContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSHOW, 0)
}

func (s *ShowTableCreationContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserTABLE, 0)
}

func (s *ShowTableCreationContext) CREATION() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCREATION, 0)
}

func (s *ShowTableCreationContext) LIKE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLIKE, 0)
}

func (s *ShowTableCreationContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTRING_LITERAL, 0)
}

func (s *ShowTableCreationContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFROM, 0)
}

func (s *ShowTableCreationContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserIN, 0)
}

func (s *ShowTableCreationContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowTableCreationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitShowTableCreation(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowWarningErrorCountContext struct {
	SupportedShowStatementContext
}

func NewShowWarningErrorCountContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowWarningErrorCountContext {
	var p = new(ShowWarningErrorCountContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowWarningErrorCountContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowWarningErrorCountContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSHOW, 0)
}

func (s *ShowWarningErrorCountContext) COUNT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOUNT, 0)
}

func (s *ShowWarningErrorCountContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLEFT_PAREN, 0)
}

func (s *ShowWarningErrorCountContext) ASTERISK() antlr.TerminalNode {
	return s.GetToken(DorisParserParserASTERISK, 0)
}

func (s *ShowWarningErrorCountContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRIGHT_PAREN, 0)
}

func (s *ShowWarningErrorCountContext) WARNINGS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserWARNINGS, 0)
}

func (s *ShowWarningErrorCountContext) ERRORS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserERRORS, 0)
}

func (s *ShowWarningErrorCountContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitShowWarningErrorCount(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowReplicaStatusContext struct {
	SupportedShowStatementContext
}

func NewShowReplicaStatusContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowReplicaStatusContext {
	var p = new(ShowReplicaStatusContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowReplicaStatusContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowReplicaStatusContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSHOW, 0)
}

func (s *ShowReplicaStatusContext) REPLICA() antlr.TerminalNode {
	return s.GetToken(DorisParserParserREPLICA, 0)
}

func (s *ShowReplicaStatusContext) STATUS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTATUS, 0)
}

func (s *ShowReplicaStatusContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFROM, 0)
}

func (s *ShowReplicaStatusContext) BaseTableRef() IBaseTableRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBaseTableRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBaseTableRefContext)
}

func (s *ShowReplicaStatusContext) WhereClause() IWhereClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhereClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhereClauseContext)
}

func (s *ShowReplicaStatusContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitShowReplicaStatus(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowDeleteContext struct {
	SupportedShowStatementContext
	database IMultipartIdentifierContext
}

func NewShowDeleteContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowDeleteContext {
	var p = new(ShowDeleteContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowDeleteContext) GetDatabase() IMultipartIdentifierContext { return s.database }

func (s *ShowDeleteContext) SetDatabase(v IMultipartIdentifierContext) { s.database = v }

func (s *ShowDeleteContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowDeleteContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSHOW, 0)
}

func (s *ShowDeleteContext) DELETE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDELETE, 0)
}

func (s *ShowDeleteContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFROM, 0)
}

func (s *ShowDeleteContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserIN, 0)
}

func (s *ShowDeleteContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowDeleteContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitShowDelete(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowTabletsFromTableContext struct {
	SupportedShowStatementContext
	tableName IMultipartIdentifierContext
}

func NewShowTabletsFromTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowTabletsFromTableContext {
	var p = new(ShowTabletsFromTableContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowTabletsFromTableContext) GetTableName() IMultipartIdentifierContext { return s.tableName }

func (s *ShowTabletsFromTableContext) SetTableName(v IMultipartIdentifierContext) { s.tableName = v }

func (s *ShowTabletsFromTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowTabletsFromTableContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSHOW, 0)
}

func (s *ShowTabletsFromTableContext) TABLETS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserTABLETS, 0)
}

func (s *ShowTabletsFromTableContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFROM, 0)
}

func (s *ShowTabletsFromTableContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowTabletsFromTableContext) PartitionSpec() IPartitionSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionSpecContext)
}

func (s *ShowTabletsFromTableContext) WildWhere() IWildWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWildWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWildWhereContext)
}

func (s *ShowTabletsFromTableContext) SortClause() ISortClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortClauseContext)
}

func (s *ShowTabletsFromTableContext) LimitClause() ILimitClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitClauseContext)
}

func (s *ShowTabletsFromTableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitShowTabletsFromTable(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowStagesContext struct {
	SupportedShowStatementContext
}

func NewShowStagesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowStagesContext {
	var p = new(ShowStagesContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowStagesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowStagesContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSHOW, 0)
}

func (s *ShowStagesContext) STAGES() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTAGES, 0)
}

func (s *ShowStagesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitShowStages(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowTransactionContext struct {
	SupportedShowStatementContext
	database IMultipartIdentifierContext
}

func NewShowTransactionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowTransactionContext {
	var p = new(ShowTransactionContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowTransactionContext) GetDatabase() IMultipartIdentifierContext { return s.database }

func (s *ShowTransactionContext) SetDatabase(v IMultipartIdentifierContext) { s.database = v }

func (s *ShowTransactionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowTransactionContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSHOW, 0)
}

func (s *ShowTransactionContext) TRANSACTION() antlr.TerminalNode {
	return s.GetToken(DorisParserParserTRANSACTION, 0)
}

func (s *ShowTransactionContext) WildWhere() IWildWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWildWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWildWhereContext)
}

func (s *ShowTransactionContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFROM, 0)
}

func (s *ShowTransactionContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserIN, 0)
}

func (s *ShowTransactionContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowTransactionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitShowTransaction(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowBrokerContext struct {
	SupportedShowStatementContext
}

func NewShowBrokerContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowBrokerContext {
	var p = new(ShowBrokerContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowBrokerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowBrokerContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSHOW, 0)
}

func (s *ShowBrokerContext) BROKER() antlr.TerminalNode {
	return s.GetToken(DorisParserParserBROKER, 0)
}

func (s *ShowBrokerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitShowBroker(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowGrantsContext struct {
	SupportedShowStatementContext
}

func NewShowGrantsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowGrantsContext {
	var p = new(ShowGrantsContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowGrantsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowGrantsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSHOW, 0)
}

func (s *ShowGrantsContext) GRANTS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserGRANTS, 0)
}

func (s *ShowGrantsContext) ALL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserALL, 0)
}

func (s *ShowGrantsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitShowGrants(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowResourcesContext struct {
	SupportedShowStatementContext
}

func NewShowResourcesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowResourcesContext {
	var p = new(ShowResourcesContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowResourcesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowResourcesContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSHOW, 0)
}

func (s *ShowResourcesContext) RESOURCES() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRESOURCES, 0)
}

func (s *ShowResourcesContext) WildWhere() IWildWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWildWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWildWhereContext)
}

func (s *ShowResourcesContext) SortClause() ISortClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortClauseContext)
}

func (s *ShowResourcesContext) LimitClause() ILimitClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitClauseContext)
}

func (s *ShowResourcesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitShowResources(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowWorkloadGroupsContext struct {
	SupportedShowStatementContext
}

func NewShowWorkloadGroupsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowWorkloadGroupsContext {
	var p = new(ShowWorkloadGroupsContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowWorkloadGroupsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowWorkloadGroupsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSHOW, 0)
}

func (s *ShowWorkloadGroupsContext) WORKLOAD() antlr.TerminalNode {
	return s.GetToken(DorisParserParserWORKLOAD, 0)
}

func (s *ShowWorkloadGroupsContext) GROUPS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserGROUPS, 0)
}

func (s *ShowWorkloadGroupsContext) LIKE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLIKE, 0)
}

func (s *ShowWorkloadGroupsContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTRING_LITERAL, 0)
}

func (s *ShowWorkloadGroupsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitShowWorkloadGroups(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowReplicaDistributionContext struct {
	SupportedShowStatementContext
}

func NewShowReplicaDistributionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowReplicaDistributionContext {
	var p = new(ShowReplicaDistributionContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowReplicaDistributionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowReplicaDistributionContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSHOW, 0)
}

func (s *ShowReplicaDistributionContext) REPLICA() antlr.TerminalNode {
	return s.GetToken(DorisParserParserREPLICA, 0)
}

func (s *ShowReplicaDistributionContext) DISTRIBUTION() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDISTRIBUTION, 0)
}

func (s *ShowReplicaDistributionContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFROM, 0)
}

func (s *ShowReplicaDistributionContext) BaseTableRef() IBaseTableRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBaseTableRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBaseTableRefContext)
}

func (s *ShowReplicaDistributionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitShowReplicaDistribution(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowTabletStorageFormatContext struct {
	SupportedShowStatementContext
}

func NewShowTabletStorageFormatContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowTabletStorageFormatContext {
	var p = new(ShowTabletStorageFormatContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowTabletStorageFormatContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowTabletStorageFormatContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSHOW, 0)
}

func (s *ShowTabletStorageFormatContext) TABLET() antlr.TerminalNode {
	return s.GetToken(DorisParserParserTABLET, 0)
}

func (s *ShowTabletStorageFormatContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTORAGE, 0)
}

func (s *ShowTabletStorageFormatContext) FORMAT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFORMAT, 0)
}

func (s *ShowTabletStorageFormatContext) VERBOSE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserVERBOSE, 0)
}

func (s *ShowTabletStorageFormatContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitShowTabletStorageFormat(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowCharsetContext struct {
	SupportedShowStatementContext
}

func NewShowCharsetContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowCharsetContext {
	var p = new(ShowCharsetContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowCharsetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCharsetContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSHOW, 0)
}

func (s *ShowCharsetContext) CHARSET() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCHARSET, 0)
}

func (s *ShowCharsetContext) CHAR() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCHAR, 0)
}

func (s *ShowCharsetContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSET, 0)
}

func (s *ShowCharsetContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitShowCharset(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowProcContext struct {
	SupportedShowStatementContext
	path antlr.Token
}

func NewShowProcContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowProcContext {
	var p = new(ShowProcContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowProcContext) GetPath() antlr.Token { return s.path }

func (s *ShowProcContext) SetPath(v antlr.Token) { s.path = v }

func (s *ShowProcContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowProcContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSHOW, 0)
}

func (s *ShowProcContext) PROC() antlr.TerminalNode {
	return s.GetToken(DorisParserParserPROC, 0)
}

func (s *ShowProcContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTRING_LITERAL, 0)
}

func (s *ShowProcContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitShowProc(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowCreateViewContext struct {
	SupportedShowStatementContext
	name IMultipartIdentifierContext
}

func NewShowCreateViewContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowCreateViewContext {
	var p = new(ShowCreateViewContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowCreateViewContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *ShowCreateViewContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *ShowCreateViewContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCreateViewContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSHOW, 0)
}

func (s *ShowCreateViewContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCREATE, 0)
}

func (s *ShowCreateViewContext) VIEW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserVIEW, 0)
}

func (s *ShowCreateViewContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowCreateViewContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitShowCreateView(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowOpenTablesContext struct {
	SupportedShowStatementContext
	database IMultipartIdentifierContext
}

func NewShowOpenTablesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowOpenTablesContext {
	var p = new(ShowOpenTablesContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowOpenTablesContext) GetDatabase() IMultipartIdentifierContext { return s.database }

func (s *ShowOpenTablesContext) SetDatabase(v IMultipartIdentifierContext) { s.database = v }

func (s *ShowOpenTablesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowOpenTablesContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSHOW, 0)
}

func (s *ShowOpenTablesContext) OPEN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserOPEN, 0)
}

func (s *ShowOpenTablesContext) TABLES() antlr.TerminalNode {
	return s.GetToken(DorisParserParserTABLES, 0)
}

func (s *ShowOpenTablesContext) WildWhere() IWildWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWildWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWildWhereContext)
}

func (s *ShowOpenTablesContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFROM, 0)
}

func (s *ShowOpenTablesContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserIN, 0)
}

func (s *ShowOpenTablesContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowOpenTablesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitShowOpenTables(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowQueryStatsContext struct {
	SupportedShowStatementContext
	database  IIdentifierContext
	tableName IMultipartIdentifierContext
}

func NewShowQueryStatsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowQueryStatsContext {
	var p = new(ShowQueryStatsContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowQueryStatsContext) GetDatabase() IIdentifierContext { return s.database }

func (s *ShowQueryStatsContext) GetTableName() IMultipartIdentifierContext { return s.tableName }

func (s *ShowQueryStatsContext) SetDatabase(v IIdentifierContext) { s.database = v }

func (s *ShowQueryStatsContext) SetTableName(v IMultipartIdentifierContext) { s.tableName = v }

func (s *ShowQueryStatsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowQueryStatsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSHOW, 0)
}

func (s *ShowQueryStatsContext) QUERY() antlr.TerminalNode {
	return s.GetToken(DorisParserParserQUERY, 0)
}

func (s *ShowQueryStatsContext) STATS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTATS, 0)
}

func (s *ShowQueryStatsContext) FOR() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFOR, 0)
}

func (s *ShowQueryStatsContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFROM, 0)
}

func (s *ShowQueryStatsContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowQueryStatsContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowQueryStatsContext) ALL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserALL, 0)
}

func (s *ShowQueryStatsContext) VERBOSE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserVERBOSE, 0)
}

func (s *ShowQueryStatsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitShowQueryStats(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowCreateDatabaseContext struct {
	SupportedShowStatementContext
	name IMultipartIdentifierContext
}

func NewShowCreateDatabaseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowCreateDatabaseContext {
	var p = new(ShowCreateDatabaseContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowCreateDatabaseContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *ShowCreateDatabaseContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *ShowCreateDatabaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCreateDatabaseContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSHOW, 0)
}

func (s *ShowCreateDatabaseContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCREATE, 0)
}

func (s *ShowCreateDatabaseContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDATABASE, 0)
}

func (s *ShowCreateDatabaseContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSCHEMA, 0)
}

func (s *ShowCreateDatabaseContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowCreateDatabaseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitShowCreateDatabase(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowQueryProfileContext struct {
	SupportedShowStatementContext
	queryIdPath antlr.Token
}

func NewShowQueryProfileContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowQueryProfileContext {
	var p = new(ShowQueryProfileContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowQueryProfileContext) GetQueryIdPath() antlr.Token { return s.queryIdPath }

func (s *ShowQueryProfileContext) SetQueryIdPath(v antlr.Token) { s.queryIdPath = v }

func (s *ShowQueryProfileContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowQueryProfileContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSHOW, 0)
}

func (s *ShowQueryProfileContext) QUERY() antlr.TerminalNode {
	return s.GetToken(DorisParserParserQUERY, 0)
}

func (s *ShowQueryProfileContext) PROFILE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserPROFILE, 0)
}

func (s *ShowQueryProfileContext) LimitClause() ILimitClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitClauseContext)
}

func (s *ShowQueryProfileContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTRING_LITERAL, 0)
}

func (s *ShowQueryProfileContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitShowQueryProfile(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowDictionariesContext struct {
	SupportedShowStatementContext
}

func NewShowDictionariesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowDictionariesContext {
	var p = new(ShowDictionariesContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowDictionariesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowDictionariesContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSHOW, 0)
}

func (s *ShowDictionariesContext) DICTIONARIES() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDICTIONARIES, 0)
}

func (s *ShowDictionariesContext) WildWhere() IWildWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWildWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWildWhereContext)
}

func (s *ShowDictionariesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitShowDictionaries(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowStoragePolicyContext struct {
	SupportedShowStatementContext
	policy IIdentifierOrTextContext
}

func NewShowStoragePolicyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowStoragePolicyContext {
	var p = new(ShowStoragePolicyContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowStoragePolicyContext) GetPolicy() IIdentifierOrTextContext { return s.policy }

func (s *ShowStoragePolicyContext) SetPolicy(v IIdentifierOrTextContext) { s.policy = v }

func (s *ShowStoragePolicyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowStoragePolicyContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSHOW, 0)
}

func (s *ShowStoragePolicyContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTORAGE, 0)
}

func (s *ShowStoragePolicyContext) POLICY() antlr.TerminalNode {
	return s.GetToken(DorisParserParserPOLICY, 0)
}

func (s *ShowStoragePolicyContext) USING() antlr.TerminalNode {
	return s.GetToken(DorisParserParserUSING, 0)
}

func (s *ShowStoragePolicyContext) FOR() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFOR, 0)
}

func (s *ShowStoragePolicyContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *ShowStoragePolicyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitShowStoragePolicy(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowEncryptKeysContext struct {
	SupportedShowStatementContext
	database IMultipartIdentifierContext
}

func NewShowEncryptKeysContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowEncryptKeysContext {
	var p = new(ShowEncryptKeysContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowEncryptKeysContext) GetDatabase() IMultipartIdentifierContext { return s.database }

func (s *ShowEncryptKeysContext) SetDatabase(v IMultipartIdentifierContext) { s.database = v }

func (s *ShowEncryptKeysContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowEncryptKeysContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSHOW, 0)
}

func (s *ShowEncryptKeysContext) ENCRYPTKEYS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserENCRYPTKEYS, 0)
}

func (s *ShowEncryptKeysContext) LIKE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLIKE, 0)
}

func (s *ShowEncryptKeysContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTRING_LITERAL, 0)
}

func (s *ShowEncryptKeysContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFROM, 0)
}

func (s *ShowEncryptKeysContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserIN, 0)
}

func (s *ShowEncryptKeysContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowEncryptKeysContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitShowEncryptKeys(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowLoadContext struct {
	SupportedShowStatementContext
	database IIdentifierContext
}

func NewShowLoadContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowLoadContext {
	var p = new(ShowLoadContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowLoadContext) GetDatabase() IIdentifierContext { return s.database }

func (s *ShowLoadContext) SetDatabase(v IIdentifierContext) { s.database = v }

func (s *ShowLoadContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowLoadContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSHOW, 0)
}

func (s *ShowLoadContext) LOAD() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLOAD, 0)
}

func (s *ShowLoadContext) STREAM() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTREAM, 0)
}

func (s *ShowLoadContext) WildWhere() IWildWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWildWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWildWhereContext)
}

func (s *ShowLoadContext) SortClause() ISortClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortClauseContext)
}

func (s *ShowLoadContext) LimitClause() ILimitClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitClauseContext)
}

func (s *ShowLoadContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFROM, 0)
}

func (s *ShowLoadContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserIN, 0)
}

func (s *ShowLoadContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowLoadContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitShowLoad(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowClustersContext struct {
	SupportedShowStatementContext
}

func NewShowClustersContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowClustersContext {
	var p = new(ShowClustersContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowClustersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowClustersContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSHOW, 0)
}

func (s *ShowClustersContext) CLUSTERS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCLUSTERS, 0)
}

func (s *ShowClustersContext) COMPUTE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOMPUTE, 0)
}

func (s *ShowClustersContext) GROUPS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserGROUPS, 0)
}

func (s *ShowClustersContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitShowClusters(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowTrashContext struct {
	SupportedShowStatementContext
	backend antlr.Token
}

func NewShowTrashContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowTrashContext {
	var p = new(ShowTrashContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowTrashContext) GetBackend() antlr.Token { return s.backend }

func (s *ShowTrashContext) SetBackend(v antlr.Token) { s.backend = v }

func (s *ShowTrashContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowTrashContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSHOW, 0)
}

func (s *ShowTrashContext) TRASH() antlr.TerminalNode {
	return s.GetToken(DorisParserParserTRASH, 0)
}

func (s *ShowTrashContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisParserParserON, 0)
}

func (s *ShowTrashContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTRING_LITERAL, 0)
}

func (s *ShowTrashContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitShowTrash(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowPartitionsContext struct {
	SupportedShowStatementContext
	tableName IMultipartIdentifierContext
}

func NewShowPartitionsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowPartitionsContext {
	var p = new(ShowPartitionsContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowPartitionsContext) GetTableName() IMultipartIdentifierContext { return s.tableName }

func (s *ShowPartitionsContext) SetTableName(v IMultipartIdentifierContext) { s.tableName = v }

func (s *ShowPartitionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowPartitionsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSHOW, 0)
}

func (s *ShowPartitionsContext) PARTITIONS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserPARTITIONS, 0)
}

func (s *ShowPartitionsContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFROM, 0)
}

func (s *ShowPartitionsContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowPartitionsContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(DorisParserParserTEMPORARY, 0)
}

func (s *ShowPartitionsContext) WildWhere() IWildWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWildWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWildWhereContext)
}

func (s *ShowPartitionsContext) SortClause() ISortClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortClauseContext)
}

func (s *ShowPartitionsContext) LimitClause() ILimitClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitClauseContext)
}

func (s *ShowPartitionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitShowPartitions(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowGlobalFunctionsContext struct {
	SupportedShowStatementContext
}

func NewShowGlobalFunctionsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowGlobalFunctionsContext {
	var p = new(ShowGlobalFunctionsContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowGlobalFunctionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowGlobalFunctionsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSHOW, 0)
}

func (s *ShowGlobalFunctionsContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserGLOBAL, 0)
}

func (s *ShowGlobalFunctionsContext) FUNCTIONS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFUNCTIONS, 0)
}

func (s *ShowGlobalFunctionsContext) FULL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFULL, 0)
}

func (s *ShowGlobalFunctionsContext) LIKE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLIKE, 0)
}

func (s *ShowGlobalFunctionsContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTRING_LITERAL, 0)
}

func (s *ShowGlobalFunctionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitShowGlobalFunctions(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowFrontendsContext struct {
	SupportedShowStatementContext
	name IIdentifierContext
}

func NewShowFrontendsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowFrontendsContext {
	var p = new(ShowFrontendsContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowFrontendsContext) GetName() IIdentifierContext { return s.name }

func (s *ShowFrontendsContext) SetName(v IIdentifierContext) { s.name = v }

func (s *ShowFrontendsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowFrontendsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSHOW, 0)
}

func (s *ShowFrontendsContext) FRONTENDS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFRONTENDS, 0)
}

func (s *ShowFrontendsContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowFrontendsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitShowFrontends(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowLoadProfileContext struct {
	SupportedShowStatementContext
	loadIdPath antlr.Token
}

func NewShowLoadProfileContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowLoadProfileContext {
	var p = new(ShowLoadProfileContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowLoadProfileContext) GetLoadIdPath() antlr.Token { return s.loadIdPath }

func (s *ShowLoadProfileContext) SetLoadIdPath(v antlr.Token) { s.loadIdPath = v }

func (s *ShowLoadProfileContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowLoadProfileContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSHOW, 0)
}

func (s *ShowLoadProfileContext) LOAD() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLOAD, 0)
}

func (s *ShowLoadProfileContext) PROFILE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserPROFILE, 0)
}

func (s *ShowLoadProfileContext) LimitClause() ILimitClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitClauseContext)
}

func (s *ShowLoadProfileContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTRING_LITERAL, 0)
}

func (s *ShowLoadProfileContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitShowLoadProfile(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowPartitionIdContext struct {
	SupportedShowStatementContext
	partitionId antlr.Token
}

func NewShowPartitionIdContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowPartitionIdContext {
	var p = new(ShowPartitionIdContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowPartitionIdContext) GetPartitionId() antlr.Token { return s.partitionId }

func (s *ShowPartitionIdContext) SetPartitionId(v antlr.Token) { s.partitionId = v }

func (s *ShowPartitionIdContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowPartitionIdContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSHOW, 0)
}

func (s *ShowPartitionIdContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(DorisParserParserPARTITION, 0)
}

func (s *ShowPartitionIdContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserINTEGER_VALUE, 0)
}

func (s *ShowPartitionIdContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitShowPartitionId(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowSnapshotContext struct {
	SupportedShowStatementContext
	repo IIdentifierContext
}

func NewShowSnapshotContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowSnapshotContext {
	var p = new(ShowSnapshotContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowSnapshotContext) GetRepo() IIdentifierContext { return s.repo }

func (s *ShowSnapshotContext) SetRepo(v IIdentifierContext) { s.repo = v }

func (s *ShowSnapshotContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowSnapshotContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSHOW, 0)
}

func (s *ShowSnapshotContext) SNAPSHOT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSNAPSHOT, 0)
}

func (s *ShowSnapshotContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisParserParserON, 0)
}

func (s *ShowSnapshotContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowSnapshotContext) WildWhere() IWildWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWildWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWildWhereContext)
}

func (s *ShowSnapshotContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitShowSnapshot(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowCatalogRecycleBinContext struct {
	SupportedShowStatementContext
}

func NewShowCatalogRecycleBinContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowCatalogRecycleBinContext {
	var p = new(ShowCatalogRecycleBinContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowCatalogRecycleBinContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCatalogRecycleBinContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSHOW, 0)
}

func (s *ShowCatalogRecycleBinContext) CATALOG() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCATALOG, 0)
}

func (s *ShowCatalogRecycleBinContext) RECYCLE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRECYCLE, 0)
}

func (s *ShowCatalogRecycleBinContext) BIN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserBIN, 0)
}

func (s *ShowCatalogRecycleBinContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserWHERE, 0)
}

func (s *ShowCatalogRecycleBinContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowCatalogRecycleBinContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitShowCatalogRecycleBin(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowCopyContext struct {
	SupportedShowStatementContext
	database IIdentifierContext
}

func NewShowCopyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowCopyContext {
	var p = new(ShowCopyContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowCopyContext) GetDatabase() IIdentifierContext { return s.database }

func (s *ShowCopyContext) SetDatabase(v IIdentifierContext) { s.database = v }

func (s *ShowCopyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCopyContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSHOW, 0)
}

func (s *ShowCopyContext) COPY() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOPY, 0)
}

func (s *ShowCopyContext) WhereClause() IWhereClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhereClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhereClauseContext)
}

func (s *ShowCopyContext) SortClause() ISortClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortClauseContext)
}

func (s *ShowCopyContext) LimitClause() ILimitClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitClauseContext)
}

func (s *ShowCopyContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFROM, 0)
}

func (s *ShowCopyContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserIN, 0)
}

func (s *ShowCopyContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowCopyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitShowCopy(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowCollationContext struct {
	SupportedShowStatementContext
}

func NewShowCollationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowCollationContext {
	var p = new(ShowCollationContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowCollationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCollationContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSHOW, 0)
}

func (s *ShowCollationContext) COLLATION() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOLLATION, 0)
}

func (s *ShowCollationContext) WildWhere() IWildWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWildWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWildWhereContext)
}

func (s *ShowCollationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitShowCollation(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowBackendsContext struct {
	SupportedShowStatementContext
}

func NewShowBackendsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowBackendsContext {
	var p = new(ShowBackendsContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowBackendsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowBackendsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSHOW, 0)
}

func (s *ShowBackendsContext) BACKENDS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserBACKENDS, 0)
}

func (s *ShowBackendsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitShowBackends(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowTypeCastContext struct {
	SupportedShowStatementContext
	database IIdentifierContext
}

func NewShowTypeCastContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowTypeCastContext {
	var p = new(ShowTypeCastContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowTypeCastContext) GetDatabase() IIdentifierContext { return s.database }

func (s *ShowTypeCastContext) SetDatabase(v IIdentifierContext) { s.database = v }

func (s *ShowTypeCastContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowTypeCastContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSHOW, 0)
}

func (s *ShowTypeCastContext) TYPECAST() antlr.TerminalNode {
	return s.GetToken(DorisParserParserTYPECAST, 0)
}

func (s *ShowTypeCastContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFROM, 0)
}

func (s *ShowTypeCastContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserIN, 0)
}

func (s *ShowTypeCastContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowTypeCastContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitShowTypeCast(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowPrivilegesContext struct {
	SupportedShowStatementContext
}

func NewShowPrivilegesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowPrivilegesContext {
	var p = new(ShowPrivilegesContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowPrivilegesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowPrivilegesContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSHOW, 0)
}

func (s *ShowPrivilegesContext) PRIVILEGES() antlr.TerminalNode {
	return s.GetToken(DorisParserParserPRIVILEGES, 0)
}

func (s *ShowPrivilegesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitShowPrivileges(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowRestoreContext struct {
	SupportedShowStatementContext
	database IIdentifierContext
}

func NewShowRestoreContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowRestoreContext {
	var p = new(ShowRestoreContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowRestoreContext) GetDatabase() IIdentifierContext { return s.database }

func (s *ShowRestoreContext) SetDatabase(v IIdentifierContext) { s.database = v }

func (s *ShowRestoreContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowRestoreContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSHOW, 0)
}

func (s *ShowRestoreContext) RESTORE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRESTORE, 0)
}

func (s *ShowRestoreContext) BRIEF() antlr.TerminalNode {
	return s.GetToken(DorisParserParserBRIEF, 0)
}

func (s *ShowRestoreContext) WildWhere() IWildWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWildWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWildWhereContext)
}

func (s *ShowRestoreContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFROM, 0)
}

func (s *ShowRestoreContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserIN, 0)
}

func (s *ShowRestoreContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowRestoreContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitShowRestore(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowLoadWaringsContext struct {
	SupportedShowStatementContext
	database IIdentifierContext
	url      antlr.Token
}

func NewShowLoadWaringsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowLoadWaringsContext {
	var p = new(ShowLoadWaringsContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowLoadWaringsContext) GetUrl() antlr.Token { return s.url }

func (s *ShowLoadWaringsContext) SetUrl(v antlr.Token) { s.url = v }

func (s *ShowLoadWaringsContext) GetDatabase() IIdentifierContext { return s.database }

func (s *ShowLoadWaringsContext) SetDatabase(v IIdentifierContext) { s.database = v }

func (s *ShowLoadWaringsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowLoadWaringsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSHOW, 0)
}

func (s *ShowLoadWaringsContext) LOAD() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLOAD, 0)
}

func (s *ShowLoadWaringsContext) WARNINGS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserWARNINGS, 0)
}

func (s *ShowLoadWaringsContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisParserParserON, 0)
}

func (s *ShowLoadWaringsContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTRING_LITERAL, 0)
}

func (s *ShowLoadWaringsContext) WildWhere() IWildWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWildWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWildWhereContext)
}

func (s *ShowLoadWaringsContext) LimitClause() ILimitClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitClauseContext)
}

func (s *ShowLoadWaringsContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFROM, 0)
}

func (s *ShowLoadWaringsContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserIN, 0)
}

func (s *ShowLoadWaringsContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowLoadWaringsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitShowLoadWarings(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowAlterTableContext struct {
	SupportedShowStatementContext
	database IMultipartIdentifierContext
}

func NewShowAlterTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowAlterTableContext {
	var p = new(ShowAlterTableContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowAlterTableContext) GetDatabase() IMultipartIdentifierContext { return s.database }

func (s *ShowAlterTableContext) SetDatabase(v IMultipartIdentifierContext) { s.database = v }

func (s *ShowAlterTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowAlterTableContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSHOW, 0)
}

func (s *ShowAlterTableContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserParserALTER, 0)
}

func (s *ShowAlterTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserTABLE, 0)
}

func (s *ShowAlterTableContext) ROLLUP() antlr.TerminalNode {
	return s.GetToken(DorisParserParserROLLUP, 0)
}

func (s *ShowAlterTableContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOLUMN, 0)
}

func (s *ShowAlterTableContext) WildWhere() IWildWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWildWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWildWhereContext)
}

func (s *ShowAlterTableContext) SortClause() ISortClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortClauseContext)
}

func (s *ShowAlterTableContext) LimitClause() ILimitClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitClauseContext)
}

func (s *ShowAlterTableContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(DorisParserParserMATERIALIZED, 0)
}

func (s *ShowAlterTableContext) VIEW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserVIEW, 0)
}

func (s *ShowAlterTableContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFROM, 0)
}

func (s *ShowAlterTableContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserIN, 0)
}

func (s *ShowAlterTableContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowAlterTableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitShowAlterTable(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowTableIdContext struct {
	SupportedShowStatementContext
	tableId antlr.Token
}

func NewShowTableIdContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowTableIdContext {
	var p = new(ShowTableIdContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowTableIdContext) GetTableId() antlr.Token { return s.tableId }

func (s *ShowTableIdContext) SetTableId(v antlr.Token) { s.tableId = v }

func (s *ShowTableIdContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowTableIdContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSHOW, 0)
}

func (s *ShowTableIdContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserTABLE, 0)
}

func (s *ShowTableIdContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserINTEGER_VALUE, 0)
}

func (s *ShowTableIdContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitShowTableId(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowSmallFilesContext struct {
	SupportedShowStatementContext
	database IMultipartIdentifierContext
}

func NewShowSmallFilesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowSmallFilesContext {
	var p = new(ShowSmallFilesContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowSmallFilesContext) GetDatabase() IMultipartIdentifierContext { return s.database }

func (s *ShowSmallFilesContext) SetDatabase(v IMultipartIdentifierContext) { s.database = v }

func (s *ShowSmallFilesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowSmallFilesContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSHOW, 0)
}

func (s *ShowSmallFilesContext) FILE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFILE, 0)
}

func (s *ShowSmallFilesContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFROM, 0)
}

func (s *ShowSmallFilesContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserIN, 0)
}

func (s *ShowSmallFilesContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowSmallFilesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitShowSmallFiles(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowDatabasesContext struct {
	SupportedShowStatementContext
	catalog IIdentifierContext
}

func NewShowDatabasesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowDatabasesContext {
	var p = new(ShowDatabasesContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowDatabasesContext) GetCatalog() IIdentifierContext { return s.catalog }

func (s *ShowDatabasesContext) SetCatalog(v IIdentifierContext) { s.catalog = v }

func (s *ShowDatabasesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowDatabasesContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSHOW, 0)
}

func (s *ShowDatabasesContext) DATABASES() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDATABASES, 0)
}

func (s *ShowDatabasesContext) SCHEMAS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSCHEMAS, 0)
}

func (s *ShowDatabasesContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFROM, 0)
}

func (s *ShowDatabasesContext) WildWhere() IWildWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWildWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWildWhereContext)
}

func (s *ShowDatabasesContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowDatabasesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitShowDatabases(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowCreateUserContext struct {
	SupportedShowStatementContext
}

func NewShowCreateUserContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowCreateUserContext {
	var p = new(ShowCreateUserContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowCreateUserContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCreateUserContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSHOW, 0)
}

func (s *ShowCreateUserContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCREATE, 0)
}

func (s *ShowCreateUserContext) USER() antlr.TerminalNode {
	return s.GetToken(DorisParserParserUSER, 0)
}

func (s *ShowCreateUserContext) UserIdentify() IUserIdentifyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserIdentifyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserIdentifyContext)
}

func (s *ShowCreateUserContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitShowCreateUser(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowTabletIdContext struct {
	SupportedShowStatementContext
	tabletId antlr.Token
}

func NewShowTabletIdContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowTabletIdContext {
	var p = new(ShowTabletIdContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowTabletIdContext) GetTabletId() antlr.Token { return s.tabletId }

func (s *ShowTabletIdContext) SetTabletId(v antlr.Token) { s.tabletId = v }

func (s *ShowTabletIdContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowTabletIdContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSHOW, 0)
}

func (s *ShowTabletIdContext) TABLET() antlr.TerminalNode {
	return s.GetToken(DorisParserParserTABLET, 0)
}

func (s *ShowTabletIdContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserINTEGER_VALUE, 0)
}

func (s *ShowTabletIdContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitShowTabletId(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowStorageVaultContext struct {
	SupportedShowStatementContext
}

func NewShowStorageVaultContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowStorageVaultContext {
	var p = new(ShowStorageVaultContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowStorageVaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowStorageVaultContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSHOW, 0)
}

func (s *ShowStorageVaultContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTORAGE, 0)
}

func (s *ShowStorageVaultContext) VAULT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserVAULT, 0)
}

func (s *ShowStorageVaultContext) VAULTS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserVAULTS, 0)
}

func (s *ShowStorageVaultContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitShowStorageVault(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowStatusContext struct {
	SupportedShowStatementContext
}

func NewShowStatusContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowStatusContext {
	var p = new(ShowStatusContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowStatusContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowStatusContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSHOW, 0)
}

func (s *ShowStatusContext) STATUS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTATUS, 0)
}

func (s *ShowStatusContext) StatementScope() IStatementScopeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementScopeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementScopeContext)
}

func (s *ShowStatusContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitShowStatus(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowUserPropertiesContext struct {
	SupportedShowStatementContext
	user IIdentifierOrTextContext
}

func NewShowUserPropertiesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowUserPropertiesContext {
	var p = new(ShowUserPropertiesContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowUserPropertiesContext) GetUser() IIdentifierOrTextContext { return s.user }

func (s *ShowUserPropertiesContext) SetUser(v IIdentifierOrTextContext) { s.user = v }

func (s *ShowUserPropertiesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowUserPropertiesContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSHOW, 0)
}

func (s *ShowUserPropertiesContext) PROPERTY() antlr.TerminalNode {
	return s.GetToken(DorisParserParserPROPERTY, 0)
}

func (s *ShowUserPropertiesContext) FOR() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFOR, 0)
}

func (s *ShowUserPropertiesContext) LIKE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLIKE, 0)
}

func (s *ShowUserPropertiesContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTRING_LITERAL, 0)
}

func (s *ShowUserPropertiesContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *ShowUserPropertiesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitShowUserProperties(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowWarmUpJobContext struct {
	SupportedShowStatementContext
}

func NewShowWarmUpJobContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowWarmUpJobContext {
	var p = new(ShowWarmUpJobContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowWarmUpJobContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowWarmUpJobContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSHOW, 0)
}

func (s *ShowWarmUpJobContext) WARM() antlr.TerminalNode {
	return s.GetToken(DorisParserParserWARM, 0)
}

func (s *ShowWarmUpJobContext) UP() antlr.TerminalNode {
	return s.GetToken(DorisParserParserUP, 0)
}

func (s *ShowWarmUpJobContext) JOB() antlr.TerminalNode {
	return s.GetToken(DorisParserParserJOB, 0)
}

func (s *ShowWarmUpJobContext) WildWhere() IWildWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWildWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWildWhereContext)
}

func (s *ShowWarmUpJobContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitShowWarmUpJob(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowLastInsertContext struct {
	SupportedShowStatementContext
}

func NewShowLastInsertContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowLastInsertContext {
	var p = new(ShowLastInsertContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowLastInsertContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowLastInsertContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSHOW, 0)
}

func (s *ShowLastInsertContext) LAST() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLAST, 0)
}

func (s *ShowLastInsertContext) INSERT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserINSERT, 0)
}

func (s *ShowLastInsertContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitShowLastInsert(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowCreateCatalogContext struct {
	SupportedShowStatementContext
	name IIdentifierContext
}

func NewShowCreateCatalogContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowCreateCatalogContext {
	var p = new(ShowCreateCatalogContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowCreateCatalogContext) GetName() IIdentifierContext { return s.name }

func (s *ShowCreateCatalogContext) SetName(v IIdentifierContext) { s.name = v }

func (s *ShowCreateCatalogContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCreateCatalogContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSHOW, 0)
}

func (s *ShowCreateCatalogContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCREATE, 0)
}

func (s *ShowCreateCatalogContext) CATALOG() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCATALOG, 0)
}

func (s *ShowCreateCatalogContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowCreateCatalogContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitShowCreateCatalog(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowCreateMaterializedViewContext struct {
	SupportedShowStatementContext
	mvName    IIdentifierContext
	tableName IMultipartIdentifierContext
}

func NewShowCreateMaterializedViewContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowCreateMaterializedViewContext {
	var p = new(ShowCreateMaterializedViewContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowCreateMaterializedViewContext) GetMvName() IIdentifierContext { return s.mvName }

func (s *ShowCreateMaterializedViewContext) GetTableName() IMultipartIdentifierContext {
	return s.tableName
}

func (s *ShowCreateMaterializedViewContext) SetMvName(v IIdentifierContext) { s.mvName = v }

func (s *ShowCreateMaterializedViewContext) SetTableName(v IMultipartIdentifierContext) {
	s.tableName = v
}

func (s *ShowCreateMaterializedViewContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCreateMaterializedViewContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSHOW, 0)
}

func (s *ShowCreateMaterializedViewContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCREATE, 0)
}

func (s *ShowCreateMaterializedViewContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(DorisParserParserMATERIALIZED, 0)
}

func (s *ShowCreateMaterializedViewContext) VIEW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserVIEW, 0)
}

func (s *ShowCreateMaterializedViewContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisParserParserON, 0)
}

func (s *ShowCreateMaterializedViewContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowCreateMaterializedViewContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowCreateMaterializedViewContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitShowCreateMaterializedView(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowProcessListContext struct {
	SupportedShowStatementContext
}

func NewShowProcessListContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowProcessListContext {
	var p = new(ShowProcessListContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowProcessListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowProcessListContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSHOW, 0)
}

func (s *ShowProcessListContext) PROCESSLIST() antlr.TerminalNode {
	return s.GetToken(DorisParserParserPROCESSLIST, 0)
}

func (s *ShowProcessListContext) FULL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFULL, 0)
}

func (s *ShowProcessListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitShowProcessList(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowDataTypesContext struct {
	SupportedShowStatementContext
}

func NewShowDataTypesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowDataTypesContext {
	var p = new(ShowDataTypesContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowDataTypesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowDataTypesContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSHOW, 0)
}

func (s *ShowDataTypesContext) DATA() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDATA, 0)
}

func (s *ShowDataTypesContext) TYPES() antlr.TerminalNode {
	return s.GetToken(DorisParserParserTYPES, 0)
}

func (s *ShowDataTypesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitShowDataTypes(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowDiagnoseTabletContext struct {
	SupportedShowStatementContext
	tabletId antlr.Token
}

func NewShowDiagnoseTabletContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowDiagnoseTabletContext {
	var p = new(ShowDiagnoseTabletContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowDiagnoseTabletContext) GetTabletId() antlr.Token { return s.tabletId }

func (s *ShowDiagnoseTabletContext) SetTabletId(v antlr.Token) { s.tabletId = v }

func (s *ShowDiagnoseTabletContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowDiagnoseTabletContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSHOW, 0)
}

func (s *ShowDiagnoseTabletContext) TABLET() antlr.TerminalNode {
	return s.GetToken(DorisParserParserTABLET, 0)
}

func (s *ShowDiagnoseTabletContext) DIAGNOSIS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDIAGNOSIS, 0)
}

func (s *ShowDiagnoseTabletContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserINTEGER_VALUE, 0)
}

func (s *ShowDiagnoseTabletContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitShowDiagnoseTablet(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowWhitelistContext struct {
	SupportedShowStatementContext
}

func NewShowWhitelistContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowWhitelistContext {
	var p = new(ShowWhitelistContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowWhitelistContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowWhitelistContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSHOW, 0)
}

func (s *ShowWhitelistContext) WHITELIST() antlr.TerminalNode {
	return s.GetToken(DorisParserParserWHITELIST, 0)
}

func (s *ShowWhitelistContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitShowWhitelist(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowViewsContext struct {
	SupportedShowStatementContext
	database IMultipartIdentifierContext
}

func NewShowViewsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowViewsContext {
	var p = new(ShowViewsContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowViewsContext) GetDatabase() IMultipartIdentifierContext { return s.database }

func (s *ShowViewsContext) SetDatabase(v IMultipartIdentifierContext) { s.database = v }

func (s *ShowViewsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowViewsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSHOW, 0)
}

func (s *ShowViewsContext) VIEWS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserVIEWS, 0)
}

func (s *ShowViewsContext) FULL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFULL, 0)
}

func (s *ShowViewsContext) WildWhere() IWildWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWildWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWildWhereContext)
}

func (s *ShowViewsContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFROM, 0)
}

func (s *ShowViewsContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserIN, 0)
}

func (s *ShowViewsContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowViewsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitShowViews(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowFunctionsContext struct {
	SupportedShowStatementContext
	database IMultipartIdentifierContext
}

func NewShowFunctionsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowFunctionsContext {
	var p = new(ShowFunctionsContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowFunctionsContext) GetDatabase() IMultipartIdentifierContext { return s.database }

func (s *ShowFunctionsContext) SetDatabase(v IMultipartIdentifierContext) { s.database = v }

func (s *ShowFunctionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowFunctionsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSHOW, 0)
}

func (s *ShowFunctionsContext) FUNCTIONS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFUNCTIONS, 0)
}

func (s *ShowFunctionsContext) FULL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFULL, 0)
}

func (s *ShowFunctionsContext) BUILTIN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserBUILTIN, 0)
}

func (s *ShowFunctionsContext) LIKE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLIKE, 0)
}

func (s *ShowFunctionsContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTRING_LITERAL, 0)
}

func (s *ShowFunctionsContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFROM, 0)
}

func (s *ShowFunctionsContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserIN, 0)
}

func (s *ShowFunctionsContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowFunctionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitShowFunctions(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowDatabaseIdContext struct {
	SupportedShowStatementContext
	databaseId antlr.Token
}

func NewShowDatabaseIdContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowDatabaseIdContext {
	var p = new(ShowDatabaseIdContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowDatabaseIdContext) GetDatabaseId() antlr.Token { return s.databaseId }

func (s *ShowDatabaseIdContext) SetDatabaseId(v antlr.Token) { s.databaseId = v }

func (s *ShowDatabaseIdContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowDatabaseIdContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSHOW, 0)
}

func (s *ShowDatabaseIdContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDATABASE, 0)
}

func (s *ShowDatabaseIdContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserINTEGER_VALUE, 0)
}

func (s *ShowDatabaseIdContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitShowDatabaseId(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowCreateRepositoryContext struct {
	SupportedShowStatementContext
}

func NewShowCreateRepositoryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowCreateRepositoryContext {
	var p = new(ShowCreateRepositoryContext)

	InitEmptySupportedShowStatementContext(&p.SupportedShowStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedShowStatementContext))

	return p
}

func (s *ShowCreateRepositoryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCreateRepositoryContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSHOW, 0)
}

func (s *ShowCreateRepositoryContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCREATE, 0)
}

func (s *ShowCreateRepositoryContext) REPOSITORY() antlr.TerminalNode {
	return s.GetToken(DorisParserParserREPOSITORY, 0)
}

func (s *ShowCreateRepositoryContext) FOR() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFOR, 0)
}

func (s *ShowCreateRepositoryContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowCreateRepositoryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitShowCreateRepository(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) SupportedShowStatement() (localctx ISupportedShowStatementContext) {
	localctx = NewSupportedShowStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, DorisParserParserRULE_supportedShowStatement)
	var _la int

	p.SetState(2614)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 345, p.GetParserRuleContext()) {
	case 1:
		localctx = NewShowVariablesContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1916)
			p.Match(DorisParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1918)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserGLOBAL || _la == DorisParserParserLOCAL || _la == DorisParserParserSESSION {
			{
				p.SetState(1917)
				p.StatementScope()
			}

		}
		{
			p.SetState(1920)
			p.Match(DorisParserParserVARIABLES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1922)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserLIKE || _la == DorisParserParserWHERE {
			{
				p.SetState(1921)
				p.WildWhere()
			}

		}

	case 2:
		localctx = NewShowAuthorsContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1924)
			p.Match(DorisParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1925)
			p.Match(DorisParserParserAUTHORS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		localctx = NewShowAlterTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1926)
			p.Match(DorisParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1927)
			p.Match(DorisParserParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1928)
			p.Match(DorisParserParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1933)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserParserROLLUP:
			{
				p.SetState(1929)
				p.Match(DorisParserParserROLLUP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserParserMATERIALIZED:
			{
				p.SetState(1930)
				p.Match(DorisParserParserMATERIALIZED)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1931)
				p.Match(DorisParserParserVIEW)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserParserCOLUMN:
			{
				p.SetState(1932)
				p.Match(DorisParserParserCOLUMN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		p.SetState(1937)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserFROM || _la == DorisParserParserIN {
			{
				p.SetState(1935)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserParserFROM || _la == DorisParserParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(1936)

				var _x = p.MultipartIdentifier()

				localctx.(*ShowAlterTableContext).database = _x
			}

		}
		p.SetState(1940)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserLIKE || _la == DorisParserParserWHERE {
			{
				p.SetState(1939)
				p.WildWhere()
			}

		}
		p.SetState(1943)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserORDER {
			{
				p.SetState(1942)
				p.SortClause()
			}

		}
		p.SetState(1946)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserLIMIT {
			{
				p.SetState(1945)
				p.LimitClause()
			}

		}

	case 4:
		localctx = NewShowCreateDatabaseContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1948)
			p.Match(DorisParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1949)
			p.Match(DorisParserParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1950)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserParserDATABASE || _la == DorisParserParserSCHEMA) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1951)

			var _x = p.MultipartIdentifier()

			localctx.(*ShowCreateDatabaseContext).name = _x
		}

	case 5:
		localctx = NewShowBackupContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1952)
			p.Match(DorisParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1953)
			p.Match(DorisParserParserBACKUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1956)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserFROM || _la == DorisParserParserIN {
			{
				p.SetState(1954)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserParserFROM || _la == DorisParserParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(1955)

				var _x = p.Identifier()

				localctx.(*ShowBackupContext).database = _x
			}

		}
		p.SetState(1959)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserLIKE || _la == DorisParserParserWHERE {
			{
				p.SetState(1958)
				p.WildWhere()
			}

		}

	case 6:
		localctx = NewShowBrokerContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1961)
			p.Match(DorisParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1962)
			p.Match(DorisParserParserBROKER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		localctx = NewShowBuildIndexContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1963)
			p.Match(DorisParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1964)
			p.Match(DorisParserParserBUILD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1965)
			p.Match(DorisParserParserINDEX)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1968)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserFROM || _la == DorisParserParserIN {
			{
				p.SetState(1966)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserParserFROM || _la == DorisParserParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(1967)

				var _x = p.Identifier()

				localctx.(*ShowBuildIndexContext).database = _x
			}

		}
		p.SetState(1971)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserLIKE || _la == DorisParserParserWHERE {
			{
				p.SetState(1970)
				p.WildWhere()
			}

		}
		p.SetState(1974)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserORDER {
			{
				p.SetState(1973)
				p.SortClause()
			}

		}
		p.SetState(1977)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserLIMIT {
			{
				p.SetState(1976)
				p.LimitClause()
			}

		}

	case 8:
		localctx = NewShowDynamicPartitionContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1979)
			p.Match(DorisParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1980)
			p.Match(DorisParserParserDYNAMIC)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1981)
			p.Match(DorisParserParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1982)
			p.Match(DorisParserParserTABLES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1985)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserFROM || _la == DorisParserParserIN {
			{
				p.SetState(1983)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserParserFROM || _la == DorisParserParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(1984)

				var _x = p.MultipartIdentifier()

				localctx.(*ShowDynamicPartitionContext).database = _x
			}

		}

	case 9:
		localctx = NewShowEventsContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1987)
			p.Match(DorisParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1988)
			p.Match(DorisParserParserEVENTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1991)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserFROM || _la == DorisParserParserIN {
			{
				p.SetState(1989)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserParserFROM || _la == DorisParserParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(1990)

				var _x = p.MultipartIdentifier()

				localctx.(*ShowEventsContext).database = _x
			}

		}
		p.SetState(1994)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserLIKE || _la == DorisParserParserWHERE {
			{
				p.SetState(1993)
				p.WildWhere()
			}

		}

	case 10:
		localctx = NewShowExportContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1996)
			p.Match(DorisParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1997)
			p.Match(DorisParserParserEXPORT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2000)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserFROM || _la == DorisParserParserIN {
			{
				p.SetState(1998)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserParserFROM || _la == DorisParserParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(1999)

				var _x = p.MultipartIdentifier()

				localctx.(*ShowExportContext).database = _x
			}

		}
		p.SetState(2003)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserLIKE || _la == DorisParserParserWHERE {
			{
				p.SetState(2002)
				p.WildWhere()
			}

		}
		p.SetState(2006)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserORDER {
			{
				p.SetState(2005)
				p.SortClause()
			}

		}
		p.SetState(2009)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserLIMIT {
			{
				p.SetState(2008)
				p.LimitClause()
			}

		}

	case 11:
		localctx = NewShowLastInsertContext(p, localctx)
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(2011)
			p.Match(DorisParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2012)
			p.Match(DorisParserParserLAST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2013)
			p.Match(DorisParserParserINSERT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 12:
		localctx = NewShowCharsetContext(p, localctx)
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(2014)
			p.Match(DorisParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2018)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserParserCHAR:
			{
				p.SetState(2015)
				p.Match(DorisParserParserCHAR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2016)
				p.Match(DorisParserParserSET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserParserCHARSET:
			{
				p.SetState(2017)
				p.Match(DorisParserParserCHARSET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 13:
		localctx = NewShowDeleteContext(p, localctx)
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(2020)
			p.Match(DorisParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2021)
			p.Match(DorisParserParserDELETE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2024)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserFROM || _la == DorisParserParserIN {
			{
				p.SetState(2022)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserParserFROM || _la == DorisParserParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(2023)

				var _x = p.MultipartIdentifier()

				localctx.(*ShowDeleteContext).database = _x
			}

		}

	case 14:
		localctx = NewShowCreateFunctionContext(p, localctx)
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(2026)
			p.Match(DorisParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2027)
			p.Match(DorisParserParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2029)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserGLOBAL || _la == DorisParserParserLOCAL || _la == DorisParserParserSESSION {
			{
				p.SetState(2028)
				p.StatementScope()
			}

		}
		{
			p.SetState(2031)
			p.Match(DorisParserParserFUNCTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2032)
			p.FunctionIdentifier()
		}
		{
			p.SetState(2033)
			p.Match(DorisParserParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2035)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&9152335059222592) != 0) || ((int64((_la-71)) & ^0x3f) == 0 && ((int64(1)<<(_la-71))&32633505112391681) != 0) || _la == DorisParserParserDOUBLE || _la == DorisParserParserFLOAT || ((int64((_la-214)) & ^0x3f) == 0 && ((int64(1)<<(_la-214))&9208814108673) != 0) || _la == DorisParserParserMAP || _la == DorisParserParserQUANTILE_STATE || ((int64((_la-427)) & ^0x3f) == 0 && ((int64(1)<<(_la-427))&704375029761) != 0) || _la == DorisParserParserVARCHAR || _la == DorisParserParserVARIANT {
			{
				p.SetState(2034)
				p.FunctionArguments()
			}

		}
		{
			p.SetState(2037)
			p.Match(DorisParserParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2040)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserFROM || _la == DorisParserParserIN {
			{
				p.SetState(2038)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserParserFROM || _la == DorisParserParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(2039)

				var _x = p.MultipartIdentifier()

				localctx.(*ShowCreateFunctionContext).database = _x
			}

		}

	case 15:
		localctx = NewShowFunctionsContext(p, localctx)
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(2042)
			p.Match(DorisParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2044)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserFULL {
			{
				p.SetState(2043)
				p.Match(DorisParserParserFULL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(2047)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserBUILTIN {
			{
				p.SetState(2046)
				p.Match(DorisParserParserBUILTIN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2049)
			p.Match(DorisParserParserFUNCTIONS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2052)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserFROM || _la == DorisParserParserIN {
			{
				p.SetState(2050)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserParserFROM || _la == DorisParserParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(2051)

				var _x = p.MultipartIdentifier()

				localctx.(*ShowFunctionsContext).database = _x
			}

		}
		p.SetState(2056)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserLIKE {
			{
				p.SetState(2054)
				p.Match(DorisParserParserLIKE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2055)
				p.Match(DorisParserParserSTRING_LITERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 16:
		localctx = NewShowGlobalFunctionsContext(p, localctx)
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(2058)
			p.Match(DorisParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2059)
			p.Match(DorisParserParserGLOBAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2061)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserFULL {
			{
				p.SetState(2060)
				p.Match(DorisParserParserFULL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2063)
			p.Match(DorisParserParserFUNCTIONS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2066)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserLIKE {
			{
				p.SetState(2064)
				p.Match(DorisParserParserLIKE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2065)
				p.Match(DorisParserParserSTRING_LITERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 17:
		localctx = NewShowGrantsContext(p, localctx)
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(2068)
			p.Match(DorisParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2070)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserALL {
			{
				p.SetState(2069)
				p.Match(DorisParserParserALL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2072)
			p.Match(DorisParserParserGRANTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 18:
		localctx = NewShowGrantsForUserContext(p, localctx)
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(2073)
			p.Match(DorisParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2074)
			p.Match(DorisParserParserGRANTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2075)
			p.Match(DorisParserParserFOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2076)
			p.UserIdentify()
		}

	case 19:
		localctx = NewShowCreateUserContext(p, localctx)
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(2077)
			p.Match(DorisParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2078)
			p.Match(DorisParserParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2079)
			p.Match(DorisParserParserUSER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2080)
			p.UserIdentify()
		}

	case 20:
		localctx = NewShowSnapshotContext(p, localctx)
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(2081)
			p.Match(DorisParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2082)
			p.Match(DorisParserParserSNAPSHOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2083)
			p.Match(DorisParserParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2084)

			var _x = p.Identifier()

			localctx.(*ShowSnapshotContext).repo = _x
		}
		p.SetState(2086)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserLIKE || _la == DorisParserParserWHERE {
			{
				p.SetState(2085)
				p.WildWhere()
			}

		}

	case 21:
		localctx = NewShowLoadProfileContext(p, localctx)
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(2088)
			p.Match(DorisParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2089)
			p.Match(DorisParserParserLOAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2090)
			p.Match(DorisParserParserPROFILE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2092)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserSTRING_LITERAL {
			{
				p.SetState(2091)

				var _m = p.Match(DorisParserParserSTRING_LITERAL)

				localctx.(*ShowLoadProfileContext).loadIdPath = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(2095)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserLIMIT {
			{
				p.SetState(2094)
				p.LimitClause()
			}

		}

	case 22:
		localctx = NewShowCreateRepositoryContext(p, localctx)
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(2097)
			p.Match(DorisParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2098)
			p.Match(DorisParserParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2099)
			p.Match(DorisParserParserREPOSITORY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2100)
			p.Match(DorisParserParserFOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2101)
			p.Identifier()
		}

	case 23:
		localctx = NewShowViewContext(p, localctx)
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(2102)
			p.Match(DorisParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2103)
			p.Match(DorisParserParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2104)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserParserFROM || _la == DorisParserParserIN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(2105)

			var _x = p.MultipartIdentifier()

			localctx.(*ShowViewContext).tableName = _x
		}
		p.SetState(2108)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserFROM || _la == DorisParserParserIN {
			{
				p.SetState(2106)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserParserFROM || _la == DorisParserParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(2107)

				var _x = p.Identifier()

				localctx.(*ShowViewContext).database = _x
			}

		}

	case 24:
		localctx = NewShowPluginsContext(p, localctx)
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(2110)
			p.Match(DorisParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2111)
			p.Match(DorisParserParserPLUGINS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 25:
		localctx = NewShowStorageVaultContext(p, localctx)
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(2112)
			p.Match(DorisParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2113)
			p.Match(DorisParserParserSTORAGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2114)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserParserVAULT || _la == DorisParserParserVAULTS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 26:
		localctx = NewShowRepositoriesContext(p, localctx)
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(2115)
			p.Match(DorisParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2116)
			p.Match(DorisParserParserREPOSITORIES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 27:
		localctx = NewShowEncryptKeysContext(p, localctx)
		p.EnterOuterAlt(localctx, 27)
		{
			p.SetState(2117)
			p.Match(DorisParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2118)
			p.Match(DorisParserParserENCRYPTKEYS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2121)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserFROM || _la == DorisParserParserIN {
			{
				p.SetState(2119)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserParserFROM || _la == DorisParserParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(2120)

				var _x = p.MultipartIdentifier()

				localctx.(*ShowEncryptKeysContext).database = _x
			}

		}
		p.SetState(2125)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserLIKE {
			{
				p.SetState(2123)
				p.Match(DorisParserParserLIKE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2124)
				p.Match(DorisParserParserSTRING_LITERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 28:
		localctx = NewShowCreateTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 28)
		{
			p.SetState(2127)
			p.Match(DorisParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2129)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserBRIEF {
			{
				p.SetState(2128)
				p.Match(DorisParserParserBRIEF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2131)
			p.Match(DorisParserParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2132)
			p.Match(DorisParserParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2133)

			var _x = p.MultipartIdentifier()

			localctx.(*ShowCreateTableContext).name = _x
		}

	case 29:
		localctx = NewShowProcessListContext(p, localctx)
		p.EnterOuterAlt(localctx, 29)
		{
			p.SetState(2134)
			p.Match(DorisParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2136)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserFULL {
			{
				p.SetState(2135)
				p.Match(DorisParserParserFULL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2138)
			p.Match(DorisParserParserPROCESSLIST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 30:
		localctx = NewShowPartitionsContext(p, localctx)
		p.EnterOuterAlt(localctx, 30)
		{
			p.SetState(2139)
			p.Match(DorisParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2141)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserTEMPORARY {
			{
				p.SetState(2140)
				p.Match(DorisParserParserTEMPORARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2143)
			p.Match(DorisParserParserPARTITIONS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2144)
			p.Match(DorisParserParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2145)

			var _x = p.MultipartIdentifier()

			localctx.(*ShowPartitionsContext).tableName = _x
		}
		p.SetState(2147)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserLIKE || _la == DorisParserParserWHERE {
			{
				p.SetState(2146)
				p.WildWhere()
			}

		}
		p.SetState(2150)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserORDER {
			{
				p.SetState(2149)
				p.SortClause()
			}

		}
		p.SetState(2153)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserLIMIT {
			{
				p.SetState(2152)
				p.LimitClause()
			}

		}

	case 31:
		localctx = NewShowRestoreContext(p, localctx)
		p.EnterOuterAlt(localctx, 31)
		{
			p.SetState(2155)
			p.Match(DorisParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2157)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserBRIEF {
			{
				p.SetState(2156)
				p.Match(DorisParserParserBRIEF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2159)
			p.Match(DorisParserParserRESTORE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2162)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserFROM || _la == DorisParserParserIN {
			{
				p.SetState(2160)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserParserFROM || _la == DorisParserParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(2161)

				var _x = p.Identifier()

				localctx.(*ShowRestoreContext).database = _x
			}

		}
		p.SetState(2165)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserLIKE || _la == DorisParserParserWHERE {
			{
				p.SetState(2164)
				p.WildWhere()
			}

		}

	case 32:
		localctx = NewShowRolesContext(p, localctx)
		p.EnterOuterAlt(localctx, 32)
		{
			p.SetState(2167)
			p.Match(DorisParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2168)
			p.Match(DorisParserParserROLES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 33:
		localctx = NewShowPartitionIdContext(p, localctx)
		p.EnterOuterAlt(localctx, 33)
		{
			p.SetState(2169)
			p.Match(DorisParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2170)
			p.Match(DorisParserParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2171)

			var _m = p.Match(DorisParserParserINTEGER_VALUE)

			localctx.(*ShowPartitionIdContext).partitionId = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 34:
		localctx = NewShowPrivilegesContext(p, localctx)
		p.EnterOuterAlt(localctx, 34)
		{
			p.SetState(2172)
			p.Match(DorisParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2173)
			p.Match(DorisParserParserPRIVILEGES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 35:
		localctx = NewShowProcContext(p, localctx)
		p.EnterOuterAlt(localctx, 35)
		{
			p.SetState(2174)
			p.Match(DorisParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2175)
			p.Match(DorisParserParserPROC)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2176)

			var _m = p.Match(DorisParserParserSTRING_LITERAL)

			localctx.(*ShowProcContext).path = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 36:
		localctx = NewShowSmallFilesContext(p, localctx)
		p.EnterOuterAlt(localctx, 36)
		{
			p.SetState(2177)
			p.Match(DorisParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2178)
			p.Match(DorisParserParserFILE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2181)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserFROM || _la == DorisParserParserIN {
			{
				p.SetState(2179)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserParserFROM || _la == DorisParserParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(2180)

				var _x = p.MultipartIdentifier()

				localctx.(*ShowSmallFilesContext).database = _x
			}

		}

	case 37:
		localctx = NewShowStorageEnginesContext(p, localctx)
		p.EnterOuterAlt(localctx, 37)
		{
			p.SetState(2183)
			p.Match(DorisParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2185)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserSTORAGE {
			{
				p.SetState(2184)
				p.Match(DorisParserParserSTORAGE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2187)
			p.Match(DorisParserParserENGINES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 38:
		localctx = NewShowCreateCatalogContext(p, localctx)
		p.EnterOuterAlt(localctx, 38)
		{
			p.SetState(2188)
			p.Match(DorisParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2189)
			p.Match(DorisParserParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2190)
			p.Match(DorisParserParserCATALOG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2191)

			var _x = p.Identifier()

			localctx.(*ShowCreateCatalogContext).name = _x
		}

	case 39:
		localctx = NewShowCatalogContext(p, localctx)
		p.EnterOuterAlt(localctx, 39)
		{
			p.SetState(2192)
			p.Match(DorisParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2193)
			p.Match(DorisParserParserCATALOG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2194)

			var _x = p.Identifier()

			localctx.(*ShowCatalogContext).name = _x
		}

	case 40:
		localctx = NewShowCatalogsContext(p, localctx)
		p.EnterOuterAlt(localctx, 40)
		{
			p.SetState(2195)
			p.Match(DorisParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2196)
			p.Match(DorisParserParserCATALOGS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2198)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserLIKE || _la == DorisParserParserWHERE {
			{
				p.SetState(2197)
				p.WildWhere()
			}

		}

	case 41:
		localctx = NewShowUserPropertiesContext(p, localctx)
		p.EnterOuterAlt(localctx, 41)
		{
			p.SetState(2200)
			p.Match(DorisParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2201)
			p.Match(DorisParserParserPROPERTY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2204)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserFOR {
			{
				p.SetState(2202)
				p.Match(DorisParserParserFOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2203)

				var _x = p.IdentifierOrText()

				localctx.(*ShowUserPropertiesContext).user = _x
			}

		}
		p.SetState(2208)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserLIKE {
			{
				p.SetState(2206)
				p.Match(DorisParserParserLIKE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2207)
				p.Match(DorisParserParserSTRING_LITERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 42:
		localctx = NewShowAllPropertiesContext(p, localctx)
		p.EnterOuterAlt(localctx, 42)
		{
			p.SetState(2210)
			p.Match(DorisParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2211)
			p.Match(DorisParserParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2212)
			p.Match(DorisParserParserPROPERTIES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2215)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserLIKE {
			{
				p.SetState(2213)
				p.Match(DorisParserParserLIKE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2214)
				p.Match(DorisParserParserSTRING_LITERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 43:
		localctx = NewShowCollationContext(p, localctx)
		p.EnterOuterAlt(localctx, 43)
		{
			p.SetState(2217)
			p.Match(DorisParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2218)
			p.Match(DorisParserParserCOLLATION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2220)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserLIKE || _la == DorisParserParserWHERE {
			{
				p.SetState(2219)
				p.WildWhere()
			}

		}

	case 44:
		localctx = NewShowRowPolicyContext(p, localctx)
		p.EnterOuterAlt(localctx, 44)
		{
			p.SetState(2222)
			p.Match(DorisParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2223)
			p.Match(DorisParserParserROW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2224)
			p.Match(DorisParserParserPOLICY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2231)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserFOR {
			{
				p.SetState(2225)
				p.Match(DorisParserParserFOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(2229)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case DorisParserParserLEFT_BRACE, DorisParserParserRIGHT_BRACE, DorisParserParserACTIONS, DorisParserParserAFTER, DorisParserParserAGG_STATE, DorisParserParserAGGREGATE, DorisParserParserALIAS, DorisParserParserANALYZED, DorisParserParserARRAY, DorisParserParserAT, DorisParserParserAUTHORS, DorisParserParserAUTO_INCREMENT, DorisParserParserALWAYS, DorisParserParserBACKENDS, DorisParserParserBACKUP, DorisParserParserBEGIN, DorisParserParserBELONG, DorisParserParserBIN, DorisParserParserBITAND, DorisParserParserBITMAP, DorisParserParserBITMAP_EMPTY, DorisParserParserBITMAP_UNION, DorisParserParserBITOR, DorisParserParserBITXOR, DorisParserParserBLOB, DorisParserParserBOOLEAN, DorisParserParserBRANCH, DorisParserParserBRIEF, DorisParserParserBROKER, DorisParserParserBUCKETS, DorisParserParserBUILD, DorisParserParserBUILTIN, DorisParserParserBULK, DorisParserParserCACHE, DorisParserParserCACHED, DorisParserParserCALL, DorisParserParserCATALOG, DorisParserParserCATALOGS, DorisParserParserCHAIN, DorisParserParserCHAR, DorisParserParserCHARSET, DorisParserParserCHECK, DorisParserParserCLUSTER, DorisParserParserCLUSTERS, DorisParserParserCOLLATION, DorisParserParserCOLLECT, DorisParserParserCOLOCATE, DorisParserParserCOLUMNS, DorisParserParserCOMMENT, DorisParserParserCOMMIT, DorisParserParserCOMMITTED, DorisParserParserCOMPACT, DorisParserParserCOMPLETE, DorisParserParserCOMPRESS_TYPE, DorisParserParserCOMPUTE, DorisParserParserCONDITIONS, DorisParserParserCONFIG, DorisParserParserCONNECTION, DorisParserParserCONNECTION_ID, DorisParserParserCONSISTENT, DorisParserParserCONSTRAINTS, DorisParserParserCONVERT, DorisParserParserCONVERT_LSC, DorisParserParserCOPY, DorisParserParserCOUNT, DorisParserParserCREATION, DorisParserParserCRON, DorisParserParserCURRENT_CATALOG, DorisParserParserCURRENT_DATE, DorisParserParserCURRENT_TIME, DorisParserParserCURRENT_TIMESTAMP, DorisParserParserCURRENT_USER, DorisParserParserDATA, DorisParserParserDATE, DorisParserParserDATETIME, DorisParserParserDATETIMEV2, DorisParserParserDATEV2, DorisParserParserDATETIMEV1, DorisParserParserDATEV1, DorisParserParserDAY, DorisParserParserDAYS, DorisParserParserDECIMAL, DorisParserParserDECIMALV2, DorisParserParserDECIMALV3, DorisParserParserDEFERRED, DorisParserParserDEMAND, DorisParserParserDIAGNOSE, DorisParserParserDIAGNOSIS, DorisParserParserDICTIONARIES, DorisParserParserDICTIONARY, DorisParserParserDISTINCTPC, DorisParserParserDISTINCTPCSA, DorisParserParserDO, DorisParserParserDORIS_INTERNAL_TABLE_ID, DorisParserParserDUAL, DorisParserParserDYNAMIC, DorisParserParserE, DorisParserParserENABLE, DorisParserParserENCRYPTKEY, DorisParserParserENCRYPTKEYS, DorisParserParserEND, DorisParserParserENDS, DorisParserParserENGINE, DorisParserParserENGINES, DorisParserParserERRORS, DorisParserParserESCAPE, DorisParserParserEVENTS, DorisParserParserEVERY, DorisParserParserEXCLUDE, DorisParserParserEXPIRED, DorisParserParserEXTERNAL, DorisParserParserFAILED_LOGIN_ATTEMPTS, DorisParserParserFAST, DorisParserParserFEATURE, DorisParserParserFIELDS, DorisParserParserFILE, DorisParserParserFILTER, DorisParserParserFIRST, DorisParserParserFORMAT, DorisParserParserFREE, DorisParserParserFRONTENDS, DorisParserParserFUNCTION, DorisParserParserGENERATED, DorisParserParserGENERIC, DorisParserParserGLOBAL, DorisParserParserGRAPH, DorisParserParserGROUPING, DorisParserParserGROUPS, DorisParserParserHASH, DorisParserParserHASH_MAP, DorisParserParserHDFS, DorisParserParserHELP, DorisParserParserHISTOGRAM, DorisParserParserHLL_UNION, DorisParserParserHOSTNAME, DorisParserParserHOTSPOT, DorisParserParserHOUR, DorisParserParserHOURS, DorisParserParserHUB, DorisParserParserIDENTIFIED, DorisParserParserIGNORE, DorisParserParserIMMEDIATE, DorisParserParserINCREMENTAL, DorisParserParserINDEXES, DorisParserParserINVERTED, DorisParserParserIP_TRIE, DorisParserParserIPV4, DorisParserParserIPV6, DorisParserParserIS_NOT_NULL_PRED, DorisParserParserIS_NULL_PRED, DorisParserParserISNULL, DorisParserParserISOLATION, DorisParserParserJOB, DorisParserParserJOBS, DorisParserParserJSON, DorisParserParserJSONB, DorisParserParserLABEL, DorisParserParserLAST, DorisParserParserLDAP, DorisParserParserLDAP_ADMIN_PASSWORD, DorisParserParserLESS, DorisParserParserLEVEL, DorisParserParserLINES, DorisParserParserLINK, DorisParserParserLOCAL, DorisParserParserLOCALTIME, DorisParserParserLOCALTIMESTAMP, DorisParserParserLOCATION, DorisParserParserLOCK, DorisParserParserLOGICAL, DorisParserParserMANUAL, DorisParserParserMAP, DorisParserParserMATCH_ALL, DorisParserParserMATCH_ANY, DorisParserParserMATCH_PHRASE, DorisParserParserMATCH_PHRASE_EDGE, DorisParserParserMATCH_PHRASE_PREFIX, DorisParserParserMATCH_REGEXP, DorisParserParserMATERIALIZED, DorisParserParserMAX, DorisParserParserMEMO, DorisParserParserMERGE, DorisParserParserMIGRATE, DorisParserParserMIGRATIONS, DorisParserParserMIN, DorisParserParserMINUTE, DorisParserParserMINUTES, DorisParserParserMODIFY, DorisParserParserMONTH, DorisParserParserMTMV, DorisParserParserNAME, DorisParserParserNAMES, DorisParserParserNEGATIVE, DorisParserParserNEVER, DorisParserParserNEXT, DorisParserParserNGRAM_BF, DorisParserParserNO, DorisParserParserNON_NULLABLE, DorisParserParserNULLS, DorisParserParserOF, DorisParserParserOFFSET, DorisParserParserONLY, DorisParserParserOPEN, DorisParserParserOPTIMIZED, DorisParserParserPARAMETER, DorisParserParserPARSED, DorisParserParserPARTITIONS, DorisParserParserPASSWORD, DorisParserParserPASSWORD_EXPIRE, DorisParserParserPASSWORD_HISTORY, DorisParserParserPASSWORD_LOCK_TIME, DorisParserParserPASSWORD_REUSE, DorisParserParserPATH, DorisParserParserPAUSE, DorisParserParserPERCENT, DorisParserParserPERIOD, DorisParserParserPERMISSIVE, DorisParserParserPHYSICAL, DorisParserParserPI, DorisParserParserPLAN, DorisParserParserPRIVILEGES, DorisParserParserPROCESS, DorisParserParserPLUGIN, DorisParserParserPLUGINS, DorisParserParserPOLICY, DorisParserParserPROC, DorisParserParserPROCESSLIST, DorisParserParserPROFILE, DorisParserParserPROPERTIES, DorisParserParserPROPERTY, DorisParserParserQUANTILE_STATE, DorisParserParserQUANTILE_UNION, DorisParserParserQUERY, DorisParserParserQUEUED, DorisParserParserQUOTA, DorisParserParserQUALIFY, DorisParserParserQUARTER, DorisParserParserRANDOM, DorisParserParserRECENT, DorisParserParserRECOVER, DorisParserParserRECYCLE, DorisParserParserREFRESH, DorisParserParserREPEATABLE, DorisParserParserREPLACE, DorisParserParserREPLACE_IF_NOT_NULL, DorisParserParserREPLAYER, DorisParserParserREPOSITORIES, DorisParserParserREPOSITORY, DorisParserParserRESOURCE, DorisParserParserRESOURCES, DorisParserParserRESTORE, DorisParserParserRESTRICTIVE, DorisParserParserRESUME, DorisParserParserRETAIN, DorisParserParserRETENTION, DorisParserParserRETURNS, DorisParserParserREWRITTEN, DorisParserParserRLIKE, DorisParserParserROLLBACK, DorisParserParserROLLUP, DorisParserParserROUTINE, DorisParserParserS3, DorisParserParserSAMPLE, DorisParserParserSCHEDULE, DorisParserParserSCHEDULER, DorisParserParserSCHEMA, DorisParserParserSECOND, DorisParserParserSERIALIZABLE, DorisParserParserSESSION, DorisParserParserSESSION_USER, DorisParserParserSET_SESSION_VARIABLE, DorisParserParserSHAPE, DorisParserParserSKEW, DorisParserParserSNAPSHOT, DorisParserParserSNAPSHOTS, DorisParserParserSONAME, DorisParserParserSPLIT, DorisParserParserSQL, DorisParserParserSTAGE, DorisParserParserSTAGES, DorisParserParserSTART, DorisParserParserSTARTS, DorisParserParserSTATS, DorisParserParserSTATUS, DorisParserParserSTOP, DorisParserParserSTORAGE, DorisParserParserSTREAM, DorisParserParserSTREAMING, DorisParserParserSTRING, DorisParserParserSTRUCT, DorisParserParserSUM, DorisParserParserTABLES, DorisParserParserTAG, DorisParserParserTASK, DorisParserParserTASKS, DorisParserParserTEMPORARY, DorisParserParserTEXT, DorisParserParserTHAN, DorisParserParserTIME, DorisParserParserTIMESTAMP, DorisParserParserTRANSACTION, DorisParserParserTREE, DorisParserParserTRIGGERS, DorisParserParserTRUNCATE, DorisParserParserTYPE, DorisParserParserTYPES, DorisParserParserUNCOMMITTED, DorisParserParserUNLOCK, DorisParserParserUNSET, DorisParserParserUP, DorisParserParserUSER, DorisParserParserVALUE, DorisParserParserVARCHAR, DorisParserParserVARIABLE, DorisParserParserVARIABLES, DorisParserParserVARIANT, DorisParserParserVAULT, DorisParserParserVAULTS, DorisParserParserVERBOSE, DorisParserParserVERSION, DorisParserParserVIEW, DorisParserParserVIEWS, DorisParserParserWARM, DorisParserParserWARNINGS, DorisParserParserWEEK, DorisParserParserWORK, DorisParserParserYEAR, DorisParserParserHINT_START, DorisParserParserHINT_END, DorisParserParserCOMMENT_START, DorisParserParserSTRING_LITERAL, DorisParserParserIDENTIFIER, DorisParserParserBACKQUOTED_IDENTIFIER:
				{
					p.SetState(2226)
					p.UserIdentify()
				}

			case DorisParserParserROLE:
				{
					p.SetState(2227)
					p.Match(DorisParserParserROLE)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2228)

					var _x = p.Identifier()

					localctx.(*ShowRowPolicyContext).role = _x
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

		}

	case 45:
		localctx = NewShowStoragePolicyContext(p, localctx)
		p.EnterOuterAlt(localctx, 45)
		{
			p.SetState(2233)
			p.Match(DorisParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2234)
			p.Match(DorisParserParserSTORAGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2235)
			p.Match(DorisParserParserPOLICY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2241)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserUSING {
			{
				p.SetState(2236)
				p.Match(DorisParserParserUSING)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(2239)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserParserFOR {
				{
					p.SetState(2237)
					p.Match(DorisParserParserFOR)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2238)

					var _x = p.IdentifierOrText()

					localctx.(*ShowStoragePolicyContext).policy = _x
				}

			}

		}

	case 46:
		localctx = NewShowSqlBlockRuleContext(p, localctx)
		p.EnterOuterAlt(localctx, 46)
		{
			p.SetState(2243)
			p.Match(DorisParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2244)
			p.Match(DorisParserParserSQL_BLOCK_RULE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2247)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserFOR {
			{
				p.SetState(2245)
				p.Match(DorisParserParserFOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2246)

				var _x = p.Identifier()

				localctx.(*ShowSqlBlockRuleContext).ruleName = _x
			}

		}

	case 47:
		localctx = NewShowCreateViewContext(p, localctx)
		p.EnterOuterAlt(localctx, 47)
		{
			p.SetState(2249)
			p.Match(DorisParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2250)
			p.Match(DorisParserParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2251)
			p.Match(DorisParserParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2252)

			var _x = p.MultipartIdentifier()

			localctx.(*ShowCreateViewContext).name = _x
		}

	case 48:
		localctx = NewShowDataTypesContext(p, localctx)
		p.EnterOuterAlt(localctx, 48)
		{
			p.SetState(2253)
			p.Match(DorisParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2254)
			p.Match(DorisParserParserDATA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2255)
			p.Match(DorisParserParserTYPES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 49:
		localctx = NewShowDataContext(p, localctx)
		p.EnterOuterAlt(localctx, 49)
		{
			p.SetState(2256)
			p.Match(DorisParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2257)
			p.Match(DorisParserParserDATA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2259)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserALL {
			{
				p.SetState(2258)
				p.Match(DorisParserParserALL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(2263)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserFROM {
			{
				p.SetState(2261)
				p.Match(DorisParserParserFROM)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2262)

				var _x = p.MultipartIdentifier()

				localctx.(*ShowDataContext).tableName = _x
			}

		}
		p.SetState(2266)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserORDER {
			{
				p.SetState(2265)
				p.SortClause()
			}

		}
		p.SetState(2269)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserPROPERTIES {
			{
				p.SetState(2268)
				p.PropertyClause()
			}

		}

	case 50:
		localctx = NewShowCreateMaterializedViewContext(p, localctx)
		p.EnterOuterAlt(localctx, 50)
		{
			p.SetState(2271)
			p.Match(DorisParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2272)
			p.Match(DorisParserParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2273)
			p.Match(DorisParserParserMATERIALIZED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2274)
			p.Match(DorisParserParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2275)

			var _x = p.Identifier()

			localctx.(*ShowCreateMaterializedViewContext).mvName = _x
		}
		{
			p.SetState(2276)
			p.Match(DorisParserParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2277)

			var _x = p.MultipartIdentifier()

			localctx.(*ShowCreateMaterializedViewContext).tableName = _x
		}

	case 51:
		localctx = NewShowWarningErrorsContext(p, localctx)
		p.EnterOuterAlt(localctx, 51)
		{
			p.SetState(2279)
			p.Match(DorisParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2280)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserParserERRORS || _la == DorisParserParserWARNINGS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(2282)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserLIMIT {
			{
				p.SetState(2281)
				p.LimitClause()
			}

		}

	case 52:
		localctx = NewShowWarningErrorCountContext(p, localctx)
		p.EnterOuterAlt(localctx, 52)
		{
			p.SetState(2284)
			p.Match(DorisParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2285)
			p.Match(DorisParserParserCOUNT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2286)
			p.Match(DorisParserParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2287)
			p.Match(DorisParserParserASTERISK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2288)
			p.Match(DorisParserParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2289)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserParserERRORS || _la == DorisParserParserWARNINGS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 53:
		localctx = NewShowBackendsContext(p, localctx)
		p.EnterOuterAlt(localctx, 53)
		{
			p.SetState(2290)
			p.Match(DorisParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2291)
			p.Match(DorisParserParserBACKENDS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 54:
		localctx = NewShowStagesContext(p, localctx)
		p.EnterOuterAlt(localctx, 54)
		{
			p.SetState(2292)
			p.Match(DorisParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2293)
			p.Match(DorisParserParserSTAGES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 55:
		localctx = NewShowReplicaDistributionContext(p, localctx)
		p.EnterOuterAlt(localctx, 55)
		{
			p.SetState(2294)
			p.Match(DorisParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2295)
			p.Match(DorisParserParserREPLICA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2296)
			p.Match(DorisParserParserDISTRIBUTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2297)
			p.Match(DorisParserParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2298)
			p.BaseTableRef()
		}

	case 56:
		localctx = NewShowResourcesContext(p, localctx)
		p.EnterOuterAlt(localctx, 56)
		{
			p.SetState(2299)
			p.Match(DorisParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2300)
			p.Match(DorisParserParserRESOURCES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2302)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserLIKE || _la == DorisParserParserWHERE {
			{
				p.SetState(2301)
				p.WildWhere()
			}

		}
		p.SetState(2305)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserORDER {
			{
				p.SetState(2304)
				p.SortClause()
			}

		}
		p.SetState(2308)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserLIMIT {
			{
				p.SetState(2307)
				p.LimitClause()
			}

		}

	case 57:
		localctx = NewShowLoadContext(p, localctx)
		p.EnterOuterAlt(localctx, 57)
		{
			p.SetState(2310)
			p.Match(DorisParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2312)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserSTREAM {
			{
				p.SetState(2311)
				p.Match(DorisParserParserSTREAM)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2314)
			p.Match(DorisParserParserLOAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2317)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserFROM || _la == DorisParserParserIN {
			{
				p.SetState(2315)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserParserFROM || _la == DorisParserParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(2316)

				var _x = p.Identifier()

				localctx.(*ShowLoadContext).database = _x
			}

		}
		p.SetState(2320)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserLIKE || _la == DorisParserParserWHERE {
			{
				p.SetState(2319)
				p.WildWhere()
			}

		}
		p.SetState(2323)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserORDER {
			{
				p.SetState(2322)
				p.SortClause()
			}

		}
		p.SetState(2326)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserLIMIT {
			{
				p.SetState(2325)
				p.LimitClause()
			}

		}

	case 58:
		localctx = NewShowLoadWaringsContext(p, localctx)
		p.EnterOuterAlt(localctx, 58)
		{
			p.SetState(2328)
			p.Match(DorisParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2329)
			p.Match(DorisParserParserLOAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2330)
			p.Match(DorisParserParserWARNINGS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2343)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserParserEOF, DorisParserParserSEMICOLON, DorisParserParserFROM, DorisParserParserIN, DorisParserParserLIKE, DorisParserParserLIMIT, DorisParserParserWHERE:
			p.SetState(2333)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserParserFROM || _la == DorisParserParserIN {
				{
					p.SetState(2331)
					_la = p.GetTokenStream().LA(1)

					if !(_la == DorisParserParserFROM || _la == DorisParserParserIN) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(2332)

					var _x = p.Identifier()

					localctx.(*ShowLoadWaringsContext).database = _x
				}

			}
			p.SetState(2336)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserParserLIKE || _la == DorisParserParserWHERE {
				{
					p.SetState(2335)
					p.WildWhere()
				}

			}
			p.SetState(2339)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserParserLIMIT {
				{
					p.SetState(2338)
					p.LimitClause()
				}

			}

		case DorisParserParserON:
			{
				p.SetState(2341)
				p.Match(DorisParserParserON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2342)

				var _m = p.Match(DorisParserParserSTRING_LITERAL)

				localctx.(*ShowLoadWaringsContext).url = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 59:
		localctx = NewShowTriggersContext(p, localctx)
		p.EnterOuterAlt(localctx, 59)
		{
			p.SetState(2345)
			p.Match(DorisParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2347)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserFULL {
			{
				p.SetState(2346)
				p.Match(DorisParserParserFULL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2349)
			p.Match(DorisParserParserTRIGGERS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2352)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserFROM || _la == DorisParserParserIN {
			{
				p.SetState(2350)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserParserFROM || _la == DorisParserParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(2351)

				var _x = p.MultipartIdentifier()

				localctx.(*ShowTriggersContext).database = _x
			}

		}
		p.SetState(2355)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserLIKE || _la == DorisParserParserWHERE {
			{
				p.SetState(2354)
				p.WildWhere()
			}

		}

	case 60:
		localctx = NewShowDiagnoseTabletContext(p, localctx)
		p.EnterOuterAlt(localctx, 60)
		{
			p.SetState(2357)
			p.Match(DorisParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2358)
			p.Match(DorisParserParserTABLET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2359)
			p.Match(DorisParserParserDIAGNOSIS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2360)

			var _m = p.Match(DorisParserParserINTEGER_VALUE)

			localctx.(*ShowDiagnoseTabletContext).tabletId = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 61:
		localctx = NewShowOpenTablesContext(p, localctx)
		p.EnterOuterAlt(localctx, 61)
		{
			p.SetState(2361)
			p.Match(DorisParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2362)
			p.Match(DorisParserParserOPEN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2363)
			p.Match(DorisParserParserTABLES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2366)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserFROM || _la == DorisParserParserIN {
			{
				p.SetState(2364)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserParserFROM || _la == DorisParserParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(2365)

				var _x = p.MultipartIdentifier()

				localctx.(*ShowOpenTablesContext).database = _x
			}

		}
		p.SetState(2369)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserLIKE || _la == DorisParserParserWHERE {
			{
				p.SetState(2368)
				p.WildWhere()
			}

		}

	case 62:
		localctx = NewShowFrontendsContext(p, localctx)
		p.EnterOuterAlt(localctx, 62)
		{
			p.SetState(2371)
			p.Match(DorisParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2372)
			p.Match(DorisParserParserFRONTENDS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2374)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-2305902462020672000) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&4609989332399152113) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-9080794533051819547) != 0) || ((int64((_la-192)) & ^0x3f) == 0 && ((int64(1)<<(_la-192))&2015220189171012521) != 0) || ((int64((_la-256)) & ^0x3f) == 0 && ((int64(1)<<(_la-256))&-5422616543060085911) != 0) || ((int64((_la-320)) & ^0x3f) == 0 && ((int64(1)<<(_la-320))&-4476015178520986877) != 0) || ((int64((_la-384)) & ^0x3f) == 0 && ((int64(1)<<(_la-384))&9222796779122679803) != 0) || ((int64((_la-452)) & ^0x3f) == 0 && ((int64(1)<<(_la-452))&2449945648119953137) != 0) || ((int64((_la-517)) & ^0x3f) == 0 && ((int64(1)<<(_la-517))&206187790337) != 0) {
			{
				p.SetState(2373)

				var _x = p.Identifier()

				localctx.(*ShowFrontendsContext).name = _x
			}

		}

	case 63:
		localctx = NewShowDatabaseIdContext(p, localctx)
		p.EnterOuterAlt(localctx, 63)
		{
			p.SetState(2376)
			p.Match(DorisParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2377)
			p.Match(DorisParserParserDATABASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2378)

			var _m = p.Match(DorisParserParserINTEGER_VALUE)

			localctx.(*ShowDatabaseIdContext).databaseId = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 64:
		localctx = NewShowColumnsContext(p, localctx)
		p.EnterOuterAlt(localctx, 64)
		{
			p.SetState(2379)
			p.Match(DorisParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2381)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserFULL {
			{
				p.SetState(2380)
				p.Match(DorisParserParserFULL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2383)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserParserCOLUMNS || _la == DorisParserParserFIELDS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(2384)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserParserFROM || _la == DorisParserParserIN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(2385)

			var _x = p.MultipartIdentifier()

			localctx.(*ShowColumnsContext).tableName = _x
		}
		p.SetState(2388)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserFROM || _la == DorisParserParserIN {
			{
				p.SetState(2386)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserParserFROM || _la == DorisParserParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(2387)

				var _x = p.MultipartIdentifier()

				localctx.(*ShowColumnsContext).database = _x
			}

		}
		p.SetState(2391)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserLIKE || _la == DorisParserParserWHERE {
			{
				p.SetState(2390)
				p.WildWhere()
			}

		}

	case 65:
		localctx = NewShowTableIdContext(p, localctx)
		p.EnterOuterAlt(localctx, 65)
		{
			p.SetState(2393)
			p.Match(DorisParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2394)
			p.Match(DorisParserParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2395)

			var _m = p.Match(DorisParserParserINTEGER_VALUE)

			localctx.(*ShowTableIdContext).tableId = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 66:
		localctx = NewShowTrashContext(p, localctx)
		p.EnterOuterAlt(localctx, 66)
		{
			p.SetState(2396)
			p.Match(DorisParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2397)
			p.Match(DorisParserParserTRASH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2400)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserON {
			{
				p.SetState(2398)
				p.Match(DorisParserParserON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2399)

				var _m = p.Match(DorisParserParserSTRING_LITERAL)

				localctx.(*ShowTrashContext).backend = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 67:
		localctx = NewShowTypeCastContext(p, localctx)
		p.EnterOuterAlt(localctx, 67)
		{
			p.SetState(2402)
			p.Match(DorisParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2403)
			p.Match(DorisParserParserTYPECAST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2406)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserFROM || _la == DorisParserParserIN {
			{
				p.SetState(2404)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserParserFROM || _la == DorisParserParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(2405)

				var _x = p.Identifier()

				localctx.(*ShowTypeCastContext).database = _x
			}

		}

	case 68:
		localctx = NewShowClustersContext(p, localctx)
		p.EnterOuterAlt(localctx, 68)
		{
			p.SetState(2408)
			p.Match(DorisParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2412)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserParserCLUSTERS:
			{
				p.SetState(2409)
				p.Match(DorisParserParserCLUSTERS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserParserCOMPUTE:
			{
				p.SetState(2410)
				p.Match(DorisParserParserCOMPUTE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2411)
				p.Match(DorisParserParserGROUPS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 69:
		localctx = NewShowStatusContext(p, localctx)
		p.EnterOuterAlt(localctx, 69)
		{
			p.SetState(2414)
			p.Match(DorisParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2416)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserGLOBAL || _la == DorisParserParserLOCAL || _la == DorisParserParserSESSION {
			{
				p.SetState(2415)
				p.StatementScope()
			}

		}
		{
			p.SetState(2418)
			p.Match(DorisParserParserSTATUS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 70:
		localctx = NewShowWhitelistContext(p, localctx)
		p.EnterOuterAlt(localctx, 70)
		{
			p.SetState(2419)
			p.Match(DorisParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2420)
			p.Match(DorisParserParserWHITELIST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 71:
		localctx = NewShowTabletsBelongContext(p, localctx)
		p.EnterOuterAlt(localctx, 71)
		{
			p.SetState(2421)
			p.Match(DorisParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2422)
			p.Match(DorisParserParserTABLETS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2423)
			p.Match(DorisParserParserBELONG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2424)

			var _m = p.Match(DorisParserParserINTEGER_VALUE)

			localctx.(*ShowTabletsBelongContext)._INTEGER_VALUE = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*ShowTabletsBelongContext).tabletIds = append(localctx.(*ShowTabletsBelongContext).tabletIds, localctx.(*ShowTabletsBelongContext)._INTEGER_VALUE)
		p.SetState(2429)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserParserCOMMA {
			{
				p.SetState(2425)
				p.Match(DorisParserParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2426)

				var _m = p.Match(DorisParserParserINTEGER_VALUE)

				localctx.(*ShowTabletsBelongContext)._INTEGER_VALUE = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			localctx.(*ShowTabletsBelongContext).tabletIds = append(localctx.(*ShowTabletsBelongContext).tabletIds, localctx.(*ShowTabletsBelongContext)._INTEGER_VALUE)

			p.SetState(2431)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 72:
		localctx = NewShowDataSkewContext(p, localctx)
		p.EnterOuterAlt(localctx, 72)
		{
			p.SetState(2432)
			p.Match(DorisParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2433)
			p.Match(DorisParserParserDATA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2434)
			p.Match(DorisParserParserSKEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2435)
			p.Match(DorisParserParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2436)
			p.BaseTableRef()
		}

	case 73:
		localctx = NewShowTableCreationContext(p, localctx)
		p.EnterOuterAlt(localctx, 73)
		{
			p.SetState(2437)
			p.Match(DorisParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2438)
			p.Match(DorisParserParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2439)
			p.Match(DorisParserParserCREATION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2442)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserFROM || _la == DorisParserParserIN {
			{
				p.SetState(2440)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserParserFROM || _la == DorisParserParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(2441)

				var _x = p.MultipartIdentifier()

				localctx.(*ShowTableCreationContext).database = _x
			}

		}
		p.SetState(2446)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserLIKE {
			{
				p.SetState(2444)
				p.Match(DorisParserParserLIKE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2445)
				p.Match(DorisParserParserSTRING_LITERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 74:
		localctx = NewShowTabletStorageFormatContext(p, localctx)
		p.EnterOuterAlt(localctx, 74)
		{
			p.SetState(2448)
			p.Match(DorisParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2449)
			p.Match(DorisParserParserTABLET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2450)
			p.Match(DorisParserParserSTORAGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2451)
			p.Match(DorisParserParserFORMAT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2453)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserVERBOSE {
			{
				p.SetState(2452)
				p.Match(DorisParserParserVERBOSE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 75:
		localctx = NewShowQueryProfileContext(p, localctx)
		p.EnterOuterAlt(localctx, 75)
		{
			p.SetState(2455)
			p.Match(DorisParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2456)
			p.Match(DorisParserParserQUERY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2457)
			p.Match(DorisParserParserPROFILE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2459)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserSTRING_LITERAL {
			{
				p.SetState(2458)

				var _m = p.Match(DorisParserParserSTRING_LITERAL)

				localctx.(*ShowQueryProfileContext).queryIdPath = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(2462)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserLIMIT {
			{
				p.SetState(2461)
				p.LimitClause()
			}

		}

	case 76:
		localctx = NewShowConvertLscContext(p, localctx)
		p.EnterOuterAlt(localctx, 76)
		{
			p.SetState(2464)
			p.Match(DorisParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2465)
			p.Match(DorisParserParserCONVERT_LSC)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2468)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserFROM || _la == DorisParserParserIN {
			{
				p.SetState(2466)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserParserFROM || _la == DorisParserParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(2467)

				var _x = p.MultipartIdentifier()

				localctx.(*ShowConvertLscContext).database = _x
			}

		}

	case 77:
		localctx = NewShowTablesContext(p, localctx)
		p.EnterOuterAlt(localctx, 77)
		{
			p.SetState(2470)
			p.Match(DorisParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2472)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserFULL {
			{
				p.SetState(2471)
				p.Match(DorisParserParserFULL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2474)
			p.Match(DorisParserParserTABLES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2477)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserFROM || _la == DorisParserParserIN {
			{
				p.SetState(2475)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserParserFROM || _la == DorisParserParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(2476)

				var _x = p.MultipartIdentifier()

				localctx.(*ShowTablesContext).database = _x
			}

		}
		p.SetState(2480)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserLIKE || _la == DorisParserParserWHERE {
			{
				p.SetState(2479)
				p.WildWhere()
			}

		}

	case 78:
		localctx = NewShowViewsContext(p, localctx)
		p.EnterOuterAlt(localctx, 78)
		{
			p.SetState(2482)
			p.Match(DorisParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2484)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserFULL {
			{
				p.SetState(2483)
				p.Match(DorisParserParserFULL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2486)
			p.Match(DorisParserParserVIEWS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2489)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserFROM || _la == DorisParserParserIN {
			{
				p.SetState(2487)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserParserFROM || _la == DorisParserParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(2488)

				var _x = p.MultipartIdentifier()

				localctx.(*ShowViewsContext).database = _x
			}

		}
		p.SetState(2492)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserLIKE || _la == DorisParserParserWHERE {
			{
				p.SetState(2491)
				p.WildWhere()
			}

		}

	case 79:
		localctx = NewShowTableStatusContext(p, localctx)
		p.EnterOuterAlt(localctx, 79)
		{
			p.SetState(2494)
			p.Match(DorisParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2495)
			p.Match(DorisParserParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2496)
			p.Match(DorisParserParserSTATUS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2499)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserFROM || _la == DorisParserParserIN {
			{
				p.SetState(2497)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserParserFROM || _la == DorisParserParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(2498)

				var _x = p.MultipartIdentifier()

				localctx.(*ShowTableStatusContext).database = _x
			}

		}
		p.SetState(2502)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserLIKE || _la == DorisParserParserWHERE {
			{
				p.SetState(2501)
				p.WildWhere()
			}

		}

	case 80:
		localctx = NewShowDatabasesContext(p, localctx)
		p.EnterOuterAlt(localctx, 80)
		{
			p.SetState(2504)
			p.Match(DorisParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2505)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserParserDATABASES || _la == DorisParserParserSCHEMAS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(2508)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserFROM {
			{
				p.SetState(2506)
				p.Match(DorisParserParserFROM)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2507)

				var _x = p.Identifier()

				localctx.(*ShowDatabasesContext).catalog = _x
			}

		}
		p.SetState(2511)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserLIKE || _la == DorisParserParserWHERE {
			{
				p.SetState(2510)
				p.WildWhere()
			}

		}

	case 81:
		localctx = NewShowTabletsFromTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 81)
		{
			p.SetState(2513)
			p.Match(DorisParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2514)
			p.Match(DorisParserParserTABLETS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2515)
			p.Match(DorisParserParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2516)

			var _x = p.MultipartIdentifier()

			localctx.(*ShowTabletsFromTableContext).tableName = _x
		}
		p.SetState(2518)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserPARTITION || _la == DorisParserParserPARTITIONS || _la == DorisParserParserTEMPORARY {
			{
				p.SetState(2517)
				p.PartitionSpec()
			}

		}
		p.SetState(2521)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserLIKE || _la == DorisParserParserWHERE {
			{
				p.SetState(2520)
				p.WildWhere()
			}

		}
		p.SetState(2524)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserORDER {
			{
				p.SetState(2523)
				p.SortClause()
			}

		}
		p.SetState(2527)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserLIMIT {
			{
				p.SetState(2526)
				p.LimitClause()
			}

		}

	case 82:
		localctx = NewShowCatalogRecycleBinContext(p, localctx)
		p.EnterOuterAlt(localctx, 82)
		{
			p.SetState(2529)
			p.Match(DorisParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2530)
			p.Match(DorisParserParserCATALOG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2531)
			p.Match(DorisParserParserRECYCLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2532)
			p.Match(DorisParserParserBIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2535)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserWHERE {
			{
				p.SetState(2533)
				p.Match(DorisParserParserWHERE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2534)
				p.Expression()
			}

		}

	case 83:
		localctx = NewShowTabletIdContext(p, localctx)
		p.EnterOuterAlt(localctx, 83)
		{
			p.SetState(2537)
			p.Match(DorisParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2538)
			p.Match(DorisParserParserTABLET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2539)

			var _m = p.Match(DorisParserParserINTEGER_VALUE)

			localctx.(*ShowTabletIdContext).tabletId = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 84:
		localctx = NewShowDictionariesContext(p, localctx)
		p.EnterOuterAlt(localctx, 84)
		{
			p.SetState(2540)
			p.Match(DorisParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2541)
			p.Match(DorisParserParserDICTIONARIES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2543)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserLIKE || _la == DorisParserParserWHERE {
			{
				p.SetState(2542)
				p.WildWhere()
			}

		}

	case 85:
		localctx = NewShowTransactionContext(p, localctx)
		p.EnterOuterAlt(localctx, 85)
		{
			p.SetState(2545)
			p.Match(DorisParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2546)
			p.Match(DorisParserParserTRANSACTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2549)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserFROM || _la == DorisParserParserIN {
			{
				p.SetState(2547)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserParserFROM || _la == DorisParserParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(2548)

				var _x = p.MultipartIdentifier()

				localctx.(*ShowTransactionContext).database = _x
			}

		}
		p.SetState(2552)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserLIKE || _la == DorisParserParserWHERE {
			{
				p.SetState(2551)
				p.WildWhere()
			}

		}

	case 86:
		localctx = NewShowReplicaStatusContext(p, localctx)
		p.EnterOuterAlt(localctx, 86)
		{
			p.SetState(2554)
			p.Match(DorisParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2555)
			p.Match(DorisParserParserREPLICA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2556)
			p.Match(DorisParserParserSTATUS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2557)
			p.Match(DorisParserParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2558)
			p.BaseTableRef()
		}
		p.SetState(2560)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserWHERE {
			{
				p.SetState(2559)
				p.WhereClause()
			}

		}

	case 87:
		localctx = NewShowWorkloadGroupsContext(p, localctx)
		p.EnterOuterAlt(localctx, 87)
		{
			p.SetState(2562)
			p.Match(DorisParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2563)
			p.Match(DorisParserParserWORKLOAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2564)
			p.Match(DorisParserParserGROUPS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2567)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserLIKE {
			{
				p.SetState(2565)
				p.Match(DorisParserParserLIKE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2566)
				p.Match(DorisParserParserSTRING_LITERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 88:
		localctx = NewShowCopyContext(p, localctx)
		p.EnterOuterAlt(localctx, 88)
		{
			p.SetState(2569)
			p.Match(DorisParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2570)
			p.Match(DorisParserParserCOPY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2573)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserFROM || _la == DorisParserParserIN {
			{
				p.SetState(2571)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserParserFROM || _la == DorisParserParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(2572)

				var _x = p.Identifier()

				localctx.(*ShowCopyContext).database = _x
			}

		}
		p.SetState(2576)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserWHERE {
			{
				p.SetState(2575)
				p.WhereClause()
			}

		}
		p.SetState(2579)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserORDER {
			{
				p.SetState(2578)
				p.SortClause()
			}

		}
		p.SetState(2582)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserLIMIT {
			{
				p.SetState(2581)
				p.LimitClause()
			}

		}

	case 89:
		localctx = NewShowQueryStatsContext(p, localctx)
		p.EnterOuterAlt(localctx, 89)
		{
			p.SetState(2584)
			p.Match(DorisParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2585)
			p.Match(DorisParserParserQUERY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2586)
			p.Match(DorisParserParserSTATS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2597)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		switch p.GetTokenStream().LA(1) {
		case DorisParserParserFOR:
			{
				p.SetState(2587)
				p.Match(DorisParserParserFOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2588)

				var _x = p.Identifier()

				localctx.(*ShowQueryStatsContext).database = _x
			}

		case DorisParserParserFROM:
			{
				p.SetState(2589)
				p.Match(DorisParserParserFROM)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2590)

				var _x = p.MultipartIdentifier()

				localctx.(*ShowQueryStatsContext).tableName = _x
			}
			p.SetState(2595)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserParserALL {
				{
					p.SetState(2591)
					p.Match(DorisParserParserALL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(2593)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == DorisParserParserVERBOSE {
					{
						p.SetState(2592)
						p.Match(DorisParserParserVERBOSE)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}

			}

		case DorisParserParserEOF, DorisParserParserSEMICOLON:

		default:
		}

	case 90:
		localctx = NewShowIndexContext(p, localctx)
		p.EnterOuterAlt(localctx, 90)
		{
			p.SetState(2599)
			p.Match(DorisParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2600)
			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-227)) & ^0x3f) == 0 && ((int64(1)<<(_la-227))&201326595) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(2601)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserParserFROM || _la == DorisParserParserIN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(2602)

			var _x = p.MultipartIdentifier()

			localctx.(*ShowIndexContext).tableName = _x
		}
		p.SetState(2605)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserFROM || _la == DorisParserParserIN {
			{
				p.SetState(2603)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserParserFROM || _la == DorisParserParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(2604)

				var _x = p.MultipartIdentifier()

				localctx.(*ShowIndexContext).database = _x
			}

		}

	case 91:
		localctx = NewShowWarmUpJobContext(p, localctx)
		p.EnterOuterAlt(localctx, 91)
		{
			p.SetState(2607)
			p.Match(DorisParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2608)
			p.Match(DorisParserParserWARM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2609)
			p.Match(DorisParserParserUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2610)
			p.Match(DorisParserParserJOB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2612)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserLIKE || _la == DorisParserParserWHERE {
			{
				p.SetState(2611)
				p.WildWhere()
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISupportedLoadStatementContext is an interface to support dynamic dispatch.
type ISupportedLoadStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSupportedLoadStatementContext differentiates from other interfaces.
	IsSupportedLoadStatementContext()
}

type SupportedLoadStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySupportedLoadStatementContext() *SupportedLoadStatementContext {
	var p = new(SupportedLoadStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_supportedLoadStatement
	return p
}

func InitEmptySupportedLoadStatementContext(p *SupportedLoadStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_supportedLoadStatement
}

func (*SupportedLoadStatementContext) IsSupportedLoadStatementContext() {}

func NewSupportedLoadStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SupportedLoadStatementContext {
	var p = new(SupportedLoadStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_supportedLoadStatement

	return p
}

func (s *SupportedLoadStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SupportedLoadStatementContext) CopyAll(ctx *SupportedLoadStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *SupportedLoadStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedLoadStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ShowRoutineLoadContext struct {
	SupportedLoadStatementContext
	label IMultipartIdentifierContext
}

func NewShowRoutineLoadContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowRoutineLoadContext {
	var p = new(ShowRoutineLoadContext)

	InitEmptySupportedLoadStatementContext(&p.SupportedLoadStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedLoadStatementContext))

	return p
}

func (s *ShowRoutineLoadContext) GetLabel() IMultipartIdentifierContext { return s.label }

func (s *ShowRoutineLoadContext) SetLabel(v IMultipartIdentifierContext) { s.label = v }

func (s *ShowRoutineLoadContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowRoutineLoadContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSHOW, 0)
}

func (s *ShowRoutineLoadContext) ROUTINE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserROUTINE, 0)
}

func (s *ShowRoutineLoadContext) LOAD() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLOAD, 0)
}

func (s *ShowRoutineLoadContext) ALL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserALL, 0)
}

func (s *ShowRoutineLoadContext) FOR() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFOR, 0)
}

func (s *ShowRoutineLoadContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowRoutineLoadContext) LIKE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLIKE, 0)
}

func (s *ShowRoutineLoadContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTRING_LITERAL, 0)
}

func (s *ShowRoutineLoadContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitShowRoutineLoad(s)

	default:
		return t.VisitChildren(s)
	}
}

type ResumeRoutineLoadContext struct {
	SupportedLoadStatementContext
	label IMultipartIdentifierContext
}

func NewResumeRoutineLoadContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ResumeRoutineLoadContext {
	var p = new(ResumeRoutineLoadContext)

	InitEmptySupportedLoadStatementContext(&p.SupportedLoadStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedLoadStatementContext))

	return p
}

func (s *ResumeRoutineLoadContext) GetLabel() IMultipartIdentifierContext { return s.label }

func (s *ResumeRoutineLoadContext) SetLabel(v IMultipartIdentifierContext) { s.label = v }

func (s *ResumeRoutineLoadContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResumeRoutineLoadContext) RESUME() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRESUME, 0)
}

func (s *ResumeRoutineLoadContext) ROUTINE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserROUTINE, 0)
}

func (s *ResumeRoutineLoadContext) LOAD() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLOAD, 0)
}

func (s *ResumeRoutineLoadContext) FOR() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFOR, 0)
}

func (s *ResumeRoutineLoadContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ResumeRoutineLoadContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitResumeRoutineLoad(s)

	default:
		return t.VisitChildren(s)
	}
}

type CreateRoutineLoadAliasContext struct {
	SupportedLoadStatementContext
}

func NewCreateRoutineLoadAliasContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateRoutineLoadAliasContext {
	var p = new(CreateRoutineLoadAliasContext)

	InitEmptySupportedLoadStatementContext(&p.SupportedLoadStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedLoadStatementContext))

	return p
}

func (s *CreateRoutineLoadAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateRoutineLoadAliasContext) CreateRoutineLoad() ICreateRoutineLoadContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateRoutineLoadContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateRoutineLoadContext)
}

func (s *CreateRoutineLoadAliasContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitCreateRoutineLoadAlias(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowIndexTokenizerContext struct {
	SupportedLoadStatementContext
}

func NewShowIndexTokenizerContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowIndexTokenizerContext {
	var p = new(ShowIndexTokenizerContext)

	InitEmptySupportedLoadStatementContext(&p.SupportedLoadStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedLoadStatementContext))

	return p
}

func (s *ShowIndexTokenizerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowIndexTokenizerContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSHOW, 0)
}

func (s *ShowIndexTokenizerContext) INVERTED() antlr.TerminalNode {
	return s.GetToken(DorisParserParserINVERTED, 0)
}

func (s *ShowIndexTokenizerContext) INDEX() antlr.TerminalNode {
	return s.GetToken(DorisParserParserINDEX, 0)
}

func (s *ShowIndexTokenizerContext) TOKENIZER() antlr.TerminalNode {
	return s.GetToken(DorisParserParserTOKENIZER, 0)
}

func (s *ShowIndexTokenizerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitShowIndexTokenizer(s)

	default:
		return t.VisitChildren(s)
	}
}

type PauseAllRoutineLoadContext struct {
	SupportedLoadStatementContext
}

func NewPauseAllRoutineLoadContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PauseAllRoutineLoadContext {
	var p = new(PauseAllRoutineLoadContext)

	InitEmptySupportedLoadStatementContext(&p.SupportedLoadStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedLoadStatementContext))

	return p
}

func (s *PauseAllRoutineLoadContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PauseAllRoutineLoadContext) PAUSE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserPAUSE, 0)
}

func (s *PauseAllRoutineLoadContext) ALL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserALL, 0)
}

func (s *PauseAllRoutineLoadContext) ROUTINE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserROUTINE, 0)
}

func (s *PauseAllRoutineLoadContext) LOAD() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLOAD, 0)
}

func (s *PauseAllRoutineLoadContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitPauseAllRoutineLoad(s)

	default:
		return t.VisitChildren(s)
	}
}

type SyncContext struct {
	SupportedLoadStatementContext
}

func NewSyncContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SyncContext {
	var p = new(SyncContext)

	InitEmptySupportedLoadStatementContext(&p.SupportedLoadStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedLoadStatementContext))

	return p
}

func (s *SyncContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SyncContext) SYNC() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSYNC, 0)
}

func (s *SyncContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitSync(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowCreateRoutineLoadContext struct {
	SupportedLoadStatementContext
	label IMultipartIdentifierContext
}

func NewShowCreateRoutineLoadContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowCreateRoutineLoadContext {
	var p = new(ShowCreateRoutineLoadContext)

	InitEmptySupportedLoadStatementContext(&p.SupportedLoadStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedLoadStatementContext))

	return p
}

func (s *ShowCreateRoutineLoadContext) GetLabel() IMultipartIdentifierContext { return s.label }

func (s *ShowCreateRoutineLoadContext) SetLabel(v IMultipartIdentifierContext) { s.label = v }

func (s *ShowCreateRoutineLoadContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCreateRoutineLoadContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSHOW, 0)
}

func (s *ShowCreateRoutineLoadContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCREATE, 0)
}

func (s *ShowCreateRoutineLoadContext) ROUTINE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserROUTINE, 0)
}

func (s *ShowCreateRoutineLoadContext) LOAD() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLOAD, 0)
}

func (s *ShowCreateRoutineLoadContext) FOR() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFOR, 0)
}

func (s *ShowCreateRoutineLoadContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowCreateRoutineLoadContext) ALL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserALL, 0)
}

func (s *ShowCreateRoutineLoadContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitShowCreateRoutineLoad(s)

	default:
		return t.VisitChildren(s)
	}
}

type PauseRoutineLoadContext struct {
	SupportedLoadStatementContext
	label IMultipartIdentifierContext
}

func NewPauseRoutineLoadContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PauseRoutineLoadContext {
	var p = new(PauseRoutineLoadContext)

	InitEmptySupportedLoadStatementContext(&p.SupportedLoadStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedLoadStatementContext))

	return p
}

func (s *PauseRoutineLoadContext) GetLabel() IMultipartIdentifierContext { return s.label }

func (s *PauseRoutineLoadContext) SetLabel(v IMultipartIdentifierContext) { s.label = v }

func (s *PauseRoutineLoadContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PauseRoutineLoadContext) PAUSE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserPAUSE, 0)
}

func (s *PauseRoutineLoadContext) ROUTINE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserROUTINE, 0)
}

func (s *PauseRoutineLoadContext) LOAD() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLOAD, 0)
}

func (s *PauseRoutineLoadContext) FOR() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFOR, 0)
}

func (s *PauseRoutineLoadContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *PauseRoutineLoadContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitPauseRoutineLoad(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowIndexTokenFilterContext struct {
	SupportedLoadStatementContext
}

func NewShowIndexTokenFilterContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowIndexTokenFilterContext {
	var p = new(ShowIndexTokenFilterContext)

	InitEmptySupportedLoadStatementContext(&p.SupportedLoadStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedLoadStatementContext))

	return p
}

func (s *ShowIndexTokenFilterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowIndexTokenFilterContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSHOW, 0)
}

func (s *ShowIndexTokenFilterContext) INVERTED() antlr.TerminalNode {
	return s.GetToken(DorisParserParserINVERTED, 0)
}

func (s *ShowIndexTokenFilterContext) INDEX() antlr.TerminalNode {
	return s.GetToken(DorisParserParserINDEX, 0)
}

func (s *ShowIndexTokenFilterContext) TOKEN_FILTER() antlr.TerminalNode {
	return s.GetToken(DorisParserParserTOKEN_FILTER, 0)
}

func (s *ShowIndexTokenFilterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitShowIndexTokenFilter(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowIndexAnalyzerContext struct {
	SupportedLoadStatementContext
}

func NewShowIndexAnalyzerContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowIndexAnalyzerContext {
	var p = new(ShowIndexAnalyzerContext)

	InitEmptySupportedLoadStatementContext(&p.SupportedLoadStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedLoadStatementContext))

	return p
}

func (s *ShowIndexAnalyzerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowIndexAnalyzerContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSHOW, 0)
}

func (s *ShowIndexAnalyzerContext) INVERTED() antlr.TerminalNode {
	return s.GetToken(DorisParserParserINVERTED, 0)
}

func (s *ShowIndexAnalyzerContext) INDEX() antlr.TerminalNode {
	return s.GetToken(DorisParserParserINDEX, 0)
}

func (s *ShowIndexAnalyzerContext) ANALYZER() antlr.TerminalNode {
	return s.GetToken(DorisParserParserANALYZER, 0)
}

func (s *ShowIndexAnalyzerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitShowIndexAnalyzer(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowRoutineLoadTaskContext struct {
	SupportedLoadStatementContext
	database IIdentifierContext
}

func NewShowRoutineLoadTaskContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowRoutineLoadTaskContext {
	var p = new(ShowRoutineLoadTaskContext)

	InitEmptySupportedLoadStatementContext(&p.SupportedLoadStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedLoadStatementContext))

	return p
}

func (s *ShowRoutineLoadTaskContext) GetDatabase() IIdentifierContext { return s.database }

func (s *ShowRoutineLoadTaskContext) SetDatabase(v IIdentifierContext) { s.database = v }

func (s *ShowRoutineLoadTaskContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowRoutineLoadTaskContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSHOW, 0)
}

func (s *ShowRoutineLoadTaskContext) ROUTINE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserROUTINE, 0)
}

func (s *ShowRoutineLoadTaskContext) LOAD() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLOAD, 0)
}

func (s *ShowRoutineLoadTaskContext) TASK() antlr.TerminalNode {
	return s.GetToken(DorisParserParserTASK, 0)
}

func (s *ShowRoutineLoadTaskContext) WildWhere() IWildWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWildWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWildWhereContext)
}

func (s *ShowRoutineLoadTaskContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFROM, 0)
}

func (s *ShowRoutineLoadTaskContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserIN, 0)
}

func (s *ShowRoutineLoadTaskContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowRoutineLoadTaskContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitShowRoutineLoadTask(s)

	default:
		return t.VisitChildren(s)
	}
}

type ResumeAllRoutineLoadContext struct {
	SupportedLoadStatementContext
}

func NewResumeAllRoutineLoadContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ResumeAllRoutineLoadContext {
	var p = new(ResumeAllRoutineLoadContext)

	InitEmptySupportedLoadStatementContext(&p.SupportedLoadStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedLoadStatementContext))

	return p
}

func (s *ResumeAllRoutineLoadContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResumeAllRoutineLoadContext) RESUME() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRESUME, 0)
}

func (s *ResumeAllRoutineLoadContext) ALL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserALL, 0)
}

func (s *ResumeAllRoutineLoadContext) ROUTINE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserROUTINE, 0)
}

func (s *ResumeAllRoutineLoadContext) LOAD() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLOAD, 0)
}

func (s *ResumeAllRoutineLoadContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitResumeAllRoutineLoad(s)

	default:
		return t.VisitChildren(s)
	}
}

type StopRoutineLoadContext struct {
	SupportedLoadStatementContext
	label IMultipartIdentifierContext
}

func NewStopRoutineLoadContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StopRoutineLoadContext {
	var p = new(StopRoutineLoadContext)

	InitEmptySupportedLoadStatementContext(&p.SupportedLoadStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedLoadStatementContext))

	return p
}

func (s *StopRoutineLoadContext) GetLabel() IMultipartIdentifierContext { return s.label }

func (s *StopRoutineLoadContext) SetLabel(v IMultipartIdentifierContext) { s.label = v }

func (s *StopRoutineLoadContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StopRoutineLoadContext) STOP() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTOP, 0)
}

func (s *StopRoutineLoadContext) ROUTINE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserROUTINE, 0)
}

func (s *StopRoutineLoadContext) LOAD() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLOAD, 0)
}

func (s *StopRoutineLoadContext) FOR() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFOR, 0)
}

func (s *StopRoutineLoadContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *StopRoutineLoadContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitStopRoutineLoad(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) SupportedLoadStatement() (localctx ISupportedLoadStatementContext) {
	localctx = NewSupportedLoadStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, DorisParserParserRULE_supportedLoadStatement)
	var _la int

	p.SetState(2687)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 352, p.GetParserRuleContext()) {
	case 1:
		localctx = NewSyncContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2616)
			p.Match(DorisParserParserSYNC)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewCreateRoutineLoadAliasContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2617)
			p.CreateRoutineLoad()
		}

	case 3:
		localctx = NewShowCreateRoutineLoadContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2618)
			p.Match(DorisParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2620)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserALL {
			{
				p.SetState(2619)
				p.Match(DorisParserParserALL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2622)
			p.Match(DorisParserParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2623)
			p.Match(DorisParserParserROUTINE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2624)
			p.Match(DorisParserParserLOAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2625)
			p.Match(DorisParserParserFOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2626)

			var _x = p.MultipartIdentifier()

			localctx.(*ShowCreateRoutineLoadContext).label = _x
		}

	case 4:
		localctx = NewPauseRoutineLoadContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2627)
			p.Match(DorisParserParserPAUSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2628)
			p.Match(DorisParserParserROUTINE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2629)
			p.Match(DorisParserParserLOAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2630)
			p.Match(DorisParserParserFOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2631)

			var _x = p.MultipartIdentifier()

			localctx.(*PauseRoutineLoadContext).label = _x
		}

	case 5:
		localctx = NewPauseAllRoutineLoadContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2632)
			p.Match(DorisParserParserPAUSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2633)
			p.Match(DorisParserParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2634)
			p.Match(DorisParserParserROUTINE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2635)
			p.Match(DorisParserParserLOAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		localctx = NewResumeRoutineLoadContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2636)
			p.Match(DorisParserParserRESUME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2637)
			p.Match(DorisParserParserROUTINE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2638)
			p.Match(DorisParserParserLOAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2639)
			p.Match(DorisParserParserFOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2640)

			var _x = p.MultipartIdentifier()

			localctx.(*ResumeRoutineLoadContext).label = _x
		}

	case 7:
		localctx = NewResumeAllRoutineLoadContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(2641)
			p.Match(DorisParserParserRESUME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2642)
			p.Match(DorisParserParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2643)
			p.Match(DorisParserParserROUTINE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2644)
			p.Match(DorisParserParserLOAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 8:
		localctx = NewStopRoutineLoadContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(2645)
			p.Match(DorisParserParserSTOP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2646)
			p.Match(DorisParserParserROUTINE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2647)
			p.Match(DorisParserParserLOAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2648)
			p.Match(DorisParserParserFOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2649)

			var _x = p.MultipartIdentifier()

			localctx.(*StopRoutineLoadContext).label = _x
		}

	case 9:
		localctx = NewShowRoutineLoadContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(2650)
			p.Match(DorisParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2652)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserALL {
			{
				p.SetState(2651)
				p.Match(DorisParserParserALL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2654)
			p.Match(DorisParserParserROUTINE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2655)
			p.Match(DorisParserParserLOAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2662)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserParserFOR:
			{
				p.SetState(2656)
				p.Match(DorisParserParserFOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2657)

				var _x = p.MultipartIdentifier()

				localctx.(*ShowRoutineLoadContext).label = _x
			}

		case DorisParserParserEOF, DorisParserParserSEMICOLON, DorisParserParserLIKE:
			p.SetState(2660)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserParserLIKE {
				{
					p.SetState(2658)
					p.Match(DorisParserParserLIKE)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2659)
					p.Match(DorisParserParserSTRING_LITERAL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 10:
		localctx = NewShowRoutineLoadTaskContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(2664)
			p.Match(DorisParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2665)
			p.Match(DorisParserParserROUTINE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2666)
			p.Match(DorisParserParserLOAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2667)
			p.Match(DorisParserParserTASK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2670)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserFROM || _la == DorisParserParserIN {
			{
				p.SetState(2668)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserParserFROM || _la == DorisParserParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(2669)

				var _x = p.Identifier()

				localctx.(*ShowRoutineLoadTaskContext).database = _x
			}

		}
		p.SetState(2673)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserLIKE || _la == DorisParserParserWHERE {
			{
				p.SetState(2672)
				p.WildWhere()
			}

		}

	case 11:
		localctx = NewShowIndexAnalyzerContext(p, localctx)
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(2675)
			p.Match(DorisParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2676)
			p.Match(DorisParserParserINVERTED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2677)
			p.Match(DorisParserParserINDEX)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2678)
			p.Match(DorisParserParserANALYZER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 12:
		localctx = NewShowIndexTokenizerContext(p, localctx)
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(2679)
			p.Match(DorisParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2680)
			p.Match(DorisParserParserINVERTED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2681)
			p.Match(DorisParserParserINDEX)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2682)
			p.Match(DorisParserParserTOKENIZER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 13:
		localctx = NewShowIndexTokenFilterContext(p, localctx)
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(2683)
			p.Match(DorisParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2684)
			p.Match(DorisParserParserINVERTED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2685)
			p.Match(DorisParserParserINDEX)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2686)
			p.Match(DorisParserParserTOKEN_FILTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISupportedKillStatementContext is an interface to support dynamic dispatch.
type ISupportedKillStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSupportedKillStatementContext differentiates from other interfaces.
	IsSupportedKillStatementContext()
}

type SupportedKillStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySupportedKillStatementContext() *SupportedKillStatementContext {
	var p = new(SupportedKillStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_supportedKillStatement
	return p
}

func InitEmptySupportedKillStatementContext(p *SupportedKillStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_supportedKillStatement
}

func (*SupportedKillStatementContext) IsSupportedKillStatementContext() {}

func NewSupportedKillStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SupportedKillStatementContext {
	var p = new(SupportedKillStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_supportedKillStatement

	return p
}

func (s *SupportedKillStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SupportedKillStatementContext) CopyAll(ctx *SupportedKillStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *SupportedKillStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedKillStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type KillQueryContext struct {
	SupportedKillStatementContext
}

func NewKillQueryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *KillQueryContext {
	var p = new(KillQueryContext)

	InitEmptySupportedKillStatementContext(&p.SupportedKillStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedKillStatementContext))

	return p
}

func (s *KillQueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KillQueryContext) KILL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserKILL, 0)
}

func (s *KillQueryContext) QUERY() antlr.TerminalNode {
	return s.GetToken(DorisParserParserQUERY, 0)
}

func (s *KillQueryContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserINTEGER_VALUE, 0)
}

func (s *KillQueryContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTRING_LITERAL, 0)
}

func (s *KillQueryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitKillQuery(s)

	default:
		return t.VisitChildren(s)
	}
}

type KillConnectionContext struct {
	SupportedKillStatementContext
}

func NewKillConnectionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *KillConnectionContext {
	var p = new(KillConnectionContext)

	InitEmptySupportedKillStatementContext(&p.SupportedKillStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedKillStatementContext))

	return p
}

func (s *KillConnectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KillConnectionContext) KILL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserKILL, 0)
}

func (s *KillConnectionContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserINTEGER_VALUE, 0)
}

func (s *KillConnectionContext) CONNECTION() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCONNECTION, 0)
}

func (s *KillConnectionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitKillConnection(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) SupportedKillStatement() (localctx ISupportedKillStatementContext) {
	localctx = NewSupportedKillStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, DorisParserParserRULE_supportedKillStatement)
	var _la int

	p.SetState(2697)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 354, p.GetParserRuleContext()) {
	case 1:
		localctx = NewKillConnectionContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2689)
			p.Match(DorisParserParserKILL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2691)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserCONNECTION {
			{
				p.SetState(2690)
				p.Match(DorisParserParserCONNECTION)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2693)
			p.Match(DorisParserParserINTEGER_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewKillQueryContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2694)
			p.Match(DorisParserParserKILL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2695)
			p.Match(DorisParserParserQUERY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2696)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserParserSTRING_LITERAL || _la == DorisParserParserINTEGER_VALUE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISupportedOtherStatementContext is an interface to support dynamic dispatch.
type ISupportedOtherStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSupportedOtherStatementContext differentiates from other interfaces.
	IsSupportedOtherStatementContext()
}

type SupportedOtherStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySupportedOtherStatementContext() *SupportedOtherStatementContext {
	var p = new(SupportedOtherStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_supportedOtherStatement
	return p
}

func InitEmptySupportedOtherStatementContext(p *SupportedOtherStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_supportedOtherStatement
}

func (*SupportedOtherStatementContext) IsSupportedOtherStatementContext() {}

func NewSupportedOtherStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SupportedOtherStatementContext {
	var p = new(SupportedOtherStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_supportedOtherStatement

	return p
}

func (s *SupportedOtherStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SupportedOtherStatementContext) CopyAll(ctx *SupportedOtherStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *SupportedOtherStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedOtherStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type HelpContext struct {
	SupportedOtherStatementContext
	mark IIdentifierOrTextContext
}

func NewHelpContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *HelpContext {
	var p = new(HelpContext)

	InitEmptySupportedOtherStatementContext(&p.SupportedOtherStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedOtherStatementContext))

	return p
}

func (s *HelpContext) GetMark() IIdentifierOrTextContext { return s.mark }

func (s *HelpContext) SetMark(v IIdentifierOrTextContext) { s.mark = v }

func (s *HelpContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HelpContext) HELP() antlr.TerminalNode {
	return s.GetToken(DorisParserParserHELP, 0)
}

func (s *HelpContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *HelpContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitHelp(s)

	default:
		return t.VisitChildren(s)
	}
}

type UnlockTablesContext struct {
	SupportedOtherStatementContext
}

func NewUnlockTablesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnlockTablesContext {
	var p = new(UnlockTablesContext)

	InitEmptySupportedOtherStatementContext(&p.SupportedOtherStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedOtherStatementContext))

	return p
}

func (s *UnlockTablesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnlockTablesContext) UNLOCK() antlr.TerminalNode {
	return s.GetToken(DorisParserParserUNLOCK, 0)
}

func (s *UnlockTablesContext) TABLES() antlr.TerminalNode {
	return s.GetToken(DorisParserParserTABLES, 0)
}

func (s *UnlockTablesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitUnlockTables(s)

	default:
		return t.VisitChildren(s)
	}
}

type UninstallPluginContext struct {
	SupportedOtherStatementContext
	name IIdentifierOrTextContext
}

func NewUninstallPluginContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UninstallPluginContext {
	var p = new(UninstallPluginContext)

	InitEmptySupportedOtherStatementContext(&p.SupportedOtherStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedOtherStatementContext))

	return p
}

func (s *UninstallPluginContext) GetName() IIdentifierOrTextContext { return s.name }

func (s *UninstallPluginContext) SetName(v IIdentifierOrTextContext) { s.name = v }

func (s *UninstallPluginContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UninstallPluginContext) UNINSTALL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserUNINSTALL, 0)
}

func (s *UninstallPluginContext) PLUGIN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserPLUGIN, 0)
}

func (s *UninstallPluginContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *UninstallPluginContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitUninstallPlugin(s)

	default:
		return t.VisitChildren(s)
	}
}

type BackupContext struct {
	SupportedOtherStatementContext
	label      IMultipartIdentifierContext
	repo       IIdentifierContext
	properties IPropertyClauseContext
}

func NewBackupContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BackupContext {
	var p = new(BackupContext)

	InitEmptySupportedOtherStatementContext(&p.SupportedOtherStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedOtherStatementContext))

	return p
}

func (s *BackupContext) GetLabel() IMultipartIdentifierContext { return s.label }

func (s *BackupContext) GetRepo() IIdentifierContext { return s.repo }

func (s *BackupContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *BackupContext) SetLabel(v IMultipartIdentifierContext) { s.label = v }

func (s *BackupContext) SetRepo(v IIdentifierContext) { s.repo = v }

func (s *BackupContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *BackupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BackupContext) BACKUP() antlr.TerminalNode {
	return s.GetToken(DorisParserParserBACKUP, 0)
}

func (s *BackupContext) SNAPSHOT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSNAPSHOT, 0)
}

func (s *BackupContext) TO() antlr.TerminalNode {
	return s.GetToken(DorisParserParserTO, 0)
}

func (s *BackupContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *BackupContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *BackupContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLEFT_PAREN, 0)
}

func (s *BackupContext) AllBaseTableRef() []IBaseTableRefContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IBaseTableRefContext); ok {
			len++
		}
	}

	tst := make([]IBaseTableRefContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IBaseTableRefContext); ok {
			tst[i] = t.(IBaseTableRefContext)
			i++
		}
	}

	return tst
}

func (s *BackupContext) BaseTableRef(i int) IBaseTableRefContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBaseTableRefContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBaseTableRefContext)
}

func (s *BackupContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRIGHT_PAREN, 0)
}

func (s *BackupContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisParserParserON, 0)
}

func (s *BackupContext) EXCLUDE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserEXCLUDE, 0)
}

func (s *BackupContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *BackupContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserCOMMA)
}

func (s *BackupContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOMMA, i)
}

func (s *BackupContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitBackup(s)

	default:
		return t.VisitChildren(s)
	}
}

type LockTablesContext struct {
	SupportedOtherStatementContext
}

func NewLockTablesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LockTablesContext {
	var p = new(LockTablesContext)

	InitEmptySupportedOtherStatementContext(&p.SupportedOtherStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedOtherStatementContext))

	return p
}

func (s *LockTablesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LockTablesContext) LOCK() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLOCK, 0)
}

func (s *LockTablesContext) TABLES() antlr.TerminalNode {
	return s.GetToken(DorisParserParserTABLES, 0)
}

func (s *LockTablesContext) AllLockTable() []ILockTableContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILockTableContext); ok {
			len++
		}
	}

	tst := make([]ILockTableContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILockTableContext); ok {
			tst[i] = t.(ILockTableContext)
			i++
		}
	}

	return tst
}

func (s *LockTablesContext) LockTable(i int) ILockTableContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILockTableContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILockTableContext)
}

func (s *LockTablesContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserCOMMA)
}

func (s *LockTablesContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOMMA, i)
}

func (s *LockTablesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitLockTables(s)

	default:
		return t.VisitChildren(s)
	}
}

type RestoreContext struct {
	SupportedOtherStatementContext
	label      IMultipartIdentifierContext
	repo       IIdentifierContext
	properties IPropertyClauseContext
}

func NewRestoreContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RestoreContext {
	var p = new(RestoreContext)

	InitEmptySupportedOtherStatementContext(&p.SupportedOtherStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedOtherStatementContext))

	return p
}

func (s *RestoreContext) GetLabel() IMultipartIdentifierContext { return s.label }

func (s *RestoreContext) GetRepo() IIdentifierContext { return s.repo }

func (s *RestoreContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *RestoreContext) SetLabel(v IMultipartIdentifierContext) { s.label = v }

func (s *RestoreContext) SetRepo(v IIdentifierContext) { s.repo = v }

func (s *RestoreContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *RestoreContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RestoreContext) RESTORE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRESTORE, 0)
}

func (s *RestoreContext) SNAPSHOT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSNAPSHOT, 0)
}

func (s *RestoreContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFROM, 0)
}

func (s *RestoreContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *RestoreContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *RestoreContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLEFT_PAREN, 0)
}

func (s *RestoreContext) AllBaseTableRef() []IBaseTableRefContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IBaseTableRefContext); ok {
			len++
		}
	}

	tst := make([]IBaseTableRefContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IBaseTableRefContext); ok {
			tst[i] = t.(IBaseTableRefContext)
			i++
		}
	}

	return tst
}

func (s *RestoreContext) BaseTableRef(i int) IBaseTableRefContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBaseTableRefContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBaseTableRefContext)
}

func (s *RestoreContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRIGHT_PAREN, 0)
}

func (s *RestoreContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisParserParserON, 0)
}

func (s *RestoreContext) EXCLUDE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserEXCLUDE, 0)
}

func (s *RestoreContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *RestoreContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserCOMMA)
}

func (s *RestoreContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOMMA, i)
}

func (s *RestoreContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitRestore(s)

	default:
		return t.VisitChildren(s)
	}
}

type InstallPluginContext struct {
	SupportedOtherStatementContext
	source     IIdentifierOrTextContext
	properties IPropertyClauseContext
}

func NewInstallPluginContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InstallPluginContext {
	var p = new(InstallPluginContext)

	InitEmptySupportedOtherStatementContext(&p.SupportedOtherStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedOtherStatementContext))

	return p
}

func (s *InstallPluginContext) GetSource() IIdentifierOrTextContext { return s.source }

func (s *InstallPluginContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *InstallPluginContext) SetSource(v IIdentifierOrTextContext) { s.source = v }

func (s *InstallPluginContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *InstallPluginContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InstallPluginContext) INSTALL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserINSTALL, 0)
}

func (s *InstallPluginContext) PLUGIN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserPLUGIN, 0)
}

func (s *InstallPluginContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFROM, 0)
}

func (s *InstallPluginContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *InstallPluginContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *InstallPluginContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitInstallPlugin(s)

	default:
		return t.VisitChildren(s)
	}
}

type WarmUpClusterContext struct {
	SupportedOtherStatementContext
	destination IIdentifierContext
	source      IIdentifierContext
}

func NewWarmUpClusterContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *WarmUpClusterContext {
	var p = new(WarmUpClusterContext)

	InitEmptySupportedOtherStatementContext(&p.SupportedOtherStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedOtherStatementContext))

	return p
}

func (s *WarmUpClusterContext) GetDestination() IIdentifierContext { return s.destination }

func (s *WarmUpClusterContext) GetSource() IIdentifierContext { return s.source }

func (s *WarmUpClusterContext) SetDestination(v IIdentifierContext) { s.destination = v }

func (s *WarmUpClusterContext) SetSource(v IIdentifierContext) { s.source = v }

func (s *WarmUpClusterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WarmUpClusterContext) WARM() antlr.TerminalNode {
	return s.GetToken(DorisParserParserWARM, 0)
}

func (s *WarmUpClusterContext) UP() antlr.TerminalNode {
	return s.GetToken(DorisParserParserUP, 0)
}

func (s *WarmUpClusterContext) WITH() antlr.TerminalNode {
	return s.GetToken(DorisParserParserWITH, 0)
}

func (s *WarmUpClusterContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *WarmUpClusterContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *WarmUpClusterContext) AllCLUSTER() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserCLUSTER)
}

func (s *WarmUpClusterContext) CLUSTER(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserCLUSTER, i)
}

func (s *WarmUpClusterContext) AllCOMPUTE() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserCOMPUTE)
}

func (s *WarmUpClusterContext) COMPUTE(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOMPUTE, i)
}

func (s *WarmUpClusterContext) AllGROUP() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserGROUP)
}

func (s *WarmUpClusterContext) GROUP(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserGROUP, i)
}

func (s *WarmUpClusterContext) FORCE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFORCE, 0)
}

func (s *WarmUpClusterContext) AllWarmUpItem() []IWarmUpItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IWarmUpItemContext); ok {
			len++
		}
	}

	tst := make([]IWarmUpItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IWarmUpItemContext); ok {
			tst[i] = t.(IWarmUpItemContext)
			i++
		}
	}

	return tst
}

func (s *WarmUpClusterContext) WarmUpItem(i int) IWarmUpItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWarmUpItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWarmUpItemContext)
}

func (s *WarmUpClusterContext) AllAND() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserAND)
}

func (s *WarmUpClusterContext) AND(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserAND, i)
}

func (s *WarmUpClusterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitWarmUpCluster(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) SupportedOtherStatement() (localctx ISupportedOtherStatementContext) {
	localctx = NewSupportedOtherStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, DorisParserParserRULE_supportedOtherStatement)
	var _la int

	p.SetState(2797)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserParserHELP:
		localctx = NewHelpContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2699)
			p.Match(DorisParserParserHELP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2700)

			var _x = p.IdentifierOrText()

			localctx.(*HelpContext).mark = _x
		}

	case DorisParserParserUNLOCK:
		localctx = NewUnlockTablesContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2701)
			p.Match(DorisParserParserUNLOCK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2702)
			p.Match(DorisParserParserTABLES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserParserINSTALL:
		localctx = NewInstallPluginContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2703)
			p.Match(DorisParserParserINSTALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2704)
			p.Match(DorisParserParserPLUGIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2705)
			p.Match(DorisParserParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2706)

			var _x = p.IdentifierOrText()

			localctx.(*InstallPluginContext).source = _x
		}
		p.SetState(2708)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserPROPERTIES {
			{
				p.SetState(2707)

				var _x = p.PropertyClause()

				localctx.(*InstallPluginContext).properties = _x
			}

		}

	case DorisParserParserUNINSTALL:
		localctx = NewUninstallPluginContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2710)
			p.Match(DorisParserParserUNINSTALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2711)
			p.Match(DorisParserParserPLUGIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2712)

			var _x = p.IdentifierOrText()

			localctx.(*UninstallPluginContext).name = _x
		}

	case DorisParserParserLOCK:
		localctx = NewLockTablesContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2713)
			p.Match(DorisParserParserLOCK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2714)
			p.Match(DorisParserParserTABLES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2723)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-2305902462020672000) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&4609989332399152113) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-9080794533051819547) != 0) || ((int64((_la-192)) & ^0x3f) == 0 && ((int64(1)<<(_la-192))&2015220189171012521) != 0) || ((int64((_la-256)) & ^0x3f) == 0 && ((int64(1)<<(_la-256))&-5422616543060085911) != 0) || ((int64((_la-320)) & ^0x3f) == 0 && ((int64(1)<<(_la-320))&-4476015178520986877) != 0) || ((int64((_la-384)) & ^0x3f) == 0 && ((int64(1)<<(_la-384))&9222796779122679803) != 0) || ((int64((_la-452)) & ^0x3f) == 0 && ((int64(1)<<(_la-452))&2449945648119953137) != 0) || ((int64((_la-517)) & ^0x3f) == 0 && ((int64(1)<<(_la-517))&206187790337) != 0) {
			{
				p.SetState(2715)
				p.LockTable()
			}
			p.SetState(2720)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == DorisParserParserCOMMA {
				{
					p.SetState(2716)
					p.Match(DorisParserParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2717)
					p.LockTable()
				}

				p.SetState(2722)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}

	case DorisParserParserRESTORE:
		localctx = NewRestoreContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2725)
			p.Match(DorisParserParserRESTORE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2726)
			p.Match(DorisParserParserSNAPSHOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2727)

			var _x = p.MultipartIdentifier()

			localctx.(*RestoreContext).label = _x
		}
		{
			p.SetState(2728)
			p.Match(DorisParserParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2729)

			var _x = p.Identifier()

			localctx.(*RestoreContext).repo = _x
		}
		p.SetState(2742)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserEXCLUDE || _la == DorisParserParserON {
			{
				p.SetState(2730)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserParserEXCLUDE || _la == DorisParserParserON) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(2731)
				p.Match(DorisParserParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2732)
				p.BaseTableRef()
			}
			p.SetState(2737)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == DorisParserParserCOMMA {
				{
					p.SetState(2733)
					p.Match(DorisParserParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2734)
					p.BaseTableRef()
				}

				p.SetState(2739)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(2740)
				p.Match(DorisParserParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(2745)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserPROPERTIES {
			{
				p.SetState(2744)

				var _x = p.PropertyClause()

				localctx.(*RestoreContext).properties = _x
			}

		}

	case DorisParserParserWARM:
		localctx = NewWarmUpClusterContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(2747)
			p.Match(DorisParserParserWARM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2748)
			p.Match(DorisParserParserUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2752)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserParserCLUSTER:
			{
				p.SetState(2749)
				p.Match(DorisParserParserCLUSTER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserParserCOMPUTE:
			{
				p.SetState(2750)
				p.Match(DorisParserParserCOMPUTE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2751)
				p.Match(DorisParserParserGROUP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(2754)

			var _x = p.Identifier()

			localctx.(*WarmUpClusterContext).destination = _x
		}
		{
			p.SetState(2755)
			p.Match(DorisParserParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2770)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserParserCLUSTER, DorisParserParserCOMPUTE:
			p.SetState(2759)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case DorisParserParserCLUSTER:
				{
					p.SetState(2756)
					p.Match(DorisParserParserCLUSTER)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case DorisParserParserCOMPUTE:
				{
					p.SetState(2757)
					p.Match(DorisParserParserCOMPUTE)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2758)
					p.Match(DorisParserParserGROUP)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}
			{
				p.SetState(2761)

				var _x = p.Identifier()

				localctx.(*WarmUpClusterContext).source = _x
			}

		case DorisParserParserTABLE:
			{
				p.SetState(2762)
				p.WarmUpItem()
			}
			p.SetState(2767)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == DorisParserParserAND {
				{
					p.SetState(2763)
					p.Match(DorisParserParserAND)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2764)
					p.WarmUpItem()
				}

				p.SetState(2769)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		p.SetState(2773)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserFORCE {
			{
				p.SetState(2772)
				p.Match(DorisParserParserFORCE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case DorisParserParserBACKUP:
		localctx = NewBackupContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(2775)
			p.Match(DorisParserParserBACKUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2776)
			p.Match(DorisParserParserSNAPSHOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2777)

			var _x = p.MultipartIdentifier()

			localctx.(*BackupContext).label = _x
		}
		{
			p.SetState(2778)
			p.Match(DorisParserParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2779)

			var _x = p.Identifier()

			localctx.(*BackupContext).repo = _x
		}
		p.SetState(2792)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserEXCLUDE || _la == DorisParserParserON {
			{
				p.SetState(2780)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserParserEXCLUDE || _la == DorisParserParserON) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(2781)
				p.Match(DorisParserParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2782)
				p.BaseTableRef()
			}
			p.SetState(2787)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == DorisParserParserCOMMA {
				{
					p.SetState(2783)
					p.Match(DorisParserParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2784)
					p.BaseTableRef()
				}

				p.SetState(2789)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(2790)
				p.Match(DorisParserParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(2795)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserPROPERTIES {
			{
				p.SetState(2794)

				var _x = p.PropertyClause()

				localctx.(*BackupContext).properties = _x
			}

		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnsupportedOtherStatementContext is an interface to support dynamic dispatch.
type IUnsupportedOtherStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsUnsupportedOtherStatementContext differentiates from other interfaces.
	IsUnsupportedOtherStatementContext()
}

type UnsupportedOtherStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnsupportedOtherStatementContext() *UnsupportedOtherStatementContext {
	var p = new(UnsupportedOtherStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_unsupportedOtherStatement
	return p
}

func InitEmptyUnsupportedOtherStatementContext(p *UnsupportedOtherStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_unsupportedOtherStatement
}

func (*UnsupportedOtherStatementContext) IsUnsupportedOtherStatementContext() {}

func NewUnsupportedOtherStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnsupportedOtherStatementContext {
	var p = new(UnsupportedOtherStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_unsupportedOtherStatement

	return p
}

func (s *UnsupportedOtherStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *UnsupportedOtherStatementContext) CopyAll(ctx *UnsupportedOtherStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *UnsupportedOtherStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnsupportedOtherStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type UnsupportedStartTransactionContext struct {
	UnsupportedOtherStatementContext
}

func NewUnsupportedStartTransactionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnsupportedStartTransactionContext {
	var p = new(UnsupportedStartTransactionContext)

	InitEmptyUnsupportedOtherStatementContext(&p.UnsupportedOtherStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedOtherStatementContext))

	return p
}

func (s *UnsupportedStartTransactionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnsupportedStartTransactionContext) START() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTART, 0)
}

func (s *UnsupportedStartTransactionContext) TRANSACTION() antlr.TerminalNode {
	return s.GetToken(DorisParserParserTRANSACTION, 0)
}

func (s *UnsupportedStartTransactionContext) WITH() antlr.TerminalNode {
	return s.GetToken(DorisParserParserWITH, 0)
}

func (s *UnsupportedStartTransactionContext) CONSISTENT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCONSISTENT, 0)
}

func (s *UnsupportedStartTransactionContext) SNAPSHOT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSNAPSHOT, 0)
}

func (s *UnsupportedStartTransactionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitUnsupportedStartTransaction(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) UnsupportedOtherStatement() (localctx IUnsupportedOtherStatementContext) {
	localctx = NewUnsupportedOtherStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, DorisParserParserRULE_unsupportedOtherStatement)
	var _la int

	localctx = NewUnsupportedStartTransactionContext(p, localctx)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2799)
		p.Match(DorisParserParserSTART)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2800)
		p.Match(DorisParserParserTRANSACTION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2804)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserParserWITH {
		{
			p.SetState(2801)
			p.Match(DorisParserParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2802)
			p.Match(DorisParserParserCONSISTENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2803)
			p.Match(DorisParserParserSNAPSHOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWarmUpItemContext is an interface to support dynamic dispatch.
type IWarmUpItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetTableName returns the tableName rule contexts.
	GetTableName() IMultipartIdentifierContext

	// GetPartitionName returns the partitionName rule contexts.
	GetPartitionName() IIdentifierContext

	// SetTableName sets the tableName rule contexts.
	SetTableName(IMultipartIdentifierContext)

	// SetPartitionName sets the partitionName rule contexts.
	SetPartitionName(IIdentifierContext)

	// Getter signatures
	TABLE() antlr.TerminalNode
	MultipartIdentifier() IMultipartIdentifierContext
	PARTITION() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsWarmUpItemContext differentiates from other interfaces.
	IsWarmUpItemContext()
}

type WarmUpItemContext struct {
	antlr.BaseParserRuleContext
	parser        antlr.Parser
	tableName     IMultipartIdentifierContext
	partitionName IIdentifierContext
}

func NewEmptyWarmUpItemContext() *WarmUpItemContext {
	var p = new(WarmUpItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_warmUpItem
	return p
}

func InitEmptyWarmUpItemContext(p *WarmUpItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_warmUpItem
}

func (*WarmUpItemContext) IsWarmUpItemContext() {}

func NewWarmUpItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WarmUpItemContext {
	var p = new(WarmUpItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_warmUpItem

	return p
}

func (s *WarmUpItemContext) GetParser() antlr.Parser { return s.parser }

func (s *WarmUpItemContext) GetTableName() IMultipartIdentifierContext { return s.tableName }

func (s *WarmUpItemContext) GetPartitionName() IIdentifierContext { return s.partitionName }

func (s *WarmUpItemContext) SetTableName(v IMultipartIdentifierContext) { s.tableName = v }

func (s *WarmUpItemContext) SetPartitionName(v IIdentifierContext) { s.partitionName = v }

func (s *WarmUpItemContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserTABLE, 0)
}

func (s *WarmUpItemContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *WarmUpItemContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(DorisParserParserPARTITION, 0)
}

func (s *WarmUpItemContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *WarmUpItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WarmUpItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WarmUpItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitWarmUpItem(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) WarmUpItem() (localctx IWarmUpItemContext) {
	localctx = NewWarmUpItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, DorisParserParserRULE_warmUpItem)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2806)
		p.Match(DorisParserParserTABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2807)

		var _x = p.MultipartIdentifier()

		localctx.(*WarmUpItemContext).tableName = _x
	}
	p.SetState(2810)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserParserPARTITION {
		{
			p.SetState(2808)
			p.Match(DorisParserParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2809)

			var _x = p.Identifier()

			localctx.(*WarmUpItemContext).partitionName = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILockTableContext is an interface to support dynamic dispatch.
type ILockTableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name rule contexts.
	GetName() IMultipartIdentifierContext

	// GetAlias returns the alias rule contexts.
	GetAlias() IIdentifierOrTextContext

	// SetName sets the name rule contexts.
	SetName(IMultipartIdentifierContext)

	// SetAlias sets the alias rule contexts.
	SetAlias(IIdentifierOrTextContext)

	// Getter signatures
	MultipartIdentifier() IMultipartIdentifierContext
	READ() antlr.TerminalNode
	WRITE() antlr.TerminalNode
	AS() antlr.TerminalNode
	IdentifierOrText() IIdentifierOrTextContext
	LOCAL() antlr.TerminalNode
	LOW_PRIORITY() antlr.TerminalNode

	// IsLockTableContext differentiates from other interfaces.
	IsLockTableContext()
}

type LockTableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	name   IMultipartIdentifierContext
	alias  IIdentifierOrTextContext
}

func NewEmptyLockTableContext() *LockTableContext {
	var p = new(LockTableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_lockTable
	return p
}

func InitEmptyLockTableContext(p *LockTableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_lockTable
}

func (*LockTableContext) IsLockTableContext() {}

func NewLockTableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LockTableContext {
	var p = new(LockTableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_lockTable

	return p
}

func (s *LockTableContext) GetParser() antlr.Parser { return s.parser }

func (s *LockTableContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *LockTableContext) GetAlias() IIdentifierOrTextContext { return s.alias }

func (s *LockTableContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *LockTableContext) SetAlias(v IIdentifierOrTextContext) { s.alias = v }

func (s *LockTableContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *LockTableContext) READ() antlr.TerminalNode {
	return s.GetToken(DorisParserParserREAD, 0)
}

func (s *LockTableContext) WRITE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserWRITE, 0)
}

func (s *LockTableContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserAS, 0)
}

func (s *LockTableContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *LockTableContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLOCAL, 0)
}

func (s *LockTableContext) LOW_PRIORITY() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLOW_PRIORITY, 0)
}

func (s *LockTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LockTableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LockTableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitLockTable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) LockTable() (localctx ILockTableContext) {
	localctx = NewLockTableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, DorisParserParserRULE_lockTable)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2812)

		var _x = p.MultipartIdentifier()

		localctx.(*LockTableContext).name = _x
	}
	p.SetState(2815)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserParserAS {
		{
			p.SetState(2813)
			p.Match(DorisParserParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2814)

			var _x = p.IdentifierOrText()

			localctx.(*LockTableContext).alias = _x
		}

	}
	p.SetState(2825)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserParserREAD:
		{
			p.SetState(2817)
			p.Match(DorisParserParserREAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2819)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserLOCAL {
			{
				p.SetState(2818)
				p.Match(DorisParserParserLOCAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case DorisParserParserLOW_PRIORITY, DorisParserParserWRITE:
		p.SetState(2822)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserLOW_PRIORITY {
			{
				p.SetState(2821)
				p.Match(DorisParserParserLOW_PRIORITY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2824)
			p.Match(DorisParserParserWRITE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateRoutineLoadContext is an interface to support dynamic dispatch.
type ICreateRoutineLoadContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetLabel returns the label rule contexts.
	GetLabel() IMultipartIdentifierContext

	// GetTable returns the table rule contexts.
	GetTable() IIdentifierContext

	// GetType_ returns the type_ rule contexts.
	GetType_() IIdentifierContext

	// GetCustomProperties returns the customProperties rule contexts.
	GetCustomProperties() IPropertyItemListContext

	// SetLabel sets the label rule contexts.
	SetLabel(IMultipartIdentifierContext)

	// SetTable sets the table rule contexts.
	SetTable(IIdentifierContext)

	// SetType_ sets the type_ rule contexts.
	SetType_(IIdentifierContext)

	// SetCustomProperties sets the customProperties rule contexts.
	SetCustomProperties(IPropertyItemListContext)

	// Getter signatures
	CREATE() antlr.TerminalNode
	ROUTINE() antlr.TerminalNode
	LOAD() antlr.TerminalNode
	FROM() antlr.TerminalNode
	LEFT_PAREN() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode
	MultipartIdentifier() IMultipartIdentifierContext
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	PropertyItemList() IPropertyItemListContext
	ON() antlr.TerminalNode
	WITH() antlr.TerminalNode
	AllLoadProperty() []ILoadPropertyContext
	LoadProperty(i int) ILoadPropertyContext
	PropertyClause() IPropertyClauseContext
	CommentSpec() ICommentSpecContext
	APPEND() antlr.TerminalNode
	DELETE() antlr.TerminalNode
	MERGE() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsCreateRoutineLoadContext differentiates from other interfaces.
	IsCreateRoutineLoadContext()
}

type CreateRoutineLoadContext struct {
	antlr.BaseParserRuleContext
	parser           antlr.Parser
	label            IMultipartIdentifierContext
	table            IIdentifierContext
	type_            IIdentifierContext
	customProperties IPropertyItemListContext
}

func NewEmptyCreateRoutineLoadContext() *CreateRoutineLoadContext {
	var p = new(CreateRoutineLoadContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_createRoutineLoad
	return p
}

func InitEmptyCreateRoutineLoadContext(p *CreateRoutineLoadContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_createRoutineLoad
}

func (*CreateRoutineLoadContext) IsCreateRoutineLoadContext() {}

func NewCreateRoutineLoadContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateRoutineLoadContext {
	var p = new(CreateRoutineLoadContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_createRoutineLoad

	return p
}

func (s *CreateRoutineLoadContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateRoutineLoadContext) GetLabel() IMultipartIdentifierContext { return s.label }

func (s *CreateRoutineLoadContext) GetTable() IIdentifierContext { return s.table }

func (s *CreateRoutineLoadContext) GetType_() IIdentifierContext { return s.type_ }

func (s *CreateRoutineLoadContext) GetCustomProperties() IPropertyItemListContext {
	return s.customProperties
}

func (s *CreateRoutineLoadContext) SetLabel(v IMultipartIdentifierContext) { s.label = v }

func (s *CreateRoutineLoadContext) SetTable(v IIdentifierContext) { s.table = v }

func (s *CreateRoutineLoadContext) SetType_(v IIdentifierContext) { s.type_ = v }

func (s *CreateRoutineLoadContext) SetCustomProperties(v IPropertyItemListContext) {
	s.customProperties = v
}

func (s *CreateRoutineLoadContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCREATE, 0)
}

func (s *CreateRoutineLoadContext) ROUTINE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserROUTINE, 0)
}

func (s *CreateRoutineLoadContext) LOAD() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLOAD, 0)
}

func (s *CreateRoutineLoadContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFROM, 0)
}

func (s *CreateRoutineLoadContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLEFT_PAREN, 0)
}

func (s *CreateRoutineLoadContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRIGHT_PAREN, 0)
}

func (s *CreateRoutineLoadContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *CreateRoutineLoadContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *CreateRoutineLoadContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateRoutineLoadContext) PropertyItemList() IPropertyItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyItemListContext)
}

func (s *CreateRoutineLoadContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisParserParserON, 0)
}

func (s *CreateRoutineLoadContext) WITH() antlr.TerminalNode {
	return s.GetToken(DorisParserParserWITH, 0)
}

func (s *CreateRoutineLoadContext) AllLoadProperty() []ILoadPropertyContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILoadPropertyContext); ok {
			len++
		}
	}

	tst := make([]ILoadPropertyContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILoadPropertyContext); ok {
			tst[i] = t.(ILoadPropertyContext)
			i++
		}
	}

	return tst
}

func (s *CreateRoutineLoadContext) LoadProperty(i int) ILoadPropertyContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILoadPropertyContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILoadPropertyContext)
}

func (s *CreateRoutineLoadContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *CreateRoutineLoadContext) CommentSpec() ICommentSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentSpecContext)
}

func (s *CreateRoutineLoadContext) APPEND() antlr.TerminalNode {
	return s.GetToken(DorisParserParserAPPEND, 0)
}

func (s *CreateRoutineLoadContext) DELETE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDELETE, 0)
}

func (s *CreateRoutineLoadContext) MERGE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserMERGE, 0)
}

func (s *CreateRoutineLoadContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserCOMMA)
}

func (s *CreateRoutineLoadContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOMMA, i)
}

func (s *CreateRoutineLoadContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateRoutineLoadContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateRoutineLoadContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitCreateRoutineLoad(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) CreateRoutineLoad() (localctx ICreateRoutineLoadContext) {
	localctx = NewCreateRoutineLoadContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, DorisParserParserRULE_createRoutineLoad)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2827)
		p.Match(DorisParserParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2828)
		p.Match(DorisParserParserROUTINE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2829)
		p.Match(DorisParserParserLOAD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2830)

		var _x = p.MultipartIdentifier()

		localctx.(*CreateRoutineLoadContext).label = _x
	}
	p.SetState(2833)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserParserON {
		{
			p.SetState(2831)
			p.Match(DorisParserParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2832)

			var _x = p.Identifier()

			localctx.(*CreateRoutineLoadContext).table = _x
		}

	}
	p.SetState(2837)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserParserWITH {
		{
			p.SetState(2835)
			p.Match(DorisParserParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2836)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserParserAPPEND || _la == DorisParserParserDELETE || _la == DorisParserParserMERGE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(2847)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserParserCOLUMNS || _la == DorisParserParserDELETE || ((int64((_la-323)) & ^0x3f) == 0 && ((int64(1)<<(_la-323))&536871297) != 0) || _la == DorisParserParserTEMPORARY || _la == DorisParserParserWHERE {
		{
			p.SetState(2839)
			p.LoadProperty()
		}
		p.SetState(2844)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserParserCOMMA {
			{
				p.SetState(2840)
				p.Match(DorisParserParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2841)
				p.LoadProperty()
			}

			p.SetState(2846)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(2850)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserParserPROPERTIES {
		{
			p.SetState(2849)
			p.PropertyClause()
		}

	}
	{
		p.SetState(2852)
		p.Match(DorisParserParserFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2853)

		var _x = p.Identifier()

		localctx.(*CreateRoutineLoadContext).type_ = _x
	}
	{
		p.SetState(2854)
		p.Match(DorisParserParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2855)

		var _x = p.PropertyItemList()

		localctx.(*CreateRoutineLoadContext).customProperties = _x
	}
	{
		p.SetState(2856)
		p.Match(DorisParserParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2858)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserParserCOMMENT {
		{
			p.SetState(2857)
			p.CommentSpec()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnsupportedLoadStatementContext is an interface to support dynamic dispatch.
type IUnsupportedLoadStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsUnsupportedLoadStatementContext differentiates from other interfaces.
	IsUnsupportedLoadStatementContext()
}

type UnsupportedLoadStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnsupportedLoadStatementContext() *UnsupportedLoadStatementContext {
	var p = new(UnsupportedLoadStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_unsupportedLoadStatement
	return p
}

func InitEmptyUnsupportedLoadStatementContext(p *UnsupportedLoadStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_unsupportedLoadStatement
}

func (*UnsupportedLoadStatementContext) IsUnsupportedLoadStatementContext() {}

func NewUnsupportedLoadStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnsupportedLoadStatementContext {
	var p = new(UnsupportedLoadStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_unsupportedLoadStatement

	return p
}

func (s *UnsupportedLoadStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *UnsupportedLoadStatementContext) CopyAll(ctx *UnsupportedLoadStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *UnsupportedLoadStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnsupportedLoadStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ShowCreateLoadContext struct {
	UnsupportedLoadStatementContext
	label IMultipartIdentifierContext
}

func NewShowCreateLoadContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowCreateLoadContext {
	var p = new(ShowCreateLoadContext)

	InitEmptyUnsupportedLoadStatementContext(&p.UnsupportedLoadStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedLoadStatementContext))

	return p
}

func (s *ShowCreateLoadContext) GetLabel() IMultipartIdentifierContext { return s.label }

func (s *ShowCreateLoadContext) SetLabel(v IMultipartIdentifierContext) { s.label = v }

func (s *ShowCreateLoadContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCreateLoadContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSHOW, 0)
}

func (s *ShowCreateLoadContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCREATE, 0)
}

func (s *ShowCreateLoadContext) LOAD() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLOAD, 0)
}

func (s *ShowCreateLoadContext) FOR() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFOR, 0)
}

func (s *ShowCreateLoadContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowCreateLoadContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitShowCreateLoad(s)

	default:
		return t.VisitChildren(s)
	}
}

type MysqlLoadContext struct {
	UnsupportedLoadStatementContext
	properties IPropertyItemListContext
}

func NewMysqlLoadContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MysqlLoadContext {
	var p = new(MysqlLoadContext)

	InitEmptyUnsupportedLoadStatementContext(&p.UnsupportedLoadStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedLoadStatementContext))

	return p
}

func (s *MysqlLoadContext) GetProperties() IPropertyItemListContext { return s.properties }

func (s *MysqlLoadContext) SetProperties(v IPropertyItemListContext) { s.properties = v }

func (s *MysqlLoadContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MysqlLoadContext) LOAD() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLOAD, 0)
}

func (s *MysqlLoadContext) MysqlDataDesc() IMysqlDataDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMysqlDataDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMysqlDataDescContext)
}

func (s *MysqlLoadContext) PROPERTIES() antlr.TerminalNode {
	return s.GetToken(DorisParserParserPROPERTIES, 0)
}

func (s *MysqlLoadContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLEFT_PAREN, 0)
}

func (s *MysqlLoadContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRIGHT_PAREN, 0)
}

func (s *MysqlLoadContext) CommentSpec() ICommentSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentSpecContext)
}

func (s *MysqlLoadContext) PropertyItemList() IPropertyItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyItemListContext)
}

func (s *MysqlLoadContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitMysqlLoad(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) UnsupportedLoadStatement() (localctx IUnsupportedLoadStatementContext) {
	localctx = NewUnsupportedLoadStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, DorisParserParserRULE_unsupportedLoadStatement)
	var _la int

	p.SetState(2877)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserParserLOAD:
		localctx = NewMysqlLoadContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2860)
			p.Match(DorisParserParserLOAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2861)
			p.MysqlDataDesc()
		}
		p.SetState(2867)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserPROPERTIES {
			{
				p.SetState(2862)
				p.Match(DorisParserParserPROPERTIES)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2863)
				p.Match(DorisParserParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2864)

				var _x = p.PropertyItemList()

				localctx.(*MysqlLoadContext).properties = _x
			}
			{
				p.SetState(2865)
				p.Match(DorisParserParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(2870)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserCOMMENT {
			{
				p.SetState(2869)
				p.CommentSpec()
			}

		}

	case DorisParserParserSHOW:
		localctx = NewShowCreateLoadContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2872)
			p.Match(DorisParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2873)
			p.Match(DorisParserParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2874)
			p.Match(DorisParserParserLOAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2875)
			p.Match(DorisParserParserFOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2876)

			var _x = p.MultipartIdentifier()

			localctx.(*ShowCreateLoadContext).label = _x
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILoadPropertyContext is an interface to support dynamic dispatch.
type ILoadPropertyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsLoadPropertyContext differentiates from other interfaces.
	IsLoadPropertyContext()
}

type LoadPropertyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLoadPropertyContext() *LoadPropertyContext {
	var p = new(LoadPropertyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_loadProperty
	return p
}

func InitEmptyLoadPropertyContext(p *LoadPropertyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_loadProperty
}

func (*LoadPropertyContext) IsLoadPropertyContext() {}

func NewLoadPropertyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LoadPropertyContext {
	var p = new(LoadPropertyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_loadProperty

	return p
}

func (s *LoadPropertyContext) GetParser() antlr.Parser { return s.parser }

func (s *LoadPropertyContext) CopyAll(ctx *LoadPropertyContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *LoadPropertyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LoadPropertyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ImportPrecedingFilterContext struct {
	LoadPropertyContext
}

func NewImportPrecedingFilterContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ImportPrecedingFilterContext {
	var p = new(ImportPrecedingFilterContext)

	InitEmptyLoadPropertyContext(&p.LoadPropertyContext)
	p.parser = parser
	p.CopyAll(ctx.(*LoadPropertyContext))

	return p
}

func (s *ImportPrecedingFilterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportPrecedingFilterContext) ImportPrecedingFilterStatement() IImportPrecedingFilterStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportPrecedingFilterStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportPrecedingFilterStatementContext)
}

func (s *ImportPrecedingFilterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitImportPrecedingFilter(s)

	default:
		return t.VisitChildren(s)
	}
}

type ImportSequenceContext struct {
	LoadPropertyContext
}

func NewImportSequenceContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ImportSequenceContext {
	var p = new(ImportSequenceContext)

	InitEmptyLoadPropertyContext(&p.LoadPropertyContext)
	p.parser = parser
	p.CopyAll(ctx.(*LoadPropertyContext))

	return p
}

func (s *ImportSequenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportSequenceContext) ImportSequenceStatement() IImportSequenceStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportSequenceStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportSequenceStatementContext)
}

func (s *ImportSequenceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitImportSequence(s)

	default:
		return t.VisitChildren(s)
	}
}

type ImportColumnsContext struct {
	LoadPropertyContext
}

func NewImportColumnsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ImportColumnsContext {
	var p = new(ImportColumnsContext)

	InitEmptyLoadPropertyContext(&p.LoadPropertyContext)
	p.parser = parser
	p.CopyAll(ctx.(*LoadPropertyContext))

	return p
}

func (s *ImportColumnsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportColumnsContext) ImportColumnsStatement() IImportColumnsStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportColumnsStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportColumnsStatementContext)
}

func (s *ImportColumnsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitImportColumns(s)

	default:
		return t.VisitChildren(s)
	}
}

type ImportWhereContext struct {
	LoadPropertyContext
}

func NewImportWhereContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ImportWhereContext {
	var p = new(ImportWhereContext)

	InitEmptyLoadPropertyContext(&p.LoadPropertyContext)
	p.parser = parser
	p.CopyAll(ctx.(*LoadPropertyContext))

	return p
}

func (s *ImportWhereContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportWhereContext) ImportWhereStatement() IImportWhereStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportWhereStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportWhereStatementContext)
}

func (s *ImportWhereContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitImportWhere(s)

	default:
		return t.VisitChildren(s)
	}
}

type SeparatorContext struct {
	LoadPropertyContext
}

func NewSeparatorContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SeparatorContext {
	var p = new(SeparatorContext)

	InitEmptyLoadPropertyContext(&p.LoadPropertyContext)
	p.parser = parser
	p.CopyAll(ctx.(*LoadPropertyContext))

	return p
}

func (s *SeparatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SeparatorContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOLUMNS, 0)
}

func (s *SeparatorContext) TERMINATED() antlr.TerminalNode {
	return s.GetToken(DorisParserParserTERMINATED, 0)
}

func (s *SeparatorContext) BY() antlr.TerminalNode {
	return s.GetToken(DorisParserParserBY, 0)
}

func (s *SeparatorContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTRING_LITERAL, 0)
}

func (s *SeparatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitSeparator(s)

	default:
		return t.VisitChildren(s)
	}
}

type ImportPartitionsContext struct {
	LoadPropertyContext
}

func NewImportPartitionsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ImportPartitionsContext {
	var p = new(ImportPartitionsContext)

	InitEmptyLoadPropertyContext(&p.LoadPropertyContext)
	p.parser = parser
	p.CopyAll(ctx.(*LoadPropertyContext))

	return p
}

func (s *ImportPartitionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportPartitionsContext) PartitionSpec() IPartitionSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionSpecContext)
}

func (s *ImportPartitionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitImportPartitions(s)

	default:
		return t.VisitChildren(s)
	}
}

type ImportDeleteOnContext struct {
	LoadPropertyContext
}

func NewImportDeleteOnContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ImportDeleteOnContext {
	var p = new(ImportDeleteOnContext)

	InitEmptyLoadPropertyContext(&p.LoadPropertyContext)
	p.parser = parser
	p.CopyAll(ctx.(*LoadPropertyContext))

	return p
}

func (s *ImportDeleteOnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportDeleteOnContext) ImportDeleteOnStatement() IImportDeleteOnStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportDeleteOnStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportDeleteOnStatementContext)
}

func (s *ImportDeleteOnContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitImportDeleteOn(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) LoadProperty() (localctx ILoadPropertyContext) {
	localctx = NewLoadPropertyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, DorisParserParserRULE_loadProperty)
	p.SetState(2889)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 385, p.GetParserRuleContext()) {
	case 1:
		localctx = NewSeparatorContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2879)
			p.Match(DorisParserParserCOLUMNS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2880)
			p.Match(DorisParserParserTERMINATED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2881)
			p.Match(DorisParserParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2882)
			p.Match(DorisParserParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewImportColumnsContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2883)
			p.ImportColumnsStatement()
		}

	case 3:
		localctx = NewImportPrecedingFilterContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2884)
			p.ImportPrecedingFilterStatement()
		}

	case 4:
		localctx = NewImportWhereContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2885)
			p.ImportWhereStatement()
		}

	case 5:
		localctx = NewImportDeleteOnContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2886)
			p.ImportDeleteOnStatement()
		}

	case 6:
		localctx = NewImportSequenceContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2887)
			p.ImportSequenceStatement()
		}

	case 7:
		localctx = NewImportPartitionsContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(2888)
			p.PartitionSpec()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImportSequenceStatementContext is an interface to support dynamic dispatch.
type IImportSequenceStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ORDER() antlr.TerminalNode
	BY() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsImportSequenceStatementContext differentiates from other interfaces.
	IsImportSequenceStatementContext()
}

type ImportSequenceStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportSequenceStatementContext() *ImportSequenceStatementContext {
	var p = new(ImportSequenceStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_importSequenceStatement
	return p
}

func InitEmptyImportSequenceStatementContext(p *ImportSequenceStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_importSequenceStatement
}

func (*ImportSequenceStatementContext) IsImportSequenceStatementContext() {}

func NewImportSequenceStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportSequenceStatementContext {
	var p = new(ImportSequenceStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_importSequenceStatement

	return p
}

func (s *ImportSequenceStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportSequenceStatementContext) ORDER() antlr.TerminalNode {
	return s.GetToken(DorisParserParserORDER, 0)
}

func (s *ImportSequenceStatementContext) BY() antlr.TerminalNode {
	return s.GetToken(DorisParserParserBY, 0)
}

func (s *ImportSequenceStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ImportSequenceStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportSequenceStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportSequenceStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitImportSequenceStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) ImportSequenceStatement() (localctx IImportSequenceStatementContext) {
	localctx = NewImportSequenceStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, DorisParserParserRULE_importSequenceStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2891)
		p.Match(DorisParserParserORDER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2892)
		p.Match(DorisParserParserBY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2893)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImportDeleteOnStatementContext is an interface to support dynamic dispatch.
type IImportDeleteOnStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DELETE() antlr.TerminalNode
	ON() antlr.TerminalNode
	BooleanExpression() IBooleanExpressionContext

	// IsImportDeleteOnStatementContext differentiates from other interfaces.
	IsImportDeleteOnStatementContext()
}

type ImportDeleteOnStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportDeleteOnStatementContext() *ImportDeleteOnStatementContext {
	var p = new(ImportDeleteOnStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_importDeleteOnStatement
	return p
}

func InitEmptyImportDeleteOnStatementContext(p *ImportDeleteOnStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_importDeleteOnStatement
}

func (*ImportDeleteOnStatementContext) IsImportDeleteOnStatementContext() {}

func NewImportDeleteOnStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportDeleteOnStatementContext {
	var p = new(ImportDeleteOnStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_importDeleteOnStatement

	return p
}

func (s *ImportDeleteOnStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportDeleteOnStatementContext) DELETE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDELETE, 0)
}

func (s *ImportDeleteOnStatementContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisParserParserON, 0)
}

func (s *ImportDeleteOnStatementContext) BooleanExpression() IBooleanExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *ImportDeleteOnStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportDeleteOnStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportDeleteOnStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitImportDeleteOnStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) ImportDeleteOnStatement() (localctx IImportDeleteOnStatementContext) {
	localctx = NewImportDeleteOnStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, DorisParserParserRULE_importDeleteOnStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2895)
		p.Match(DorisParserParserDELETE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2896)
		p.Match(DorisParserParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2897)
		p.booleanExpression(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImportWhereStatementContext is an interface to support dynamic dispatch.
type IImportWhereStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WHERE() antlr.TerminalNode
	BooleanExpression() IBooleanExpressionContext

	// IsImportWhereStatementContext differentiates from other interfaces.
	IsImportWhereStatementContext()
}

type ImportWhereStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportWhereStatementContext() *ImportWhereStatementContext {
	var p = new(ImportWhereStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_importWhereStatement
	return p
}

func InitEmptyImportWhereStatementContext(p *ImportWhereStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_importWhereStatement
}

func (*ImportWhereStatementContext) IsImportWhereStatementContext() {}

func NewImportWhereStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportWhereStatementContext {
	var p = new(ImportWhereStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_importWhereStatement

	return p
}

func (s *ImportWhereStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportWhereStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserWHERE, 0)
}

func (s *ImportWhereStatementContext) BooleanExpression() IBooleanExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *ImportWhereStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportWhereStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportWhereStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitImportWhereStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) ImportWhereStatement() (localctx IImportWhereStatementContext) {
	localctx = NewImportWhereStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, DorisParserParserRULE_importWhereStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2899)
		p.Match(DorisParserParserWHERE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2900)
		p.booleanExpression(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImportPrecedingFilterStatementContext is an interface to support dynamic dispatch.
type IImportPrecedingFilterStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PRECEDING() antlr.TerminalNode
	FILTER() antlr.TerminalNode
	BooleanExpression() IBooleanExpressionContext

	// IsImportPrecedingFilterStatementContext differentiates from other interfaces.
	IsImportPrecedingFilterStatementContext()
}

type ImportPrecedingFilterStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportPrecedingFilterStatementContext() *ImportPrecedingFilterStatementContext {
	var p = new(ImportPrecedingFilterStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_importPrecedingFilterStatement
	return p
}

func InitEmptyImportPrecedingFilterStatementContext(p *ImportPrecedingFilterStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_importPrecedingFilterStatement
}

func (*ImportPrecedingFilterStatementContext) IsImportPrecedingFilterStatementContext() {}

func NewImportPrecedingFilterStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportPrecedingFilterStatementContext {
	var p = new(ImportPrecedingFilterStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_importPrecedingFilterStatement

	return p
}

func (s *ImportPrecedingFilterStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportPrecedingFilterStatementContext) PRECEDING() antlr.TerminalNode {
	return s.GetToken(DorisParserParserPRECEDING, 0)
}

func (s *ImportPrecedingFilterStatementContext) FILTER() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFILTER, 0)
}

func (s *ImportPrecedingFilterStatementContext) BooleanExpression() IBooleanExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *ImportPrecedingFilterStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportPrecedingFilterStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportPrecedingFilterStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitImportPrecedingFilterStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) ImportPrecedingFilterStatement() (localctx IImportPrecedingFilterStatementContext) {
	localctx = NewImportPrecedingFilterStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, DorisParserParserRULE_importPrecedingFilterStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2902)
		p.Match(DorisParserParserPRECEDING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2903)
		p.Match(DorisParserParserFILTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2904)
		p.booleanExpression(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImportColumnsStatementContext is an interface to support dynamic dispatch.
type IImportColumnsStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COLUMNS() antlr.TerminalNode
	LEFT_PAREN() antlr.TerminalNode
	AllImportColumnDesc() []IImportColumnDescContext
	ImportColumnDesc(i int) IImportColumnDescContext
	RIGHT_PAREN() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsImportColumnsStatementContext differentiates from other interfaces.
	IsImportColumnsStatementContext()
}

type ImportColumnsStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportColumnsStatementContext() *ImportColumnsStatementContext {
	var p = new(ImportColumnsStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_importColumnsStatement
	return p
}

func InitEmptyImportColumnsStatementContext(p *ImportColumnsStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_importColumnsStatement
}

func (*ImportColumnsStatementContext) IsImportColumnsStatementContext() {}

func NewImportColumnsStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportColumnsStatementContext {
	var p = new(ImportColumnsStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_importColumnsStatement

	return p
}

func (s *ImportColumnsStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportColumnsStatementContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOLUMNS, 0)
}

func (s *ImportColumnsStatementContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLEFT_PAREN, 0)
}

func (s *ImportColumnsStatementContext) AllImportColumnDesc() []IImportColumnDescContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IImportColumnDescContext); ok {
			len++
		}
	}

	tst := make([]IImportColumnDescContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IImportColumnDescContext); ok {
			tst[i] = t.(IImportColumnDescContext)
			i++
		}
	}

	return tst
}

func (s *ImportColumnsStatementContext) ImportColumnDesc(i int) IImportColumnDescContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportColumnDescContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportColumnDescContext)
}

func (s *ImportColumnsStatementContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRIGHT_PAREN, 0)
}

func (s *ImportColumnsStatementContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserCOMMA)
}

func (s *ImportColumnsStatementContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOMMA, i)
}

func (s *ImportColumnsStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportColumnsStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportColumnsStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitImportColumnsStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) ImportColumnsStatement() (localctx IImportColumnsStatementContext) {
	localctx = NewImportColumnsStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, DorisParserParserRULE_importColumnsStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2906)
		p.Match(DorisParserParserCOLUMNS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2907)
		p.Match(DorisParserParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2908)
		p.ImportColumnDesc()
	}
	p.SetState(2913)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisParserParserCOMMA {
		{
			p.SetState(2909)
			p.Match(DorisParserParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2910)
			p.ImportColumnDesc()
		}

		p.SetState(2915)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2916)
		p.Match(DorisParserParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImportColumnDescContext is an interface to support dynamic dispatch.
type IImportColumnDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name rule contexts.
	GetName() IIdentifierContext

	// SetName sets the name rule contexts.
	SetName(IIdentifierContext)

	// Getter signatures
	Identifier() IIdentifierContext
	EQ() antlr.TerminalNode
	BooleanExpression() IBooleanExpressionContext
	LEFT_PAREN() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode

	// IsImportColumnDescContext differentiates from other interfaces.
	IsImportColumnDescContext()
}

type ImportColumnDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	name   IIdentifierContext
}

func NewEmptyImportColumnDescContext() *ImportColumnDescContext {
	var p = new(ImportColumnDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_importColumnDesc
	return p
}

func InitEmptyImportColumnDescContext(p *ImportColumnDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_importColumnDesc
}

func (*ImportColumnDescContext) IsImportColumnDescContext() {}

func NewImportColumnDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportColumnDescContext {
	var p = new(ImportColumnDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_importColumnDesc

	return p
}

func (s *ImportColumnDescContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportColumnDescContext) GetName() IIdentifierContext { return s.name }

func (s *ImportColumnDescContext) SetName(v IIdentifierContext) { s.name = v }

func (s *ImportColumnDescContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ImportColumnDescContext) EQ() antlr.TerminalNode {
	return s.GetToken(DorisParserParserEQ, 0)
}

func (s *ImportColumnDescContext) BooleanExpression() IBooleanExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *ImportColumnDescContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLEFT_PAREN, 0)
}

func (s *ImportColumnDescContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRIGHT_PAREN, 0)
}

func (s *ImportColumnDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportColumnDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportColumnDescContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitImportColumnDesc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) ImportColumnDesc() (localctx IImportColumnDescContext) {
	localctx = NewImportColumnDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, DorisParserParserRULE_importColumnDesc)
	var _la int

	p.SetState(2931)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserParserLEFT_BRACE, DorisParserParserRIGHT_BRACE, DorisParserParserACTIONS, DorisParserParserAFTER, DorisParserParserAGG_STATE, DorisParserParserAGGREGATE, DorisParserParserALIAS, DorisParserParserANALYZED, DorisParserParserARRAY, DorisParserParserAT, DorisParserParserAUTHORS, DorisParserParserAUTO_INCREMENT, DorisParserParserALWAYS, DorisParserParserBACKENDS, DorisParserParserBACKUP, DorisParserParserBEGIN, DorisParserParserBELONG, DorisParserParserBIN, DorisParserParserBITAND, DorisParserParserBITMAP, DorisParserParserBITMAP_EMPTY, DorisParserParserBITMAP_UNION, DorisParserParserBITOR, DorisParserParserBITXOR, DorisParserParserBLOB, DorisParserParserBOOLEAN, DorisParserParserBRANCH, DorisParserParserBRIEF, DorisParserParserBROKER, DorisParserParserBUCKETS, DorisParserParserBUILD, DorisParserParserBUILTIN, DorisParserParserBULK, DorisParserParserCACHE, DorisParserParserCACHED, DorisParserParserCALL, DorisParserParserCATALOG, DorisParserParserCATALOGS, DorisParserParserCHAIN, DorisParserParserCHAR, DorisParserParserCHARSET, DorisParserParserCHECK, DorisParserParserCLUSTER, DorisParserParserCLUSTERS, DorisParserParserCOLLATION, DorisParserParserCOLLECT, DorisParserParserCOLOCATE, DorisParserParserCOLUMNS, DorisParserParserCOMMENT, DorisParserParserCOMMIT, DorisParserParserCOMMITTED, DorisParserParserCOMPACT, DorisParserParserCOMPLETE, DorisParserParserCOMPRESS_TYPE, DorisParserParserCOMPUTE, DorisParserParserCONDITIONS, DorisParserParserCONFIG, DorisParserParserCONNECTION, DorisParserParserCONNECTION_ID, DorisParserParserCONSISTENT, DorisParserParserCONSTRAINTS, DorisParserParserCONVERT, DorisParserParserCONVERT_LSC, DorisParserParserCOPY, DorisParserParserCOUNT, DorisParserParserCREATION, DorisParserParserCRON, DorisParserParserCURRENT_CATALOG, DorisParserParserCURRENT_DATE, DorisParserParserCURRENT_TIME, DorisParserParserCURRENT_TIMESTAMP, DorisParserParserCURRENT_USER, DorisParserParserDATA, DorisParserParserDATE, DorisParserParserDATETIME, DorisParserParserDATETIMEV2, DorisParserParserDATEV2, DorisParserParserDATETIMEV1, DorisParserParserDATEV1, DorisParserParserDAY, DorisParserParserDAYS, DorisParserParserDECIMAL, DorisParserParserDECIMALV2, DorisParserParserDECIMALV3, DorisParserParserDEFERRED, DorisParserParserDEMAND, DorisParserParserDIAGNOSE, DorisParserParserDIAGNOSIS, DorisParserParserDICTIONARIES, DorisParserParserDICTIONARY, DorisParserParserDISTINCTPC, DorisParserParserDISTINCTPCSA, DorisParserParserDO, DorisParserParserDORIS_INTERNAL_TABLE_ID, DorisParserParserDUAL, DorisParserParserDYNAMIC, DorisParserParserE, DorisParserParserENABLE, DorisParserParserENCRYPTKEY, DorisParserParserENCRYPTKEYS, DorisParserParserEND, DorisParserParserENDS, DorisParserParserENGINE, DorisParserParserENGINES, DorisParserParserERRORS, DorisParserParserESCAPE, DorisParserParserEVENTS, DorisParserParserEVERY, DorisParserParserEXCLUDE, DorisParserParserEXPIRED, DorisParserParserEXTERNAL, DorisParserParserFAILED_LOGIN_ATTEMPTS, DorisParserParserFAST, DorisParserParserFEATURE, DorisParserParserFIELDS, DorisParserParserFILE, DorisParserParserFILTER, DorisParserParserFIRST, DorisParserParserFORMAT, DorisParserParserFREE, DorisParserParserFRONTENDS, DorisParserParserFUNCTION, DorisParserParserGENERATED, DorisParserParserGENERIC, DorisParserParserGLOBAL, DorisParserParserGRAPH, DorisParserParserGROUPING, DorisParserParserGROUPS, DorisParserParserHASH, DorisParserParserHASH_MAP, DorisParserParserHDFS, DorisParserParserHELP, DorisParserParserHISTOGRAM, DorisParserParserHLL_UNION, DorisParserParserHOSTNAME, DorisParserParserHOTSPOT, DorisParserParserHOUR, DorisParserParserHOURS, DorisParserParserHUB, DorisParserParserIDENTIFIED, DorisParserParserIGNORE, DorisParserParserIMMEDIATE, DorisParserParserINCREMENTAL, DorisParserParserINDEXES, DorisParserParserINVERTED, DorisParserParserIP_TRIE, DorisParserParserIPV4, DorisParserParserIPV6, DorisParserParserIS_NOT_NULL_PRED, DorisParserParserIS_NULL_PRED, DorisParserParserISNULL, DorisParserParserISOLATION, DorisParserParserJOB, DorisParserParserJOBS, DorisParserParserJSON, DorisParserParserJSONB, DorisParserParserLABEL, DorisParserParserLAST, DorisParserParserLDAP, DorisParserParserLDAP_ADMIN_PASSWORD, DorisParserParserLESS, DorisParserParserLEVEL, DorisParserParserLINES, DorisParserParserLINK, DorisParserParserLOCAL, DorisParserParserLOCALTIME, DorisParserParserLOCALTIMESTAMP, DorisParserParserLOCATION, DorisParserParserLOCK, DorisParserParserLOGICAL, DorisParserParserMANUAL, DorisParserParserMAP, DorisParserParserMATCH_ALL, DorisParserParserMATCH_ANY, DorisParserParserMATCH_PHRASE, DorisParserParserMATCH_PHRASE_EDGE, DorisParserParserMATCH_PHRASE_PREFIX, DorisParserParserMATCH_REGEXP, DorisParserParserMATERIALIZED, DorisParserParserMAX, DorisParserParserMEMO, DorisParserParserMERGE, DorisParserParserMIGRATE, DorisParserParserMIGRATIONS, DorisParserParserMIN, DorisParserParserMINUTE, DorisParserParserMINUTES, DorisParserParserMODIFY, DorisParserParserMONTH, DorisParserParserMTMV, DorisParserParserNAME, DorisParserParserNAMES, DorisParserParserNEGATIVE, DorisParserParserNEVER, DorisParserParserNEXT, DorisParserParserNGRAM_BF, DorisParserParserNO, DorisParserParserNON_NULLABLE, DorisParserParserNULLS, DorisParserParserOF, DorisParserParserOFFSET, DorisParserParserONLY, DorisParserParserOPEN, DorisParserParserOPTIMIZED, DorisParserParserPARAMETER, DorisParserParserPARSED, DorisParserParserPARTITIONS, DorisParserParserPASSWORD, DorisParserParserPASSWORD_EXPIRE, DorisParserParserPASSWORD_HISTORY, DorisParserParserPASSWORD_LOCK_TIME, DorisParserParserPASSWORD_REUSE, DorisParserParserPATH, DorisParserParserPAUSE, DorisParserParserPERCENT, DorisParserParserPERIOD, DorisParserParserPERMISSIVE, DorisParserParserPHYSICAL, DorisParserParserPI, DorisParserParserPLAN, DorisParserParserPRIVILEGES, DorisParserParserPROCESS, DorisParserParserPLUGIN, DorisParserParserPLUGINS, DorisParserParserPOLICY, DorisParserParserPROC, DorisParserParserPROCESSLIST, DorisParserParserPROFILE, DorisParserParserPROPERTIES, DorisParserParserPROPERTY, DorisParserParserQUANTILE_STATE, DorisParserParserQUANTILE_UNION, DorisParserParserQUERY, DorisParserParserQUEUED, DorisParserParserQUOTA, DorisParserParserQUALIFY, DorisParserParserQUARTER, DorisParserParserRANDOM, DorisParserParserRECENT, DorisParserParserRECOVER, DorisParserParserRECYCLE, DorisParserParserREFRESH, DorisParserParserREPEATABLE, DorisParserParserREPLACE, DorisParserParserREPLACE_IF_NOT_NULL, DorisParserParserREPLAYER, DorisParserParserREPOSITORIES, DorisParserParserREPOSITORY, DorisParserParserRESOURCE, DorisParserParserRESOURCES, DorisParserParserRESTORE, DorisParserParserRESTRICTIVE, DorisParserParserRESUME, DorisParserParserRETAIN, DorisParserParserRETENTION, DorisParserParserRETURNS, DorisParserParserREWRITTEN, DorisParserParserRLIKE, DorisParserParserROLLBACK, DorisParserParserROLLUP, DorisParserParserROUTINE, DorisParserParserS3, DorisParserParserSAMPLE, DorisParserParserSCHEDULE, DorisParserParserSCHEDULER, DorisParserParserSCHEMA, DorisParserParserSECOND, DorisParserParserSERIALIZABLE, DorisParserParserSESSION, DorisParserParserSESSION_USER, DorisParserParserSET_SESSION_VARIABLE, DorisParserParserSHAPE, DorisParserParserSKEW, DorisParserParserSNAPSHOT, DorisParserParserSNAPSHOTS, DorisParserParserSONAME, DorisParserParserSPLIT, DorisParserParserSQL, DorisParserParserSTAGE, DorisParserParserSTAGES, DorisParserParserSTART, DorisParserParserSTARTS, DorisParserParserSTATS, DorisParserParserSTATUS, DorisParserParserSTOP, DorisParserParserSTORAGE, DorisParserParserSTREAM, DorisParserParserSTREAMING, DorisParserParserSTRING, DorisParserParserSTRUCT, DorisParserParserSUM, DorisParserParserTABLES, DorisParserParserTAG, DorisParserParserTASK, DorisParserParserTASKS, DorisParserParserTEMPORARY, DorisParserParserTEXT, DorisParserParserTHAN, DorisParserParserTIME, DorisParserParserTIMESTAMP, DorisParserParserTRANSACTION, DorisParserParserTREE, DorisParserParserTRIGGERS, DorisParserParserTRUNCATE, DorisParserParserTYPE, DorisParserParserTYPES, DorisParserParserUNCOMMITTED, DorisParserParserUNLOCK, DorisParserParserUNSET, DorisParserParserUP, DorisParserParserUSER, DorisParserParserVALUE, DorisParserParserVARCHAR, DorisParserParserVARIABLE, DorisParserParserVARIABLES, DorisParserParserVARIANT, DorisParserParserVAULT, DorisParserParserVAULTS, DorisParserParserVERBOSE, DorisParserParserVERSION, DorisParserParserVIEW, DorisParserParserVIEWS, DorisParserParserWARM, DorisParserParserWARNINGS, DorisParserParserWEEK, DorisParserParserWORK, DorisParserParserYEAR, DorisParserParserHINT_START, DorisParserParserHINT_END, DorisParserParserCOMMENT_START, DorisParserParserIDENTIFIER, DorisParserParserBACKQUOTED_IDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2918)

			var _x = p.Identifier()

			localctx.(*ImportColumnDescContext).name = _x
		}
		p.SetState(2921)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserEQ {
			{
				p.SetState(2919)
				p.Match(DorisParserParserEQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2920)
				p.booleanExpression(0)
			}

		}

	case DorisParserParserLEFT_PAREN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2923)
			p.Match(DorisParserParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2924)

			var _x = p.Identifier()

			localctx.(*ImportColumnDescContext).name = _x
		}
		p.SetState(2927)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserEQ {
			{
				p.SetState(2925)
				p.Match(DorisParserParserEQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2926)
				p.booleanExpression(0)
			}

		}
		{
			p.SetState(2929)
			p.Match(DorisParserParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISupportedRefreshStatementContext is an interface to support dynamic dispatch.
type ISupportedRefreshStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSupportedRefreshStatementContext differentiates from other interfaces.
	IsSupportedRefreshStatementContext()
}

type SupportedRefreshStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySupportedRefreshStatementContext() *SupportedRefreshStatementContext {
	var p = new(SupportedRefreshStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_supportedRefreshStatement
	return p
}

func InitEmptySupportedRefreshStatementContext(p *SupportedRefreshStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_supportedRefreshStatement
}

func (*SupportedRefreshStatementContext) IsSupportedRefreshStatementContext() {}

func NewSupportedRefreshStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SupportedRefreshStatementContext {
	var p = new(SupportedRefreshStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_supportedRefreshStatement

	return p
}

func (s *SupportedRefreshStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SupportedRefreshStatementContext) CopyAll(ctx *SupportedRefreshStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *SupportedRefreshStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedRefreshStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type RefreshCatalogContext struct {
	SupportedRefreshStatementContext
	name IIdentifierContext
}

func NewRefreshCatalogContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RefreshCatalogContext {
	var p = new(RefreshCatalogContext)

	InitEmptySupportedRefreshStatementContext(&p.SupportedRefreshStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedRefreshStatementContext))

	return p
}

func (s *RefreshCatalogContext) GetName() IIdentifierContext { return s.name }

func (s *RefreshCatalogContext) SetName(v IIdentifierContext) { s.name = v }

func (s *RefreshCatalogContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RefreshCatalogContext) REFRESH() antlr.TerminalNode {
	return s.GetToken(DorisParserParserREFRESH, 0)
}

func (s *RefreshCatalogContext) CATALOG() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCATALOG, 0)
}

func (s *RefreshCatalogContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *RefreshCatalogContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *RefreshCatalogContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitRefreshCatalog(s)

	default:
		return t.VisitChildren(s)
	}
}

type RefreshDictionaryContext struct {
	SupportedRefreshStatementContext
	name IMultipartIdentifierContext
}

func NewRefreshDictionaryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RefreshDictionaryContext {
	var p = new(RefreshDictionaryContext)

	InitEmptySupportedRefreshStatementContext(&p.SupportedRefreshStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedRefreshStatementContext))

	return p
}

func (s *RefreshDictionaryContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *RefreshDictionaryContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *RefreshDictionaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RefreshDictionaryContext) REFRESH() antlr.TerminalNode {
	return s.GetToken(DorisParserParserREFRESH, 0)
}

func (s *RefreshDictionaryContext) DICTIONARY() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDICTIONARY, 0)
}

func (s *RefreshDictionaryContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *RefreshDictionaryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitRefreshDictionary(s)

	default:
		return t.VisitChildren(s)
	}
}

type RefreshDatabaseContext struct {
	SupportedRefreshStatementContext
	name IMultipartIdentifierContext
}

func NewRefreshDatabaseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RefreshDatabaseContext {
	var p = new(RefreshDatabaseContext)

	InitEmptySupportedRefreshStatementContext(&p.SupportedRefreshStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedRefreshStatementContext))

	return p
}

func (s *RefreshDatabaseContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *RefreshDatabaseContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *RefreshDatabaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RefreshDatabaseContext) REFRESH() antlr.TerminalNode {
	return s.GetToken(DorisParserParserREFRESH, 0)
}

func (s *RefreshDatabaseContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDATABASE, 0)
}

func (s *RefreshDatabaseContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *RefreshDatabaseContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *RefreshDatabaseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitRefreshDatabase(s)

	default:
		return t.VisitChildren(s)
	}
}

type RefreshTableContext struct {
	SupportedRefreshStatementContext
	name IMultipartIdentifierContext
}

func NewRefreshTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RefreshTableContext {
	var p = new(RefreshTableContext)

	InitEmptySupportedRefreshStatementContext(&p.SupportedRefreshStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedRefreshStatementContext))

	return p
}

func (s *RefreshTableContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *RefreshTableContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *RefreshTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RefreshTableContext) REFRESH() antlr.TerminalNode {
	return s.GetToken(DorisParserParserREFRESH, 0)
}

func (s *RefreshTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserTABLE, 0)
}

func (s *RefreshTableContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *RefreshTableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitRefreshTable(s)

	default:
		return t.VisitChildren(s)
	}
}

type RefreshLdapContext struct {
	SupportedRefreshStatementContext
	user IIdentifierOrTextContext
}

func NewRefreshLdapContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RefreshLdapContext {
	var p = new(RefreshLdapContext)

	InitEmptySupportedRefreshStatementContext(&p.SupportedRefreshStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedRefreshStatementContext))

	return p
}

func (s *RefreshLdapContext) GetUser() IIdentifierOrTextContext { return s.user }

func (s *RefreshLdapContext) SetUser(v IIdentifierOrTextContext) { s.user = v }

func (s *RefreshLdapContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RefreshLdapContext) REFRESH() antlr.TerminalNode {
	return s.GetToken(DorisParserParserREFRESH, 0)
}

func (s *RefreshLdapContext) LDAP() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLDAP, 0)
}

func (s *RefreshLdapContext) ALL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserALL, 0)
}

func (s *RefreshLdapContext) FOR() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFOR, 0)
}

func (s *RefreshLdapContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *RefreshLdapContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitRefreshLdap(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) SupportedRefreshStatement() (localctx ISupportedRefreshStatementContext) {
	localctx = NewSupportedRefreshStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, DorisParserParserRULE_supportedRefreshStatement)
	var _la int

	p.SetState(2958)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 393, p.GetParserRuleContext()) {
	case 1:
		localctx = NewRefreshCatalogContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2933)
			p.Match(DorisParserParserREFRESH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2934)
			p.Match(DorisParserParserCATALOG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2935)

			var _x = p.Identifier()

			localctx.(*RefreshCatalogContext).name = _x
		}
		p.SetState(2937)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserPROPERTIES {
			{
				p.SetState(2936)
				p.PropertyClause()
			}

		}

	case 2:
		localctx = NewRefreshDatabaseContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2939)
			p.Match(DorisParserParserREFRESH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2940)
			p.Match(DorisParserParserDATABASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2941)

			var _x = p.MultipartIdentifier()

			localctx.(*RefreshDatabaseContext).name = _x
		}
		p.SetState(2943)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserPROPERTIES {
			{
				p.SetState(2942)
				p.PropertyClause()
			}

		}

	case 3:
		localctx = NewRefreshTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2945)
			p.Match(DorisParserParserREFRESH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2946)
			p.Match(DorisParserParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2947)

			var _x = p.MultipartIdentifier()

			localctx.(*RefreshTableContext).name = _x
		}

	case 4:
		localctx = NewRefreshDictionaryContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2948)
			p.Match(DorisParserParserREFRESH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2949)
			p.Match(DorisParserParserDICTIONARY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2950)

			var _x = p.MultipartIdentifier()

			localctx.(*RefreshDictionaryContext).name = _x
		}

	case 5:
		localctx = NewRefreshLdapContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2951)
			p.Match(DorisParserParserREFRESH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2952)
			p.Match(DorisParserParserLDAP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2956)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserParserALL:
			{
				p.SetState(2953)
				p.Match(DorisParserParserALL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserParserFOR:
			{
				p.SetState(2954)
				p.Match(DorisParserParserFOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2955)

				var _x = p.IdentifierOrText()

				localctx.(*RefreshLdapContext).user = _x
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISupportedCleanStatementContext is an interface to support dynamic dispatch.
type ISupportedCleanStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSupportedCleanStatementContext differentiates from other interfaces.
	IsSupportedCleanStatementContext()
}

type SupportedCleanStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySupportedCleanStatementContext() *SupportedCleanStatementContext {
	var p = new(SupportedCleanStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_supportedCleanStatement
	return p
}

func InitEmptySupportedCleanStatementContext(p *SupportedCleanStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_supportedCleanStatement
}

func (*SupportedCleanStatementContext) IsSupportedCleanStatementContext() {}

func NewSupportedCleanStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SupportedCleanStatementContext {
	var p = new(SupportedCleanStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_supportedCleanStatement

	return p
}

func (s *SupportedCleanStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SupportedCleanStatementContext) CopyAll(ctx *SupportedCleanStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *SupportedCleanStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedCleanStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type CleanLabelContext struct {
	SupportedCleanStatementContext
	label    IIdentifierContext
	database IIdentifierContext
}

func NewCleanLabelContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CleanLabelContext {
	var p = new(CleanLabelContext)

	InitEmptySupportedCleanStatementContext(&p.SupportedCleanStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedCleanStatementContext))

	return p
}

func (s *CleanLabelContext) GetLabel() IIdentifierContext { return s.label }

func (s *CleanLabelContext) GetDatabase() IIdentifierContext { return s.database }

func (s *CleanLabelContext) SetLabel(v IIdentifierContext) { s.label = v }

func (s *CleanLabelContext) SetDatabase(v IIdentifierContext) { s.database = v }

func (s *CleanLabelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CleanLabelContext) CLEAN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCLEAN, 0)
}

func (s *CleanLabelContext) LABEL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLABEL, 0)
}

func (s *CleanLabelContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFROM, 0)
}

func (s *CleanLabelContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserIN, 0)
}

func (s *CleanLabelContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *CleanLabelContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CleanLabelContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitCleanLabel(s)

	default:
		return t.VisitChildren(s)
	}
}

type CleanQueryStatsContext struct {
	SupportedCleanStatementContext
	database IIdentifierContext
	table    IMultipartIdentifierContext
}

func NewCleanQueryStatsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CleanQueryStatsContext {
	var p = new(CleanQueryStatsContext)

	InitEmptySupportedCleanStatementContext(&p.SupportedCleanStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedCleanStatementContext))

	return p
}

func (s *CleanQueryStatsContext) GetDatabase() IIdentifierContext { return s.database }

func (s *CleanQueryStatsContext) GetTable() IMultipartIdentifierContext { return s.table }

func (s *CleanQueryStatsContext) SetDatabase(v IIdentifierContext) { s.database = v }

func (s *CleanQueryStatsContext) SetTable(v IMultipartIdentifierContext) { s.table = v }

func (s *CleanQueryStatsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CleanQueryStatsContext) CLEAN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCLEAN, 0)
}

func (s *CleanQueryStatsContext) QUERY() antlr.TerminalNode {
	return s.GetToken(DorisParserParserQUERY, 0)
}

func (s *CleanQueryStatsContext) STATS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTATS, 0)
}

func (s *CleanQueryStatsContext) FOR() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFOR, 0)
}

func (s *CleanQueryStatsContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CleanQueryStatsContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFROM, 0)
}

func (s *CleanQueryStatsContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserIN, 0)
}

func (s *CleanQueryStatsContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *CleanQueryStatsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitCleanQueryStats(s)

	default:
		return t.VisitChildren(s)
	}
}

type CleanAllProfileContext struct {
	SupportedCleanStatementContext
}

func NewCleanAllProfileContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CleanAllProfileContext {
	var p = new(CleanAllProfileContext)

	InitEmptySupportedCleanStatementContext(&p.SupportedCleanStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedCleanStatementContext))

	return p
}

func (s *CleanAllProfileContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CleanAllProfileContext) CLEAN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCLEAN, 0)
}

func (s *CleanAllProfileContext) ALL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserALL, 0)
}

func (s *CleanAllProfileContext) PROFILE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserPROFILE, 0)
}

func (s *CleanAllProfileContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitCleanAllProfile(s)

	default:
		return t.VisitChildren(s)
	}
}

type CleanAllQueryStatsContext struct {
	SupportedCleanStatementContext
}

func NewCleanAllQueryStatsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CleanAllQueryStatsContext {
	var p = new(CleanAllQueryStatsContext)

	InitEmptySupportedCleanStatementContext(&p.SupportedCleanStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedCleanStatementContext))

	return p
}

func (s *CleanAllQueryStatsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CleanAllQueryStatsContext) CLEAN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCLEAN, 0)
}

func (s *CleanAllQueryStatsContext) ALL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserALL, 0)
}

func (s *CleanAllQueryStatsContext) QUERY() antlr.TerminalNode {
	return s.GetToken(DorisParserParserQUERY, 0)
}

func (s *CleanAllQueryStatsContext) STATS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTATS, 0)
}

func (s *CleanAllQueryStatsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitCleanAllQueryStats(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) SupportedCleanStatement() (localctx ISupportedCleanStatementContext) {
	localctx = NewSupportedCleanStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, DorisParserParserRULE_supportedCleanStatement)
	var _la int

	p.SetState(2983)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 396, p.GetParserRuleContext()) {
	case 1:
		localctx = NewCleanAllProfileContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2960)
			p.Match(DorisParserParserCLEAN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2961)
			p.Match(DorisParserParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2962)
			p.Match(DorisParserParserPROFILE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewCleanLabelContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2963)
			p.Match(DorisParserParserCLEAN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2964)
			p.Match(DorisParserParserLABEL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2966)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-2305902462020672000) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&4609989332399152113) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-9080794533051819547) != 0) || ((int64((_la-192)) & ^0x3f) == 0 && ((int64(1)<<(_la-192))&2015220189171012521) != 0) || ((int64((_la-256)) & ^0x3f) == 0 && ((int64(1)<<(_la-256))&-5422616543060085911) != 0) || ((int64((_la-320)) & ^0x3f) == 0 && ((int64(1)<<(_la-320))&-4476015178520986877) != 0) || ((int64((_la-384)) & ^0x3f) == 0 && ((int64(1)<<(_la-384))&9222796779122679803) != 0) || ((int64((_la-452)) & ^0x3f) == 0 && ((int64(1)<<(_la-452))&2449945648119953137) != 0) || ((int64((_la-517)) & ^0x3f) == 0 && ((int64(1)<<(_la-517))&206187790337) != 0) {
			{
				p.SetState(2965)

				var _x = p.Identifier()

				localctx.(*CleanLabelContext).label = _x
			}

		}
		{
			p.SetState(2968)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserParserFROM || _la == DorisParserParserIN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(2969)

			var _x = p.Identifier()

			localctx.(*CleanLabelContext).database = _x
		}

	case 3:
		localctx = NewCleanQueryStatsContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2970)
			p.Match(DorisParserParserCLEAN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2971)
			p.Match(DorisParserParserQUERY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2972)
			p.Match(DorisParserParserSTATS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2977)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserParserFOR:
			{
				p.SetState(2973)
				p.Match(DorisParserParserFOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2974)

				var _x = p.Identifier()

				localctx.(*CleanQueryStatsContext).database = _x
			}

		case DorisParserParserFROM, DorisParserParserIN:
			{
				p.SetState(2975)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserParserFROM || _la == DorisParserParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(2976)

				var _x = p.MultipartIdentifier()

				localctx.(*CleanQueryStatsContext).table = _x
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 4:
		localctx = NewCleanAllQueryStatsContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2979)
			p.Match(DorisParserParserCLEAN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2980)
			p.Match(DorisParserParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2981)
			p.Match(DorisParserParserQUERY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2982)
			p.Match(DorisParserParserSTATS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISupportedCancelStatementContext is an interface to support dynamic dispatch.
type ISupportedCancelStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSupportedCancelStatementContext differentiates from other interfaces.
	IsSupportedCancelStatementContext()
}

type SupportedCancelStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySupportedCancelStatementContext() *SupportedCancelStatementContext {
	var p = new(SupportedCancelStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_supportedCancelStatement
	return p
}

func InitEmptySupportedCancelStatementContext(p *SupportedCancelStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_supportedCancelStatement
}

func (*SupportedCancelStatementContext) IsSupportedCancelStatementContext() {}

func NewSupportedCancelStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SupportedCancelStatementContext {
	var p = new(SupportedCancelStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_supportedCancelStatement

	return p
}

func (s *SupportedCancelStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SupportedCancelStatementContext) CopyAll(ctx *SupportedCancelStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *SupportedCancelStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedCancelStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type CancelBackupContext struct {
	SupportedCancelStatementContext
	database IIdentifierContext
}

func NewCancelBackupContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CancelBackupContext {
	var p = new(CancelBackupContext)

	InitEmptySupportedCancelStatementContext(&p.SupportedCancelStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedCancelStatementContext))

	return p
}

func (s *CancelBackupContext) GetDatabase() IIdentifierContext { return s.database }

func (s *CancelBackupContext) SetDatabase(v IIdentifierContext) { s.database = v }

func (s *CancelBackupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CancelBackupContext) CANCEL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCANCEL, 0)
}

func (s *CancelBackupContext) BACKUP() antlr.TerminalNode {
	return s.GetToken(DorisParserParserBACKUP, 0)
}

func (s *CancelBackupContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFROM, 0)
}

func (s *CancelBackupContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserIN, 0)
}

func (s *CancelBackupContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CancelBackupContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitCancelBackup(s)

	default:
		return t.VisitChildren(s)
	}
}

type CancelWarmUpJobContext struct {
	SupportedCancelStatementContext
}

func NewCancelWarmUpJobContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CancelWarmUpJobContext {
	var p = new(CancelWarmUpJobContext)

	InitEmptySupportedCancelStatementContext(&p.SupportedCancelStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedCancelStatementContext))

	return p
}

func (s *CancelWarmUpJobContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CancelWarmUpJobContext) CANCEL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCANCEL, 0)
}

func (s *CancelWarmUpJobContext) WARM() antlr.TerminalNode {
	return s.GetToken(DorisParserParserWARM, 0)
}

func (s *CancelWarmUpJobContext) UP() antlr.TerminalNode {
	return s.GetToken(DorisParserParserUP, 0)
}

func (s *CancelWarmUpJobContext) JOB() antlr.TerminalNode {
	return s.GetToken(DorisParserParserJOB, 0)
}

func (s *CancelWarmUpJobContext) WildWhere() IWildWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWildWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWildWhereContext)
}

func (s *CancelWarmUpJobContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitCancelWarmUpJob(s)

	default:
		return t.VisitChildren(s)
	}
}

type CancelExportContext struct {
	SupportedCancelStatementContext
	database IIdentifierContext
}

func NewCancelExportContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CancelExportContext {
	var p = new(CancelExportContext)

	InitEmptySupportedCancelStatementContext(&p.SupportedCancelStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedCancelStatementContext))

	return p
}

func (s *CancelExportContext) GetDatabase() IIdentifierContext { return s.database }

func (s *CancelExportContext) SetDatabase(v IIdentifierContext) { s.database = v }

func (s *CancelExportContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CancelExportContext) CANCEL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCANCEL, 0)
}

func (s *CancelExportContext) EXPORT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserEXPORT, 0)
}

func (s *CancelExportContext) WildWhere() IWildWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWildWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWildWhereContext)
}

func (s *CancelExportContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFROM, 0)
}

func (s *CancelExportContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserIN, 0)
}

func (s *CancelExportContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CancelExportContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitCancelExport(s)

	default:
		return t.VisitChildren(s)
	}
}

type CancelBuildIndexContext struct {
	SupportedCancelStatementContext
	tableName      IMultipartIdentifierContext
	_INTEGER_VALUE antlr.Token
	jobIds         []antlr.Token
}

func NewCancelBuildIndexContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CancelBuildIndexContext {
	var p = new(CancelBuildIndexContext)

	InitEmptySupportedCancelStatementContext(&p.SupportedCancelStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedCancelStatementContext))

	return p
}

func (s *CancelBuildIndexContext) Get_INTEGER_VALUE() antlr.Token { return s._INTEGER_VALUE }

func (s *CancelBuildIndexContext) Set_INTEGER_VALUE(v antlr.Token) { s._INTEGER_VALUE = v }

func (s *CancelBuildIndexContext) GetJobIds() []antlr.Token { return s.jobIds }

func (s *CancelBuildIndexContext) SetJobIds(v []antlr.Token) { s.jobIds = v }

func (s *CancelBuildIndexContext) GetTableName() IMultipartIdentifierContext { return s.tableName }

func (s *CancelBuildIndexContext) SetTableName(v IMultipartIdentifierContext) { s.tableName = v }

func (s *CancelBuildIndexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CancelBuildIndexContext) CANCEL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCANCEL, 0)
}

func (s *CancelBuildIndexContext) BUILD() antlr.TerminalNode {
	return s.GetToken(DorisParserParserBUILD, 0)
}

func (s *CancelBuildIndexContext) INDEX() antlr.TerminalNode {
	return s.GetToken(DorisParserParserINDEX, 0)
}

func (s *CancelBuildIndexContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisParserParserON, 0)
}

func (s *CancelBuildIndexContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *CancelBuildIndexContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLEFT_PAREN, 0)
}

func (s *CancelBuildIndexContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRIGHT_PAREN, 0)
}

func (s *CancelBuildIndexContext) AllINTEGER_VALUE() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserINTEGER_VALUE)
}

func (s *CancelBuildIndexContext) INTEGER_VALUE(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserINTEGER_VALUE, i)
}

func (s *CancelBuildIndexContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserCOMMA)
}

func (s *CancelBuildIndexContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOMMA, i)
}

func (s *CancelBuildIndexContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitCancelBuildIndex(s)

	default:
		return t.VisitChildren(s)
	}
}

type CancelRestoreContext struct {
	SupportedCancelStatementContext
	database IIdentifierContext
}

func NewCancelRestoreContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CancelRestoreContext {
	var p = new(CancelRestoreContext)

	InitEmptySupportedCancelStatementContext(&p.SupportedCancelStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedCancelStatementContext))

	return p
}

func (s *CancelRestoreContext) GetDatabase() IIdentifierContext { return s.database }

func (s *CancelRestoreContext) SetDatabase(v IIdentifierContext) { s.database = v }

func (s *CancelRestoreContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CancelRestoreContext) CANCEL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCANCEL, 0)
}

func (s *CancelRestoreContext) RESTORE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRESTORE, 0)
}

func (s *CancelRestoreContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFROM, 0)
}

func (s *CancelRestoreContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserIN, 0)
}

func (s *CancelRestoreContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CancelRestoreContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitCancelRestore(s)

	default:
		return t.VisitChildren(s)
	}
}

type CancelLoadContext struct {
	SupportedCancelStatementContext
	database IIdentifierContext
}

func NewCancelLoadContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CancelLoadContext {
	var p = new(CancelLoadContext)

	InitEmptySupportedCancelStatementContext(&p.SupportedCancelStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedCancelStatementContext))

	return p
}

func (s *CancelLoadContext) GetDatabase() IIdentifierContext { return s.database }

func (s *CancelLoadContext) SetDatabase(v IIdentifierContext) { s.database = v }

func (s *CancelLoadContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CancelLoadContext) CANCEL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCANCEL, 0)
}

func (s *CancelLoadContext) LOAD() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLOAD, 0)
}

func (s *CancelLoadContext) WildWhere() IWildWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWildWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWildWhereContext)
}

func (s *CancelLoadContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFROM, 0)
}

func (s *CancelLoadContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserIN, 0)
}

func (s *CancelLoadContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CancelLoadContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitCancelLoad(s)

	default:
		return t.VisitChildren(s)
	}
}

type CancelDecommisionBackendContext struct {
	SupportedCancelStatementContext
	_STRING_LITERAL antlr.Token
	hostPorts       []antlr.Token
}

func NewCancelDecommisionBackendContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CancelDecommisionBackendContext {
	var p = new(CancelDecommisionBackendContext)

	InitEmptySupportedCancelStatementContext(&p.SupportedCancelStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedCancelStatementContext))

	return p
}

func (s *CancelDecommisionBackendContext) Get_STRING_LITERAL() antlr.Token { return s._STRING_LITERAL }

func (s *CancelDecommisionBackendContext) Set_STRING_LITERAL(v antlr.Token) { s._STRING_LITERAL = v }

func (s *CancelDecommisionBackendContext) GetHostPorts() []antlr.Token { return s.hostPorts }

func (s *CancelDecommisionBackendContext) SetHostPorts(v []antlr.Token) { s.hostPorts = v }

func (s *CancelDecommisionBackendContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CancelDecommisionBackendContext) CANCEL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCANCEL, 0)
}

func (s *CancelDecommisionBackendContext) DECOMMISSION() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDECOMMISSION, 0)
}

func (s *CancelDecommisionBackendContext) BACKEND() antlr.TerminalNode {
	return s.GetToken(DorisParserParserBACKEND, 0)
}

func (s *CancelDecommisionBackendContext) AllSTRING_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserSTRING_LITERAL)
}

func (s *CancelDecommisionBackendContext) STRING_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTRING_LITERAL, i)
}

func (s *CancelDecommisionBackendContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserCOMMA)
}

func (s *CancelDecommisionBackendContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOMMA, i)
}

func (s *CancelDecommisionBackendContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitCancelDecommisionBackend(s)

	default:
		return t.VisitChildren(s)
	}
}

type CancelAlterTableContext struct {
	SupportedCancelStatementContext
	tableName      IMultipartIdentifierContext
	_INTEGER_VALUE antlr.Token
	jobIds         []antlr.Token
}

func NewCancelAlterTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CancelAlterTableContext {
	var p = new(CancelAlterTableContext)

	InitEmptySupportedCancelStatementContext(&p.SupportedCancelStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedCancelStatementContext))

	return p
}

func (s *CancelAlterTableContext) Get_INTEGER_VALUE() antlr.Token { return s._INTEGER_VALUE }

func (s *CancelAlterTableContext) Set_INTEGER_VALUE(v antlr.Token) { s._INTEGER_VALUE = v }

func (s *CancelAlterTableContext) GetJobIds() []antlr.Token { return s.jobIds }

func (s *CancelAlterTableContext) SetJobIds(v []antlr.Token) { s.jobIds = v }

func (s *CancelAlterTableContext) GetTableName() IMultipartIdentifierContext { return s.tableName }

func (s *CancelAlterTableContext) SetTableName(v IMultipartIdentifierContext) { s.tableName = v }

func (s *CancelAlterTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CancelAlterTableContext) CANCEL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCANCEL, 0)
}

func (s *CancelAlterTableContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserParserALTER, 0)
}

func (s *CancelAlterTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserTABLE, 0)
}

func (s *CancelAlterTableContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFROM, 0)
}

func (s *CancelAlterTableContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *CancelAlterTableContext) ROLLUP() antlr.TerminalNode {
	return s.GetToken(DorisParserParserROLLUP, 0)
}

func (s *CancelAlterTableContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOLUMN, 0)
}

func (s *CancelAlterTableContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLEFT_PAREN, 0)
}

func (s *CancelAlterTableContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRIGHT_PAREN, 0)
}

func (s *CancelAlterTableContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(DorisParserParserMATERIALIZED, 0)
}

func (s *CancelAlterTableContext) VIEW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserVIEW, 0)
}

func (s *CancelAlterTableContext) AllINTEGER_VALUE() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserINTEGER_VALUE)
}

func (s *CancelAlterTableContext) INTEGER_VALUE(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserINTEGER_VALUE, i)
}

func (s *CancelAlterTableContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserCOMMA)
}

func (s *CancelAlterTableContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOMMA, i)
}

func (s *CancelAlterTableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitCancelAlterTable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) SupportedCancelStatement() (localctx ISupportedCancelStatementContext) {
	localctx = NewSupportedCancelStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, DorisParserParserRULE_supportedCancelStatement)
	var _la int

	p.SetState(3073)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 410, p.GetParserRuleContext()) {
	case 1:
		localctx = NewCancelLoadContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2985)
			p.Match(DorisParserParserCANCEL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2986)
			p.Match(DorisParserParserLOAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2989)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserFROM || _la == DorisParserParserIN {
			{
				p.SetState(2987)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserParserFROM || _la == DorisParserParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(2988)

				var _x = p.Identifier()

				localctx.(*CancelLoadContext).database = _x
			}

		}
		p.SetState(2992)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserLIKE || _la == DorisParserParserWHERE {
			{
				p.SetState(2991)
				p.WildWhere()
			}

		}

	case 2:
		localctx = NewCancelExportContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2994)
			p.Match(DorisParserParserCANCEL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2995)
			p.Match(DorisParserParserEXPORT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2998)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserFROM || _la == DorisParserParserIN {
			{
				p.SetState(2996)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserParserFROM || _la == DorisParserParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(2997)

				var _x = p.Identifier()

				localctx.(*CancelExportContext).database = _x
			}

		}
		p.SetState(3001)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserLIKE || _la == DorisParserParserWHERE {
			{
				p.SetState(3000)
				p.WildWhere()
			}

		}

	case 3:
		localctx = NewCancelWarmUpJobContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3003)
			p.Match(DorisParserParserCANCEL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3004)
			p.Match(DorisParserParserWARM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3005)
			p.Match(DorisParserParserUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3006)
			p.Match(DorisParserParserJOB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3008)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserLIKE || _la == DorisParserParserWHERE {
			{
				p.SetState(3007)
				p.WildWhere()
			}

		}

	case 4:
		localctx = NewCancelDecommisionBackendContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3010)
			p.Match(DorisParserParserCANCEL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3011)
			p.Match(DorisParserParserDECOMMISSION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3012)
			p.Match(DorisParserParserBACKEND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3013)

			var _m = p.Match(DorisParserParserSTRING_LITERAL)

			localctx.(*CancelDecommisionBackendContext)._STRING_LITERAL = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*CancelDecommisionBackendContext).hostPorts = append(localctx.(*CancelDecommisionBackendContext).hostPorts, localctx.(*CancelDecommisionBackendContext)._STRING_LITERAL)
		p.SetState(3018)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserParserCOMMA {
			{
				p.SetState(3014)
				p.Match(DorisParserParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3015)

				var _m = p.Match(DorisParserParserSTRING_LITERAL)

				localctx.(*CancelDecommisionBackendContext)._STRING_LITERAL = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			localctx.(*CancelDecommisionBackendContext).hostPorts = append(localctx.(*CancelDecommisionBackendContext).hostPorts, localctx.(*CancelDecommisionBackendContext)._STRING_LITERAL)

			p.SetState(3020)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 5:
		localctx = NewCancelBackupContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(3021)
			p.Match(DorisParserParserCANCEL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3022)
			p.Match(DorisParserParserBACKUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3025)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserFROM || _la == DorisParserParserIN {
			{
				p.SetState(3023)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserParserFROM || _la == DorisParserParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(3024)

				var _x = p.Identifier()

				localctx.(*CancelBackupContext).database = _x
			}

		}

	case 6:
		localctx = NewCancelRestoreContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(3027)
			p.Match(DorisParserParserCANCEL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3028)
			p.Match(DorisParserParserRESTORE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3031)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserFROM || _la == DorisParserParserIN {
			{
				p.SetState(3029)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserParserFROM || _la == DorisParserParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(3030)

				var _x = p.Identifier()

				localctx.(*CancelRestoreContext).database = _x
			}

		}

	case 7:
		localctx = NewCancelBuildIndexContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(3033)
			p.Match(DorisParserParserCANCEL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3034)
			p.Match(DorisParserParserBUILD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3035)
			p.Match(DorisParserParserINDEX)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3036)
			p.Match(DorisParserParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3037)

			var _x = p.MultipartIdentifier()

			localctx.(*CancelBuildIndexContext).tableName = _x
		}
		p.SetState(3048)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserLEFT_PAREN {
			{
				p.SetState(3038)
				p.Match(DorisParserParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3039)

				var _m = p.Match(DorisParserParserINTEGER_VALUE)

				localctx.(*CancelBuildIndexContext)._INTEGER_VALUE = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			localctx.(*CancelBuildIndexContext).jobIds = append(localctx.(*CancelBuildIndexContext).jobIds, localctx.(*CancelBuildIndexContext)._INTEGER_VALUE)
			p.SetState(3044)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == DorisParserParserCOMMA {
				{
					p.SetState(3040)
					p.Match(DorisParserParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(3041)

					var _m = p.Match(DorisParserParserINTEGER_VALUE)

					localctx.(*CancelBuildIndexContext)._INTEGER_VALUE = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				localctx.(*CancelBuildIndexContext).jobIds = append(localctx.(*CancelBuildIndexContext).jobIds, localctx.(*CancelBuildIndexContext)._INTEGER_VALUE)

				p.SetState(3046)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(3047)
				p.Match(DorisParserParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 8:
		localctx = NewCancelAlterTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(3050)
			p.Match(DorisParserParserCANCEL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3051)
			p.Match(DorisParserParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3052)
			p.Match(DorisParserParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3057)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserParserROLLUP:
			{
				p.SetState(3053)
				p.Match(DorisParserParserROLLUP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserParserMATERIALIZED:
			{
				p.SetState(3054)
				p.Match(DorisParserParserMATERIALIZED)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3055)
				p.Match(DorisParserParserVIEW)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserParserCOLUMN:
			{
				p.SetState(3056)
				p.Match(DorisParserParserCOLUMN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(3059)
			p.Match(DorisParserParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3060)

			var _x = p.MultipartIdentifier()

			localctx.(*CancelAlterTableContext).tableName = _x
		}
		p.SetState(3071)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserLEFT_PAREN {
			{
				p.SetState(3061)
				p.Match(DorisParserParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3062)

				var _m = p.Match(DorisParserParserINTEGER_VALUE)

				localctx.(*CancelAlterTableContext)._INTEGER_VALUE = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			localctx.(*CancelAlterTableContext).jobIds = append(localctx.(*CancelAlterTableContext).jobIds, localctx.(*CancelAlterTableContext)._INTEGER_VALUE)
			p.SetState(3067)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == DorisParserParserCOMMA {
				{
					p.SetState(3063)
					p.Match(DorisParserParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(3064)

					var _m = p.Match(DorisParserParserINTEGER_VALUE)

					localctx.(*CancelAlterTableContext)._INTEGER_VALUE = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				localctx.(*CancelAlterTableContext).jobIds = append(localctx.(*CancelAlterTableContext).jobIds, localctx.(*CancelAlterTableContext)._INTEGER_VALUE)

				p.SetState(3069)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(3070)
				p.Match(DorisParserParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISupportedAdminStatementContext is an interface to support dynamic dispatch.
type ISupportedAdminStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSupportedAdminStatementContext differentiates from other interfaces.
	IsSupportedAdminStatementContext()
}

type SupportedAdminStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySupportedAdminStatementContext() *SupportedAdminStatementContext {
	var p = new(SupportedAdminStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_supportedAdminStatement
	return p
}

func InitEmptySupportedAdminStatementContext(p *SupportedAdminStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_supportedAdminStatement
}

func (*SupportedAdminStatementContext) IsSupportedAdminStatementContext() {}

func NewSupportedAdminStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SupportedAdminStatementContext {
	var p = new(SupportedAdminStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_supportedAdminStatement

	return p
}

func (s *SupportedAdminStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SupportedAdminStatementContext) CopyAll(ctx *SupportedAdminStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *SupportedAdminStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedAdminStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type AdminShowReplicaDistributionContext struct {
	SupportedAdminStatementContext
}

func NewAdminShowReplicaDistributionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AdminShowReplicaDistributionContext {
	var p = new(AdminShowReplicaDistributionContext)

	InitEmptySupportedAdminStatementContext(&p.SupportedAdminStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedAdminStatementContext))

	return p
}

func (s *AdminShowReplicaDistributionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdminShowReplicaDistributionContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserADMIN, 0)
}

func (s *AdminShowReplicaDistributionContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSHOW, 0)
}

func (s *AdminShowReplicaDistributionContext) REPLICA() antlr.TerminalNode {
	return s.GetToken(DorisParserParserREPLICA, 0)
}

func (s *AdminShowReplicaDistributionContext) DISTRIBUTION() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDISTRIBUTION, 0)
}

func (s *AdminShowReplicaDistributionContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFROM, 0)
}

func (s *AdminShowReplicaDistributionContext) BaseTableRef() IBaseTableRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBaseTableRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBaseTableRefContext)
}

func (s *AdminShowReplicaDistributionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitAdminShowReplicaDistribution(s)

	default:
		return t.VisitChildren(s)
	}
}

type AdminShowTabletStorageFormatContext struct {
	SupportedAdminStatementContext
}

func NewAdminShowTabletStorageFormatContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AdminShowTabletStorageFormatContext {
	var p = new(AdminShowTabletStorageFormatContext)

	InitEmptySupportedAdminStatementContext(&p.SupportedAdminStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedAdminStatementContext))

	return p
}

func (s *AdminShowTabletStorageFormatContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdminShowTabletStorageFormatContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserADMIN, 0)
}

func (s *AdminShowTabletStorageFormatContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSHOW, 0)
}

func (s *AdminShowTabletStorageFormatContext) TABLET() antlr.TerminalNode {
	return s.GetToken(DorisParserParserTABLET, 0)
}

func (s *AdminShowTabletStorageFormatContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTORAGE, 0)
}

func (s *AdminShowTabletStorageFormatContext) FORMAT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFORMAT, 0)
}

func (s *AdminShowTabletStorageFormatContext) VERBOSE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserVERBOSE, 0)
}

func (s *AdminShowTabletStorageFormatContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitAdminShowTabletStorageFormat(s)

	default:
		return t.VisitChildren(s)
	}
}

type AdminRebalanceDiskContext struct {
	SupportedAdminStatementContext
	_STRING_LITERAL antlr.Token
	backends        []antlr.Token
}

func NewAdminRebalanceDiskContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AdminRebalanceDiskContext {
	var p = new(AdminRebalanceDiskContext)

	InitEmptySupportedAdminStatementContext(&p.SupportedAdminStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedAdminStatementContext))

	return p
}

func (s *AdminRebalanceDiskContext) Get_STRING_LITERAL() antlr.Token { return s._STRING_LITERAL }

func (s *AdminRebalanceDiskContext) Set_STRING_LITERAL(v antlr.Token) { s._STRING_LITERAL = v }

func (s *AdminRebalanceDiskContext) GetBackends() []antlr.Token { return s.backends }

func (s *AdminRebalanceDiskContext) SetBackends(v []antlr.Token) { s.backends = v }

func (s *AdminRebalanceDiskContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdminRebalanceDiskContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserADMIN, 0)
}

func (s *AdminRebalanceDiskContext) REBALANCE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserREBALANCE, 0)
}

func (s *AdminRebalanceDiskContext) DISK() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDISK, 0)
}

func (s *AdminRebalanceDiskContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisParserParserON, 0)
}

func (s *AdminRebalanceDiskContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLEFT_PAREN, 0)
}

func (s *AdminRebalanceDiskContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRIGHT_PAREN, 0)
}

func (s *AdminRebalanceDiskContext) AllSTRING_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserSTRING_LITERAL)
}

func (s *AdminRebalanceDiskContext) STRING_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTRING_LITERAL, i)
}

func (s *AdminRebalanceDiskContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserCOMMA)
}

func (s *AdminRebalanceDiskContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOMMA, i)
}

func (s *AdminRebalanceDiskContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitAdminRebalanceDisk(s)

	default:
		return t.VisitChildren(s)
	}
}

type AdminSetReplicaStatusContext struct {
	SupportedAdminStatementContext
}

func NewAdminSetReplicaStatusContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AdminSetReplicaStatusContext {
	var p = new(AdminSetReplicaStatusContext)

	InitEmptySupportedAdminStatementContext(&p.SupportedAdminStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedAdminStatementContext))

	return p
}

func (s *AdminSetReplicaStatusContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdminSetReplicaStatusContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserADMIN, 0)
}

func (s *AdminSetReplicaStatusContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSET, 0)
}

func (s *AdminSetReplicaStatusContext) REPLICA() antlr.TerminalNode {
	return s.GetToken(DorisParserParserREPLICA, 0)
}

func (s *AdminSetReplicaStatusContext) STATUS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTATUS, 0)
}

func (s *AdminSetReplicaStatusContext) PROPERTIES() antlr.TerminalNode {
	return s.GetToken(DorisParserParserPROPERTIES, 0)
}

func (s *AdminSetReplicaStatusContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLEFT_PAREN, 0)
}

func (s *AdminSetReplicaStatusContext) PropertyItemList() IPropertyItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyItemListContext)
}

func (s *AdminSetReplicaStatusContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRIGHT_PAREN, 0)
}

func (s *AdminSetReplicaStatusContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitAdminSetReplicaStatus(s)

	default:
		return t.VisitChildren(s)
	}
}

type AdminSetReplicaVersionContext struct {
	SupportedAdminStatementContext
}

func NewAdminSetReplicaVersionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AdminSetReplicaVersionContext {
	var p = new(AdminSetReplicaVersionContext)

	InitEmptySupportedAdminStatementContext(&p.SupportedAdminStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedAdminStatementContext))

	return p
}

func (s *AdminSetReplicaVersionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdminSetReplicaVersionContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserADMIN, 0)
}

func (s *AdminSetReplicaVersionContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSET, 0)
}

func (s *AdminSetReplicaVersionContext) REPLICA() antlr.TerminalNode {
	return s.GetToken(DorisParserParserREPLICA, 0)
}

func (s *AdminSetReplicaVersionContext) VERSION() antlr.TerminalNode {
	return s.GetToken(DorisParserParserVERSION, 0)
}

func (s *AdminSetReplicaVersionContext) PROPERTIES() antlr.TerminalNode {
	return s.GetToken(DorisParserParserPROPERTIES, 0)
}

func (s *AdminSetReplicaVersionContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLEFT_PAREN, 0)
}

func (s *AdminSetReplicaVersionContext) PropertyItemList() IPropertyItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyItemListContext)
}

func (s *AdminSetReplicaVersionContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRIGHT_PAREN, 0)
}

func (s *AdminSetReplicaVersionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitAdminSetReplicaVersion(s)

	default:
		return t.VisitChildren(s)
	}
}

type AdminSetTableStatusContext struct {
	SupportedAdminStatementContext
	name       IMultipartIdentifierContext
	properties IPropertyClauseContext
}

func NewAdminSetTableStatusContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AdminSetTableStatusContext {
	var p = new(AdminSetTableStatusContext)

	InitEmptySupportedAdminStatementContext(&p.SupportedAdminStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedAdminStatementContext))

	return p
}

func (s *AdminSetTableStatusContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *AdminSetTableStatusContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *AdminSetTableStatusContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *AdminSetTableStatusContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *AdminSetTableStatusContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdminSetTableStatusContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserADMIN, 0)
}

func (s *AdminSetTableStatusContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSET, 0)
}

func (s *AdminSetTableStatusContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserTABLE, 0)
}

func (s *AdminSetTableStatusContext) STATUS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTATUS, 0)
}

func (s *AdminSetTableStatusContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *AdminSetTableStatusContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *AdminSetTableStatusContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitAdminSetTableStatus(s)

	default:
		return t.VisitChildren(s)
	}
}

type AdminCancelRepairTableContext struct {
	SupportedAdminStatementContext
}

func NewAdminCancelRepairTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AdminCancelRepairTableContext {
	var p = new(AdminCancelRepairTableContext)

	InitEmptySupportedAdminStatementContext(&p.SupportedAdminStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedAdminStatementContext))

	return p
}

func (s *AdminCancelRepairTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdminCancelRepairTableContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserADMIN, 0)
}

func (s *AdminCancelRepairTableContext) CANCEL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCANCEL, 0)
}

func (s *AdminCancelRepairTableContext) REPAIR() antlr.TerminalNode {
	return s.GetToken(DorisParserParserREPAIR, 0)
}

func (s *AdminCancelRepairTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserTABLE, 0)
}

func (s *AdminCancelRepairTableContext) BaseTableRef() IBaseTableRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBaseTableRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBaseTableRefContext)
}

func (s *AdminCancelRepairTableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitAdminCancelRepairTable(s)

	default:
		return t.VisitChildren(s)
	}
}

type AdminCopyTabletContext struct {
	SupportedAdminStatementContext
	tabletId   antlr.Token
	properties IPropertyClauseContext
}

func NewAdminCopyTabletContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AdminCopyTabletContext {
	var p = new(AdminCopyTabletContext)

	InitEmptySupportedAdminStatementContext(&p.SupportedAdminStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedAdminStatementContext))

	return p
}

func (s *AdminCopyTabletContext) GetTabletId() antlr.Token { return s.tabletId }

func (s *AdminCopyTabletContext) SetTabletId(v antlr.Token) { s.tabletId = v }

func (s *AdminCopyTabletContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *AdminCopyTabletContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *AdminCopyTabletContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdminCopyTabletContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserADMIN, 0)
}

func (s *AdminCopyTabletContext) COPY() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOPY, 0)
}

func (s *AdminCopyTabletContext) TABLET() antlr.TerminalNode {
	return s.GetToken(DorisParserParserTABLET, 0)
}

func (s *AdminCopyTabletContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserINTEGER_VALUE, 0)
}

func (s *AdminCopyTabletContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *AdminCopyTabletContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitAdminCopyTablet(s)

	default:
		return t.VisitChildren(s)
	}
}

type AdminRepairTableContext struct {
	SupportedAdminStatementContext
}

func NewAdminRepairTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AdminRepairTableContext {
	var p = new(AdminRepairTableContext)

	InitEmptySupportedAdminStatementContext(&p.SupportedAdminStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedAdminStatementContext))

	return p
}

func (s *AdminRepairTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdminRepairTableContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserADMIN, 0)
}

func (s *AdminRepairTableContext) REPAIR() antlr.TerminalNode {
	return s.GetToken(DorisParserParserREPAIR, 0)
}

func (s *AdminRepairTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserTABLE, 0)
}

func (s *AdminRepairTableContext) BaseTableRef() IBaseTableRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBaseTableRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBaseTableRefContext)
}

func (s *AdminRepairTableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitAdminRepairTable(s)

	default:
		return t.VisitChildren(s)
	}
}

type AdminSetFrontendConfigContext struct {
	SupportedAdminStatementContext
}

func NewAdminSetFrontendConfigContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AdminSetFrontendConfigContext {
	var p = new(AdminSetFrontendConfigContext)

	InitEmptySupportedAdminStatementContext(&p.SupportedAdminStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedAdminStatementContext))

	return p
}

func (s *AdminSetFrontendConfigContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdminSetFrontendConfigContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserADMIN, 0)
}

func (s *AdminSetFrontendConfigContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSET, 0)
}

func (s *AdminSetFrontendConfigContext) CONFIG() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCONFIG, 0)
}

func (s *AdminSetFrontendConfigContext) FRONTEND() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFRONTEND, 0)
}

func (s *AdminSetFrontendConfigContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLEFT_PAREN, 0)
}

func (s *AdminSetFrontendConfigContext) PropertyItemList() IPropertyItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyItemListContext)
}

func (s *AdminSetFrontendConfigContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRIGHT_PAREN, 0)
}

func (s *AdminSetFrontendConfigContext) AllALL() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserALL)
}

func (s *AdminSetFrontendConfigContext) ALL(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserALL, i)
}

func (s *AdminSetFrontendConfigContext) FRONTENDS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFRONTENDS, 0)
}

func (s *AdminSetFrontendConfigContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitAdminSetFrontendConfig(s)

	default:
		return t.VisitChildren(s)
	}
}

type AdminCheckTabletsContext struct {
	SupportedAdminStatementContext
	properties IPropertyClauseContext
}

func NewAdminCheckTabletsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AdminCheckTabletsContext {
	var p = new(AdminCheckTabletsContext)

	InitEmptySupportedAdminStatementContext(&p.SupportedAdminStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedAdminStatementContext))

	return p
}

func (s *AdminCheckTabletsContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *AdminCheckTabletsContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *AdminCheckTabletsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdminCheckTabletsContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserADMIN, 0)
}

func (s *AdminCheckTabletsContext) CHECK() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCHECK, 0)
}

func (s *AdminCheckTabletsContext) TabletList() ITabletListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITabletListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITabletListContext)
}

func (s *AdminCheckTabletsContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *AdminCheckTabletsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitAdminCheckTablets(s)

	default:
		return t.VisitChildren(s)
	}
}

type AdminCleanTrashContext struct {
	SupportedAdminStatementContext
	_STRING_LITERAL antlr.Token
	backends        []antlr.Token
}

func NewAdminCleanTrashContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AdminCleanTrashContext {
	var p = new(AdminCleanTrashContext)

	InitEmptySupportedAdminStatementContext(&p.SupportedAdminStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedAdminStatementContext))

	return p
}

func (s *AdminCleanTrashContext) Get_STRING_LITERAL() antlr.Token { return s._STRING_LITERAL }

func (s *AdminCleanTrashContext) Set_STRING_LITERAL(v antlr.Token) { s._STRING_LITERAL = v }

func (s *AdminCleanTrashContext) GetBackends() []antlr.Token { return s.backends }

func (s *AdminCleanTrashContext) SetBackends(v []antlr.Token) { s.backends = v }

func (s *AdminCleanTrashContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdminCleanTrashContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserADMIN, 0)
}

func (s *AdminCleanTrashContext) CLEAN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCLEAN, 0)
}

func (s *AdminCleanTrashContext) TRASH() antlr.TerminalNode {
	return s.GetToken(DorisParserParserTRASH, 0)
}

func (s *AdminCleanTrashContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisParserParserON, 0)
}

func (s *AdminCleanTrashContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLEFT_PAREN, 0)
}

func (s *AdminCleanTrashContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRIGHT_PAREN, 0)
}

func (s *AdminCleanTrashContext) AllSTRING_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserSTRING_LITERAL)
}

func (s *AdminCleanTrashContext) STRING_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTRING_LITERAL, i)
}

func (s *AdminCleanTrashContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserCOMMA)
}

func (s *AdminCleanTrashContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOMMA, i)
}

func (s *AdminCleanTrashContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitAdminCleanTrash(s)

	default:
		return t.VisitChildren(s)
	}
}

type AdminCompactTableContext struct {
	SupportedAdminStatementContext
}

func NewAdminCompactTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AdminCompactTableContext {
	var p = new(AdminCompactTableContext)

	InitEmptySupportedAdminStatementContext(&p.SupportedAdminStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedAdminStatementContext))

	return p
}

func (s *AdminCompactTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdminCompactTableContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserADMIN, 0)
}

func (s *AdminCompactTableContext) COMPACT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOMPACT, 0)
}

func (s *AdminCompactTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserTABLE, 0)
}

func (s *AdminCompactTableContext) BaseTableRef() IBaseTableRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBaseTableRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBaseTableRefContext)
}

func (s *AdminCompactTableContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserWHERE, 0)
}

func (s *AdminCompactTableContext) TYPE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserTYPE, 0)
}

func (s *AdminCompactTableContext) EQ() antlr.TerminalNode {
	return s.GetToken(DorisParserParserEQ, 0)
}

func (s *AdminCompactTableContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTRING_LITERAL, 0)
}

func (s *AdminCompactTableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitAdminCompactTable(s)

	default:
		return t.VisitChildren(s)
	}
}

type AdminDiagnoseTabletContext struct {
	SupportedAdminStatementContext
	tabletId antlr.Token
}

func NewAdminDiagnoseTabletContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AdminDiagnoseTabletContext {
	var p = new(AdminDiagnoseTabletContext)

	InitEmptySupportedAdminStatementContext(&p.SupportedAdminStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedAdminStatementContext))

	return p
}

func (s *AdminDiagnoseTabletContext) GetTabletId() antlr.Token { return s.tabletId }

func (s *AdminDiagnoseTabletContext) SetTabletId(v antlr.Token) { s.tabletId = v }

func (s *AdminDiagnoseTabletContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdminDiagnoseTabletContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserADMIN, 0)
}

func (s *AdminDiagnoseTabletContext) DIAGNOSE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDIAGNOSE, 0)
}

func (s *AdminDiagnoseTabletContext) TABLET() antlr.TerminalNode {
	return s.GetToken(DorisParserParserTABLET, 0)
}

func (s *AdminDiagnoseTabletContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserINTEGER_VALUE, 0)
}

func (s *AdminDiagnoseTabletContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitAdminDiagnoseTablet(s)

	default:
		return t.VisitChildren(s)
	}
}

type AdminCancelRebalanceDiskContext struct {
	SupportedAdminStatementContext
	_STRING_LITERAL antlr.Token
	backends        []antlr.Token
}

func NewAdminCancelRebalanceDiskContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AdminCancelRebalanceDiskContext {
	var p = new(AdminCancelRebalanceDiskContext)

	InitEmptySupportedAdminStatementContext(&p.SupportedAdminStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedAdminStatementContext))

	return p
}

func (s *AdminCancelRebalanceDiskContext) Get_STRING_LITERAL() antlr.Token { return s._STRING_LITERAL }

func (s *AdminCancelRebalanceDiskContext) Set_STRING_LITERAL(v antlr.Token) { s._STRING_LITERAL = v }

func (s *AdminCancelRebalanceDiskContext) GetBackends() []antlr.Token { return s.backends }

func (s *AdminCancelRebalanceDiskContext) SetBackends(v []antlr.Token) { s.backends = v }

func (s *AdminCancelRebalanceDiskContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdminCancelRebalanceDiskContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserADMIN, 0)
}

func (s *AdminCancelRebalanceDiskContext) CANCEL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCANCEL, 0)
}

func (s *AdminCancelRebalanceDiskContext) REBALANCE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserREBALANCE, 0)
}

func (s *AdminCancelRebalanceDiskContext) DISK() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDISK, 0)
}

func (s *AdminCancelRebalanceDiskContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisParserParserON, 0)
}

func (s *AdminCancelRebalanceDiskContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLEFT_PAREN, 0)
}

func (s *AdminCancelRebalanceDiskContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRIGHT_PAREN, 0)
}

func (s *AdminCancelRebalanceDiskContext) AllSTRING_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserSTRING_LITERAL)
}

func (s *AdminCancelRebalanceDiskContext) STRING_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTRING_LITERAL, i)
}

func (s *AdminCancelRebalanceDiskContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserCOMMA)
}

func (s *AdminCancelRebalanceDiskContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOMMA, i)
}

func (s *AdminCancelRebalanceDiskContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitAdminCancelRebalanceDisk(s)

	default:
		return t.VisitChildren(s)
	}
}

type AdminShowReplicaStatusContext struct {
	SupportedAdminStatementContext
}

func NewAdminShowReplicaStatusContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AdminShowReplicaStatusContext {
	var p = new(AdminShowReplicaStatusContext)

	InitEmptySupportedAdminStatementContext(&p.SupportedAdminStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedAdminStatementContext))

	return p
}

func (s *AdminShowReplicaStatusContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdminShowReplicaStatusContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserADMIN, 0)
}

func (s *AdminShowReplicaStatusContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSHOW, 0)
}

func (s *AdminShowReplicaStatusContext) REPLICA() antlr.TerminalNode {
	return s.GetToken(DorisParserParserREPLICA, 0)
}

func (s *AdminShowReplicaStatusContext) AllSTATUS() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserSTATUS)
}

func (s *AdminShowReplicaStatusContext) STATUS(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTATUS, i)
}

func (s *AdminShowReplicaStatusContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFROM, 0)
}

func (s *AdminShowReplicaStatusContext) BaseTableRef() IBaseTableRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBaseTableRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBaseTableRefContext)
}

func (s *AdminShowReplicaStatusContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserWHERE, 0)
}

func (s *AdminShowReplicaStatusContext) EQ() antlr.TerminalNode {
	return s.GetToken(DorisParserParserEQ, 0)
}

func (s *AdminShowReplicaStatusContext) NEQ() antlr.TerminalNode {
	return s.GetToken(DorisParserParserNEQ, 0)
}

func (s *AdminShowReplicaStatusContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTRING_LITERAL, 0)
}

func (s *AdminShowReplicaStatusContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitAdminShowReplicaStatus(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) SupportedAdminStatement() (localctx ISupportedAdminStatementContext) {
	localctx = NewSupportedAdminStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, DorisParserParserRULE_supportedAdminStatement)
	var _la int

	p.SetState(3230)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 426, p.GetParserRuleContext()) {
	case 1:
		localctx = NewAdminShowReplicaDistributionContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3075)
			p.Match(DorisParserParserADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3076)
			p.Match(DorisParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3077)
			p.Match(DorisParserParserREPLICA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3078)
			p.Match(DorisParserParserDISTRIBUTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3079)
			p.Match(DorisParserParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3080)
			p.BaseTableRef()
		}

	case 2:
		localctx = NewAdminRebalanceDiskContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3081)
			p.Match(DorisParserParserADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3082)
			p.Match(DorisParserParserREBALANCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3083)
			p.Match(DorisParserParserDISK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3095)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserON {
			{
				p.SetState(3084)
				p.Match(DorisParserParserON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3085)
				p.Match(DorisParserParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3086)

				var _m = p.Match(DorisParserParserSTRING_LITERAL)

				localctx.(*AdminRebalanceDiskContext)._STRING_LITERAL = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			localctx.(*AdminRebalanceDiskContext).backends = append(localctx.(*AdminRebalanceDiskContext).backends, localctx.(*AdminRebalanceDiskContext)._STRING_LITERAL)
			p.SetState(3091)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == DorisParserParserCOMMA {
				{
					p.SetState(3087)
					p.Match(DorisParserParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(3088)

					var _m = p.Match(DorisParserParserSTRING_LITERAL)

					localctx.(*AdminRebalanceDiskContext)._STRING_LITERAL = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				localctx.(*AdminRebalanceDiskContext).backends = append(localctx.(*AdminRebalanceDiskContext).backends, localctx.(*AdminRebalanceDiskContext)._STRING_LITERAL)

				p.SetState(3093)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(3094)
				p.Match(DorisParserParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 3:
		localctx = NewAdminCancelRebalanceDiskContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3097)
			p.Match(DorisParserParserADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3098)
			p.Match(DorisParserParserCANCEL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3099)
			p.Match(DorisParserParserREBALANCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3100)
			p.Match(DorisParserParserDISK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3112)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserON {
			{
				p.SetState(3101)
				p.Match(DorisParserParserON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3102)
				p.Match(DorisParserParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3103)

				var _m = p.Match(DorisParserParserSTRING_LITERAL)

				localctx.(*AdminCancelRebalanceDiskContext)._STRING_LITERAL = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			localctx.(*AdminCancelRebalanceDiskContext).backends = append(localctx.(*AdminCancelRebalanceDiskContext).backends, localctx.(*AdminCancelRebalanceDiskContext)._STRING_LITERAL)
			p.SetState(3108)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == DorisParserParserCOMMA {
				{
					p.SetState(3104)
					p.Match(DorisParserParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(3105)

					var _m = p.Match(DorisParserParserSTRING_LITERAL)

					localctx.(*AdminCancelRebalanceDiskContext)._STRING_LITERAL = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				localctx.(*AdminCancelRebalanceDiskContext).backends = append(localctx.(*AdminCancelRebalanceDiskContext).backends, localctx.(*AdminCancelRebalanceDiskContext)._STRING_LITERAL)

				p.SetState(3110)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(3111)
				p.Match(DorisParserParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 4:
		localctx = NewAdminDiagnoseTabletContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3114)
			p.Match(DorisParserParserADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3115)
			p.Match(DorisParserParserDIAGNOSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3116)
			p.Match(DorisParserParserTABLET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3117)

			var _m = p.Match(DorisParserParserINTEGER_VALUE)

			localctx.(*AdminDiagnoseTabletContext).tabletId = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		localctx = NewAdminShowReplicaStatusContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(3118)
			p.Match(DorisParserParserADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3119)
			p.Match(DorisParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3120)
			p.Match(DorisParserParserREPLICA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3121)
			p.Match(DorisParserParserSTATUS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3122)
			p.Match(DorisParserParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3123)
			p.BaseTableRef()
		}
		p.SetState(3129)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		switch p.GetTokenStream().LA(1) {
		case DorisParserParserWHERE:
			{
				p.SetState(3124)
				p.Match(DorisParserParserWHERE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3125)
				p.Match(DorisParserParserSTATUS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3126)
				p.Match(DorisParserParserEQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserParserNEQ:
			{
				p.SetState(3127)
				p.Match(DorisParserParserNEQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3128)
				p.Match(DorisParserParserSTRING_LITERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserParserEOF, DorisParserParserSEMICOLON:

		default:
		}

	case 6:
		localctx = NewAdminCompactTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(3131)
			p.Match(DorisParserParserADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3132)
			p.Match(DorisParserParserCOMPACT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3133)
			p.Match(DorisParserParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3134)
			p.BaseTableRef()
		}
		p.SetState(3139)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserWHERE {
			{
				p.SetState(3135)
				p.Match(DorisParserParserWHERE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3136)
				p.Match(DorisParserParserTYPE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3137)
				p.Match(DorisParserParserEQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3138)
				p.Match(DorisParserParserSTRING_LITERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 7:
		localctx = NewAdminCheckTabletsContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(3141)
			p.Match(DorisParserParserADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3142)
			p.Match(DorisParserParserCHECK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3143)
			p.TabletList()
		}
		p.SetState(3145)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserPROPERTIES {
			{
				p.SetState(3144)

				var _x = p.PropertyClause()

				localctx.(*AdminCheckTabletsContext).properties = _x
			}

		}

	case 8:
		localctx = NewAdminShowTabletStorageFormatContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(3147)
			p.Match(DorisParserParserADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3148)
			p.Match(DorisParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3149)
			p.Match(DorisParserParserTABLET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3150)
			p.Match(DorisParserParserSTORAGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3151)
			p.Match(DorisParserParserFORMAT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3153)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserVERBOSE {
			{
				p.SetState(3152)
				p.Match(DorisParserParserVERBOSE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 9:
		localctx = NewAdminSetFrontendConfigContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(3155)
			p.Match(DorisParserParserADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3156)
			p.Match(DorisParserParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3160)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserParserFRONTEND:
			{
				p.SetState(3157)
				p.Match(DorisParserParserFRONTEND)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserParserALL:
			{
				p.SetState(3158)
				p.Match(DorisParserParserALL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3159)
				p.Match(DorisParserParserFRONTENDS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(3162)
			p.Match(DorisParserParserCONFIG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3167)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserLEFT_PAREN {
			{
				p.SetState(3163)
				p.Match(DorisParserParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3164)
				p.PropertyItemList()
			}
			{
				p.SetState(3165)
				p.Match(DorisParserParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(3170)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserALL {
			{
				p.SetState(3169)
				p.Match(DorisParserParserALL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 10:
		localctx = NewAdminCleanTrashContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(3172)
			p.Match(DorisParserParserADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3173)
			p.Match(DorisParserParserCLEAN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3174)
			p.Match(DorisParserParserTRASH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3186)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserON {
			{
				p.SetState(3175)
				p.Match(DorisParserParserON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3176)
				p.Match(DorisParserParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3177)

				var _m = p.Match(DorisParserParserSTRING_LITERAL)

				localctx.(*AdminCleanTrashContext)._STRING_LITERAL = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			localctx.(*AdminCleanTrashContext).backends = append(localctx.(*AdminCleanTrashContext).backends, localctx.(*AdminCleanTrashContext)._STRING_LITERAL)
			p.SetState(3182)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == DorisParserParserCOMMA {
				{
					p.SetState(3178)
					p.Match(DorisParserParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(3179)

					var _m = p.Match(DorisParserParserSTRING_LITERAL)

					localctx.(*AdminCleanTrashContext)._STRING_LITERAL = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				localctx.(*AdminCleanTrashContext).backends = append(localctx.(*AdminCleanTrashContext).backends, localctx.(*AdminCleanTrashContext)._STRING_LITERAL)

				p.SetState(3184)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(3185)
				p.Match(DorisParserParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 11:
		localctx = NewAdminSetReplicaVersionContext(p, localctx)
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(3188)
			p.Match(DorisParserParserADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3189)
			p.Match(DorisParserParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3190)
			p.Match(DorisParserParserREPLICA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3191)
			p.Match(DorisParserParserVERSION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3192)
			p.Match(DorisParserParserPROPERTIES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3193)
			p.Match(DorisParserParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3194)
			p.PropertyItemList()
		}
		{
			p.SetState(3195)
			p.Match(DorisParserParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 12:
		localctx = NewAdminSetTableStatusContext(p, localctx)
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(3197)
			p.Match(DorisParserParserADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3198)
			p.Match(DorisParserParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3199)
			p.Match(DorisParserParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3200)

			var _x = p.MultipartIdentifier()

			localctx.(*AdminSetTableStatusContext).name = _x
		}
		{
			p.SetState(3201)
			p.Match(DorisParserParserSTATUS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3203)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserPROPERTIES {
			{
				p.SetState(3202)

				var _x = p.PropertyClause()

				localctx.(*AdminSetTableStatusContext).properties = _x
			}

		}

	case 13:
		localctx = NewAdminSetReplicaStatusContext(p, localctx)
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(3205)
			p.Match(DorisParserParserADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3206)
			p.Match(DorisParserParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3207)
			p.Match(DorisParserParserREPLICA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3208)
			p.Match(DorisParserParserSTATUS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3209)
			p.Match(DorisParserParserPROPERTIES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3210)
			p.Match(DorisParserParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3211)
			p.PropertyItemList()
		}
		{
			p.SetState(3212)
			p.Match(DorisParserParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 14:
		localctx = NewAdminRepairTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(3214)
			p.Match(DorisParserParserADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3215)
			p.Match(DorisParserParserREPAIR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3216)
			p.Match(DorisParserParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3217)
			p.BaseTableRef()
		}

	case 15:
		localctx = NewAdminCancelRepairTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(3218)
			p.Match(DorisParserParserADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3219)
			p.Match(DorisParserParserCANCEL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3220)
			p.Match(DorisParserParserREPAIR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3221)
			p.Match(DorisParserParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3222)
			p.BaseTableRef()
		}

	case 16:
		localctx = NewAdminCopyTabletContext(p, localctx)
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(3223)
			p.Match(DorisParserParserADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3224)
			p.Match(DorisParserParserCOPY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3225)
			p.Match(DorisParserParserTABLET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3226)

			var _m = p.Match(DorisParserParserINTEGER_VALUE)

			localctx.(*AdminCopyTabletContext).tabletId = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3228)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserPROPERTIES {
			{
				p.SetState(3227)

				var _x = p.PropertyClause()

				localctx.(*AdminCopyTabletContext).properties = _x
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISupportedRecoverStatementContext is an interface to support dynamic dispatch.
type ISupportedRecoverStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSupportedRecoverStatementContext differentiates from other interfaces.
	IsSupportedRecoverStatementContext()
}

type SupportedRecoverStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySupportedRecoverStatementContext() *SupportedRecoverStatementContext {
	var p = new(SupportedRecoverStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_supportedRecoverStatement
	return p
}

func InitEmptySupportedRecoverStatementContext(p *SupportedRecoverStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_supportedRecoverStatement
}

func (*SupportedRecoverStatementContext) IsSupportedRecoverStatementContext() {}

func NewSupportedRecoverStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SupportedRecoverStatementContext {
	var p = new(SupportedRecoverStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_supportedRecoverStatement

	return p
}

func (s *SupportedRecoverStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SupportedRecoverStatementContext) CopyAll(ctx *SupportedRecoverStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *SupportedRecoverStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedRecoverStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type RecoverPartitionContext struct {
	SupportedRecoverStatementContext
	name      IIdentifierContext
	id        antlr.Token
	alias     IIdentifierContext
	tableName IMultipartIdentifierContext
}

func NewRecoverPartitionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RecoverPartitionContext {
	var p = new(RecoverPartitionContext)

	InitEmptySupportedRecoverStatementContext(&p.SupportedRecoverStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedRecoverStatementContext))

	return p
}

func (s *RecoverPartitionContext) GetId() antlr.Token { return s.id }

func (s *RecoverPartitionContext) SetId(v antlr.Token) { s.id = v }

func (s *RecoverPartitionContext) GetName() IIdentifierContext { return s.name }

func (s *RecoverPartitionContext) GetAlias() IIdentifierContext { return s.alias }

func (s *RecoverPartitionContext) GetTableName() IMultipartIdentifierContext { return s.tableName }

func (s *RecoverPartitionContext) SetName(v IIdentifierContext) { s.name = v }

func (s *RecoverPartitionContext) SetAlias(v IIdentifierContext) { s.alias = v }

func (s *RecoverPartitionContext) SetTableName(v IMultipartIdentifierContext) { s.tableName = v }

func (s *RecoverPartitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecoverPartitionContext) RECOVER() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRECOVER, 0)
}

func (s *RecoverPartitionContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(DorisParserParserPARTITION, 0)
}

func (s *RecoverPartitionContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFROM, 0)
}

func (s *RecoverPartitionContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *RecoverPartitionContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *RecoverPartitionContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *RecoverPartitionContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserAS, 0)
}

func (s *RecoverPartitionContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserINTEGER_VALUE, 0)
}

func (s *RecoverPartitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitRecoverPartition(s)

	default:
		return t.VisitChildren(s)
	}
}

type RecoverTableContext struct {
	SupportedRecoverStatementContext
	name  IMultipartIdentifierContext
	id    antlr.Token
	alias IIdentifierContext
}

func NewRecoverTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RecoverTableContext {
	var p = new(RecoverTableContext)

	InitEmptySupportedRecoverStatementContext(&p.SupportedRecoverStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedRecoverStatementContext))

	return p
}

func (s *RecoverTableContext) GetId() antlr.Token { return s.id }

func (s *RecoverTableContext) SetId(v antlr.Token) { s.id = v }

func (s *RecoverTableContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *RecoverTableContext) GetAlias() IIdentifierContext { return s.alias }

func (s *RecoverTableContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *RecoverTableContext) SetAlias(v IIdentifierContext) { s.alias = v }

func (s *RecoverTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecoverTableContext) RECOVER() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRECOVER, 0)
}

func (s *RecoverTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserTABLE, 0)
}

func (s *RecoverTableContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *RecoverTableContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserAS, 0)
}

func (s *RecoverTableContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserINTEGER_VALUE, 0)
}

func (s *RecoverTableContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *RecoverTableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitRecoverTable(s)

	default:
		return t.VisitChildren(s)
	}
}

type RecoverDatabaseContext struct {
	SupportedRecoverStatementContext
	name  IIdentifierContext
	id    antlr.Token
	alias IIdentifierContext
}

func NewRecoverDatabaseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RecoverDatabaseContext {
	var p = new(RecoverDatabaseContext)

	InitEmptySupportedRecoverStatementContext(&p.SupportedRecoverStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedRecoverStatementContext))

	return p
}

func (s *RecoverDatabaseContext) GetId() antlr.Token { return s.id }

func (s *RecoverDatabaseContext) SetId(v antlr.Token) { s.id = v }

func (s *RecoverDatabaseContext) GetName() IIdentifierContext { return s.name }

func (s *RecoverDatabaseContext) GetAlias() IIdentifierContext { return s.alias }

func (s *RecoverDatabaseContext) SetName(v IIdentifierContext) { s.name = v }

func (s *RecoverDatabaseContext) SetAlias(v IIdentifierContext) { s.alias = v }

func (s *RecoverDatabaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecoverDatabaseContext) RECOVER() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRECOVER, 0)
}

func (s *RecoverDatabaseContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDATABASE, 0)
}

func (s *RecoverDatabaseContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *RecoverDatabaseContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *RecoverDatabaseContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserAS, 0)
}

func (s *RecoverDatabaseContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserINTEGER_VALUE, 0)
}

func (s *RecoverDatabaseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitRecoverDatabase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) SupportedRecoverStatement() (localctx ISupportedRecoverStatementContext) {
	localctx = NewSupportedRecoverStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, DorisParserParserRULE_supportedRecoverStatement)
	var _la int

	p.SetState(3265)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 433, p.GetParserRuleContext()) {
	case 1:
		localctx = NewRecoverDatabaseContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3232)
			p.Match(DorisParserParserRECOVER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3233)
			p.Match(DorisParserParserDATABASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3234)

			var _x = p.Identifier()

			localctx.(*RecoverDatabaseContext).name = _x
		}
		p.SetState(3236)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserINTEGER_VALUE {
			{
				p.SetState(3235)

				var _m = p.Match(DorisParserParserINTEGER_VALUE)

				localctx.(*RecoverDatabaseContext).id = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(3240)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserAS {
			{
				p.SetState(3238)
				p.Match(DorisParserParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3239)

				var _x = p.Identifier()

				localctx.(*RecoverDatabaseContext).alias = _x
			}

		}

	case 2:
		localctx = NewRecoverTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3242)
			p.Match(DorisParserParserRECOVER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3243)
			p.Match(DorisParserParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3244)

			var _x = p.MultipartIdentifier()

			localctx.(*RecoverTableContext).name = _x
		}
		p.SetState(3246)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserINTEGER_VALUE {
			{
				p.SetState(3245)

				var _m = p.Match(DorisParserParserINTEGER_VALUE)

				localctx.(*RecoverTableContext).id = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(3250)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserAS {
			{
				p.SetState(3248)
				p.Match(DorisParserParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3249)

				var _x = p.Identifier()

				localctx.(*RecoverTableContext).alias = _x
			}

		}

	case 3:
		localctx = NewRecoverPartitionContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3252)
			p.Match(DorisParserParserRECOVER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3253)
			p.Match(DorisParserParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3254)

			var _x = p.Identifier()

			localctx.(*RecoverPartitionContext).name = _x
		}
		p.SetState(3256)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserINTEGER_VALUE {
			{
				p.SetState(3255)

				var _m = p.Match(DorisParserParserINTEGER_VALUE)

				localctx.(*RecoverPartitionContext).id = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(3260)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserAS {
			{
				p.SetState(3258)
				p.Match(DorisParserParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3259)

				var _x = p.Identifier()

				localctx.(*RecoverPartitionContext).alias = _x
			}

		}
		{
			p.SetState(3262)
			p.Match(DorisParserParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3263)

			var _x = p.MultipartIdentifier()

			localctx.(*RecoverPartitionContext).tableName = _x
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnsupportedAdminStatementContext is an interface to support dynamic dispatch.
type IUnsupportedAdminStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsUnsupportedAdminStatementContext differentiates from other interfaces.
	IsUnsupportedAdminStatementContext()
}

type UnsupportedAdminStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnsupportedAdminStatementContext() *UnsupportedAdminStatementContext {
	var p = new(UnsupportedAdminStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_unsupportedAdminStatement
	return p
}

func InitEmptyUnsupportedAdminStatementContext(p *UnsupportedAdminStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_unsupportedAdminStatement
}

func (*UnsupportedAdminStatementContext) IsUnsupportedAdminStatementContext() {}

func NewUnsupportedAdminStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnsupportedAdminStatementContext {
	var p = new(UnsupportedAdminStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_unsupportedAdminStatement

	return p
}

func (s *UnsupportedAdminStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *UnsupportedAdminStatementContext) CopyAll(ctx *UnsupportedAdminStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *UnsupportedAdminStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnsupportedAdminStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type AdminSetPartitionVersionContext struct {
	UnsupportedAdminStatementContext
	name       IMultipartIdentifierContext
	properties IPropertyClauseContext
}

func NewAdminSetPartitionVersionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AdminSetPartitionVersionContext {
	var p = new(AdminSetPartitionVersionContext)

	InitEmptyUnsupportedAdminStatementContext(&p.UnsupportedAdminStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedAdminStatementContext))

	return p
}

func (s *AdminSetPartitionVersionContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *AdminSetPartitionVersionContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *AdminSetPartitionVersionContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *AdminSetPartitionVersionContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *AdminSetPartitionVersionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdminSetPartitionVersionContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserADMIN, 0)
}

func (s *AdminSetPartitionVersionContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSET, 0)
}

func (s *AdminSetPartitionVersionContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserTABLE, 0)
}

func (s *AdminSetPartitionVersionContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(DorisParserParserPARTITION, 0)
}

func (s *AdminSetPartitionVersionContext) VERSION() antlr.TerminalNode {
	return s.GetToken(DorisParserParserVERSION, 0)
}

func (s *AdminSetPartitionVersionContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *AdminSetPartitionVersionContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *AdminSetPartitionVersionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitAdminSetPartitionVersion(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) UnsupportedAdminStatement() (localctx IUnsupportedAdminStatementContext) {
	localctx = NewUnsupportedAdminStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, DorisParserParserRULE_unsupportedAdminStatement)
	var _la int

	localctx = NewAdminSetPartitionVersionContext(p, localctx)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3267)
		p.Match(DorisParserParserADMIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3268)
		p.Match(DorisParserParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3269)
		p.Match(DorisParserParserTABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3270)

		var _x = p.MultipartIdentifier()

		localctx.(*AdminSetPartitionVersionContext).name = _x
	}
	{
		p.SetState(3271)
		p.Match(DorisParserParserPARTITION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3272)
		p.Match(DorisParserParserVERSION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3274)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserParserPROPERTIES {
		{
			p.SetState(3273)

			var _x = p.PropertyClause()

			localctx.(*AdminSetPartitionVersionContext).properties = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBaseTableRefContext is an interface to support dynamic dispatch.
type IBaseTableRefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MultipartIdentifier() IMultipartIdentifierContext
	TableAlias() ITableAliasContext
	OptScanParams() IOptScanParamsContext
	TableSnapshot() ITableSnapshotContext
	SpecifiedPartition() ISpecifiedPartitionContext
	TabletList() ITabletListContext
	Sample() ISampleContext
	RelationHint() IRelationHintContext

	// IsBaseTableRefContext differentiates from other interfaces.
	IsBaseTableRefContext()
}

type BaseTableRefContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBaseTableRefContext() *BaseTableRefContext {
	var p = new(BaseTableRefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_baseTableRef
	return p
}

func InitEmptyBaseTableRefContext(p *BaseTableRefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_baseTableRef
}

func (*BaseTableRefContext) IsBaseTableRefContext() {}

func NewBaseTableRefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BaseTableRefContext {
	var p = new(BaseTableRefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_baseTableRef

	return p
}

func (s *BaseTableRefContext) GetParser() antlr.Parser { return s.parser }

func (s *BaseTableRefContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *BaseTableRefContext) TableAlias() ITableAliasContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableAliasContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableAliasContext)
}

func (s *BaseTableRefContext) OptScanParams() IOptScanParamsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOptScanParamsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOptScanParamsContext)
}

func (s *BaseTableRefContext) TableSnapshot() ITableSnapshotContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableSnapshotContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableSnapshotContext)
}

func (s *BaseTableRefContext) SpecifiedPartition() ISpecifiedPartitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISpecifiedPartitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISpecifiedPartitionContext)
}

func (s *BaseTableRefContext) TabletList() ITabletListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITabletListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITabletListContext)
}

func (s *BaseTableRefContext) Sample() ISampleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISampleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISampleContext)
}

func (s *BaseTableRefContext) RelationHint() IRelationHintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationHintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationHintContext)
}

func (s *BaseTableRefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BaseTableRefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BaseTableRefContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitBaseTableRef(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) BaseTableRef() (localctx IBaseTableRefContext) {
	localctx = NewBaseTableRefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, DorisParserParserRULE_baseTableRef)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3276)
		p.MultipartIdentifier()
	}
	p.SetState(3278)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserParserATSIGN {
		{
			p.SetState(3277)
			p.OptScanParams()
		}

	}
	p.SetState(3281)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserParserFOR {
		{
			p.SetState(3280)
			p.TableSnapshot()
		}

	}
	p.SetState(3284)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 437, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3283)
			p.SpecifiedPartition()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(3287)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserParserTABLET {
		{
			p.SetState(3286)
			p.TabletList()
		}

	}
	{
		p.SetState(3289)
		p.TableAlias()
	}
	p.SetState(3291)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserParserTABLESAMPLE {
		{
			p.SetState(3290)
			p.Sample()
		}

	}
	p.SetState(3294)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserParserLEFT_BRACKET || _la == DorisParserParserHINT_START {
		{
			p.SetState(3293)
			p.RelationHint()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWildWhereContext is an interface to support dynamic dispatch.
type IWildWhereContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LIKE() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext

	// IsWildWhereContext differentiates from other interfaces.
	IsWildWhereContext()
}

type WildWhereContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWildWhereContext() *WildWhereContext {
	var p = new(WildWhereContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_wildWhere
	return p
}

func InitEmptyWildWhereContext(p *WildWhereContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_wildWhere
}

func (*WildWhereContext) IsWildWhereContext() {}

func NewWildWhereContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WildWhereContext {
	var p = new(WildWhereContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_wildWhere

	return p
}

func (s *WildWhereContext) GetParser() antlr.Parser { return s.parser }

func (s *WildWhereContext) LIKE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLIKE, 0)
}

func (s *WildWhereContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTRING_LITERAL, 0)
}

func (s *WildWhereContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserWHERE, 0)
}

func (s *WildWhereContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *WildWhereContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WildWhereContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WildWhereContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitWildWhere(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) WildWhere() (localctx IWildWhereContext) {
	localctx = NewWildWhereContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, DorisParserParserRULE_wildWhere)
	p.SetState(3300)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserParserLIKE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3296)
			p.Match(DorisParserParserLIKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3297)
			p.Match(DorisParserParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserParserWHERE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3298)
			p.Match(DorisParserParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3299)
			p.Expression()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISupportedTransactionStatementContext is an interface to support dynamic dispatch.
type ISupportedTransactionStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSupportedTransactionStatementContext differentiates from other interfaces.
	IsSupportedTransactionStatementContext()
}

type SupportedTransactionStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySupportedTransactionStatementContext() *SupportedTransactionStatementContext {
	var p = new(SupportedTransactionStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_supportedTransactionStatement
	return p
}

func InitEmptySupportedTransactionStatementContext(p *SupportedTransactionStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_supportedTransactionStatement
}

func (*SupportedTransactionStatementContext) IsSupportedTransactionStatementContext() {}

func NewSupportedTransactionStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SupportedTransactionStatementContext {
	var p = new(SupportedTransactionStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_supportedTransactionStatement

	return p
}

func (s *SupportedTransactionStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SupportedTransactionStatementContext) CopyAll(ctx *SupportedTransactionStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *SupportedTransactionStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedTransactionStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type TranscationCommitContext struct {
	SupportedTransactionStatementContext
}

func NewTranscationCommitContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TranscationCommitContext {
	var p = new(TranscationCommitContext)

	InitEmptySupportedTransactionStatementContext(&p.SupportedTransactionStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedTransactionStatementContext))

	return p
}

func (s *TranscationCommitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TranscationCommitContext) COMMIT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOMMIT, 0)
}

func (s *TranscationCommitContext) WORK() antlr.TerminalNode {
	return s.GetToken(DorisParserParserWORK, 0)
}

func (s *TranscationCommitContext) AND() antlr.TerminalNode {
	return s.GetToken(DorisParserParserAND, 0)
}

func (s *TranscationCommitContext) CHAIN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCHAIN, 0)
}

func (s *TranscationCommitContext) RELEASE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRELEASE, 0)
}

func (s *TranscationCommitContext) AllNO() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserNO)
}

func (s *TranscationCommitContext) NO(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserNO, i)
}

func (s *TranscationCommitContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitTranscationCommit(s)

	default:
		return t.VisitChildren(s)
	}
}

type TransactionRollbackContext struct {
	SupportedTransactionStatementContext
}

func NewTransactionRollbackContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TransactionRollbackContext {
	var p = new(TransactionRollbackContext)

	InitEmptySupportedTransactionStatementContext(&p.SupportedTransactionStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedTransactionStatementContext))

	return p
}

func (s *TransactionRollbackContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TransactionRollbackContext) ROLLBACK() antlr.TerminalNode {
	return s.GetToken(DorisParserParserROLLBACK, 0)
}

func (s *TransactionRollbackContext) WORK() antlr.TerminalNode {
	return s.GetToken(DorisParserParserWORK, 0)
}

func (s *TransactionRollbackContext) AND() antlr.TerminalNode {
	return s.GetToken(DorisParserParserAND, 0)
}

func (s *TransactionRollbackContext) CHAIN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCHAIN, 0)
}

func (s *TransactionRollbackContext) RELEASE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRELEASE, 0)
}

func (s *TransactionRollbackContext) AllNO() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserNO)
}

func (s *TransactionRollbackContext) NO(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserNO, i)
}

func (s *TransactionRollbackContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitTransactionRollback(s)

	default:
		return t.VisitChildren(s)
	}
}

type TransactionBeginContext struct {
	SupportedTransactionStatementContext
}

func NewTransactionBeginContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TransactionBeginContext {
	var p = new(TransactionBeginContext)

	InitEmptySupportedTransactionStatementContext(&p.SupportedTransactionStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedTransactionStatementContext))

	return p
}

func (s *TransactionBeginContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TransactionBeginContext) BEGIN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserBEGIN, 0)
}

func (s *TransactionBeginContext) WITH() antlr.TerminalNode {
	return s.GetToken(DorisParserParserWITH, 0)
}

func (s *TransactionBeginContext) LABEL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLABEL, 0)
}

func (s *TransactionBeginContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TransactionBeginContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitTransactionBegin(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) SupportedTransactionStatement() (localctx ISupportedTransactionStatementContext) {
	localctx = NewSupportedTransactionStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, DorisParserParserRULE_supportedTransactionStatement)
	var _la int

	p.SetState(3344)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserParserBEGIN:
		localctx = NewTransactionBeginContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3302)
			p.Match(DorisParserParserBEGIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3308)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserWITH {
			{
				p.SetState(3303)
				p.Match(DorisParserParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3304)
				p.Match(DorisParserParserLABEL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(3306)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-2305902462020672000) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&4609989332399152113) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-9080794533051819547) != 0) || ((int64((_la-192)) & ^0x3f) == 0 && ((int64(1)<<(_la-192))&2015220189171012521) != 0) || ((int64((_la-256)) & ^0x3f) == 0 && ((int64(1)<<(_la-256))&-5422616543060085911) != 0) || ((int64((_la-320)) & ^0x3f) == 0 && ((int64(1)<<(_la-320))&-4476015178520986877) != 0) || ((int64((_la-384)) & ^0x3f) == 0 && ((int64(1)<<(_la-384))&9222796779122679803) != 0) || ((int64((_la-452)) & ^0x3f) == 0 && ((int64(1)<<(_la-452))&2449945648119953137) != 0) || ((int64((_la-517)) & ^0x3f) == 0 && ((int64(1)<<(_la-517))&206187790337) != 0) {
				{
					p.SetState(3305)
					p.Identifier()
				}

			}

		}

	case DorisParserParserCOMMIT:
		localctx = NewTranscationCommitContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3310)
			p.Match(DorisParserParserCOMMIT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3312)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserWORK {
			{
				p.SetState(3311)
				p.Match(DorisParserParserWORK)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(3319)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserAND {
			{
				p.SetState(3314)
				p.Match(DorisParserParserAND)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(3316)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserParserNO {
				{
					p.SetState(3315)
					p.Match(DorisParserParserNO)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(3318)
				p.Match(DorisParserParserCHAIN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(3325)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserNO || _la == DorisParserParserRELEASE {
			p.SetState(3322)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserParserNO {
				{
					p.SetState(3321)
					p.Match(DorisParserParserNO)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(3324)
				p.Match(DorisParserParserRELEASE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case DorisParserParserROLLBACK:
		localctx = NewTransactionRollbackContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3327)
			p.Match(DorisParserParserROLLBACK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3329)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserWORK {
			{
				p.SetState(3328)
				p.Match(DorisParserParserWORK)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(3336)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserAND {
			{
				p.SetState(3331)
				p.Match(DorisParserParserAND)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(3333)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserParserNO {
				{
					p.SetState(3332)
					p.Match(DorisParserParserNO)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(3335)
				p.Match(DorisParserParserCHAIN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(3342)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserNO || _la == DorisParserParserRELEASE {
			p.SetState(3339)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserParserNO {
				{
					p.SetState(3338)
					p.Match(DorisParserParserNO)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(3341)
				p.Match(DorisParserParserRELEASE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISupportedGrantRevokeStatementContext is an interface to support dynamic dispatch.
type ISupportedGrantRevokeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSupportedGrantRevokeStatementContext differentiates from other interfaces.
	IsSupportedGrantRevokeStatementContext()
}

type SupportedGrantRevokeStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySupportedGrantRevokeStatementContext() *SupportedGrantRevokeStatementContext {
	var p = new(SupportedGrantRevokeStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_supportedGrantRevokeStatement
	return p
}

func InitEmptySupportedGrantRevokeStatementContext(p *SupportedGrantRevokeStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_supportedGrantRevokeStatement
}

func (*SupportedGrantRevokeStatementContext) IsSupportedGrantRevokeStatementContext() {}

func NewSupportedGrantRevokeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SupportedGrantRevokeStatementContext {
	var p = new(SupportedGrantRevokeStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_supportedGrantRevokeStatement

	return p
}

func (s *SupportedGrantRevokeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SupportedGrantRevokeStatementContext) CopyAll(ctx *SupportedGrantRevokeStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *SupportedGrantRevokeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedGrantRevokeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type GrantResourcePrivilegeContext struct {
	SupportedGrantRevokeStatementContext
}

func NewGrantResourcePrivilegeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *GrantResourcePrivilegeContext {
	var p = new(GrantResourcePrivilegeContext)

	InitEmptySupportedGrantRevokeStatementContext(&p.SupportedGrantRevokeStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedGrantRevokeStatementContext))

	return p
}

func (s *GrantResourcePrivilegeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GrantResourcePrivilegeContext) GRANT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserGRANT, 0)
}

func (s *GrantResourcePrivilegeContext) PrivilegeList() IPrivilegeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivilegeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivilegeListContext)
}

func (s *GrantResourcePrivilegeContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisParserParserON, 0)
}

func (s *GrantResourcePrivilegeContext) IdentifierOrTextOrAsterisk() IIdentifierOrTextOrAsteriskContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextOrAsteriskContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextOrAsteriskContext)
}

func (s *GrantResourcePrivilegeContext) TO() antlr.TerminalNode {
	return s.GetToken(DorisParserParserTO, 0)
}

func (s *GrantResourcePrivilegeContext) RESOURCE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRESOURCE, 0)
}

func (s *GrantResourcePrivilegeContext) CLUSTER() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCLUSTER, 0)
}

func (s *GrantResourcePrivilegeContext) COMPUTE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOMPUTE, 0)
}

func (s *GrantResourcePrivilegeContext) GROUP() antlr.TerminalNode {
	return s.GetToken(DorisParserParserGROUP, 0)
}

func (s *GrantResourcePrivilegeContext) STAGE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTAGE, 0)
}

func (s *GrantResourcePrivilegeContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTORAGE, 0)
}

func (s *GrantResourcePrivilegeContext) VAULT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserVAULT, 0)
}

func (s *GrantResourcePrivilegeContext) WORKLOAD() antlr.TerminalNode {
	return s.GetToken(DorisParserParserWORKLOAD, 0)
}

func (s *GrantResourcePrivilegeContext) UserIdentify() IUserIdentifyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserIdentifyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserIdentifyContext)
}

func (s *GrantResourcePrivilegeContext) ROLE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserROLE, 0)
}

func (s *GrantResourcePrivilegeContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *GrantResourcePrivilegeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitGrantResourcePrivilege(s)

	default:
		return t.VisitChildren(s)
	}
}

type RevokeRoleContext struct {
	SupportedGrantRevokeStatementContext
	_identifierOrText IIdentifierOrTextContext
	roles             []IIdentifierOrTextContext
}

func NewRevokeRoleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RevokeRoleContext {
	var p = new(RevokeRoleContext)

	InitEmptySupportedGrantRevokeStatementContext(&p.SupportedGrantRevokeStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedGrantRevokeStatementContext))

	return p
}

func (s *RevokeRoleContext) Get_identifierOrText() IIdentifierOrTextContext {
	return s._identifierOrText
}

func (s *RevokeRoleContext) Set_identifierOrText(v IIdentifierOrTextContext) { s._identifierOrText = v }

func (s *RevokeRoleContext) GetRoles() []IIdentifierOrTextContext { return s.roles }

func (s *RevokeRoleContext) SetRoles(v []IIdentifierOrTextContext) { s.roles = v }

func (s *RevokeRoleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RevokeRoleContext) REVOKE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserREVOKE, 0)
}

func (s *RevokeRoleContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFROM, 0)
}

func (s *RevokeRoleContext) UserIdentify() IUserIdentifyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserIdentifyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserIdentifyContext)
}

func (s *RevokeRoleContext) AllIdentifierOrText() []IIdentifierOrTextContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierOrTextContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierOrTextContext); ok {
			tst[i] = t.(IIdentifierOrTextContext)
			i++
		}
	}

	return tst
}

func (s *RevokeRoleContext) IdentifierOrText(i int) IIdentifierOrTextContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *RevokeRoleContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserCOMMA)
}

func (s *RevokeRoleContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOMMA, i)
}

func (s *RevokeRoleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitRevokeRole(s)

	default:
		return t.VisitChildren(s)
	}
}

type GrantTablePrivilegeContext struct {
	SupportedGrantRevokeStatementContext
}

func NewGrantTablePrivilegeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *GrantTablePrivilegeContext {
	var p = new(GrantTablePrivilegeContext)

	InitEmptySupportedGrantRevokeStatementContext(&p.SupportedGrantRevokeStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedGrantRevokeStatementContext))

	return p
}

func (s *GrantTablePrivilegeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GrantTablePrivilegeContext) GRANT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserGRANT, 0)
}

func (s *GrantTablePrivilegeContext) PrivilegeList() IPrivilegeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivilegeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivilegeListContext)
}

func (s *GrantTablePrivilegeContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisParserParserON, 0)
}

func (s *GrantTablePrivilegeContext) MultipartIdentifierOrAsterisk() IMultipartIdentifierOrAsteriskContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierOrAsteriskContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierOrAsteriskContext)
}

func (s *GrantTablePrivilegeContext) TO() antlr.TerminalNode {
	return s.GetToken(DorisParserParserTO, 0)
}

func (s *GrantTablePrivilegeContext) UserIdentify() IUserIdentifyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserIdentifyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserIdentifyContext)
}

func (s *GrantTablePrivilegeContext) ROLE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserROLE, 0)
}

func (s *GrantTablePrivilegeContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *GrantTablePrivilegeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitGrantTablePrivilege(s)

	default:
		return t.VisitChildren(s)
	}
}

type GrantRoleContext struct {
	SupportedGrantRevokeStatementContext
	_identifierOrText IIdentifierOrTextContext
	roles             []IIdentifierOrTextContext
}

func NewGrantRoleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *GrantRoleContext {
	var p = new(GrantRoleContext)

	InitEmptySupportedGrantRevokeStatementContext(&p.SupportedGrantRevokeStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedGrantRevokeStatementContext))

	return p
}

func (s *GrantRoleContext) Get_identifierOrText() IIdentifierOrTextContext {
	return s._identifierOrText
}

func (s *GrantRoleContext) Set_identifierOrText(v IIdentifierOrTextContext) { s._identifierOrText = v }

func (s *GrantRoleContext) GetRoles() []IIdentifierOrTextContext { return s.roles }

func (s *GrantRoleContext) SetRoles(v []IIdentifierOrTextContext) { s.roles = v }

func (s *GrantRoleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GrantRoleContext) GRANT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserGRANT, 0)
}

func (s *GrantRoleContext) TO() antlr.TerminalNode {
	return s.GetToken(DorisParserParserTO, 0)
}

func (s *GrantRoleContext) UserIdentify() IUserIdentifyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserIdentifyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserIdentifyContext)
}

func (s *GrantRoleContext) AllIdentifierOrText() []IIdentifierOrTextContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierOrTextContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierOrTextContext); ok {
			tst[i] = t.(IIdentifierOrTextContext)
			i++
		}
	}

	return tst
}

func (s *GrantRoleContext) IdentifierOrText(i int) IIdentifierOrTextContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *GrantRoleContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserCOMMA)
}

func (s *GrantRoleContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOMMA, i)
}

func (s *GrantRoleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitGrantRole(s)

	default:
		return t.VisitChildren(s)
	}
}

type RevokeResourcePrivilegeContext struct {
	SupportedGrantRevokeStatementContext
}

func NewRevokeResourcePrivilegeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RevokeResourcePrivilegeContext {
	var p = new(RevokeResourcePrivilegeContext)

	InitEmptySupportedGrantRevokeStatementContext(&p.SupportedGrantRevokeStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedGrantRevokeStatementContext))

	return p
}

func (s *RevokeResourcePrivilegeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RevokeResourcePrivilegeContext) REVOKE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserREVOKE, 0)
}

func (s *RevokeResourcePrivilegeContext) PrivilegeList() IPrivilegeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivilegeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivilegeListContext)
}

func (s *RevokeResourcePrivilegeContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisParserParserON, 0)
}

func (s *RevokeResourcePrivilegeContext) IdentifierOrTextOrAsterisk() IIdentifierOrTextOrAsteriskContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextOrAsteriskContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextOrAsteriskContext)
}

func (s *RevokeResourcePrivilegeContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFROM, 0)
}

func (s *RevokeResourcePrivilegeContext) RESOURCE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRESOURCE, 0)
}

func (s *RevokeResourcePrivilegeContext) CLUSTER() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCLUSTER, 0)
}

func (s *RevokeResourcePrivilegeContext) COMPUTE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOMPUTE, 0)
}

func (s *RevokeResourcePrivilegeContext) GROUP() antlr.TerminalNode {
	return s.GetToken(DorisParserParserGROUP, 0)
}

func (s *RevokeResourcePrivilegeContext) STAGE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTAGE, 0)
}

func (s *RevokeResourcePrivilegeContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTORAGE, 0)
}

func (s *RevokeResourcePrivilegeContext) VAULT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserVAULT, 0)
}

func (s *RevokeResourcePrivilegeContext) WORKLOAD() antlr.TerminalNode {
	return s.GetToken(DorisParserParserWORKLOAD, 0)
}

func (s *RevokeResourcePrivilegeContext) UserIdentify() IUserIdentifyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserIdentifyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserIdentifyContext)
}

func (s *RevokeResourcePrivilegeContext) ROLE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserROLE, 0)
}

func (s *RevokeResourcePrivilegeContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *RevokeResourcePrivilegeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitRevokeResourcePrivilege(s)

	default:
		return t.VisitChildren(s)
	}
}

type RevokeTablePrivilegeContext struct {
	SupportedGrantRevokeStatementContext
}

func NewRevokeTablePrivilegeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RevokeTablePrivilegeContext {
	var p = new(RevokeTablePrivilegeContext)

	InitEmptySupportedGrantRevokeStatementContext(&p.SupportedGrantRevokeStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedGrantRevokeStatementContext))

	return p
}

func (s *RevokeTablePrivilegeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RevokeTablePrivilegeContext) REVOKE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserREVOKE, 0)
}

func (s *RevokeTablePrivilegeContext) PrivilegeList() IPrivilegeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivilegeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivilegeListContext)
}

func (s *RevokeTablePrivilegeContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisParserParserON, 0)
}

func (s *RevokeTablePrivilegeContext) MultipartIdentifierOrAsterisk() IMultipartIdentifierOrAsteriskContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierOrAsteriskContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierOrAsteriskContext)
}

func (s *RevokeTablePrivilegeContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFROM, 0)
}

func (s *RevokeTablePrivilegeContext) UserIdentify() IUserIdentifyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserIdentifyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserIdentifyContext)
}

func (s *RevokeTablePrivilegeContext) ROLE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserROLE, 0)
}

func (s *RevokeTablePrivilegeContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *RevokeTablePrivilegeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitRevokeTablePrivilege(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) SupportedGrantRevokeStatement() (localctx ISupportedGrantRevokeStatementContext) {
	localctx = NewSupportedGrantRevokeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, DorisParserParserRULE_supportedGrantRevokeStatement)
	var _la int

	p.SetState(3432)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 463, p.GetParserRuleContext()) {
	case 1:
		localctx = NewGrantTablePrivilegeContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3346)
			p.Match(DorisParserParserGRANT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3347)
			p.PrivilegeList()
		}
		{
			p.SetState(3348)
			p.Match(DorisParserParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3349)
			p.MultipartIdentifierOrAsterisk()
		}
		{
			p.SetState(3350)
			p.Match(DorisParserParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3354)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserParserLEFT_BRACE, DorisParserParserRIGHT_BRACE, DorisParserParserACTIONS, DorisParserParserAFTER, DorisParserParserAGG_STATE, DorisParserParserAGGREGATE, DorisParserParserALIAS, DorisParserParserANALYZED, DorisParserParserARRAY, DorisParserParserAT, DorisParserParserAUTHORS, DorisParserParserAUTO_INCREMENT, DorisParserParserALWAYS, DorisParserParserBACKENDS, DorisParserParserBACKUP, DorisParserParserBEGIN, DorisParserParserBELONG, DorisParserParserBIN, DorisParserParserBITAND, DorisParserParserBITMAP, DorisParserParserBITMAP_EMPTY, DorisParserParserBITMAP_UNION, DorisParserParserBITOR, DorisParserParserBITXOR, DorisParserParserBLOB, DorisParserParserBOOLEAN, DorisParserParserBRANCH, DorisParserParserBRIEF, DorisParserParserBROKER, DorisParserParserBUCKETS, DorisParserParserBUILD, DorisParserParserBUILTIN, DorisParserParserBULK, DorisParserParserCACHE, DorisParserParserCACHED, DorisParserParserCALL, DorisParserParserCATALOG, DorisParserParserCATALOGS, DorisParserParserCHAIN, DorisParserParserCHAR, DorisParserParserCHARSET, DorisParserParserCHECK, DorisParserParserCLUSTER, DorisParserParserCLUSTERS, DorisParserParserCOLLATION, DorisParserParserCOLLECT, DorisParserParserCOLOCATE, DorisParserParserCOLUMNS, DorisParserParserCOMMENT, DorisParserParserCOMMIT, DorisParserParserCOMMITTED, DorisParserParserCOMPACT, DorisParserParserCOMPLETE, DorisParserParserCOMPRESS_TYPE, DorisParserParserCOMPUTE, DorisParserParserCONDITIONS, DorisParserParserCONFIG, DorisParserParserCONNECTION, DorisParserParserCONNECTION_ID, DorisParserParserCONSISTENT, DorisParserParserCONSTRAINTS, DorisParserParserCONVERT, DorisParserParserCONVERT_LSC, DorisParserParserCOPY, DorisParserParserCOUNT, DorisParserParserCREATION, DorisParserParserCRON, DorisParserParserCURRENT_CATALOG, DorisParserParserCURRENT_DATE, DorisParserParserCURRENT_TIME, DorisParserParserCURRENT_TIMESTAMP, DorisParserParserCURRENT_USER, DorisParserParserDATA, DorisParserParserDATE, DorisParserParserDATETIME, DorisParserParserDATETIMEV2, DorisParserParserDATEV2, DorisParserParserDATETIMEV1, DorisParserParserDATEV1, DorisParserParserDAY, DorisParserParserDAYS, DorisParserParserDECIMAL, DorisParserParserDECIMALV2, DorisParserParserDECIMALV3, DorisParserParserDEFERRED, DorisParserParserDEMAND, DorisParserParserDIAGNOSE, DorisParserParserDIAGNOSIS, DorisParserParserDICTIONARIES, DorisParserParserDICTIONARY, DorisParserParserDISTINCTPC, DorisParserParserDISTINCTPCSA, DorisParserParserDO, DorisParserParserDORIS_INTERNAL_TABLE_ID, DorisParserParserDUAL, DorisParserParserDYNAMIC, DorisParserParserE, DorisParserParserENABLE, DorisParserParserENCRYPTKEY, DorisParserParserENCRYPTKEYS, DorisParserParserEND, DorisParserParserENDS, DorisParserParserENGINE, DorisParserParserENGINES, DorisParserParserERRORS, DorisParserParserESCAPE, DorisParserParserEVENTS, DorisParserParserEVERY, DorisParserParserEXCLUDE, DorisParserParserEXPIRED, DorisParserParserEXTERNAL, DorisParserParserFAILED_LOGIN_ATTEMPTS, DorisParserParserFAST, DorisParserParserFEATURE, DorisParserParserFIELDS, DorisParserParserFILE, DorisParserParserFILTER, DorisParserParserFIRST, DorisParserParserFORMAT, DorisParserParserFREE, DorisParserParserFRONTENDS, DorisParserParserFUNCTION, DorisParserParserGENERATED, DorisParserParserGENERIC, DorisParserParserGLOBAL, DorisParserParserGRAPH, DorisParserParserGROUPING, DorisParserParserGROUPS, DorisParserParserHASH, DorisParserParserHASH_MAP, DorisParserParserHDFS, DorisParserParserHELP, DorisParserParserHISTOGRAM, DorisParserParserHLL_UNION, DorisParserParserHOSTNAME, DorisParserParserHOTSPOT, DorisParserParserHOUR, DorisParserParserHOURS, DorisParserParserHUB, DorisParserParserIDENTIFIED, DorisParserParserIGNORE, DorisParserParserIMMEDIATE, DorisParserParserINCREMENTAL, DorisParserParserINDEXES, DorisParserParserINVERTED, DorisParserParserIP_TRIE, DorisParserParserIPV4, DorisParserParserIPV6, DorisParserParserIS_NOT_NULL_PRED, DorisParserParserIS_NULL_PRED, DorisParserParserISNULL, DorisParserParserISOLATION, DorisParserParserJOB, DorisParserParserJOBS, DorisParserParserJSON, DorisParserParserJSONB, DorisParserParserLABEL, DorisParserParserLAST, DorisParserParserLDAP, DorisParserParserLDAP_ADMIN_PASSWORD, DorisParserParserLESS, DorisParserParserLEVEL, DorisParserParserLINES, DorisParserParserLINK, DorisParserParserLOCAL, DorisParserParserLOCALTIME, DorisParserParserLOCALTIMESTAMP, DorisParserParserLOCATION, DorisParserParserLOCK, DorisParserParserLOGICAL, DorisParserParserMANUAL, DorisParserParserMAP, DorisParserParserMATCH_ALL, DorisParserParserMATCH_ANY, DorisParserParserMATCH_PHRASE, DorisParserParserMATCH_PHRASE_EDGE, DorisParserParserMATCH_PHRASE_PREFIX, DorisParserParserMATCH_REGEXP, DorisParserParserMATERIALIZED, DorisParserParserMAX, DorisParserParserMEMO, DorisParserParserMERGE, DorisParserParserMIGRATE, DorisParserParserMIGRATIONS, DorisParserParserMIN, DorisParserParserMINUTE, DorisParserParserMINUTES, DorisParserParserMODIFY, DorisParserParserMONTH, DorisParserParserMTMV, DorisParserParserNAME, DorisParserParserNAMES, DorisParserParserNEGATIVE, DorisParserParserNEVER, DorisParserParserNEXT, DorisParserParserNGRAM_BF, DorisParserParserNO, DorisParserParserNON_NULLABLE, DorisParserParserNULLS, DorisParserParserOF, DorisParserParserOFFSET, DorisParserParserONLY, DorisParserParserOPEN, DorisParserParserOPTIMIZED, DorisParserParserPARAMETER, DorisParserParserPARSED, DorisParserParserPARTITIONS, DorisParserParserPASSWORD, DorisParserParserPASSWORD_EXPIRE, DorisParserParserPASSWORD_HISTORY, DorisParserParserPASSWORD_LOCK_TIME, DorisParserParserPASSWORD_REUSE, DorisParserParserPATH, DorisParserParserPAUSE, DorisParserParserPERCENT, DorisParserParserPERIOD, DorisParserParserPERMISSIVE, DorisParserParserPHYSICAL, DorisParserParserPI, DorisParserParserPLAN, DorisParserParserPRIVILEGES, DorisParserParserPROCESS, DorisParserParserPLUGIN, DorisParserParserPLUGINS, DorisParserParserPOLICY, DorisParserParserPROC, DorisParserParserPROCESSLIST, DorisParserParserPROFILE, DorisParserParserPROPERTIES, DorisParserParserPROPERTY, DorisParserParserQUANTILE_STATE, DorisParserParserQUANTILE_UNION, DorisParserParserQUERY, DorisParserParserQUEUED, DorisParserParserQUOTA, DorisParserParserQUALIFY, DorisParserParserQUARTER, DorisParserParserRANDOM, DorisParserParserRECENT, DorisParserParserRECOVER, DorisParserParserRECYCLE, DorisParserParserREFRESH, DorisParserParserREPEATABLE, DorisParserParserREPLACE, DorisParserParserREPLACE_IF_NOT_NULL, DorisParserParserREPLAYER, DorisParserParserREPOSITORIES, DorisParserParserREPOSITORY, DorisParserParserRESOURCE, DorisParserParserRESOURCES, DorisParserParserRESTORE, DorisParserParserRESTRICTIVE, DorisParserParserRESUME, DorisParserParserRETAIN, DorisParserParserRETENTION, DorisParserParserRETURNS, DorisParserParserREWRITTEN, DorisParserParserRLIKE, DorisParserParserROLLBACK, DorisParserParserROLLUP, DorisParserParserROUTINE, DorisParserParserS3, DorisParserParserSAMPLE, DorisParserParserSCHEDULE, DorisParserParserSCHEDULER, DorisParserParserSCHEMA, DorisParserParserSECOND, DorisParserParserSERIALIZABLE, DorisParserParserSESSION, DorisParserParserSESSION_USER, DorisParserParserSET_SESSION_VARIABLE, DorisParserParserSHAPE, DorisParserParserSKEW, DorisParserParserSNAPSHOT, DorisParserParserSNAPSHOTS, DorisParserParserSONAME, DorisParserParserSPLIT, DorisParserParserSQL, DorisParserParserSTAGE, DorisParserParserSTAGES, DorisParserParserSTART, DorisParserParserSTARTS, DorisParserParserSTATS, DorisParserParserSTATUS, DorisParserParserSTOP, DorisParserParserSTORAGE, DorisParserParserSTREAM, DorisParserParserSTREAMING, DorisParserParserSTRING, DorisParserParserSTRUCT, DorisParserParserSUM, DorisParserParserTABLES, DorisParserParserTAG, DorisParserParserTASK, DorisParserParserTASKS, DorisParserParserTEMPORARY, DorisParserParserTEXT, DorisParserParserTHAN, DorisParserParserTIME, DorisParserParserTIMESTAMP, DorisParserParserTRANSACTION, DorisParserParserTREE, DorisParserParserTRIGGERS, DorisParserParserTRUNCATE, DorisParserParserTYPE, DorisParserParserTYPES, DorisParserParserUNCOMMITTED, DorisParserParserUNLOCK, DorisParserParserUNSET, DorisParserParserUP, DorisParserParserUSER, DorisParserParserVALUE, DorisParserParserVARCHAR, DorisParserParserVARIABLE, DorisParserParserVARIABLES, DorisParserParserVARIANT, DorisParserParserVAULT, DorisParserParserVAULTS, DorisParserParserVERBOSE, DorisParserParserVERSION, DorisParserParserVIEW, DorisParserParserVIEWS, DorisParserParserWARM, DorisParserParserWARNINGS, DorisParserParserWEEK, DorisParserParserWORK, DorisParserParserYEAR, DorisParserParserHINT_START, DorisParserParserHINT_END, DorisParserParserCOMMENT_START, DorisParserParserSTRING_LITERAL, DorisParserParserIDENTIFIER, DorisParserParserBACKQUOTED_IDENTIFIER:
			{
				p.SetState(3351)
				p.UserIdentify()
			}

		case DorisParserParserROLE:
			{
				p.SetState(3352)
				p.Match(DorisParserParserROLE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3353)
				p.IdentifierOrText()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 2:
		localctx = NewGrantResourcePrivilegeContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3356)
			p.Match(DorisParserParserGRANT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3357)
			p.PrivilegeList()
		}
		{
			p.SetState(3358)
			p.Match(DorisParserParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3368)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserParserRESOURCE:
			{
				p.SetState(3359)
				p.Match(DorisParserParserRESOURCE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserParserCLUSTER:
			{
				p.SetState(3360)
				p.Match(DorisParserParserCLUSTER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserParserCOMPUTE:
			{
				p.SetState(3361)
				p.Match(DorisParserParserCOMPUTE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3362)
				p.Match(DorisParserParserGROUP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserParserSTAGE:
			{
				p.SetState(3363)
				p.Match(DorisParserParserSTAGE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserParserSTORAGE:
			{
				p.SetState(3364)
				p.Match(DorisParserParserSTORAGE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3365)
				p.Match(DorisParserParserVAULT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserParserWORKLOAD:
			{
				p.SetState(3366)
				p.Match(DorisParserParserWORKLOAD)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3367)
				p.Match(DorisParserParserGROUP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(3370)
			p.IdentifierOrTextOrAsterisk()
		}
		{
			p.SetState(3371)
			p.Match(DorisParserParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3375)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserParserLEFT_BRACE, DorisParserParserRIGHT_BRACE, DorisParserParserACTIONS, DorisParserParserAFTER, DorisParserParserAGG_STATE, DorisParserParserAGGREGATE, DorisParserParserALIAS, DorisParserParserANALYZED, DorisParserParserARRAY, DorisParserParserAT, DorisParserParserAUTHORS, DorisParserParserAUTO_INCREMENT, DorisParserParserALWAYS, DorisParserParserBACKENDS, DorisParserParserBACKUP, DorisParserParserBEGIN, DorisParserParserBELONG, DorisParserParserBIN, DorisParserParserBITAND, DorisParserParserBITMAP, DorisParserParserBITMAP_EMPTY, DorisParserParserBITMAP_UNION, DorisParserParserBITOR, DorisParserParserBITXOR, DorisParserParserBLOB, DorisParserParserBOOLEAN, DorisParserParserBRANCH, DorisParserParserBRIEF, DorisParserParserBROKER, DorisParserParserBUCKETS, DorisParserParserBUILD, DorisParserParserBUILTIN, DorisParserParserBULK, DorisParserParserCACHE, DorisParserParserCACHED, DorisParserParserCALL, DorisParserParserCATALOG, DorisParserParserCATALOGS, DorisParserParserCHAIN, DorisParserParserCHAR, DorisParserParserCHARSET, DorisParserParserCHECK, DorisParserParserCLUSTER, DorisParserParserCLUSTERS, DorisParserParserCOLLATION, DorisParserParserCOLLECT, DorisParserParserCOLOCATE, DorisParserParserCOLUMNS, DorisParserParserCOMMENT, DorisParserParserCOMMIT, DorisParserParserCOMMITTED, DorisParserParserCOMPACT, DorisParserParserCOMPLETE, DorisParserParserCOMPRESS_TYPE, DorisParserParserCOMPUTE, DorisParserParserCONDITIONS, DorisParserParserCONFIG, DorisParserParserCONNECTION, DorisParserParserCONNECTION_ID, DorisParserParserCONSISTENT, DorisParserParserCONSTRAINTS, DorisParserParserCONVERT, DorisParserParserCONVERT_LSC, DorisParserParserCOPY, DorisParserParserCOUNT, DorisParserParserCREATION, DorisParserParserCRON, DorisParserParserCURRENT_CATALOG, DorisParserParserCURRENT_DATE, DorisParserParserCURRENT_TIME, DorisParserParserCURRENT_TIMESTAMP, DorisParserParserCURRENT_USER, DorisParserParserDATA, DorisParserParserDATE, DorisParserParserDATETIME, DorisParserParserDATETIMEV2, DorisParserParserDATEV2, DorisParserParserDATETIMEV1, DorisParserParserDATEV1, DorisParserParserDAY, DorisParserParserDAYS, DorisParserParserDECIMAL, DorisParserParserDECIMALV2, DorisParserParserDECIMALV3, DorisParserParserDEFERRED, DorisParserParserDEMAND, DorisParserParserDIAGNOSE, DorisParserParserDIAGNOSIS, DorisParserParserDICTIONARIES, DorisParserParserDICTIONARY, DorisParserParserDISTINCTPC, DorisParserParserDISTINCTPCSA, DorisParserParserDO, DorisParserParserDORIS_INTERNAL_TABLE_ID, DorisParserParserDUAL, DorisParserParserDYNAMIC, DorisParserParserE, DorisParserParserENABLE, DorisParserParserENCRYPTKEY, DorisParserParserENCRYPTKEYS, DorisParserParserEND, DorisParserParserENDS, DorisParserParserENGINE, DorisParserParserENGINES, DorisParserParserERRORS, DorisParserParserESCAPE, DorisParserParserEVENTS, DorisParserParserEVERY, DorisParserParserEXCLUDE, DorisParserParserEXPIRED, DorisParserParserEXTERNAL, DorisParserParserFAILED_LOGIN_ATTEMPTS, DorisParserParserFAST, DorisParserParserFEATURE, DorisParserParserFIELDS, DorisParserParserFILE, DorisParserParserFILTER, DorisParserParserFIRST, DorisParserParserFORMAT, DorisParserParserFREE, DorisParserParserFRONTENDS, DorisParserParserFUNCTION, DorisParserParserGENERATED, DorisParserParserGENERIC, DorisParserParserGLOBAL, DorisParserParserGRAPH, DorisParserParserGROUPING, DorisParserParserGROUPS, DorisParserParserHASH, DorisParserParserHASH_MAP, DorisParserParserHDFS, DorisParserParserHELP, DorisParserParserHISTOGRAM, DorisParserParserHLL_UNION, DorisParserParserHOSTNAME, DorisParserParserHOTSPOT, DorisParserParserHOUR, DorisParserParserHOURS, DorisParserParserHUB, DorisParserParserIDENTIFIED, DorisParserParserIGNORE, DorisParserParserIMMEDIATE, DorisParserParserINCREMENTAL, DorisParserParserINDEXES, DorisParserParserINVERTED, DorisParserParserIP_TRIE, DorisParserParserIPV4, DorisParserParserIPV6, DorisParserParserIS_NOT_NULL_PRED, DorisParserParserIS_NULL_PRED, DorisParserParserISNULL, DorisParserParserISOLATION, DorisParserParserJOB, DorisParserParserJOBS, DorisParserParserJSON, DorisParserParserJSONB, DorisParserParserLABEL, DorisParserParserLAST, DorisParserParserLDAP, DorisParserParserLDAP_ADMIN_PASSWORD, DorisParserParserLESS, DorisParserParserLEVEL, DorisParserParserLINES, DorisParserParserLINK, DorisParserParserLOCAL, DorisParserParserLOCALTIME, DorisParserParserLOCALTIMESTAMP, DorisParserParserLOCATION, DorisParserParserLOCK, DorisParserParserLOGICAL, DorisParserParserMANUAL, DorisParserParserMAP, DorisParserParserMATCH_ALL, DorisParserParserMATCH_ANY, DorisParserParserMATCH_PHRASE, DorisParserParserMATCH_PHRASE_EDGE, DorisParserParserMATCH_PHRASE_PREFIX, DorisParserParserMATCH_REGEXP, DorisParserParserMATERIALIZED, DorisParserParserMAX, DorisParserParserMEMO, DorisParserParserMERGE, DorisParserParserMIGRATE, DorisParserParserMIGRATIONS, DorisParserParserMIN, DorisParserParserMINUTE, DorisParserParserMINUTES, DorisParserParserMODIFY, DorisParserParserMONTH, DorisParserParserMTMV, DorisParserParserNAME, DorisParserParserNAMES, DorisParserParserNEGATIVE, DorisParserParserNEVER, DorisParserParserNEXT, DorisParserParserNGRAM_BF, DorisParserParserNO, DorisParserParserNON_NULLABLE, DorisParserParserNULLS, DorisParserParserOF, DorisParserParserOFFSET, DorisParserParserONLY, DorisParserParserOPEN, DorisParserParserOPTIMIZED, DorisParserParserPARAMETER, DorisParserParserPARSED, DorisParserParserPARTITIONS, DorisParserParserPASSWORD, DorisParserParserPASSWORD_EXPIRE, DorisParserParserPASSWORD_HISTORY, DorisParserParserPASSWORD_LOCK_TIME, DorisParserParserPASSWORD_REUSE, DorisParserParserPATH, DorisParserParserPAUSE, DorisParserParserPERCENT, DorisParserParserPERIOD, DorisParserParserPERMISSIVE, DorisParserParserPHYSICAL, DorisParserParserPI, DorisParserParserPLAN, DorisParserParserPRIVILEGES, DorisParserParserPROCESS, DorisParserParserPLUGIN, DorisParserParserPLUGINS, DorisParserParserPOLICY, DorisParserParserPROC, DorisParserParserPROCESSLIST, DorisParserParserPROFILE, DorisParserParserPROPERTIES, DorisParserParserPROPERTY, DorisParserParserQUANTILE_STATE, DorisParserParserQUANTILE_UNION, DorisParserParserQUERY, DorisParserParserQUEUED, DorisParserParserQUOTA, DorisParserParserQUALIFY, DorisParserParserQUARTER, DorisParserParserRANDOM, DorisParserParserRECENT, DorisParserParserRECOVER, DorisParserParserRECYCLE, DorisParserParserREFRESH, DorisParserParserREPEATABLE, DorisParserParserREPLACE, DorisParserParserREPLACE_IF_NOT_NULL, DorisParserParserREPLAYER, DorisParserParserREPOSITORIES, DorisParserParserREPOSITORY, DorisParserParserRESOURCE, DorisParserParserRESOURCES, DorisParserParserRESTORE, DorisParserParserRESTRICTIVE, DorisParserParserRESUME, DorisParserParserRETAIN, DorisParserParserRETENTION, DorisParserParserRETURNS, DorisParserParserREWRITTEN, DorisParserParserRLIKE, DorisParserParserROLLBACK, DorisParserParserROLLUP, DorisParserParserROUTINE, DorisParserParserS3, DorisParserParserSAMPLE, DorisParserParserSCHEDULE, DorisParserParserSCHEDULER, DorisParserParserSCHEMA, DorisParserParserSECOND, DorisParserParserSERIALIZABLE, DorisParserParserSESSION, DorisParserParserSESSION_USER, DorisParserParserSET_SESSION_VARIABLE, DorisParserParserSHAPE, DorisParserParserSKEW, DorisParserParserSNAPSHOT, DorisParserParserSNAPSHOTS, DorisParserParserSONAME, DorisParserParserSPLIT, DorisParserParserSQL, DorisParserParserSTAGE, DorisParserParserSTAGES, DorisParserParserSTART, DorisParserParserSTARTS, DorisParserParserSTATS, DorisParserParserSTATUS, DorisParserParserSTOP, DorisParserParserSTORAGE, DorisParserParserSTREAM, DorisParserParserSTREAMING, DorisParserParserSTRING, DorisParserParserSTRUCT, DorisParserParserSUM, DorisParserParserTABLES, DorisParserParserTAG, DorisParserParserTASK, DorisParserParserTASKS, DorisParserParserTEMPORARY, DorisParserParserTEXT, DorisParserParserTHAN, DorisParserParserTIME, DorisParserParserTIMESTAMP, DorisParserParserTRANSACTION, DorisParserParserTREE, DorisParserParserTRIGGERS, DorisParserParserTRUNCATE, DorisParserParserTYPE, DorisParserParserTYPES, DorisParserParserUNCOMMITTED, DorisParserParserUNLOCK, DorisParserParserUNSET, DorisParserParserUP, DorisParserParserUSER, DorisParserParserVALUE, DorisParserParserVARCHAR, DorisParserParserVARIABLE, DorisParserParserVARIABLES, DorisParserParserVARIANT, DorisParserParserVAULT, DorisParserParserVAULTS, DorisParserParserVERBOSE, DorisParserParserVERSION, DorisParserParserVIEW, DorisParserParserVIEWS, DorisParserParserWARM, DorisParserParserWARNINGS, DorisParserParserWEEK, DorisParserParserWORK, DorisParserParserYEAR, DorisParserParserHINT_START, DorisParserParserHINT_END, DorisParserParserCOMMENT_START, DorisParserParserSTRING_LITERAL, DorisParserParserIDENTIFIER, DorisParserParserBACKQUOTED_IDENTIFIER:
			{
				p.SetState(3372)
				p.UserIdentify()
			}

		case DorisParserParserROLE:
			{
				p.SetState(3373)
				p.Match(DorisParserParserROLE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3374)
				p.IdentifierOrText()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 3:
		localctx = NewGrantRoleContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3377)
			p.Match(DorisParserParserGRANT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3378)

			var _x = p.IdentifierOrText()

			localctx.(*GrantRoleContext)._identifierOrText = _x
		}
		localctx.(*GrantRoleContext).roles = append(localctx.(*GrantRoleContext).roles, localctx.(*GrantRoleContext)._identifierOrText)
		p.SetState(3383)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserParserCOMMA {
			{
				p.SetState(3379)
				p.Match(DorisParserParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3380)

				var _x = p.IdentifierOrText()

				localctx.(*GrantRoleContext)._identifierOrText = _x
			}
			localctx.(*GrantRoleContext).roles = append(localctx.(*GrantRoleContext).roles, localctx.(*GrantRoleContext)._identifierOrText)

			p.SetState(3385)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3386)
			p.Match(DorisParserParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3387)
			p.UserIdentify()
		}

	case 4:
		localctx = NewRevokeRoleContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3389)
			p.Match(DorisParserParserREVOKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3390)

			var _x = p.IdentifierOrText()

			localctx.(*RevokeRoleContext)._identifierOrText = _x
		}
		localctx.(*RevokeRoleContext).roles = append(localctx.(*RevokeRoleContext).roles, localctx.(*RevokeRoleContext)._identifierOrText)
		p.SetState(3395)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserParserCOMMA {
			{
				p.SetState(3391)
				p.Match(DorisParserParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3392)

				var _x = p.IdentifierOrText()

				localctx.(*RevokeRoleContext)._identifierOrText = _x
			}
			localctx.(*RevokeRoleContext).roles = append(localctx.(*RevokeRoleContext).roles, localctx.(*RevokeRoleContext)._identifierOrText)

			p.SetState(3397)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3398)
			p.Match(DorisParserParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3399)
			p.UserIdentify()
		}

	case 5:
		localctx = NewRevokeResourcePrivilegeContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(3401)
			p.Match(DorisParserParserREVOKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3402)
			p.PrivilegeList()
		}
		{
			p.SetState(3403)
			p.Match(DorisParserParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3413)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserParserRESOURCE:
			{
				p.SetState(3404)
				p.Match(DorisParserParserRESOURCE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserParserCLUSTER:
			{
				p.SetState(3405)
				p.Match(DorisParserParserCLUSTER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserParserCOMPUTE:
			{
				p.SetState(3406)
				p.Match(DorisParserParserCOMPUTE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3407)
				p.Match(DorisParserParserGROUP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserParserSTAGE:
			{
				p.SetState(3408)
				p.Match(DorisParserParserSTAGE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserParserSTORAGE:
			{
				p.SetState(3409)
				p.Match(DorisParserParserSTORAGE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3410)
				p.Match(DorisParserParserVAULT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserParserWORKLOAD:
			{
				p.SetState(3411)
				p.Match(DorisParserParserWORKLOAD)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3412)
				p.Match(DorisParserParserGROUP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(3415)
			p.IdentifierOrTextOrAsterisk()
		}
		{
			p.SetState(3416)
			p.Match(DorisParserParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3420)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserParserLEFT_BRACE, DorisParserParserRIGHT_BRACE, DorisParserParserACTIONS, DorisParserParserAFTER, DorisParserParserAGG_STATE, DorisParserParserAGGREGATE, DorisParserParserALIAS, DorisParserParserANALYZED, DorisParserParserARRAY, DorisParserParserAT, DorisParserParserAUTHORS, DorisParserParserAUTO_INCREMENT, DorisParserParserALWAYS, DorisParserParserBACKENDS, DorisParserParserBACKUP, DorisParserParserBEGIN, DorisParserParserBELONG, DorisParserParserBIN, DorisParserParserBITAND, DorisParserParserBITMAP, DorisParserParserBITMAP_EMPTY, DorisParserParserBITMAP_UNION, DorisParserParserBITOR, DorisParserParserBITXOR, DorisParserParserBLOB, DorisParserParserBOOLEAN, DorisParserParserBRANCH, DorisParserParserBRIEF, DorisParserParserBROKER, DorisParserParserBUCKETS, DorisParserParserBUILD, DorisParserParserBUILTIN, DorisParserParserBULK, DorisParserParserCACHE, DorisParserParserCACHED, DorisParserParserCALL, DorisParserParserCATALOG, DorisParserParserCATALOGS, DorisParserParserCHAIN, DorisParserParserCHAR, DorisParserParserCHARSET, DorisParserParserCHECK, DorisParserParserCLUSTER, DorisParserParserCLUSTERS, DorisParserParserCOLLATION, DorisParserParserCOLLECT, DorisParserParserCOLOCATE, DorisParserParserCOLUMNS, DorisParserParserCOMMENT, DorisParserParserCOMMIT, DorisParserParserCOMMITTED, DorisParserParserCOMPACT, DorisParserParserCOMPLETE, DorisParserParserCOMPRESS_TYPE, DorisParserParserCOMPUTE, DorisParserParserCONDITIONS, DorisParserParserCONFIG, DorisParserParserCONNECTION, DorisParserParserCONNECTION_ID, DorisParserParserCONSISTENT, DorisParserParserCONSTRAINTS, DorisParserParserCONVERT, DorisParserParserCONVERT_LSC, DorisParserParserCOPY, DorisParserParserCOUNT, DorisParserParserCREATION, DorisParserParserCRON, DorisParserParserCURRENT_CATALOG, DorisParserParserCURRENT_DATE, DorisParserParserCURRENT_TIME, DorisParserParserCURRENT_TIMESTAMP, DorisParserParserCURRENT_USER, DorisParserParserDATA, DorisParserParserDATE, DorisParserParserDATETIME, DorisParserParserDATETIMEV2, DorisParserParserDATEV2, DorisParserParserDATETIMEV1, DorisParserParserDATEV1, DorisParserParserDAY, DorisParserParserDAYS, DorisParserParserDECIMAL, DorisParserParserDECIMALV2, DorisParserParserDECIMALV3, DorisParserParserDEFERRED, DorisParserParserDEMAND, DorisParserParserDIAGNOSE, DorisParserParserDIAGNOSIS, DorisParserParserDICTIONARIES, DorisParserParserDICTIONARY, DorisParserParserDISTINCTPC, DorisParserParserDISTINCTPCSA, DorisParserParserDO, DorisParserParserDORIS_INTERNAL_TABLE_ID, DorisParserParserDUAL, DorisParserParserDYNAMIC, DorisParserParserE, DorisParserParserENABLE, DorisParserParserENCRYPTKEY, DorisParserParserENCRYPTKEYS, DorisParserParserEND, DorisParserParserENDS, DorisParserParserENGINE, DorisParserParserENGINES, DorisParserParserERRORS, DorisParserParserESCAPE, DorisParserParserEVENTS, DorisParserParserEVERY, DorisParserParserEXCLUDE, DorisParserParserEXPIRED, DorisParserParserEXTERNAL, DorisParserParserFAILED_LOGIN_ATTEMPTS, DorisParserParserFAST, DorisParserParserFEATURE, DorisParserParserFIELDS, DorisParserParserFILE, DorisParserParserFILTER, DorisParserParserFIRST, DorisParserParserFORMAT, DorisParserParserFREE, DorisParserParserFRONTENDS, DorisParserParserFUNCTION, DorisParserParserGENERATED, DorisParserParserGENERIC, DorisParserParserGLOBAL, DorisParserParserGRAPH, DorisParserParserGROUPING, DorisParserParserGROUPS, DorisParserParserHASH, DorisParserParserHASH_MAP, DorisParserParserHDFS, DorisParserParserHELP, DorisParserParserHISTOGRAM, DorisParserParserHLL_UNION, DorisParserParserHOSTNAME, DorisParserParserHOTSPOT, DorisParserParserHOUR, DorisParserParserHOURS, DorisParserParserHUB, DorisParserParserIDENTIFIED, DorisParserParserIGNORE, DorisParserParserIMMEDIATE, DorisParserParserINCREMENTAL, DorisParserParserINDEXES, DorisParserParserINVERTED, DorisParserParserIP_TRIE, DorisParserParserIPV4, DorisParserParserIPV6, DorisParserParserIS_NOT_NULL_PRED, DorisParserParserIS_NULL_PRED, DorisParserParserISNULL, DorisParserParserISOLATION, DorisParserParserJOB, DorisParserParserJOBS, DorisParserParserJSON, DorisParserParserJSONB, DorisParserParserLABEL, DorisParserParserLAST, DorisParserParserLDAP, DorisParserParserLDAP_ADMIN_PASSWORD, DorisParserParserLESS, DorisParserParserLEVEL, DorisParserParserLINES, DorisParserParserLINK, DorisParserParserLOCAL, DorisParserParserLOCALTIME, DorisParserParserLOCALTIMESTAMP, DorisParserParserLOCATION, DorisParserParserLOCK, DorisParserParserLOGICAL, DorisParserParserMANUAL, DorisParserParserMAP, DorisParserParserMATCH_ALL, DorisParserParserMATCH_ANY, DorisParserParserMATCH_PHRASE, DorisParserParserMATCH_PHRASE_EDGE, DorisParserParserMATCH_PHRASE_PREFIX, DorisParserParserMATCH_REGEXP, DorisParserParserMATERIALIZED, DorisParserParserMAX, DorisParserParserMEMO, DorisParserParserMERGE, DorisParserParserMIGRATE, DorisParserParserMIGRATIONS, DorisParserParserMIN, DorisParserParserMINUTE, DorisParserParserMINUTES, DorisParserParserMODIFY, DorisParserParserMONTH, DorisParserParserMTMV, DorisParserParserNAME, DorisParserParserNAMES, DorisParserParserNEGATIVE, DorisParserParserNEVER, DorisParserParserNEXT, DorisParserParserNGRAM_BF, DorisParserParserNO, DorisParserParserNON_NULLABLE, DorisParserParserNULLS, DorisParserParserOF, DorisParserParserOFFSET, DorisParserParserONLY, DorisParserParserOPEN, DorisParserParserOPTIMIZED, DorisParserParserPARAMETER, DorisParserParserPARSED, DorisParserParserPARTITIONS, DorisParserParserPASSWORD, DorisParserParserPASSWORD_EXPIRE, DorisParserParserPASSWORD_HISTORY, DorisParserParserPASSWORD_LOCK_TIME, DorisParserParserPASSWORD_REUSE, DorisParserParserPATH, DorisParserParserPAUSE, DorisParserParserPERCENT, DorisParserParserPERIOD, DorisParserParserPERMISSIVE, DorisParserParserPHYSICAL, DorisParserParserPI, DorisParserParserPLAN, DorisParserParserPRIVILEGES, DorisParserParserPROCESS, DorisParserParserPLUGIN, DorisParserParserPLUGINS, DorisParserParserPOLICY, DorisParserParserPROC, DorisParserParserPROCESSLIST, DorisParserParserPROFILE, DorisParserParserPROPERTIES, DorisParserParserPROPERTY, DorisParserParserQUANTILE_STATE, DorisParserParserQUANTILE_UNION, DorisParserParserQUERY, DorisParserParserQUEUED, DorisParserParserQUOTA, DorisParserParserQUALIFY, DorisParserParserQUARTER, DorisParserParserRANDOM, DorisParserParserRECENT, DorisParserParserRECOVER, DorisParserParserRECYCLE, DorisParserParserREFRESH, DorisParserParserREPEATABLE, DorisParserParserREPLACE, DorisParserParserREPLACE_IF_NOT_NULL, DorisParserParserREPLAYER, DorisParserParserREPOSITORIES, DorisParserParserREPOSITORY, DorisParserParserRESOURCE, DorisParserParserRESOURCES, DorisParserParserRESTORE, DorisParserParserRESTRICTIVE, DorisParserParserRESUME, DorisParserParserRETAIN, DorisParserParserRETENTION, DorisParserParserRETURNS, DorisParserParserREWRITTEN, DorisParserParserRLIKE, DorisParserParserROLLBACK, DorisParserParserROLLUP, DorisParserParserROUTINE, DorisParserParserS3, DorisParserParserSAMPLE, DorisParserParserSCHEDULE, DorisParserParserSCHEDULER, DorisParserParserSCHEMA, DorisParserParserSECOND, DorisParserParserSERIALIZABLE, DorisParserParserSESSION, DorisParserParserSESSION_USER, DorisParserParserSET_SESSION_VARIABLE, DorisParserParserSHAPE, DorisParserParserSKEW, DorisParserParserSNAPSHOT, DorisParserParserSNAPSHOTS, DorisParserParserSONAME, DorisParserParserSPLIT, DorisParserParserSQL, DorisParserParserSTAGE, DorisParserParserSTAGES, DorisParserParserSTART, DorisParserParserSTARTS, DorisParserParserSTATS, DorisParserParserSTATUS, DorisParserParserSTOP, DorisParserParserSTORAGE, DorisParserParserSTREAM, DorisParserParserSTREAMING, DorisParserParserSTRING, DorisParserParserSTRUCT, DorisParserParserSUM, DorisParserParserTABLES, DorisParserParserTAG, DorisParserParserTASK, DorisParserParserTASKS, DorisParserParserTEMPORARY, DorisParserParserTEXT, DorisParserParserTHAN, DorisParserParserTIME, DorisParserParserTIMESTAMP, DorisParserParserTRANSACTION, DorisParserParserTREE, DorisParserParserTRIGGERS, DorisParserParserTRUNCATE, DorisParserParserTYPE, DorisParserParserTYPES, DorisParserParserUNCOMMITTED, DorisParserParserUNLOCK, DorisParserParserUNSET, DorisParserParserUP, DorisParserParserUSER, DorisParserParserVALUE, DorisParserParserVARCHAR, DorisParserParserVARIABLE, DorisParserParserVARIABLES, DorisParserParserVARIANT, DorisParserParserVAULT, DorisParserParserVAULTS, DorisParserParserVERBOSE, DorisParserParserVERSION, DorisParserParserVIEW, DorisParserParserVIEWS, DorisParserParserWARM, DorisParserParserWARNINGS, DorisParserParserWEEK, DorisParserParserWORK, DorisParserParserYEAR, DorisParserParserHINT_START, DorisParserParserHINT_END, DorisParserParserCOMMENT_START, DorisParserParserSTRING_LITERAL, DorisParserParserIDENTIFIER, DorisParserParserBACKQUOTED_IDENTIFIER:
			{
				p.SetState(3417)
				p.UserIdentify()
			}

		case DorisParserParserROLE:
			{
				p.SetState(3418)
				p.Match(DorisParserParserROLE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3419)
				p.IdentifierOrText()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 6:
		localctx = NewRevokeTablePrivilegeContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(3422)
			p.Match(DorisParserParserREVOKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3423)
			p.PrivilegeList()
		}
		{
			p.SetState(3424)
			p.Match(DorisParserParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3425)
			p.MultipartIdentifierOrAsterisk()
		}
		{
			p.SetState(3426)
			p.Match(DorisParserParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3430)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserParserLEFT_BRACE, DorisParserParserRIGHT_BRACE, DorisParserParserACTIONS, DorisParserParserAFTER, DorisParserParserAGG_STATE, DorisParserParserAGGREGATE, DorisParserParserALIAS, DorisParserParserANALYZED, DorisParserParserARRAY, DorisParserParserAT, DorisParserParserAUTHORS, DorisParserParserAUTO_INCREMENT, DorisParserParserALWAYS, DorisParserParserBACKENDS, DorisParserParserBACKUP, DorisParserParserBEGIN, DorisParserParserBELONG, DorisParserParserBIN, DorisParserParserBITAND, DorisParserParserBITMAP, DorisParserParserBITMAP_EMPTY, DorisParserParserBITMAP_UNION, DorisParserParserBITOR, DorisParserParserBITXOR, DorisParserParserBLOB, DorisParserParserBOOLEAN, DorisParserParserBRANCH, DorisParserParserBRIEF, DorisParserParserBROKER, DorisParserParserBUCKETS, DorisParserParserBUILD, DorisParserParserBUILTIN, DorisParserParserBULK, DorisParserParserCACHE, DorisParserParserCACHED, DorisParserParserCALL, DorisParserParserCATALOG, DorisParserParserCATALOGS, DorisParserParserCHAIN, DorisParserParserCHAR, DorisParserParserCHARSET, DorisParserParserCHECK, DorisParserParserCLUSTER, DorisParserParserCLUSTERS, DorisParserParserCOLLATION, DorisParserParserCOLLECT, DorisParserParserCOLOCATE, DorisParserParserCOLUMNS, DorisParserParserCOMMENT, DorisParserParserCOMMIT, DorisParserParserCOMMITTED, DorisParserParserCOMPACT, DorisParserParserCOMPLETE, DorisParserParserCOMPRESS_TYPE, DorisParserParserCOMPUTE, DorisParserParserCONDITIONS, DorisParserParserCONFIG, DorisParserParserCONNECTION, DorisParserParserCONNECTION_ID, DorisParserParserCONSISTENT, DorisParserParserCONSTRAINTS, DorisParserParserCONVERT, DorisParserParserCONVERT_LSC, DorisParserParserCOPY, DorisParserParserCOUNT, DorisParserParserCREATION, DorisParserParserCRON, DorisParserParserCURRENT_CATALOG, DorisParserParserCURRENT_DATE, DorisParserParserCURRENT_TIME, DorisParserParserCURRENT_TIMESTAMP, DorisParserParserCURRENT_USER, DorisParserParserDATA, DorisParserParserDATE, DorisParserParserDATETIME, DorisParserParserDATETIMEV2, DorisParserParserDATEV2, DorisParserParserDATETIMEV1, DorisParserParserDATEV1, DorisParserParserDAY, DorisParserParserDAYS, DorisParserParserDECIMAL, DorisParserParserDECIMALV2, DorisParserParserDECIMALV3, DorisParserParserDEFERRED, DorisParserParserDEMAND, DorisParserParserDIAGNOSE, DorisParserParserDIAGNOSIS, DorisParserParserDICTIONARIES, DorisParserParserDICTIONARY, DorisParserParserDISTINCTPC, DorisParserParserDISTINCTPCSA, DorisParserParserDO, DorisParserParserDORIS_INTERNAL_TABLE_ID, DorisParserParserDUAL, DorisParserParserDYNAMIC, DorisParserParserE, DorisParserParserENABLE, DorisParserParserENCRYPTKEY, DorisParserParserENCRYPTKEYS, DorisParserParserEND, DorisParserParserENDS, DorisParserParserENGINE, DorisParserParserENGINES, DorisParserParserERRORS, DorisParserParserESCAPE, DorisParserParserEVENTS, DorisParserParserEVERY, DorisParserParserEXCLUDE, DorisParserParserEXPIRED, DorisParserParserEXTERNAL, DorisParserParserFAILED_LOGIN_ATTEMPTS, DorisParserParserFAST, DorisParserParserFEATURE, DorisParserParserFIELDS, DorisParserParserFILE, DorisParserParserFILTER, DorisParserParserFIRST, DorisParserParserFORMAT, DorisParserParserFREE, DorisParserParserFRONTENDS, DorisParserParserFUNCTION, DorisParserParserGENERATED, DorisParserParserGENERIC, DorisParserParserGLOBAL, DorisParserParserGRAPH, DorisParserParserGROUPING, DorisParserParserGROUPS, DorisParserParserHASH, DorisParserParserHASH_MAP, DorisParserParserHDFS, DorisParserParserHELP, DorisParserParserHISTOGRAM, DorisParserParserHLL_UNION, DorisParserParserHOSTNAME, DorisParserParserHOTSPOT, DorisParserParserHOUR, DorisParserParserHOURS, DorisParserParserHUB, DorisParserParserIDENTIFIED, DorisParserParserIGNORE, DorisParserParserIMMEDIATE, DorisParserParserINCREMENTAL, DorisParserParserINDEXES, DorisParserParserINVERTED, DorisParserParserIP_TRIE, DorisParserParserIPV4, DorisParserParserIPV6, DorisParserParserIS_NOT_NULL_PRED, DorisParserParserIS_NULL_PRED, DorisParserParserISNULL, DorisParserParserISOLATION, DorisParserParserJOB, DorisParserParserJOBS, DorisParserParserJSON, DorisParserParserJSONB, DorisParserParserLABEL, DorisParserParserLAST, DorisParserParserLDAP, DorisParserParserLDAP_ADMIN_PASSWORD, DorisParserParserLESS, DorisParserParserLEVEL, DorisParserParserLINES, DorisParserParserLINK, DorisParserParserLOCAL, DorisParserParserLOCALTIME, DorisParserParserLOCALTIMESTAMP, DorisParserParserLOCATION, DorisParserParserLOCK, DorisParserParserLOGICAL, DorisParserParserMANUAL, DorisParserParserMAP, DorisParserParserMATCH_ALL, DorisParserParserMATCH_ANY, DorisParserParserMATCH_PHRASE, DorisParserParserMATCH_PHRASE_EDGE, DorisParserParserMATCH_PHRASE_PREFIX, DorisParserParserMATCH_REGEXP, DorisParserParserMATERIALIZED, DorisParserParserMAX, DorisParserParserMEMO, DorisParserParserMERGE, DorisParserParserMIGRATE, DorisParserParserMIGRATIONS, DorisParserParserMIN, DorisParserParserMINUTE, DorisParserParserMINUTES, DorisParserParserMODIFY, DorisParserParserMONTH, DorisParserParserMTMV, DorisParserParserNAME, DorisParserParserNAMES, DorisParserParserNEGATIVE, DorisParserParserNEVER, DorisParserParserNEXT, DorisParserParserNGRAM_BF, DorisParserParserNO, DorisParserParserNON_NULLABLE, DorisParserParserNULLS, DorisParserParserOF, DorisParserParserOFFSET, DorisParserParserONLY, DorisParserParserOPEN, DorisParserParserOPTIMIZED, DorisParserParserPARAMETER, DorisParserParserPARSED, DorisParserParserPARTITIONS, DorisParserParserPASSWORD, DorisParserParserPASSWORD_EXPIRE, DorisParserParserPASSWORD_HISTORY, DorisParserParserPASSWORD_LOCK_TIME, DorisParserParserPASSWORD_REUSE, DorisParserParserPATH, DorisParserParserPAUSE, DorisParserParserPERCENT, DorisParserParserPERIOD, DorisParserParserPERMISSIVE, DorisParserParserPHYSICAL, DorisParserParserPI, DorisParserParserPLAN, DorisParserParserPRIVILEGES, DorisParserParserPROCESS, DorisParserParserPLUGIN, DorisParserParserPLUGINS, DorisParserParserPOLICY, DorisParserParserPROC, DorisParserParserPROCESSLIST, DorisParserParserPROFILE, DorisParserParserPROPERTIES, DorisParserParserPROPERTY, DorisParserParserQUANTILE_STATE, DorisParserParserQUANTILE_UNION, DorisParserParserQUERY, DorisParserParserQUEUED, DorisParserParserQUOTA, DorisParserParserQUALIFY, DorisParserParserQUARTER, DorisParserParserRANDOM, DorisParserParserRECENT, DorisParserParserRECOVER, DorisParserParserRECYCLE, DorisParserParserREFRESH, DorisParserParserREPEATABLE, DorisParserParserREPLACE, DorisParserParserREPLACE_IF_NOT_NULL, DorisParserParserREPLAYER, DorisParserParserREPOSITORIES, DorisParserParserREPOSITORY, DorisParserParserRESOURCE, DorisParserParserRESOURCES, DorisParserParserRESTORE, DorisParserParserRESTRICTIVE, DorisParserParserRESUME, DorisParserParserRETAIN, DorisParserParserRETENTION, DorisParserParserRETURNS, DorisParserParserREWRITTEN, DorisParserParserRLIKE, DorisParserParserROLLBACK, DorisParserParserROLLUP, DorisParserParserROUTINE, DorisParserParserS3, DorisParserParserSAMPLE, DorisParserParserSCHEDULE, DorisParserParserSCHEDULER, DorisParserParserSCHEMA, DorisParserParserSECOND, DorisParserParserSERIALIZABLE, DorisParserParserSESSION, DorisParserParserSESSION_USER, DorisParserParserSET_SESSION_VARIABLE, DorisParserParserSHAPE, DorisParserParserSKEW, DorisParserParserSNAPSHOT, DorisParserParserSNAPSHOTS, DorisParserParserSONAME, DorisParserParserSPLIT, DorisParserParserSQL, DorisParserParserSTAGE, DorisParserParserSTAGES, DorisParserParserSTART, DorisParserParserSTARTS, DorisParserParserSTATS, DorisParserParserSTATUS, DorisParserParserSTOP, DorisParserParserSTORAGE, DorisParserParserSTREAM, DorisParserParserSTREAMING, DorisParserParserSTRING, DorisParserParserSTRUCT, DorisParserParserSUM, DorisParserParserTABLES, DorisParserParserTAG, DorisParserParserTASK, DorisParserParserTASKS, DorisParserParserTEMPORARY, DorisParserParserTEXT, DorisParserParserTHAN, DorisParserParserTIME, DorisParserParserTIMESTAMP, DorisParserParserTRANSACTION, DorisParserParserTREE, DorisParserParserTRIGGERS, DorisParserParserTRUNCATE, DorisParserParserTYPE, DorisParserParserTYPES, DorisParserParserUNCOMMITTED, DorisParserParserUNLOCK, DorisParserParserUNSET, DorisParserParserUP, DorisParserParserUSER, DorisParserParserVALUE, DorisParserParserVARCHAR, DorisParserParserVARIABLE, DorisParserParserVARIABLES, DorisParserParserVARIANT, DorisParserParserVAULT, DorisParserParserVAULTS, DorisParserParserVERBOSE, DorisParserParserVERSION, DorisParserParserVIEW, DorisParserParserVIEWS, DorisParserParserWARM, DorisParserParserWARNINGS, DorisParserParserWEEK, DorisParserParserWORK, DorisParserParserYEAR, DorisParserParserHINT_START, DorisParserParserHINT_END, DorisParserParserCOMMENT_START, DorisParserParserSTRING_LITERAL, DorisParserParserIDENTIFIER, DorisParserParserBACKQUOTED_IDENTIFIER:
			{
				p.SetState(3427)
				p.UserIdentify()
			}

		case DorisParserParserROLE:
			{
				p.SetState(3428)
				p.Match(DorisParserParserROLE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3429)
				p.IdentifierOrText()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrivilegeContext is an interface to support dynamic dispatch.
type IPrivilegeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name rule contexts.
	GetName() IIdentifierContext

	// GetColumns returns the columns rule contexts.
	GetColumns() IIdentifierListContext

	// SetName sets the name rule contexts.
	SetName(IIdentifierContext)

	// SetColumns sets the columns rule contexts.
	SetColumns(IIdentifierListContext)

	// Getter signatures
	Identifier() IIdentifierContext
	IdentifierList() IIdentifierListContext
	ALL() antlr.TerminalNode

	// IsPrivilegeContext differentiates from other interfaces.
	IsPrivilegeContext()
}

type PrivilegeContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	name    IIdentifierContext
	columns IIdentifierListContext
}

func NewEmptyPrivilegeContext() *PrivilegeContext {
	var p = new(PrivilegeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_privilege
	return p
}

func InitEmptyPrivilegeContext(p *PrivilegeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_privilege
}

func (*PrivilegeContext) IsPrivilegeContext() {}

func NewPrivilegeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrivilegeContext {
	var p = new(PrivilegeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_privilege

	return p
}

func (s *PrivilegeContext) GetParser() antlr.Parser { return s.parser }

func (s *PrivilegeContext) GetName() IIdentifierContext { return s.name }

func (s *PrivilegeContext) GetColumns() IIdentifierListContext { return s.columns }

func (s *PrivilegeContext) SetName(v IIdentifierContext) { s.name = v }

func (s *PrivilegeContext) SetColumns(v IIdentifierListContext) { s.columns = v }

func (s *PrivilegeContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PrivilegeContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *PrivilegeContext) ALL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserALL, 0)
}

func (s *PrivilegeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrivilegeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrivilegeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitPrivilege(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) Privilege() (localctx IPrivilegeContext) {
	localctx = NewPrivilegeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, DorisParserParserRULE_privilege)
	var _la int

	p.SetState(3439)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserParserLEFT_BRACE, DorisParserParserRIGHT_BRACE, DorisParserParserACTIONS, DorisParserParserAFTER, DorisParserParserAGG_STATE, DorisParserParserAGGREGATE, DorisParserParserALIAS, DorisParserParserANALYZED, DorisParserParserARRAY, DorisParserParserAT, DorisParserParserAUTHORS, DorisParserParserAUTO_INCREMENT, DorisParserParserALWAYS, DorisParserParserBACKENDS, DorisParserParserBACKUP, DorisParserParserBEGIN, DorisParserParserBELONG, DorisParserParserBIN, DorisParserParserBITAND, DorisParserParserBITMAP, DorisParserParserBITMAP_EMPTY, DorisParserParserBITMAP_UNION, DorisParserParserBITOR, DorisParserParserBITXOR, DorisParserParserBLOB, DorisParserParserBOOLEAN, DorisParserParserBRANCH, DorisParserParserBRIEF, DorisParserParserBROKER, DorisParserParserBUCKETS, DorisParserParserBUILD, DorisParserParserBUILTIN, DorisParserParserBULK, DorisParserParserCACHE, DorisParserParserCACHED, DorisParserParserCALL, DorisParserParserCATALOG, DorisParserParserCATALOGS, DorisParserParserCHAIN, DorisParserParserCHAR, DorisParserParserCHARSET, DorisParserParserCHECK, DorisParserParserCLUSTER, DorisParserParserCLUSTERS, DorisParserParserCOLLATION, DorisParserParserCOLLECT, DorisParserParserCOLOCATE, DorisParserParserCOLUMNS, DorisParserParserCOMMENT, DorisParserParserCOMMIT, DorisParserParserCOMMITTED, DorisParserParserCOMPACT, DorisParserParserCOMPLETE, DorisParserParserCOMPRESS_TYPE, DorisParserParserCOMPUTE, DorisParserParserCONDITIONS, DorisParserParserCONFIG, DorisParserParserCONNECTION, DorisParserParserCONNECTION_ID, DorisParserParserCONSISTENT, DorisParserParserCONSTRAINTS, DorisParserParserCONVERT, DorisParserParserCONVERT_LSC, DorisParserParserCOPY, DorisParserParserCOUNT, DorisParserParserCREATION, DorisParserParserCRON, DorisParserParserCURRENT_CATALOG, DorisParserParserCURRENT_DATE, DorisParserParserCURRENT_TIME, DorisParserParserCURRENT_TIMESTAMP, DorisParserParserCURRENT_USER, DorisParserParserDATA, DorisParserParserDATE, DorisParserParserDATETIME, DorisParserParserDATETIMEV2, DorisParserParserDATEV2, DorisParserParserDATETIMEV1, DorisParserParserDATEV1, DorisParserParserDAY, DorisParserParserDAYS, DorisParserParserDECIMAL, DorisParserParserDECIMALV2, DorisParserParserDECIMALV3, DorisParserParserDEFERRED, DorisParserParserDEMAND, DorisParserParserDIAGNOSE, DorisParserParserDIAGNOSIS, DorisParserParserDICTIONARIES, DorisParserParserDICTIONARY, DorisParserParserDISTINCTPC, DorisParserParserDISTINCTPCSA, DorisParserParserDO, DorisParserParserDORIS_INTERNAL_TABLE_ID, DorisParserParserDUAL, DorisParserParserDYNAMIC, DorisParserParserE, DorisParserParserENABLE, DorisParserParserENCRYPTKEY, DorisParserParserENCRYPTKEYS, DorisParserParserEND, DorisParserParserENDS, DorisParserParserENGINE, DorisParserParserENGINES, DorisParserParserERRORS, DorisParserParserESCAPE, DorisParserParserEVENTS, DorisParserParserEVERY, DorisParserParserEXCLUDE, DorisParserParserEXPIRED, DorisParserParserEXTERNAL, DorisParserParserFAILED_LOGIN_ATTEMPTS, DorisParserParserFAST, DorisParserParserFEATURE, DorisParserParserFIELDS, DorisParserParserFILE, DorisParserParserFILTER, DorisParserParserFIRST, DorisParserParserFORMAT, DorisParserParserFREE, DorisParserParserFRONTENDS, DorisParserParserFUNCTION, DorisParserParserGENERATED, DorisParserParserGENERIC, DorisParserParserGLOBAL, DorisParserParserGRAPH, DorisParserParserGROUPING, DorisParserParserGROUPS, DorisParserParserHASH, DorisParserParserHASH_MAP, DorisParserParserHDFS, DorisParserParserHELP, DorisParserParserHISTOGRAM, DorisParserParserHLL_UNION, DorisParserParserHOSTNAME, DorisParserParserHOTSPOT, DorisParserParserHOUR, DorisParserParserHOURS, DorisParserParserHUB, DorisParserParserIDENTIFIED, DorisParserParserIGNORE, DorisParserParserIMMEDIATE, DorisParserParserINCREMENTAL, DorisParserParserINDEXES, DorisParserParserINVERTED, DorisParserParserIP_TRIE, DorisParserParserIPV4, DorisParserParserIPV6, DorisParserParserIS_NOT_NULL_PRED, DorisParserParserIS_NULL_PRED, DorisParserParserISNULL, DorisParserParserISOLATION, DorisParserParserJOB, DorisParserParserJOBS, DorisParserParserJSON, DorisParserParserJSONB, DorisParserParserLABEL, DorisParserParserLAST, DorisParserParserLDAP, DorisParserParserLDAP_ADMIN_PASSWORD, DorisParserParserLESS, DorisParserParserLEVEL, DorisParserParserLINES, DorisParserParserLINK, DorisParserParserLOCAL, DorisParserParserLOCALTIME, DorisParserParserLOCALTIMESTAMP, DorisParserParserLOCATION, DorisParserParserLOCK, DorisParserParserLOGICAL, DorisParserParserMANUAL, DorisParserParserMAP, DorisParserParserMATCH_ALL, DorisParserParserMATCH_ANY, DorisParserParserMATCH_PHRASE, DorisParserParserMATCH_PHRASE_EDGE, DorisParserParserMATCH_PHRASE_PREFIX, DorisParserParserMATCH_REGEXP, DorisParserParserMATERIALIZED, DorisParserParserMAX, DorisParserParserMEMO, DorisParserParserMERGE, DorisParserParserMIGRATE, DorisParserParserMIGRATIONS, DorisParserParserMIN, DorisParserParserMINUTE, DorisParserParserMINUTES, DorisParserParserMODIFY, DorisParserParserMONTH, DorisParserParserMTMV, DorisParserParserNAME, DorisParserParserNAMES, DorisParserParserNEGATIVE, DorisParserParserNEVER, DorisParserParserNEXT, DorisParserParserNGRAM_BF, DorisParserParserNO, DorisParserParserNON_NULLABLE, DorisParserParserNULLS, DorisParserParserOF, DorisParserParserOFFSET, DorisParserParserONLY, DorisParserParserOPEN, DorisParserParserOPTIMIZED, DorisParserParserPARAMETER, DorisParserParserPARSED, DorisParserParserPARTITIONS, DorisParserParserPASSWORD, DorisParserParserPASSWORD_EXPIRE, DorisParserParserPASSWORD_HISTORY, DorisParserParserPASSWORD_LOCK_TIME, DorisParserParserPASSWORD_REUSE, DorisParserParserPATH, DorisParserParserPAUSE, DorisParserParserPERCENT, DorisParserParserPERIOD, DorisParserParserPERMISSIVE, DorisParserParserPHYSICAL, DorisParserParserPI, DorisParserParserPLAN, DorisParserParserPRIVILEGES, DorisParserParserPROCESS, DorisParserParserPLUGIN, DorisParserParserPLUGINS, DorisParserParserPOLICY, DorisParserParserPROC, DorisParserParserPROCESSLIST, DorisParserParserPROFILE, DorisParserParserPROPERTIES, DorisParserParserPROPERTY, DorisParserParserQUANTILE_STATE, DorisParserParserQUANTILE_UNION, DorisParserParserQUERY, DorisParserParserQUEUED, DorisParserParserQUOTA, DorisParserParserQUALIFY, DorisParserParserQUARTER, DorisParserParserRANDOM, DorisParserParserRECENT, DorisParserParserRECOVER, DorisParserParserRECYCLE, DorisParserParserREFRESH, DorisParserParserREPEATABLE, DorisParserParserREPLACE, DorisParserParserREPLACE_IF_NOT_NULL, DorisParserParserREPLAYER, DorisParserParserREPOSITORIES, DorisParserParserREPOSITORY, DorisParserParserRESOURCE, DorisParserParserRESOURCES, DorisParserParserRESTORE, DorisParserParserRESTRICTIVE, DorisParserParserRESUME, DorisParserParserRETAIN, DorisParserParserRETENTION, DorisParserParserRETURNS, DorisParserParserREWRITTEN, DorisParserParserRLIKE, DorisParserParserROLLBACK, DorisParserParserROLLUP, DorisParserParserROUTINE, DorisParserParserS3, DorisParserParserSAMPLE, DorisParserParserSCHEDULE, DorisParserParserSCHEDULER, DorisParserParserSCHEMA, DorisParserParserSECOND, DorisParserParserSERIALIZABLE, DorisParserParserSESSION, DorisParserParserSESSION_USER, DorisParserParserSET_SESSION_VARIABLE, DorisParserParserSHAPE, DorisParserParserSKEW, DorisParserParserSNAPSHOT, DorisParserParserSNAPSHOTS, DorisParserParserSONAME, DorisParserParserSPLIT, DorisParserParserSQL, DorisParserParserSTAGE, DorisParserParserSTAGES, DorisParserParserSTART, DorisParserParserSTARTS, DorisParserParserSTATS, DorisParserParserSTATUS, DorisParserParserSTOP, DorisParserParserSTORAGE, DorisParserParserSTREAM, DorisParserParserSTREAMING, DorisParserParserSTRING, DorisParserParserSTRUCT, DorisParserParserSUM, DorisParserParserTABLES, DorisParserParserTAG, DorisParserParserTASK, DorisParserParserTASKS, DorisParserParserTEMPORARY, DorisParserParserTEXT, DorisParserParserTHAN, DorisParserParserTIME, DorisParserParserTIMESTAMP, DorisParserParserTRANSACTION, DorisParserParserTREE, DorisParserParserTRIGGERS, DorisParserParserTRUNCATE, DorisParserParserTYPE, DorisParserParserTYPES, DorisParserParserUNCOMMITTED, DorisParserParserUNLOCK, DorisParserParserUNSET, DorisParserParserUP, DorisParserParserUSER, DorisParserParserVALUE, DorisParserParserVARCHAR, DorisParserParserVARIABLE, DorisParserParserVARIABLES, DorisParserParserVARIANT, DorisParserParserVAULT, DorisParserParserVAULTS, DorisParserParserVERBOSE, DorisParserParserVERSION, DorisParserParserVIEW, DorisParserParserVIEWS, DorisParserParserWARM, DorisParserParserWARNINGS, DorisParserParserWEEK, DorisParserParserWORK, DorisParserParserYEAR, DorisParserParserHINT_START, DorisParserParserHINT_END, DorisParserParserCOMMENT_START, DorisParserParserIDENTIFIER, DorisParserParserBACKQUOTED_IDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3434)

			var _x = p.Identifier()

			localctx.(*PrivilegeContext).name = _x
		}
		p.SetState(3436)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserLEFT_PAREN {
			{
				p.SetState(3435)

				var _x = p.IdentifierList()

				localctx.(*PrivilegeContext).columns = _x
			}

		}

	case DorisParserParserALL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3438)
			p.Match(DorisParserParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrivilegeListContext is an interface to support dynamic dispatch.
type IPrivilegeListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllPrivilege() []IPrivilegeContext
	Privilege(i int) IPrivilegeContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsPrivilegeListContext differentiates from other interfaces.
	IsPrivilegeListContext()
}

type PrivilegeListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrivilegeListContext() *PrivilegeListContext {
	var p = new(PrivilegeListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_privilegeList
	return p
}

func InitEmptyPrivilegeListContext(p *PrivilegeListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_privilegeList
}

func (*PrivilegeListContext) IsPrivilegeListContext() {}

func NewPrivilegeListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrivilegeListContext {
	var p = new(PrivilegeListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_privilegeList

	return p
}

func (s *PrivilegeListContext) GetParser() antlr.Parser { return s.parser }

func (s *PrivilegeListContext) AllPrivilege() []IPrivilegeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPrivilegeContext); ok {
			len++
		}
	}

	tst := make([]IPrivilegeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPrivilegeContext); ok {
			tst[i] = t.(IPrivilegeContext)
			i++
		}
	}

	return tst
}

func (s *PrivilegeListContext) Privilege(i int) IPrivilegeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivilegeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivilegeContext)
}

func (s *PrivilegeListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserCOMMA)
}

func (s *PrivilegeListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOMMA, i)
}

func (s *PrivilegeListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrivilegeListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrivilegeListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitPrivilegeList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) PrivilegeList() (localctx IPrivilegeListContext) {
	localctx = NewPrivilegeListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, DorisParserParserRULE_privilegeList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3441)
		p.Privilege()
	}
	p.SetState(3446)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisParserParserCOMMA {
		{
			p.SetState(3442)
			p.Match(DorisParserParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3443)
			p.Privilege()
		}

		p.SetState(3448)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterSystemClauseContext is an interface to support dynamic dispatch.
type IAlterSystemClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsAlterSystemClauseContext differentiates from other interfaces.
	IsAlterSystemClauseContext()
}

type AlterSystemClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterSystemClauseContext() *AlterSystemClauseContext {
	var p = new(AlterSystemClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_alterSystemClause
	return p
}

func InitEmptyAlterSystemClauseContext(p *AlterSystemClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_alterSystemClause
}

func (*AlterSystemClauseContext) IsAlterSystemClauseContext() {}

func NewAlterSystemClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterSystemClauseContext {
	var p = new(AlterSystemClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_alterSystemClause

	return p
}

func (s *AlterSystemClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterSystemClauseContext) CopyAll(ctx *AlterSystemClauseContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *AlterSystemClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterSystemClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type DropBrokerClauseContext struct {
	AlterSystemClauseContext
	name            IIdentifierOrTextContext
	_STRING_LITERAL antlr.Token
	hostPorts       []antlr.Token
}

func NewDropBrokerClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropBrokerClauseContext {
	var p = new(DropBrokerClauseContext)

	InitEmptyAlterSystemClauseContext(&p.AlterSystemClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSystemClauseContext))

	return p
}

func (s *DropBrokerClauseContext) Get_STRING_LITERAL() antlr.Token { return s._STRING_LITERAL }

func (s *DropBrokerClauseContext) Set_STRING_LITERAL(v antlr.Token) { s._STRING_LITERAL = v }

func (s *DropBrokerClauseContext) GetHostPorts() []antlr.Token { return s.hostPorts }

func (s *DropBrokerClauseContext) SetHostPorts(v []antlr.Token) { s.hostPorts = v }

func (s *DropBrokerClauseContext) GetName() IIdentifierOrTextContext { return s.name }

func (s *DropBrokerClauseContext) SetName(v IIdentifierOrTextContext) { s.name = v }

func (s *DropBrokerClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropBrokerClauseContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDROP, 0)
}

func (s *DropBrokerClauseContext) BROKER() antlr.TerminalNode {
	return s.GetToken(DorisParserParserBROKER, 0)
}

func (s *DropBrokerClauseContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *DropBrokerClauseContext) AllSTRING_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserSTRING_LITERAL)
}

func (s *DropBrokerClauseContext) STRING_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTRING_LITERAL, i)
}

func (s *DropBrokerClauseContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserCOMMA)
}

func (s *DropBrokerClauseContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOMMA, i)
}

func (s *DropBrokerClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitDropBrokerClause(s)

	default:
		return t.VisitChildren(s)
	}
}

type ModifyFrontendOrBackendHostNameClauseContext struct {
	AlterSystemClauseContext
	hostPort antlr.Token
	hostName antlr.Token
}

func NewModifyFrontendOrBackendHostNameClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ModifyFrontendOrBackendHostNameClauseContext {
	var p = new(ModifyFrontendOrBackendHostNameClauseContext)

	InitEmptyAlterSystemClauseContext(&p.AlterSystemClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSystemClauseContext))

	return p
}

func (s *ModifyFrontendOrBackendHostNameClauseContext) GetHostPort() antlr.Token { return s.hostPort }

func (s *ModifyFrontendOrBackendHostNameClauseContext) GetHostName() antlr.Token { return s.hostName }

func (s *ModifyFrontendOrBackendHostNameClauseContext) SetHostPort(v antlr.Token) { s.hostPort = v }

func (s *ModifyFrontendOrBackendHostNameClauseContext) SetHostName(v antlr.Token) { s.hostName = v }

func (s *ModifyFrontendOrBackendHostNameClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModifyFrontendOrBackendHostNameClauseContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(DorisParserParserMODIFY, 0)
}

func (s *ModifyFrontendOrBackendHostNameClauseContext) HOSTNAME() antlr.TerminalNode {
	return s.GetToken(DorisParserParserHOSTNAME, 0)
}

func (s *ModifyFrontendOrBackendHostNameClauseContext) FRONTEND() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFRONTEND, 0)
}

func (s *ModifyFrontendOrBackendHostNameClauseContext) BACKEND() antlr.TerminalNode {
	return s.GetToken(DorisParserParserBACKEND, 0)
}

func (s *ModifyFrontendOrBackendHostNameClauseContext) AllSTRING_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserSTRING_LITERAL)
}

func (s *ModifyFrontendOrBackendHostNameClauseContext) STRING_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTRING_LITERAL, i)
}

func (s *ModifyFrontendOrBackendHostNameClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitModifyFrontendOrBackendHostNameClause(s)

	default:
		return t.VisitChildren(s)
	}
}

type DropObserverClauseContext struct {
	AlterSystemClauseContext
	hostPort antlr.Token
}

func NewDropObserverClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropObserverClauseContext {
	var p = new(DropObserverClauseContext)

	InitEmptyAlterSystemClauseContext(&p.AlterSystemClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSystemClauseContext))

	return p
}

func (s *DropObserverClauseContext) GetHostPort() antlr.Token { return s.hostPort }

func (s *DropObserverClauseContext) SetHostPort(v antlr.Token) { s.hostPort = v }

func (s *DropObserverClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropObserverClauseContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDROP, 0)
}

func (s *DropObserverClauseContext) OBSERVER() antlr.TerminalNode {
	return s.GetToken(DorisParserParserOBSERVER, 0)
}

func (s *DropObserverClauseContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTRING_LITERAL, 0)
}

func (s *DropObserverClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitDropObserverClause(s)

	default:
		return t.VisitChildren(s)
	}
}

type AddFollowerClauseContext struct {
	AlterSystemClauseContext
	hostPort antlr.Token
}

func NewAddFollowerClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AddFollowerClauseContext {
	var p = new(AddFollowerClauseContext)

	InitEmptyAlterSystemClauseContext(&p.AlterSystemClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSystemClauseContext))

	return p
}

func (s *AddFollowerClauseContext) GetHostPort() antlr.Token { return s.hostPort }

func (s *AddFollowerClauseContext) SetHostPort(v antlr.Token) { s.hostPort = v }

func (s *AddFollowerClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddFollowerClauseContext) ADD() antlr.TerminalNode {
	return s.GetToken(DorisParserParserADD, 0)
}

func (s *AddFollowerClauseContext) FOLLOWER() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFOLLOWER, 0)
}

func (s *AddFollowerClauseContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTRING_LITERAL, 0)
}

func (s *AddFollowerClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitAddFollowerClause(s)

	default:
		return t.VisitChildren(s)
	}
}

type DropFollowerClauseContext struct {
	AlterSystemClauseContext
	hostPort antlr.Token
}

func NewDropFollowerClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropFollowerClauseContext {
	var p = new(DropFollowerClauseContext)

	InitEmptyAlterSystemClauseContext(&p.AlterSystemClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSystemClauseContext))

	return p
}

func (s *DropFollowerClauseContext) GetHostPort() antlr.Token { return s.hostPort }

func (s *DropFollowerClauseContext) SetHostPort(v antlr.Token) { s.hostPort = v }

func (s *DropFollowerClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropFollowerClauseContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDROP, 0)
}

func (s *DropFollowerClauseContext) FOLLOWER() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFOLLOWER, 0)
}

func (s *DropFollowerClauseContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTRING_LITERAL, 0)
}

func (s *DropFollowerClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitDropFollowerClause(s)

	default:
		return t.VisitChildren(s)
	}
}

type DropAllBrokerClauseContext struct {
	AlterSystemClauseContext
	name IIdentifierOrTextContext
}

func NewDropAllBrokerClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropAllBrokerClauseContext {
	var p = new(DropAllBrokerClauseContext)

	InitEmptyAlterSystemClauseContext(&p.AlterSystemClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSystemClauseContext))

	return p
}

func (s *DropAllBrokerClauseContext) GetName() IIdentifierOrTextContext { return s.name }

func (s *DropAllBrokerClauseContext) SetName(v IIdentifierOrTextContext) { s.name = v }

func (s *DropAllBrokerClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropAllBrokerClauseContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDROP, 0)
}

func (s *DropAllBrokerClauseContext) ALL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserALL, 0)
}

func (s *DropAllBrokerClauseContext) BROKER() antlr.TerminalNode {
	return s.GetToken(DorisParserParserBROKER, 0)
}

func (s *DropAllBrokerClauseContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *DropAllBrokerClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitDropAllBrokerClause(s)

	default:
		return t.VisitChildren(s)
	}
}

type DropBackendClauseContext struct {
	AlterSystemClauseContext
	_STRING_LITERAL antlr.Token
	hostPorts       []antlr.Token
}

func NewDropBackendClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropBackendClauseContext {
	var p = new(DropBackendClauseContext)

	InitEmptyAlterSystemClauseContext(&p.AlterSystemClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSystemClauseContext))

	return p
}

func (s *DropBackendClauseContext) Get_STRING_LITERAL() antlr.Token { return s._STRING_LITERAL }

func (s *DropBackendClauseContext) Set_STRING_LITERAL(v antlr.Token) { s._STRING_LITERAL = v }

func (s *DropBackendClauseContext) GetHostPorts() []antlr.Token { return s.hostPorts }

func (s *DropBackendClauseContext) SetHostPorts(v []antlr.Token) { s.hostPorts = v }

func (s *DropBackendClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropBackendClauseContext) BACKEND() antlr.TerminalNode {
	return s.GetToken(DorisParserParserBACKEND, 0)
}

func (s *DropBackendClauseContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDROP, 0)
}

func (s *DropBackendClauseContext) DROPP() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDROPP, 0)
}

func (s *DropBackendClauseContext) AllSTRING_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserSTRING_LITERAL)
}

func (s *DropBackendClauseContext) STRING_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTRING_LITERAL, i)
}

func (s *DropBackendClauseContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserCOMMA)
}

func (s *DropBackendClauseContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOMMA, i)
}

func (s *DropBackendClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitDropBackendClause(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterLoadErrorUrlClauseContext struct {
	AlterSystemClauseContext
	properties IPropertyClauseContext
}

func NewAlterLoadErrorUrlClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterLoadErrorUrlClauseContext {
	var p = new(AlterLoadErrorUrlClauseContext)

	InitEmptyAlterSystemClauseContext(&p.AlterSystemClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSystemClauseContext))

	return p
}

func (s *AlterLoadErrorUrlClauseContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *AlterLoadErrorUrlClauseContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *AlterLoadErrorUrlClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterLoadErrorUrlClauseContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSET, 0)
}

func (s *AlterLoadErrorUrlClauseContext) LOAD() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLOAD, 0)
}

func (s *AlterLoadErrorUrlClauseContext) ERRORS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserERRORS, 0)
}

func (s *AlterLoadErrorUrlClauseContext) HUB() antlr.TerminalNode {
	return s.GetToken(DorisParserParserHUB, 0)
}

func (s *AlterLoadErrorUrlClauseContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *AlterLoadErrorUrlClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitAlterLoadErrorUrlClause(s)

	default:
		return t.VisitChildren(s)
	}
}

type ModifyBackendClauseContext struct {
	AlterSystemClauseContext
	_STRING_LITERAL antlr.Token
	hostPorts       []antlr.Token
}

func NewModifyBackendClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ModifyBackendClauseContext {
	var p = new(ModifyBackendClauseContext)

	InitEmptyAlterSystemClauseContext(&p.AlterSystemClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSystemClauseContext))

	return p
}

func (s *ModifyBackendClauseContext) Get_STRING_LITERAL() antlr.Token { return s._STRING_LITERAL }

func (s *ModifyBackendClauseContext) Set_STRING_LITERAL(v antlr.Token) { s._STRING_LITERAL = v }

func (s *ModifyBackendClauseContext) GetHostPorts() []antlr.Token { return s.hostPorts }

func (s *ModifyBackendClauseContext) SetHostPorts(v []antlr.Token) { s.hostPorts = v }

func (s *ModifyBackendClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModifyBackendClauseContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(DorisParserParserMODIFY, 0)
}

func (s *ModifyBackendClauseContext) BACKEND() antlr.TerminalNode {
	return s.GetToken(DorisParserParserBACKEND, 0)
}

func (s *ModifyBackendClauseContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSET, 0)
}

func (s *ModifyBackendClauseContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLEFT_PAREN, 0)
}

func (s *ModifyBackendClauseContext) PropertyItemList() IPropertyItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyItemListContext)
}

func (s *ModifyBackendClauseContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRIGHT_PAREN, 0)
}

func (s *ModifyBackendClauseContext) AllSTRING_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserSTRING_LITERAL)
}

func (s *ModifyBackendClauseContext) STRING_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTRING_LITERAL, i)
}

func (s *ModifyBackendClauseContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserCOMMA)
}

func (s *ModifyBackendClauseContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOMMA, i)
}

func (s *ModifyBackendClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitModifyBackendClause(s)

	default:
		return t.VisitChildren(s)
	}
}

type AddBrokerClauseContext struct {
	AlterSystemClauseContext
	name            IIdentifierOrTextContext
	_STRING_LITERAL antlr.Token
	hostPorts       []antlr.Token
}

func NewAddBrokerClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AddBrokerClauseContext {
	var p = new(AddBrokerClauseContext)

	InitEmptyAlterSystemClauseContext(&p.AlterSystemClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSystemClauseContext))

	return p
}

func (s *AddBrokerClauseContext) Get_STRING_LITERAL() antlr.Token { return s._STRING_LITERAL }

func (s *AddBrokerClauseContext) Set_STRING_LITERAL(v antlr.Token) { s._STRING_LITERAL = v }

func (s *AddBrokerClauseContext) GetHostPorts() []antlr.Token { return s.hostPorts }

func (s *AddBrokerClauseContext) SetHostPorts(v []antlr.Token) { s.hostPorts = v }

func (s *AddBrokerClauseContext) GetName() IIdentifierOrTextContext { return s.name }

func (s *AddBrokerClauseContext) SetName(v IIdentifierOrTextContext) { s.name = v }

func (s *AddBrokerClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddBrokerClauseContext) ADD() antlr.TerminalNode {
	return s.GetToken(DorisParserParserADD, 0)
}

func (s *AddBrokerClauseContext) BROKER() antlr.TerminalNode {
	return s.GetToken(DorisParserParserBROKER, 0)
}

func (s *AddBrokerClauseContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *AddBrokerClauseContext) AllSTRING_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserSTRING_LITERAL)
}

func (s *AddBrokerClauseContext) STRING_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTRING_LITERAL, i)
}

func (s *AddBrokerClauseContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserCOMMA)
}

func (s *AddBrokerClauseContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOMMA, i)
}

func (s *AddBrokerClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitAddBrokerClause(s)

	default:
		return t.VisitChildren(s)
	}
}

type AddObserverClauseContext struct {
	AlterSystemClauseContext
	hostPort antlr.Token
}

func NewAddObserverClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AddObserverClauseContext {
	var p = new(AddObserverClauseContext)

	InitEmptyAlterSystemClauseContext(&p.AlterSystemClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSystemClauseContext))

	return p
}

func (s *AddObserverClauseContext) GetHostPort() antlr.Token { return s.hostPort }

func (s *AddObserverClauseContext) SetHostPort(v antlr.Token) { s.hostPort = v }

func (s *AddObserverClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddObserverClauseContext) ADD() antlr.TerminalNode {
	return s.GetToken(DorisParserParserADD, 0)
}

func (s *AddObserverClauseContext) OBSERVER() antlr.TerminalNode {
	return s.GetToken(DorisParserParserOBSERVER, 0)
}

func (s *AddObserverClauseContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTRING_LITERAL, 0)
}

func (s *AddObserverClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitAddObserverClause(s)

	default:
		return t.VisitChildren(s)
	}
}

type DecommissionBackendClauseContext struct {
	AlterSystemClauseContext
	_STRING_LITERAL antlr.Token
	hostPorts       []antlr.Token
}

func NewDecommissionBackendClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DecommissionBackendClauseContext {
	var p = new(DecommissionBackendClauseContext)

	InitEmptyAlterSystemClauseContext(&p.AlterSystemClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSystemClauseContext))

	return p
}

func (s *DecommissionBackendClauseContext) Get_STRING_LITERAL() antlr.Token { return s._STRING_LITERAL }

func (s *DecommissionBackendClauseContext) Set_STRING_LITERAL(v antlr.Token) { s._STRING_LITERAL = v }

func (s *DecommissionBackendClauseContext) GetHostPorts() []antlr.Token { return s.hostPorts }

func (s *DecommissionBackendClauseContext) SetHostPorts(v []antlr.Token) { s.hostPorts = v }

func (s *DecommissionBackendClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DecommissionBackendClauseContext) DECOMMISSION() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDECOMMISSION, 0)
}

func (s *DecommissionBackendClauseContext) BACKEND() antlr.TerminalNode {
	return s.GetToken(DorisParserParserBACKEND, 0)
}

func (s *DecommissionBackendClauseContext) AllSTRING_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserSTRING_LITERAL)
}

func (s *DecommissionBackendClauseContext) STRING_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTRING_LITERAL, i)
}

func (s *DecommissionBackendClauseContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserCOMMA)
}

func (s *DecommissionBackendClauseContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOMMA, i)
}

func (s *DecommissionBackendClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitDecommissionBackendClause(s)

	default:
		return t.VisitChildren(s)
	}
}

type AddBackendClauseContext struct {
	AlterSystemClauseContext
	_STRING_LITERAL antlr.Token
	hostPorts       []antlr.Token
	properties      IPropertyClauseContext
}

func NewAddBackendClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AddBackendClauseContext {
	var p = new(AddBackendClauseContext)

	InitEmptyAlterSystemClauseContext(&p.AlterSystemClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterSystemClauseContext))

	return p
}

func (s *AddBackendClauseContext) Get_STRING_LITERAL() antlr.Token { return s._STRING_LITERAL }

func (s *AddBackendClauseContext) Set_STRING_LITERAL(v antlr.Token) { s._STRING_LITERAL = v }

func (s *AddBackendClauseContext) GetHostPorts() []antlr.Token { return s.hostPorts }

func (s *AddBackendClauseContext) SetHostPorts(v []antlr.Token) { s.hostPorts = v }

func (s *AddBackendClauseContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *AddBackendClauseContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *AddBackendClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddBackendClauseContext) ADD() antlr.TerminalNode {
	return s.GetToken(DorisParserParserADD, 0)
}

func (s *AddBackendClauseContext) BACKEND() antlr.TerminalNode {
	return s.GetToken(DorisParserParserBACKEND, 0)
}

func (s *AddBackendClauseContext) AllSTRING_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserSTRING_LITERAL)
}

func (s *AddBackendClauseContext) STRING_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTRING_LITERAL, i)
}

func (s *AddBackendClauseContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserCOMMA)
}

func (s *AddBackendClauseContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOMMA, i)
}

func (s *AddBackendClauseContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *AddBackendClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitAddBackendClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) AlterSystemClause() (localctx IAlterSystemClauseContext) {
	localctx = NewAlterSystemClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, DorisParserParserRULE_alterSystemClause)
	var _la int

	p.SetState(3547)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 475, p.GetParserRuleContext()) {
	case 1:
		localctx = NewAddBackendClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3449)
			p.Match(DorisParserParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3450)
			p.Match(DorisParserParserBACKEND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3451)

			var _m = p.Match(DorisParserParserSTRING_LITERAL)

			localctx.(*AddBackendClauseContext)._STRING_LITERAL = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*AddBackendClauseContext).hostPorts = append(localctx.(*AddBackendClauseContext).hostPorts, localctx.(*AddBackendClauseContext)._STRING_LITERAL)
		p.SetState(3456)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserParserCOMMA {
			{
				p.SetState(3452)
				p.Match(DorisParserParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3453)

				var _m = p.Match(DorisParserParserSTRING_LITERAL)

				localctx.(*AddBackendClauseContext)._STRING_LITERAL = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			localctx.(*AddBackendClauseContext).hostPorts = append(localctx.(*AddBackendClauseContext).hostPorts, localctx.(*AddBackendClauseContext)._STRING_LITERAL)

			p.SetState(3458)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(3460)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserPROPERTIES {
			{
				p.SetState(3459)

				var _x = p.PropertyClause()

				localctx.(*AddBackendClauseContext).properties = _x
			}

		}

	case 2:
		localctx = NewDropBackendClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3462)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserParserDROP || _la == DorisParserParserDROPP) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(3463)
			p.Match(DorisParserParserBACKEND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3464)

			var _m = p.Match(DorisParserParserSTRING_LITERAL)

			localctx.(*DropBackendClauseContext)._STRING_LITERAL = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*DropBackendClauseContext).hostPorts = append(localctx.(*DropBackendClauseContext).hostPorts, localctx.(*DropBackendClauseContext)._STRING_LITERAL)
		p.SetState(3469)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserParserCOMMA {
			{
				p.SetState(3465)
				p.Match(DorisParserParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3466)

				var _m = p.Match(DorisParserParserSTRING_LITERAL)

				localctx.(*DropBackendClauseContext)._STRING_LITERAL = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			localctx.(*DropBackendClauseContext).hostPorts = append(localctx.(*DropBackendClauseContext).hostPorts, localctx.(*DropBackendClauseContext)._STRING_LITERAL)

			p.SetState(3471)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 3:
		localctx = NewDecommissionBackendClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3472)
			p.Match(DorisParserParserDECOMMISSION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3473)
			p.Match(DorisParserParserBACKEND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3474)

			var _m = p.Match(DorisParserParserSTRING_LITERAL)

			localctx.(*DecommissionBackendClauseContext)._STRING_LITERAL = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*DecommissionBackendClauseContext).hostPorts = append(localctx.(*DecommissionBackendClauseContext).hostPorts, localctx.(*DecommissionBackendClauseContext)._STRING_LITERAL)
		p.SetState(3479)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserParserCOMMA {
			{
				p.SetState(3475)
				p.Match(DorisParserParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3476)

				var _m = p.Match(DorisParserParserSTRING_LITERAL)

				localctx.(*DecommissionBackendClauseContext)._STRING_LITERAL = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			localctx.(*DecommissionBackendClauseContext).hostPorts = append(localctx.(*DecommissionBackendClauseContext).hostPorts, localctx.(*DecommissionBackendClauseContext)._STRING_LITERAL)

			p.SetState(3481)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 4:
		localctx = NewAddObserverClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3482)
			p.Match(DorisParserParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3483)
			p.Match(DorisParserParserOBSERVER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3484)

			var _m = p.Match(DorisParserParserSTRING_LITERAL)

			localctx.(*AddObserverClauseContext).hostPort = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		localctx = NewDropObserverClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(3485)
			p.Match(DorisParserParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3486)
			p.Match(DorisParserParserOBSERVER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3487)

			var _m = p.Match(DorisParserParserSTRING_LITERAL)

			localctx.(*DropObserverClauseContext).hostPort = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		localctx = NewAddFollowerClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(3488)
			p.Match(DorisParserParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3489)
			p.Match(DorisParserParserFOLLOWER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3490)

			var _m = p.Match(DorisParserParserSTRING_LITERAL)

			localctx.(*AddFollowerClauseContext).hostPort = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		localctx = NewDropFollowerClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(3491)
			p.Match(DorisParserParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3492)
			p.Match(DorisParserParserFOLLOWER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3493)

			var _m = p.Match(DorisParserParserSTRING_LITERAL)

			localctx.(*DropFollowerClauseContext).hostPort = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 8:
		localctx = NewAddBrokerClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(3494)
			p.Match(DorisParserParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3495)
			p.Match(DorisParserParserBROKER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3496)

			var _x = p.IdentifierOrText()

			localctx.(*AddBrokerClauseContext).name = _x
		}
		{
			p.SetState(3497)

			var _m = p.Match(DorisParserParserSTRING_LITERAL)

			localctx.(*AddBrokerClauseContext)._STRING_LITERAL = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*AddBrokerClauseContext).hostPorts = append(localctx.(*AddBrokerClauseContext).hostPorts, localctx.(*AddBrokerClauseContext)._STRING_LITERAL)
		p.SetState(3502)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserParserCOMMA {
			{
				p.SetState(3498)
				p.Match(DorisParserParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3499)

				var _m = p.Match(DorisParserParserSTRING_LITERAL)

				localctx.(*AddBrokerClauseContext)._STRING_LITERAL = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			localctx.(*AddBrokerClauseContext).hostPorts = append(localctx.(*AddBrokerClauseContext).hostPorts, localctx.(*AddBrokerClauseContext)._STRING_LITERAL)

			p.SetState(3504)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 9:
		localctx = NewDropBrokerClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(3505)
			p.Match(DorisParserParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3506)
			p.Match(DorisParserParserBROKER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3507)

			var _x = p.IdentifierOrText()

			localctx.(*DropBrokerClauseContext).name = _x
		}
		{
			p.SetState(3508)

			var _m = p.Match(DorisParserParserSTRING_LITERAL)

			localctx.(*DropBrokerClauseContext)._STRING_LITERAL = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*DropBrokerClauseContext).hostPorts = append(localctx.(*DropBrokerClauseContext).hostPorts, localctx.(*DropBrokerClauseContext)._STRING_LITERAL)
		p.SetState(3513)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserParserCOMMA {
			{
				p.SetState(3509)
				p.Match(DorisParserParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3510)

				var _m = p.Match(DorisParserParserSTRING_LITERAL)

				localctx.(*DropBrokerClauseContext)._STRING_LITERAL = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			localctx.(*DropBrokerClauseContext).hostPorts = append(localctx.(*DropBrokerClauseContext).hostPorts, localctx.(*DropBrokerClauseContext)._STRING_LITERAL)

			p.SetState(3515)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 10:
		localctx = NewDropAllBrokerClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(3516)
			p.Match(DorisParserParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3517)
			p.Match(DorisParserParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3518)
			p.Match(DorisParserParserBROKER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3519)

			var _x = p.IdentifierOrText()

			localctx.(*DropAllBrokerClauseContext).name = _x
		}

	case 11:
		localctx = NewAlterLoadErrorUrlClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(3520)
			p.Match(DorisParserParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3521)
			p.Match(DorisParserParserLOAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3522)
			p.Match(DorisParserParserERRORS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3523)
			p.Match(DorisParserParserHUB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3525)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserPROPERTIES {
			{
				p.SetState(3524)

				var _x = p.PropertyClause()

				localctx.(*AlterLoadErrorUrlClauseContext).properties = _x
			}

		}

	case 12:
		localctx = NewModifyBackendClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(3527)
			p.Match(DorisParserParserMODIFY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3528)
			p.Match(DorisParserParserBACKEND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3529)

			var _m = p.Match(DorisParserParserSTRING_LITERAL)

			localctx.(*ModifyBackendClauseContext)._STRING_LITERAL = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*ModifyBackendClauseContext).hostPorts = append(localctx.(*ModifyBackendClauseContext).hostPorts, localctx.(*ModifyBackendClauseContext)._STRING_LITERAL)
		p.SetState(3534)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserParserCOMMA {
			{
				p.SetState(3530)
				p.Match(DorisParserParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3531)

				var _m = p.Match(DorisParserParserSTRING_LITERAL)

				localctx.(*ModifyBackendClauseContext)._STRING_LITERAL = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			localctx.(*ModifyBackendClauseContext).hostPorts = append(localctx.(*ModifyBackendClauseContext).hostPorts, localctx.(*ModifyBackendClauseContext)._STRING_LITERAL)

			p.SetState(3536)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3537)
			p.Match(DorisParserParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3538)
			p.Match(DorisParserParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3539)
			p.PropertyItemList()
		}
		{
			p.SetState(3540)
			p.Match(DorisParserParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 13:
		localctx = NewModifyFrontendOrBackendHostNameClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(3542)
			p.Match(DorisParserParserMODIFY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3543)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserParserBACKEND || _la == DorisParserParserFRONTEND) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(3544)

			var _m = p.Match(DorisParserParserSTRING_LITERAL)

			localctx.(*ModifyFrontendOrBackendHostNameClauseContext).hostPort = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3545)
			p.Match(DorisParserParserHOSTNAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3546)

			var _m = p.Match(DorisParserParserSTRING_LITERAL)

			localctx.(*ModifyFrontendOrBackendHostNameClauseContext).hostName = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropRollupClauseContext is an interface to support dynamic dispatch.
type IDropRollupClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetRollupName returns the rollupName rule contexts.
	GetRollupName() IIdentifierContext

	// GetProperties returns the properties rule contexts.
	GetProperties() IPropertyClauseContext

	// SetRollupName sets the rollupName rule contexts.
	SetRollupName(IIdentifierContext)

	// SetProperties sets the properties rule contexts.
	SetProperties(IPropertyClauseContext)

	// Getter signatures
	Identifier() IIdentifierContext
	PropertyClause() IPropertyClauseContext

	// IsDropRollupClauseContext differentiates from other interfaces.
	IsDropRollupClauseContext()
}

type DropRollupClauseContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	rollupName IIdentifierContext
	properties IPropertyClauseContext
}

func NewEmptyDropRollupClauseContext() *DropRollupClauseContext {
	var p = new(DropRollupClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_dropRollupClause
	return p
}

func InitEmptyDropRollupClauseContext(p *DropRollupClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_dropRollupClause
}

func (*DropRollupClauseContext) IsDropRollupClauseContext() {}

func NewDropRollupClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropRollupClauseContext {
	var p = new(DropRollupClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_dropRollupClause

	return p
}

func (s *DropRollupClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DropRollupClauseContext) GetRollupName() IIdentifierContext { return s.rollupName }

func (s *DropRollupClauseContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *DropRollupClauseContext) SetRollupName(v IIdentifierContext) { s.rollupName = v }

func (s *DropRollupClauseContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *DropRollupClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DropRollupClauseContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *DropRollupClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropRollupClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropRollupClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitDropRollupClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) DropRollupClause() (localctx IDropRollupClauseContext) {
	localctx = NewDropRollupClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, DorisParserParserRULE_dropRollupClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3549)

		var _x = p.Identifier()

		localctx.(*DropRollupClauseContext).rollupName = _x
	}
	p.SetState(3551)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserParserPROPERTIES {
		{
			p.SetState(3550)

			var _x = p.PropertyClause()

			localctx.(*DropRollupClauseContext).properties = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAddRollupClauseContext is an interface to support dynamic dispatch.
type IAddRollupClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetRollupName returns the rollupName rule contexts.
	GetRollupName() IIdentifierContext

	// GetColumns returns the columns rule contexts.
	GetColumns() IIdentifierListContext

	// GetDupKeys returns the dupKeys rule contexts.
	GetDupKeys() IIdentifierListContext

	// GetProperties returns the properties rule contexts.
	GetProperties() IPropertyClauseContext

	// SetRollupName sets the rollupName rule contexts.
	SetRollupName(IIdentifierContext)

	// SetColumns sets the columns rule contexts.
	SetColumns(IIdentifierListContext)

	// SetDupKeys sets the dupKeys rule contexts.
	SetDupKeys(IIdentifierListContext)

	// SetProperties sets the properties rule contexts.
	SetProperties(IPropertyClauseContext)

	// Getter signatures
	Identifier() IIdentifierContext
	AllIdentifierList() []IIdentifierListContext
	IdentifierList(i int) IIdentifierListContext
	DUPLICATE() antlr.TerminalNode
	KEY() antlr.TerminalNode
	FromRollup() IFromRollupContext
	PropertyClause() IPropertyClauseContext

	// IsAddRollupClauseContext differentiates from other interfaces.
	IsAddRollupClauseContext()
}

type AddRollupClauseContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	rollupName IIdentifierContext
	columns    IIdentifierListContext
	dupKeys    IIdentifierListContext
	properties IPropertyClauseContext
}

func NewEmptyAddRollupClauseContext() *AddRollupClauseContext {
	var p = new(AddRollupClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_addRollupClause
	return p
}

func InitEmptyAddRollupClauseContext(p *AddRollupClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_addRollupClause
}

func (*AddRollupClauseContext) IsAddRollupClauseContext() {}

func NewAddRollupClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AddRollupClauseContext {
	var p = new(AddRollupClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_addRollupClause

	return p
}

func (s *AddRollupClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *AddRollupClauseContext) GetRollupName() IIdentifierContext { return s.rollupName }

func (s *AddRollupClauseContext) GetColumns() IIdentifierListContext { return s.columns }

func (s *AddRollupClauseContext) GetDupKeys() IIdentifierListContext { return s.dupKeys }

func (s *AddRollupClauseContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *AddRollupClauseContext) SetRollupName(v IIdentifierContext) { s.rollupName = v }

func (s *AddRollupClauseContext) SetColumns(v IIdentifierListContext) { s.columns = v }

func (s *AddRollupClauseContext) SetDupKeys(v IIdentifierListContext) { s.dupKeys = v }

func (s *AddRollupClauseContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *AddRollupClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AddRollupClauseContext) AllIdentifierList() []IIdentifierListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierListContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierListContext); ok {
			tst[i] = t.(IIdentifierListContext)
			i++
		}
	}

	return tst
}

func (s *AddRollupClauseContext) IdentifierList(i int) IIdentifierListContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *AddRollupClauseContext) DUPLICATE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDUPLICATE, 0)
}

func (s *AddRollupClauseContext) KEY() antlr.TerminalNode {
	return s.GetToken(DorisParserParserKEY, 0)
}

func (s *AddRollupClauseContext) FromRollup() IFromRollupContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFromRollupContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFromRollupContext)
}

func (s *AddRollupClauseContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *AddRollupClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddRollupClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AddRollupClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitAddRollupClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) AddRollupClause() (localctx IAddRollupClauseContext) {
	localctx = NewAddRollupClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, DorisParserParserRULE_addRollupClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3553)

		var _x = p.Identifier()

		localctx.(*AddRollupClauseContext).rollupName = _x
	}
	{
		p.SetState(3554)

		var _x = p.IdentifierList()

		localctx.(*AddRollupClauseContext).columns = _x
	}
	p.SetState(3558)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserParserDUPLICATE {
		{
			p.SetState(3555)
			p.Match(DorisParserParserDUPLICATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3556)
			p.Match(DorisParserParserKEY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3557)

			var _x = p.IdentifierList()

			localctx.(*AddRollupClauseContext).dupKeys = _x
		}

	}
	p.SetState(3561)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserParserFROM {
		{
			p.SetState(3560)
			p.FromRollup()
		}

	}
	p.SetState(3564)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserParserPROPERTIES {
		{
			p.SetState(3563)

			var _x = p.PropertyClause()

			localctx.(*AddRollupClauseContext).properties = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterTableClauseContext is an interface to support dynamic dispatch.
type IAlterTableClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsAlterTableClauseContext differentiates from other interfaces.
	IsAlterTableClauseContext()
}

type AlterTableClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterTableClauseContext() *AlterTableClauseContext {
	var p = new(AlterTableClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_alterTableClause
	return p
}

func InitEmptyAlterTableClauseContext(p *AlterTableClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_alterTableClause
}

func (*AlterTableClauseContext) IsAlterTableClauseContext() {}

func NewAlterTableClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterTableClauseContext {
	var p = new(AlterTableClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_alterTableClause

	return p
}

func (s *AlterTableClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterTableClauseContext) CopyAll(ctx *AlterTableClauseContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *AlterTableClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ModifyDistributionClauseContext struct {
	AlterTableClauseContext
	hashKeys   IIdentifierListContext
	autoBucket antlr.Token
}

func NewModifyDistributionClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ModifyDistributionClauseContext {
	var p = new(ModifyDistributionClauseContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *ModifyDistributionClauseContext) GetAutoBucket() antlr.Token { return s.autoBucket }

func (s *ModifyDistributionClauseContext) SetAutoBucket(v antlr.Token) { s.autoBucket = v }

func (s *ModifyDistributionClauseContext) GetHashKeys() IIdentifierListContext { return s.hashKeys }

func (s *ModifyDistributionClauseContext) SetHashKeys(v IIdentifierListContext) { s.hashKeys = v }

func (s *ModifyDistributionClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModifyDistributionClauseContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(DorisParserParserMODIFY, 0)
}

func (s *ModifyDistributionClauseContext) DISTRIBUTION() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDISTRIBUTION, 0)
}

func (s *ModifyDistributionClauseContext) DISTRIBUTED() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDISTRIBUTED, 0)
}

func (s *ModifyDistributionClauseContext) BY() antlr.TerminalNode {
	return s.GetToken(DorisParserParserBY, 0)
}

func (s *ModifyDistributionClauseContext) HASH() antlr.TerminalNode {
	return s.GetToken(DorisParserParserHASH, 0)
}

func (s *ModifyDistributionClauseContext) RANDOM() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRANDOM, 0)
}

func (s *ModifyDistributionClauseContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *ModifyDistributionClauseContext) BUCKETS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserBUCKETS, 0)
}

func (s *ModifyDistributionClauseContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserINTEGER_VALUE, 0)
}

func (s *ModifyDistributionClauseContext) AUTO() antlr.TerminalNode {
	return s.GetToken(DorisParserParserAUTO, 0)
}

func (s *ModifyDistributionClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitModifyDistributionClause(s)

	default:
		return t.VisitChildren(s)
	}
}

type AddColumnClauseContext struct {
	AlterTableClauseContext
	properties IPropertyClauseContext
}

func NewAddColumnClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AddColumnClauseContext {
	var p = new(AddColumnClauseContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *AddColumnClauseContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *AddColumnClauseContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *AddColumnClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddColumnClauseContext) ADD() antlr.TerminalNode {
	return s.GetToken(DorisParserParserADD, 0)
}

func (s *AddColumnClauseContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOLUMN, 0)
}

func (s *AddColumnClauseContext) ColumnDef() IColumnDefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnDefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnDefContext)
}

func (s *AddColumnClauseContext) ColumnPosition() IColumnPositionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnPositionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnPositionContext)
}

func (s *AddColumnClauseContext) ToRollup() IToRollupContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IToRollupContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IToRollupContext)
}

func (s *AddColumnClauseContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *AddColumnClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitAddColumnClause(s)

	default:
		return t.VisitChildren(s)
	}
}

type ModifyColumnClauseContext struct {
	AlterTableClauseContext
	properties IPropertyClauseContext
}

func NewModifyColumnClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ModifyColumnClauseContext {
	var p = new(ModifyColumnClauseContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *ModifyColumnClauseContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *ModifyColumnClauseContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *ModifyColumnClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModifyColumnClauseContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(DorisParserParserMODIFY, 0)
}

func (s *ModifyColumnClauseContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOLUMN, 0)
}

func (s *ModifyColumnClauseContext) ColumnDef() IColumnDefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnDefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnDefContext)
}

func (s *ModifyColumnClauseContext) ColumnPosition() IColumnPositionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnPositionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnPositionContext)
}

func (s *ModifyColumnClauseContext) FromRollup() IFromRollupContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFromRollupContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFromRollupContext)
}

func (s *ModifyColumnClauseContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *ModifyColumnClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitModifyColumnClause(s)

	default:
		return t.VisitChildren(s)
	}
}

type AddColumnsClauseContext struct {
	AlterTableClauseContext
	properties IPropertyClauseContext
}

func NewAddColumnsClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AddColumnsClauseContext {
	var p = new(AddColumnsClauseContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *AddColumnsClauseContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *AddColumnsClauseContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *AddColumnsClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddColumnsClauseContext) ADD() antlr.TerminalNode {
	return s.GetToken(DorisParserParserADD, 0)
}

func (s *AddColumnsClauseContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOLUMN, 0)
}

func (s *AddColumnsClauseContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLEFT_PAREN, 0)
}

func (s *AddColumnsClauseContext) ColumnDefs() IColumnDefsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnDefsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnDefsContext)
}

func (s *AddColumnsClauseContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRIGHT_PAREN, 0)
}

func (s *AddColumnsClauseContext) ToRollup() IToRollupContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IToRollupContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IToRollupContext)
}

func (s *AddColumnsClauseContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *AddColumnsClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitAddColumnsClause(s)

	default:
		return t.VisitChildren(s)
	}
}

type ReplaceTableClauseContext struct {
	AlterTableClauseContext
	name       IIdentifierContext
	properties IPropertyClauseContext
}

func NewReplaceTableClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ReplaceTableClauseContext {
	var p = new(ReplaceTableClauseContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *ReplaceTableClauseContext) GetName() IIdentifierContext { return s.name }

func (s *ReplaceTableClauseContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *ReplaceTableClauseContext) SetName(v IIdentifierContext) { s.name = v }

func (s *ReplaceTableClauseContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *ReplaceTableClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReplaceTableClauseContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserREPLACE, 0)
}

func (s *ReplaceTableClauseContext) WITH() antlr.TerminalNode {
	return s.GetToken(DorisParserParserWITH, 0)
}

func (s *ReplaceTableClauseContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserTABLE, 0)
}

func (s *ReplaceTableClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ReplaceTableClauseContext) FORCE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFORCE, 0)
}

func (s *ReplaceTableClauseContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *ReplaceTableClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitReplaceTableClause(s)

	default:
		return t.VisitChildren(s)
	}
}

type DropIndexClauseContext struct {
	AlterTableClauseContext
	name IIdentifierContext
}

func NewDropIndexClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropIndexClauseContext {
	var p = new(DropIndexClauseContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *DropIndexClauseContext) GetName() IIdentifierContext { return s.name }

func (s *DropIndexClauseContext) SetName(v IIdentifierContext) { s.name = v }

func (s *DropIndexClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropIndexClauseContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDROP, 0)
}

func (s *DropIndexClauseContext) INDEX() antlr.TerminalNode {
	return s.GetToken(DorisParserParserINDEX, 0)
}

func (s *DropIndexClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DropIndexClauseContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserParserIF, 0)
}

func (s *DropIndexClauseContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserEXISTS, 0)
}

func (s *DropIndexClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitDropIndexClause(s)

	default:
		return t.VisitChildren(s)
	}
}

type DropPartitionClauseContext struct {
	AlterTableClauseContext
	partitionName IIdentifierContext
	indexName     IIdentifierContext
}

func NewDropPartitionClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropPartitionClauseContext {
	var p = new(DropPartitionClauseContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *DropPartitionClauseContext) GetPartitionName() IIdentifierContext { return s.partitionName }

func (s *DropPartitionClauseContext) GetIndexName() IIdentifierContext { return s.indexName }

func (s *DropPartitionClauseContext) SetPartitionName(v IIdentifierContext) { s.partitionName = v }

func (s *DropPartitionClauseContext) SetIndexName(v IIdentifierContext) { s.indexName = v }

func (s *DropPartitionClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropPartitionClauseContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDROP, 0)
}

func (s *DropPartitionClauseContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(DorisParserParserPARTITION, 0)
}

func (s *DropPartitionClauseContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *DropPartitionClauseContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DropPartitionClauseContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(DorisParserParserTEMPORARY, 0)
}

func (s *DropPartitionClauseContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserParserIF, 0)
}

func (s *DropPartitionClauseContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserEXISTS, 0)
}

func (s *DropPartitionClauseContext) FORCE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFORCE, 0)
}

func (s *DropPartitionClauseContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFROM, 0)
}

func (s *DropPartitionClauseContext) INDEX() antlr.TerminalNode {
	return s.GetToken(DorisParserParserINDEX, 0)
}

func (s *DropPartitionClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitDropPartitionClause(s)

	default:
		return t.VisitChildren(s)
	}
}

type ReplacePartitionClauseContext struct {
	AlterTableClauseContext
	partitions     IPartitionSpecContext
	tempPartitions IPartitionSpecContext
	properties     IPropertyClauseContext
}

func NewReplacePartitionClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ReplacePartitionClauseContext {
	var p = new(ReplacePartitionClauseContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *ReplacePartitionClauseContext) GetPartitions() IPartitionSpecContext { return s.partitions }

func (s *ReplacePartitionClauseContext) GetTempPartitions() IPartitionSpecContext {
	return s.tempPartitions
}

func (s *ReplacePartitionClauseContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *ReplacePartitionClauseContext) SetPartitions(v IPartitionSpecContext) { s.partitions = v }

func (s *ReplacePartitionClauseContext) SetTempPartitions(v IPartitionSpecContext) {
	s.tempPartitions = v
}

func (s *ReplacePartitionClauseContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *ReplacePartitionClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReplacePartitionClauseContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserREPLACE, 0)
}

func (s *ReplacePartitionClauseContext) WITH() antlr.TerminalNode {
	return s.GetToken(DorisParserParserWITH, 0)
}

func (s *ReplacePartitionClauseContext) FORCE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFORCE, 0)
}

func (s *ReplacePartitionClauseContext) AllPartitionSpec() []IPartitionSpecContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionSpecContext); ok {
			len++
		}
	}

	tst := make([]IPartitionSpecContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionSpecContext); ok {
			tst[i] = t.(IPartitionSpecContext)
			i++
		}
	}

	return tst
}

func (s *ReplacePartitionClauseContext) PartitionSpec(i int) IPartitionSpecContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionSpecContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionSpecContext)
}

func (s *ReplacePartitionClauseContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *ReplacePartitionClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitReplacePartitionClause(s)

	default:
		return t.VisitChildren(s)
	}
}

type ModifyTableCommentClauseContext struct {
	AlterTableClauseContext
	comment antlr.Token
}

func NewModifyTableCommentClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ModifyTableCommentClauseContext {
	var p = new(ModifyTableCommentClauseContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *ModifyTableCommentClauseContext) GetComment() antlr.Token { return s.comment }

func (s *ModifyTableCommentClauseContext) SetComment(v antlr.Token) { s.comment = v }

func (s *ModifyTableCommentClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModifyTableCommentClauseContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(DorisParserParserMODIFY, 0)
}

func (s *ModifyTableCommentClauseContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOMMENT, 0)
}

func (s *ModifyTableCommentClauseContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTRING_LITERAL, 0)
}

func (s *ModifyTableCommentClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitModifyTableCommentClause(s)

	default:
		return t.VisitChildren(s)
	}
}

type ReorderColumnsClauseContext struct {
	AlterTableClauseContext
	properties IPropertyClauseContext
}

func NewReorderColumnsClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ReorderColumnsClauseContext {
	var p = new(ReorderColumnsClauseContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *ReorderColumnsClauseContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *ReorderColumnsClauseContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *ReorderColumnsClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReorderColumnsClauseContext) ORDER() antlr.TerminalNode {
	return s.GetToken(DorisParserParserORDER, 0)
}

func (s *ReorderColumnsClauseContext) BY() antlr.TerminalNode {
	return s.GetToken(DorisParserParserBY, 0)
}

func (s *ReorderColumnsClauseContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *ReorderColumnsClauseContext) FromRollup() IFromRollupContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFromRollupContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFromRollupContext)
}

func (s *ReorderColumnsClauseContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *ReorderColumnsClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitReorderColumnsClause(s)

	default:
		return t.VisitChildren(s)
	}
}

type DropBranchClausesContext struct {
	AlterTableClauseContext
}

func NewDropBranchClausesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropBranchClausesContext {
	var p = new(DropBranchClausesContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *DropBranchClausesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropBranchClausesContext) DropBranchClause() IDropBranchClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropBranchClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropBranchClauseContext)
}

func (s *DropBranchClausesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitDropBranchClauses(s)

	default:
		return t.VisitChildren(s)
	}
}

type AddIndexClauseContext struct {
	AlterTableClauseContext
}

func NewAddIndexClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AddIndexClauseContext {
	var p = new(AddIndexClauseContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *AddIndexClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddIndexClauseContext) ADD() antlr.TerminalNode {
	return s.GetToken(DorisParserParserADD, 0)
}

func (s *AddIndexClauseContext) IndexDef() IIndexDefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexDefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexDefContext)
}

func (s *AddIndexClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitAddIndexClause(s)

	default:
		return t.VisitChildren(s)
	}
}

type ModifyColumnCommentClauseContext struct {
	AlterTableClauseContext
	name    IIdentifierContext
	comment antlr.Token
}

func NewModifyColumnCommentClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ModifyColumnCommentClauseContext {
	var p = new(ModifyColumnCommentClauseContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *ModifyColumnCommentClauseContext) GetComment() antlr.Token { return s.comment }

func (s *ModifyColumnCommentClauseContext) SetComment(v antlr.Token) { s.comment = v }

func (s *ModifyColumnCommentClauseContext) GetName() IIdentifierContext { return s.name }

func (s *ModifyColumnCommentClauseContext) SetName(v IIdentifierContext) { s.name = v }

func (s *ModifyColumnCommentClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModifyColumnCommentClauseContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(DorisParserParserMODIFY, 0)
}

func (s *ModifyColumnCommentClauseContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOLUMN, 0)
}

func (s *ModifyColumnCommentClauseContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOMMENT, 0)
}

func (s *ModifyColumnCommentClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ModifyColumnCommentClauseContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTRING_LITERAL, 0)
}

func (s *ModifyColumnCommentClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitModifyColumnCommentClause(s)

	default:
		return t.VisitChildren(s)
	}
}

type RenameColumnClauseContext struct {
	AlterTableClauseContext
	name    IIdentifierContext
	newName IIdentifierContext
}

func NewRenameColumnClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RenameColumnClauseContext {
	var p = new(RenameColumnClauseContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *RenameColumnClauseContext) GetName() IIdentifierContext { return s.name }

func (s *RenameColumnClauseContext) GetNewName() IIdentifierContext { return s.newName }

func (s *RenameColumnClauseContext) SetName(v IIdentifierContext) { s.name = v }

func (s *RenameColumnClauseContext) SetNewName(v IIdentifierContext) { s.newName = v }

func (s *RenameColumnClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RenameColumnClauseContext) RENAME() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRENAME, 0)
}

func (s *RenameColumnClauseContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOLUMN, 0)
}

func (s *RenameColumnClauseContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *RenameColumnClauseContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *RenameColumnClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitRenameColumnClause(s)

	default:
		return t.VisitChildren(s)
	}
}

type CreateOrReplaceTagClausesContext struct {
	AlterTableClauseContext
}

func NewCreateOrReplaceTagClausesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateOrReplaceTagClausesContext {
	var p = new(CreateOrReplaceTagClausesContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *CreateOrReplaceTagClausesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateOrReplaceTagClausesContext) CreateOrReplaceTagClause() ICreateOrReplaceTagClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateOrReplaceTagClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateOrReplaceTagClauseContext)
}

func (s *CreateOrReplaceTagClausesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitCreateOrReplaceTagClauses(s)

	default:
		return t.VisitChildren(s)
	}
}

type EnableFeatureClauseContext struct {
	AlterTableClauseContext
	name       antlr.Token
	properties IPropertyClauseContext
}

func NewEnableFeatureClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *EnableFeatureClauseContext {
	var p = new(EnableFeatureClauseContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *EnableFeatureClauseContext) GetName() antlr.Token { return s.name }

func (s *EnableFeatureClauseContext) SetName(v antlr.Token) { s.name = v }

func (s *EnableFeatureClauseContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *EnableFeatureClauseContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *EnableFeatureClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnableFeatureClauseContext) ENABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserENABLE, 0)
}

func (s *EnableFeatureClauseContext) FEATURE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFEATURE, 0)
}

func (s *EnableFeatureClauseContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTRING_LITERAL, 0)
}

func (s *EnableFeatureClauseContext) WITH() antlr.TerminalNode {
	return s.GetToken(DorisParserParserWITH, 0)
}

func (s *EnableFeatureClauseContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *EnableFeatureClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitEnableFeatureClause(s)

	default:
		return t.VisitChildren(s)
	}
}

type CreateOrReplaceBranchClausesContext struct {
	AlterTableClauseContext
}

func NewCreateOrReplaceBranchClausesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateOrReplaceBranchClausesContext {
	var p = new(CreateOrReplaceBranchClausesContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *CreateOrReplaceBranchClausesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateOrReplaceBranchClausesContext) CreateOrReplaceBranchClause() ICreateOrReplaceBranchClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateOrReplaceBranchClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateOrReplaceBranchClauseContext)
}

func (s *CreateOrReplaceBranchClausesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitCreateOrReplaceBranchClauses(s)

	default:
		return t.VisitChildren(s)
	}
}

type AddPartitionClauseContext struct {
	AlterTableClauseContext
	hashKeys   IIdentifierListContext
	autoBucket antlr.Token
	properties IPropertyClauseContext
}

func NewAddPartitionClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AddPartitionClauseContext {
	var p = new(AddPartitionClauseContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *AddPartitionClauseContext) GetAutoBucket() antlr.Token { return s.autoBucket }

func (s *AddPartitionClauseContext) SetAutoBucket(v antlr.Token) { s.autoBucket = v }

func (s *AddPartitionClauseContext) GetHashKeys() IIdentifierListContext { return s.hashKeys }

func (s *AddPartitionClauseContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *AddPartitionClauseContext) SetHashKeys(v IIdentifierListContext) { s.hashKeys = v }

func (s *AddPartitionClauseContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *AddPartitionClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddPartitionClauseContext) ADD() antlr.TerminalNode {
	return s.GetToken(DorisParserParserADD, 0)
}

func (s *AddPartitionClauseContext) PartitionDef() IPartitionDefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionDefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionDefContext)
}

func (s *AddPartitionClauseContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(DorisParserParserTEMPORARY, 0)
}

func (s *AddPartitionClauseContext) DISTRIBUTED() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDISTRIBUTED, 0)
}

func (s *AddPartitionClauseContext) BY() antlr.TerminalNode {
	return s.GetToken(DorisParserParserBY, 0)
}

func (s *AddPartitionClauseContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *AddPartitionClauseContext) HASH() antlr.TerminalNode {
	return s.GetToken(DorisParserParserHASH, 0)
}

func (s *AddPartitionClauseContext) RANDOM() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRANDOM, 0)
}

func (s *AddPartitionClauseContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *AddPartitionClauseContext) BUCKETS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserBUCKETS, 0)
}

func (s *AddPartitionClauseContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserINTEGER_VALUE, 0)
}

func (s *AddPartitionClauseContext) AUTO() antlr.TerminalNode {
	return s.GetToken(DorisParserParserAUTO, 0)
}

func (s *AddPartitionClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitAddPartitionClause(s)

	default:
		return t.VisitChildren(s)
	}
}

type RenameRollupClauseContext struct {
	AlterTableClauseContext
	name    IIdentifierContext
	newName IIdentifierContext
}

func NewRenameRollupClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RenameRollupClauseContext {
	var p = new(RenameRollupClauseContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *RenameRollupClauseContext) GetName() IIdentifierContext { return s.name }

func (s *RenameRollupClauseContext) GetNewName() IIdentifierContext { return s.newName }

func (s *RenameRollupClauseContext) SetName(v IIdentifierContext) { s.name = v }

func (s *RenameRollupClauseContext) SetNewName(v IIdentifierContext) { s.newName = v }

func (s *RenameRollupClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RenameRollupClauseContext) RENAME() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRENAME, 0)
}

func (s *RenameRollupClauseContext) ROLLUP() antlr.TerminalNode {
	return s.GetToken(DorisParserParserROLLUP, 0)
}

func (s *RenameRollupClauseContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *RenameRollupClauseContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *RenameRollupClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitRenameRollupClause(s)

	default:
		return t.VisitChildren(s)
	}
}

type RenamePartitionClauseContext struct {
	AlterTableClauseContext
	name    IIdentifierContext
	newName IIdentifierContext
}

func NewRenamePartitionClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RenamePartitionClauseContext {
	var p = new(RenamePartitionClauseContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *RenamePartitionClauseContext) GetName() IIdentifierContext { return s.name }

func (s *RenamePartitionClauseContext) GetNewName() IIdentifierContext { return s.newName }

func (s *RenamePartitionClauseContext) SetName(v IIdentifierContext) { s.name = v }

func (s *RenamePartitionClauseContext) SetNewName(v IIdentifierContext) { s.newName = v }

func (s *RenamePartitionClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RenamePartitionClauseContext) RENAME() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRENAME, 0)
}

func (s *RenamePartitionClauseContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(DorisParserParserPARTITION, 0)
}

func (s *RenamePartitionClauseContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *RenamePartitionClauseContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *RenamePartitionClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitRenamePartitionClause(s)

	default:
		return t.VisitChildren(s)
	}
}

type DropColumnClauseContext struct {
	AlterTableClauseContext
	name       IIdentifierContext
	properties IPropertyClauseContext
}

func NewDropColumnClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropColumnClauseContext {
	var p = new(DropColumnClauseContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *DropColumnClauseContext) GetName() IIdentifierContext { return s.name }

func (s *DropColumnClauseContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *DropColumnClauseContext) SetName(v IIdentifierContext) { s.name = v }

func (s *DropColumnClauseContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *DropColumnClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropColumnClauseContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDROP, 0)
}

func (s *DropColumnClauseContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOLUMN, 0)
}

func (s *DropColumnClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DropColumnClauseContext) FromRollup() IFromRollupContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFromRollupContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFromRollupContext)
}

func (s *DropColumnClauseContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *DropColumnClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitDropColumnClause(s)

	default:
		return t.VisitChildren(s)
	}
}

type RenameClauseContext struct {
	AlterTableClauseContext
	newName IIdentifierContext
}

func NewRenameClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RenameClauseContext {
	var p = new(RenameClauseContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *RenameClauseContext) GetNewName() IIdentifierContext { return s.newName }

func (s *RenameClauseContext) SetNewName(v IIdentifierContext) { s.newName = v }

func (s *RenameClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RenameClauseContext) RENAME() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRENAME, 0)
}

func (s *RenameClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *RenameClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitRenameClause(s)

	default:
		return t.VisitChildren(s)
	}
}

type ModifyPartitionClauseContext struct {
	AlterTableClauseContext
	partitionName       IIdentifierContext
	partitionNames      IIdentifierListContext
	partitionProperties IPropertyItemListContext
}

func NewModifyPartitionClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ModifyPartitionClauseContext {
	var p = new(ModifyPartitionClauseContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *ModifyPartitionClauseContext) GetPartitionName() IIdentifierContext { return s.partitionName }

func (s *ModifyPartitionClauseContext) GetPartitionNames() IIdentifierListContext {
	return s.partitionNames
}

func (s *ModifyPartitionClauseContext) GetPartitionProperties() IPropertyItemListContext {
	return s.partitionProperties
}

func (s *ModifyPartitionClauseContext) SetPartitionName(v IIdentifierContext) { s.partitionName = v }

func (s *ModifyPartitionClauseContext) SetPartitionNames(v IIdentifierListContext) {
	s.partitionNames = v
}

func (s *ModifyPartitionClauseContext) SetPartitionProperties(v IPropertyItemListContext) {
	s.partitionProperties = v
}

func (s *ModifyPartitionClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModifyPartitionClauseContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(DorisParserParserMODIFY, 0)
}

func (s *ModifyPartitionClauseContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(DorisParserParserPARTITION, 0)
}

func (s *ModifyPartitionClauseContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSET, 0)
}

func (s *ModifyPartitionClauseContext) AllLEFT_PAREN() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserLEFT_PAREN)
}

func (s *ModifyPartitionClauseContext) LEFT_PAREN(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserLEFT_PAREN, i)
}

func (s *ModifyPartitionClauseContext) AllRIGHT_PAREN() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserRIGHT_PAREN)
}

func (s *ModifyPartitionClauseContext) RIGHT_PAREN(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserRIGHT_PAREN, i)
}

func (s *ModifyPartitionClauseContext) PropertyItemList() IPropertyItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyItemListContext)
}

func (s *ModifyPartitionClauseContext) ASTERISK() antlr.TerminalNode {
	return s.GetToken(DorisParserParserASTERISK, 0)
}

func (s *ModifyPartitionClauseContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(DorisParserParserTEMPORARY, 0)
}

func (s *ModifyPartitionClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ModifyPartitionClauseContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *ModifyPartitionClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitModifyPartitionClause(s)

	default:
		return t.VisitChildren(s)
	}
}

type ModifyEngineClauseContext struct {
	AlterTableClauseContext
	name       IIdentifierContext
	properties IPropertyClauseContext
}

func NewModifyEngineClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ModifyEngineClauseContext {
	var p = new(ModifyEngineClauseContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *ModifyEngineClauseContext) GetName() IIdentifierContext { return s.name }

func (s *ModifyEngineClauseContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *ModifyEngineClauseContext) SetName(v IIdentifierContext) { s.name = v }

func (s *ModifyEngineClauseContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *ModifyEngineClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModifyEngineClauseContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(DorisParserParserMODIFY, 0)
}

func (s *ModifyEngineClauseContext) ENGINE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserENGINE, 0)
}

func (s *ModifyEngineClauseContext) TO() antlr.TerminalNode {
	return s.GetToken(DorisParserParserTO, 0)
}

func (s *ModifyEngineClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ModifyEngineClauseContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *ModifyEngineClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitModifyEngineClause(s)

	default:
		return t.VisitChildren(s)
	}
}

type DropTagClausesContext struct {
	AlterTableClauseContext
}

func NewDropTagClausesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropTagClausesContext {
	var p = new(DropTagClausesContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *DropTagClausesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropTagClausesContext) DropTagClause() IDropTagClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropTagClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropTagClauseContext)
}

func (s *DropTagClausesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitDropTagClauses(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterMultiPartitionClauseContext struct {
	AlterTableClauseContext
	from       IPartitionValueListContext
	to         IPartitionValueListContext
	unit       IIdentifierContext
	properties IPropertyClauseContext
}

func NewAlterMultiPartitionClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterMultiPartitionClauseContext {
	var p = new(AlterMultiPartitionClauseContext)

	InitEmptyAlterTableClauseContext(&p.AlterTableClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AlterTableClauseContext))

	return p
}

func (s *AlterMultiPartitionClauseContext) GetFrom() IPartitionValueListContext { return s.from }

func (s *AlterMultiPartitionClauseContext) GetTo() IPartitionValueListContext { return s.to }

func (s *AlterMultiPartitionClauseContext) GetUnit() IIdentifierContext { return s.unit }

func (s *AlterMultiPartitionClauseContext) GetProperties() IPropertyClauseContext {
	return s.properties
}

func (s *AlterMultiPartitionClauseContext) SetFrom(v IPartitionValueListContext) { s.from = v }

func (s *AlterMultiPartitionClauseContext) SetTo(v IPartitionValueListContext) { s.to = v }

func (s *AlterMultiPartitionClauseContext) SetUnit(v IIdentifierContext) { s.unit = v }

func (s *AlterMultiPartitionClauseContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *AlterMultiPartitionClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterMultiPartitionClauseContext) ADD() antlr.TerminalNode {
	return s.GetToken(DorisParserParserADD, 0)
}

func (s *AlterMultiPartitionClauseContext) PARTITIONS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserPARTITIONS, 0)
}

func (s *AlterMultiPartitionClauseContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFROM, 0)
}

func (s *AlterMultiPartitionClauseContext) TO() antlr.TerminalNode {
	return s.GetToken(DorisParserParserTO, 0)
}

func (s *AlterMultiPartitionClauseContext) INTERVAL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserINTERVAL, 0)
}

func (s *AlterMultiPartitionClauseContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserINTEGER_VALUE, 0)
}

func (s *AlterMultiPartitionClauseContext) AllPartitionValueList() []IPartitionValueListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionValueListContext); ok {
			len++
		}
	}

	tst := make([]IPartitionValueListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionValueListContext); ok {
			tst[i] = t.(IPartitionValueListContext)
			i++
		}
	}

	return tst
}

func (s *AlterMultiPartitionClauseContext) PartitionValueList(i int) IPartitionValueListContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionValueListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionValueListContext)
}

func (s *AlterMultiPartitionClauseContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(DorisParserParserTEMPORARY, 0)
}

func (s *AlterMultiPartitionClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AlterMultiPartitionClauseContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *AlterMultiPartitionClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitAlterMultiPartitionClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) AlterTableClause() (localctx IAlterTableClauseContext) {
	localctx = NewAlterTableClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, DorisParserParserRULE_alterTableClause)
	var _la int

	p.SetState(3790)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 520, p.GetParserRuleContext()) {
	case 1:
		localctx = NewAddColumnClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3566)
			p.Match(DorisParserParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3567)
			p.Match(DorisParserParserCOLUMN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3568)
			p.ColumnDef()
		}
		p.SetState(3570)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserAFTER || _la == DorisParserParserFIRST {
			{
				p.SetState(3569)
				p.ColumnPosition()
			}

		}
		p.SetState(3573)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserIN || _la == DorisParserParserTO {
			{
				p.SetState(3572)
				p.ToRollup()
			}

		}
		p.SetState(3576)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserPROPERTIES {
			{
				p.SetState(3575)

				var _x = p.PropertyClause()

				localctx.(*AddColumnClauseContext).properties = _x
			}

		}

	case 2:
		localctx = NewAddColumnsClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3578)
			p.Match(DorisParserParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3579)
			p.Match(DorisParserParserCOLUMN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3580)
			p.Match(DorisParserParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3581)
			p.ColumnDefs()
		}
		{
			p.SetState(3582)
			p.Match(DorisParserParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3584)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserIN || _la == DorisParserParserTO {
			{
				p.SetState(3583)
				p.ToRollup()
			}

		}
		p.SetState(3587)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserPROPERTIES {
			{
				p.SetState(3586)

				var _x = p.PropertyClause()

				localctx.(*AddColumnsClauseContext).properties = _x
			}

		}

	case 3:
		localctx = NewDropColumnClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3589)
			p.Match(DorisParserParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3590)
			p.Match(DorisParserParserCOLUMN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3591)

			var _x = p.Identifier()

			localctx.(*DropColumnClauseContext).name = _x
		}
		p.SetState(3593)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserFROM {
			{
				p.SetState(3592)
				p.FromRollup()
			}

		}
		p.SetState(3596)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserPROPERTIES {
			{
				p.SetState(3595)

				var _x = p.PropertyClause()

				localctx.(*DropColumnClauseContext).properties = _x
			}

		}

	case 4:
		localctx = NewModifyColumnClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3598)
			p.Match(DorisParserParserMODIFY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3599)
			p.Match(DorisParserParserCOLUMN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3600)
			p.ColumnDef()
		}
		p.SetState(3602)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserAFTER || _la == DorisParserParserFIRST {
			{
				p.SetState(3601)
				p.ColumnPosition()
			}

		}
		p.SetState(3605)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserFROM {
			{
				p.SetState(3604)
				p.FromRollup()
			}

		}
		p.SetState(3608)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserPROPERTIES {
			{
				p.SetState(3607)

				var _x = p.PropertyClause()

				localctx.(*ModifyColumnClauseContext).properties = _x
			}

		}

	case 5:
		localctx = NewReorderColumnsClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(3610)
			p.Match(DorisParserParserORDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3611)
			p.Match(DorisParserParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3612)
			p.IdentifierList()
		}
		p.SetState(3614)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserFROM {
			{
				p.SetState(3613)
				p.FromRollup()
			}

		}
		p.SetState(3617)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserPROPERTIES {
			{
				p.SetState(3616)

				var _x = p.PropertyClause()

				localctx.(*ReorderColumnsClauseContext).properties = _x
			}

		}

	case 6:
		localctx = NewAddPartitionClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(3619)
			p.Match(DorisParserParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3621)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserTEMPORARY {
			{
				p.SetState(3620)
				p.Match(DorisParserParserTEMPORARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3623)
			p.PartitionDef()
		}
		p.SetState(3638)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserDISTRIBUTED {
			{
				p.SetState(3624)
				p.Match(DorisParserParserDISTRIBUTED)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3625)
				p.Match(DorisParserParserBY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(3629)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case DorisParserParserHASH:
				{
					p.SetState(3626)
					p.Match(DorisParserParserHASH)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(3627)

					var _x = p.IdentifierList()

					localctx.(*AddPartitionClauseContext).hashKeys = _x
				}

			case DorisParserParserRANDOM:
				{
					p.SetState(3628)
					p.Match(DorisParserParserRANDOM)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}
			p.SetState(3636)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserParserBUCKETS {
				{
					p.SetState(3631)
					p.Match(DorisParserParserBUCKETS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(3634)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}

				switch p.GetTokenStream().LA(1) {
				case DorisParserParserINTEGER_VALUE:
					{
						p.SetState(3632)
						p.Match(DorisParserParserINTEGER_VALUE)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				case DorisParserParserAUTO:
					{
						p.SetState(3633)

						var _m = p.Match(DorisParserParserAUTO)

						localctx.(*AddPartitionClauseContext).autoBucket = _m
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				default:
					p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
					goto errorExit
				}

			}

		}
		p.SetState(3641)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserPROPERTIES {
			{
				p.SetState(3640)

				var _x = p.PropertyClause()

				localctx.(*AddPartitionClauseContext).properties = _x
			}

		}

	case 7:
		localctx = NewDropPartitionClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(3643)
			p.Match(DorisParserParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3645)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserTEMPORARY {
			{
				p.SetState(3644)
				p.Match(DorisParserParserTEMPORARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3647)
			p.Match(DorisParserParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3650)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserIF {
			{
				p.SetState(3648)
				p.Match(DorisParserParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3649)
				p.Match(DorisParserParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3652)

			var _x = p.Identifier()

			localctx.(*DropPartitionClauseContext).partitionName = _x
		}
		p.SetState(3654)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserFORCE {
			{
				p.SetState(3653)
				p.Match(DorisParserParserFORCE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(3659)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserFROM {
			{
				p.SetState(3656)
				p.Match(DorisParserParserFROM)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3657)
				p.Match(DorisParserParserINDEX)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3658)

				var _x = p.Identifier()

				localctx.(*DropPartitionClauseContext).indexName = _x
			}

		}

	case 8:
		localctx = NewModifyPartitionClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(3661)
			p.Match(DorisParserParserMODIFY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3663)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserTEMPORARY {
			{
				p.SetState(3662)
				p.Match(DorisParserParserTEMPORARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3665)
			p.Match(DorisParserParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3671)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 503, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(3666)

				var _x = p.Identifier()

				localctx.(*ModifyPartitionClauseContext).partitionName = _x
			}

		case 2:
			{
				p.SetState(3667)

				var _x = p.IdentifierList()

				localctx.(*ModifyPartitionClauseContext).partitionNames = _x
			}

		case 3:
			{
				p.SetState(3668)
				p.Match(DorisParserParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3669)
				p.Match(DorisParserParserASTERISK)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3670)
				p.Match(DorisParserParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		{
			p.SetState(3673)
			p.Match(DorisParserParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3674)
			p.Match(DorisParserParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3675)

			var _x = p.PropertyItemList()

			localctx.(*ModifyPartitionClauseContext).partitionProperties = _x
		}
		{
			p.SetState(3676)
			p.Match(DorisParserParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 9:
		localctx = NewReplacePartitionClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(3678)
			p.Match(DorisParserParserREPLACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3680)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserPARTITION || _la == DorisParserParserPARTITIONS || _la == DorisParserParserTEMPORARY {
			{
				p.SetState(3679)

				var _x = p.PartitionSpec()

				localctx.(*ReplacePartitionClauseContext).partitions = _x
			}

		}
		{
			p.SetState(3682)
			p.Match(DorisParserParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3684)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserPARTITION || _la == DorisParserParserPARTITIONS || _la == DorisParserParserTEMPORARY {
			{
				p.SetState(3683)

				var _x = p.PartitionSpec()

				localctx.(*ReplacePartitionClauseContext).tempPartitions = _x
			}

		}
		p.SetState(3687)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserFORCE {
			{
				p.SetState(3686)
				p.Match(DorisParserParserFORCE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(3690)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserPROPERTIES {
			{
				p.SetState(3689)

				var _x = p.PropertyClause()

				localctx.(*ReplacePartitionClauseContext).properties = _x
			}

		}

	case 10:
		localctx = NewReplaceTableClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(3692)
			p.Match(DorisParserParserREPLACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3693)
			p.Match(DorisParserParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3694)
			p.Match(DorisParserParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3695)

			var _x = p.Identifier()

			localctx.(*ReplaceTableClauseContext).name = _x
		}
		p.SetState(3697)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserPROPERTIES {
			{
				p.SetState(3696)

				var _x = p.PropertyClause()

				localctx.(*ReplaceTableClauseContext).properties = _x
			}

		}
		p.SetState(3700)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserFORCE {
			{
				p.SetState(3699)
				p.Match(DorisParserParserFORCE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 11:
		localctx = NewRenameClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(3702)
			p.Match(DorisParserParserRENAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3703)

			var _x = p.Identifier()

			localctx.(*RenameClauseContext).newName = _x
		}

	case 12:
		localctx = NewRenameRollupClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(3704)
			p.Match(DorisParserParserRENAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3705)
			p.Match(DorisParserParserROLLUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3706)

			var _x = p.Identifier()

			localctx.(*RenameRollupClauseContext).name = _x
		}
		{
			p.SetState(3707)

			var _x = p.Identifier()

			localctx.(*RenameRollupClauseContext).newName = _x
		}

	case 13:
		localctx = NewRenamePartitionClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(3709)
			p.Match(DorisParserParserRENAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3710)
			p.Match(DorisParserParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3711)

			var _x = p.Identifier()

			localctx.(*RenamePartitionClauseContext).name = _x
		}
		{
			p.SetState(3712)

			var _x = p.Identifier()

			localctx.(*RenamePartitionClauseContext).newName = _x
		}

	case 14:
		localctx = NewRenameColumnClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(3714)
			p.Match(DorisParserParserRENAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3715)
			p.Match(DorisParserParserCOLUMN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3716)

			var _x = p.Identifier()

			localctx.(*RenameColumnClauseContext).name = _x
		}
		{
			p.SetState(3717)

			var _x = p.Identifier()

			localctx.(*RenameColumnClauseContext).newName = _x
		}

	case 15:
		localctx = NewAddIndexClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(3719)
			p.Match(DorisParserParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3720)
			p.IndexDef()
		}

	case 16:
		localctx = NewDropIndexClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(3721)
			p.Match(DorisParserParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3722)
			p.Match(DorisParserParserINDEX)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3725)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserIF {
			{
				p.SetState(3723)
				p.Match(DorisParserParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3724)
				p.Match(DorisParserParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3727)

			var _x = p.Identifier()

			localctx.(*DropIndexClauseContext).name = _x
		}

	case 17:
		localctx = NewEnableFeatureClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(3728)
			p.Match(DorisParserParserENABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3729)
			p.Match(DorisParserParserFEATURE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3730)

			var _m = p.Match(DorisParserParserSTRING_LITERAL)

			localctx.(*EnableFeatureClauseContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3733)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserWITH {
			{
				p.SetState(3731)
				p.Match(DorisParserParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3732)

				var _x = p.PropertyClause()

				localctx.(*EnableFeatureClauseContext).properties = _x
			}

		}

	case 18:
		localctx = NewModifyDistributionClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(3735)
			p.Match(DorisParserParserMODIFY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3736)
			p.Match(DorisParserParserDISTRIBUTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3751)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserDISTRIBUTED {
			{
				p.SetState(3737)
				p.Match(DorisParserParserDISTRIBUTED)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3738)
				p.Match(DorisParserParserBY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(3742)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case DorisParserParserHASH:
				{
					p.SetState(3739)
					p.Match(DorisParserParserHASH)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(3740)

					var _x = p.IdentifierList()

					localctx.(*ModifyDistributionClauseContext).hashKeys = _x
				}

			case DorisParserParserRANDOM:
				{
					p.SetState(3741)
					p.Match(DorisParserParserRANDOM)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}
			p.SetState(3749)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserParserBUCKETS {
				{
					p.SetState(3744)
					p.Match(DorisParserParserBUCKETS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(3747)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}

				switch p.GetTokenStream().LA(1) {
				case DorisParserParserINTEGER_VALUE:
					{
						p.SetState(3745)
						p.Match(DorisParserParserINTEGER_VALUE)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				case DorisParserParserAUTO:
					{
						p.SetState(3746)

						var _m = p.Match(DorisParserParserAUTO)

						localctx.(*ModifyDistributionClauseContext).autoBucket = _m
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				default:
					p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
					goto errorExit
				}

			}

		}

	case 19:
		localctx = NewModifyTableCommentClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(3753)
			p.Match(DorisParserParserMODIFY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3754)
			p.Match(DorisParserParserCOMMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3755)

			var _m = p.Match(DorisParserParserSTRING_LITERAL)

			localctx.(*ModifyTableCommentClauseContext).comment = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 20:
		localctx = NewModifyColumnCommentClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(3756)
			p.Match(DorisParserParserMODIFY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3757)
			p.Match(DorisParserParserCOLUMN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3758)

			var _x = p.Identifier()

			localctx.(*ModifyColumnCommentClauseContext).name = _x
		}
		{
			p.SetState(3759)
			p.Match(DorisParserParserCOMMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3760)

			var _m = p.Match(DorisParserParserSTRING_LITERAL)

			localctx.(*ModifyColumnCommentClauseContext).comment = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 21:
		localctx = NewModifyEngineClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(3762)
			p.Match(DorisParserParserMODIFY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3763)
			p.Match(DorisParserParserENGINE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3764)
			p.Match(DorisParserParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3765)

			var _x = p.Identifier()

			localctx.(*ModifyEngineClauseContext).name = _x
		}
		p.SetState(3767)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserPROPERTIES {
			{
				p.SetState(3766)

				var _x = p.PropertyClause()

				localctx.(*ModifyEngineClauseContext).properties = _x
			}

		}

	case 22:
		localctx = NewAlterMultiPartitionClauseContext(p, localctx)
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(3769)
			p.Match(DorisParserParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3771)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserTEMPORARY {
			{
				p.SetState(3770)
				p.Match(DorisParserParserTEMPORARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3773)
			p.Match(DorisParserParserPARTITIONS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3774)
			p.Match(DorisParserParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3775)

			var _x = p.PartitionValueList()

			localctx.(*AlterMultiPartitionClauseContext).from = _x
		}
		{
			p.SetState(3776)
			p.Match(DorisParserParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3777)

			var _x = p.PartitionValueList()

			localctx.(*AlterMultiPartitionClauseContext).to = _x
		}
		{
			p.SetState(3778)
			p.Match(DorisParserParserINTERVAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3779)
			p.Match(DorisParserParserINTEGER_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3781)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 518, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3780)

				var _x = p.Identifier()

				localctx.(*AlterMultiPartitionClauseContext).unit = _x
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(3784)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserPROPERTIES {
			{
				p.SetState(3783)

				var _x = p.PropertyClause()

				localctx.(*AlterMultiPartitionClauseContext).properties = _x
			}

		}

	case 23:
		localctx = NewCreateOrReplaceTagClausesContext(p, localctx)
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(3786)
			p.CreateOrReplaceTagClause()
		}

	case 24:
		localctx = NewCreateOrReplaceBranchClausesContext(p, localctx)
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(3787)
			p.CreateOrReplaceBranchClause()
		}

	case 25:
		localctx = NewDropBranchClausesContext(p, localctx)
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(3788)
			p.DropBranchClause()
		}

	case 26:
		localctx = NewDropTagClausesContext(p, localctx)
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(3789)
			p.DropTagClause()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateOrReplaceTagClauseContext is an interface to support dynamic dispatch.
type ICreateOrReplaceTagClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name rule contexts.
	GetName() IIdentifierContext

	// GetOps returns the ops rule contexts.
	GetOps() ITagOptionsContext

	// SetName sets the name rule contexts.
	SetName(IIdentifierContext)

	// SetOps sets the ops rule contexts.
	SetOps(ITagOptionsContext)

	// Getter signatures
	CREATE() antlr.TerminalNode
	TAG() antlr.TerminalNode
	Identifier() IIdentifierContext
	TagOptions() ITagOptionsContext
	IF() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	REPLACE() antlr.TerminalNode
	OR() antlr.TerminalNode

	// IsCreateOrReplaceTagClauseContext differentiates from other interfaces.
	IsCreateOrReplaceTagClauseContext()
}

type CreateOrReplaceTagClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	name   IIdentifierContext
	ops    ITagOptionsContext
}

func NewEmptyCreateOrReplaceTagClauseContext() *CreateOrReplaceTagClauseContext {
	var p = new(CreateOrReplaceTagClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_createOrReplaceTagClause
	return p
}

func InitEmptyCreateOrReplaceTagClauseContext(p *CreateOrReplaceTagClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_createOrReplaceTagClause
}

func (*CreateOrReplaceTagClauseContext) IsCreateOrReplaceTagClauseContext() {}

func NewCreateOrReplaceTagClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateOrReplaceTagClauseContext {
	var p = new(CreateOrReplaceTagClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_createOrReplaceTagClause

	return p
}

func (s *CreateOrReplaceTagClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateOrReplaceTagClauseContext) GetName() IIdentifierContext { return s.name }

func (s *CreateOrReplaceTagClauseContext) GetOps() ITagOptionsContext { return s.ops }

func (s *CreateOrReplaceTagClauseContext) SetName(v IIdentifierContext) { s.name = v }

func (s *CreateOrReplaceTagClauseContext) SetOps(v ITagOptionsContext) { s.ops = v }

func (s *CreateOrReplaceTagClauseContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCREATE, 0)
}

func (s *CreateOrReplaceTagClauseContext) TAG() antlr.TerminalNode {
	return s.GetToken(DorisParserParserTAG, 0)
}

func (s *CreateOrReplaceTagClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateOrReplaceTagClauseContext) TagOptions() ITagOptionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITagOptionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITagOptionsContext)
}

func (s *CreateOrReplaceTagClauseContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserParserIF, 0)
}

func (s *CreateOrReplaceTagClauseContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserNOT, 0)
}

func (s *CreateOrReplaceTagClauseContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserEXISTS, 0)
}

func (s *CreateOrReplaceTagClauseContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserREPLACE, 0)
}

func (s *CreateOrReplaceTagClauseContext) OR() antlr.TerminalNode {
	return s.GetToken(DorisParserParserOR, 0)
}

func (s *CreateOrReplaceTagClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateOrReplaceTagClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateOrReplaceTagClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitCreateOrReplaceTagClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) CreateOrReplaceTagClause() (localctx ICreateOrReplaceTagClauseContext) {
	localctx = NewCreateOrReplaceTagClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, DorisParserParserRULE_createOrReplaceTagClause)
	var _la int

	p.SetState(3811)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 523, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3792)
			p.Match(DorisParserParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3793)
			p.Match(DorisParserParserTAG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3797)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserIF {
			{
				p.SetState(3794)
				p.Match(DorisParserParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3795)
				p.Match(DorisParserParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3796)
				p.Match(DorisParserParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3799)

			var _x = p.Identifier()

			localctx.(*CreateOrReplaceTagClauseContext).name = _x
		}
		{
			p.SetState(3800)

			var _x = p.TagOptions()

			localctx.(*CreateOrReplaceTagClauseContext).ops = _x
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(3804)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserCREATE {
			{
				p.SetState(3802)
				p.Match(DorisParserParserCREATE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3803)
				p.Match(DorisParserParserOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3806)
			p.Match(DorisParserParserREPLACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3807)
			p.Match(DorisParserParserTAG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3808)

			var _x = p.Identifier()

			localctx.(*CreateOrReplaceTagClauseContext).name = _x
		}
		{
			p.SetState(3809)

			var _x = p.TagOptions()

			localctx.(*CreateOrReplaceTagClauseContext).ops = _x
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateOrReplaceBranchClauseContext is an interface to support dynamic dispatch.
type ICreateOrReplaceBranchClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name rule contexts.
	GetName() IIdentifierContext

	// GetOps returns the ops rule contexts.
	GetOps() IBranchOptionsContext

	// SetName sets the name rule contexts.
	SetName(IIdentifierContext)

	// SetOps sets the ops rule contexts.
	SetOps(IBranchOptionsContext)

	// Getter signatures
	CREATE() antlr.TerminalNode
	BRANCH() antlr.TerminalNode
	Identifier() IIdentifierContext
	BranchOptions() IBranchOptionsContext
	IF() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	REPLACE() antlr.TerminalNode
	OR() antlr.TerminalNode

	// IsCreateOrReplaceBranchClauseContext differentiates from other interfaces.
	IsCreateOrReplaceBranchClauseContext()
}

type CreateOrReplaceBranchClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	name   IIdentifierContext
	ops    IBranchOptionsContext
}

func NewEmptyCreateOrReplaceBranchClauseContext() *CreateOrReplaceBranchClauseContext {
	var p = new(CreateOrReplaceBranchClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_createOrReplaceBranchClause
	return p
}

func InitEmptyCreateOrReplaceBranchClauseContext(p *CreateOrReplaceBranchClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_createOrReplaceBranchClause
}

func (*CreateOrReplaceBranchClauseContext) IsCreateOrReplaceBranchClauseContext() {}

func NewCreateOrReplaceBranchClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateOrReplaceBranchClauseContext {
	var p = new(CreateOrReplaceBranchClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_createOrReplaceBranchClause

	return p
}

func (s *CreateOrReplaceBranchClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateOrReplaceBranchClauseContext) GetName() IIdentifierContext { return s.name }

func (s *CreateOrReplaceBranchClauseContext) GetOps() IBranchOptionsContext { return s.ops }

func (s *CreateOrReplaceBranchClauseContext) SetName(v IIdentifierContext) { s.name = v }

func (s *CreateOrReplaceBranchClauseContext) SetOps(v IBranchOptionsContext) { s.ops = v }

func (s *CreateOrReplaceBranchClauseContext) CREATE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCREATE, 0)
}

func (s *CreateOrReplaceBranchClauseContext) BRANCH() antlr.TerminalNode {
	return s.GetToken(DorisParserParserBRANCH, 0)
}

func (s *CreateOrReplaceBranchClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateOrReplaceBranchClauseContext) BranchOptions() IBranchOptionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBranchOptionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBranchOptionsContext)
}

func (s *CreateOrReplaceBranchClauseContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserParserIF, 0)
}

func (s *CreateOrReplaceBranchClauseContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserNOT, 0)
}

func (s *CreateOrReplaceBranchClauseContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserEXISTS, 0)
}

func (s *CreateOrReplaceBranchClauseContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserREPLACE, 0)
}

func (s *CreateOrReplaceBranchClauseContext) OR() antlr.TerminalNode {
	return s.GetToken(DorisParserParserOR, 0)
}

func (s *CreateOrReplaceBranchClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateOrReplaceBranchClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateOrReplaceBranchClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitCreateOrReplaceBranchClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) CreateOrReplaceBranchClause() (localctx ICreateOrReplaceBranchClauseContext) {
	localctx = NewCreateOrReplaceBranchClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, DorisParserParserRULE_createOrReplaceBranchClause)
	var _la int

	p.SetState(3832)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 526, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3813)
			p.Match(DorisParserParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3814)
			p.Match(DorisParserParserBRANCH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3818)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserIF {
			{
				p.SetState(3815)
				p.Match(DorisParserParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3816)
				p.Match(DorisParserParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3817)
				p.Match(DorisParserParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3820)

			var _x = p.Identifier()

			localctx.(*CreateOrReplaceBranchClauseContext).name = _x
		}
		{
			p.SetState(3821)

			var _x = p.BranchOptions()

			localctx.(*CreateOrReplaceBranchClauseContext).ops = _x
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(3825)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserCREATE {
			{
				p.SetState(3823)
				p.Match(DorisParserParserCREATE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3824)
				p.Match(DorisParserParserOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3827)
			p.Match(DorisParserParserREPLACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3828)
			p.Match(DorisParserParserBRANCH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3829)

			var _x = p.Identifier()

			localctx.(*CreateOrReplaceBranchClauseContext).name = _x
		}
		{
			p.SetState(3830)

			var _x = p.BranchOptions()

			localctx.(*CreateOrReplaceBranchClauseContext).ops = _x
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITagOptionsContext is an interface to support dynamic dispatch.
type ITagOptionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetVersion returns the version token.
	GetVersion() antlr.Token

	// SetVersion sets the version token.
	SetVersion(antlr.Token)

	// Getter signatures
	AS() antlr.TerminalNode
	OF() antlr.TerminalNode
	VERSION() antlr.TerminalNode
	RetainTime() IRetainTimeContext
	INTEGER_VALUE() antlr.TerminalNode

	// IsTagOptionsContext differentiates from other interfaces.
	IsTagOptionsContext()
}

type TagOptionsContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	version antlr.Token
}

func NewEmptyTagOptionsContext() *TagOptionsContext {
	var p = new(TagOptionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_tagOptions
	return p
}

func InitEmptyTagOptionsContext(p *TagOptionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_tagOptions
}

func (*TagOptionsContext) IsTagOptionsContext() {}

func NewTagOptionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TagOptionsContext {
	var p = new(TagOptionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_tagOptions

	return p
}

func (s *TagOptionsContext) GetParser() antlr.Parser { return s.parser }

func (s *TagOptionsContext) GetVersion() antlr.Token { return s.version }

func (s *TagOptionsContext) SetVersion(v antlr.Token) { s.version = v }

func (s *TagOptionsContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserAS, 0)
}

func (s *TagOptionsContext) OF() antlr.TerminalNode {
	return s.GetToken(DorisParserParserOF, 0)
}

func (s *TagOptionsContext) VERSION() antlr.TerminalNode {
	return s.GetToken(DorisParserParserVERSION, 0)
}

func (s *TagOptionsContext) RetainTime() IRetainTimeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRetainTimeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRetainTimeContext)
}

func (s *TagOptionsContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserINTEGER_VALUE, 0)
}

func (s *TagOptionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TagOptionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TagOptionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitTagOptions(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) TagOptions() (localctx ITagOptionsContext) {
	localctx = NewTagOptionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, DorisParserParserRULE_tagOptions)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3838)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserParserAS {
		{
			p.SetState(3834)
			p.Match(DorisParserParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3835)
			p.Match(DorisParserParserOF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3836)
			p.Match(DorisParserParserVERSION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3837)

			var _m = p.Match(DorisParserParserINTEGER_VALUE)

			localctx.(*TagOptionsContext).version = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(3841)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserParserRETAIN {
		{
			p.SetState(3840)
			p.RetainTime()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBranchOptionsContext is an interface to support dynamic dispatch.
type IBranchOptionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetVersion returns the version token.
	GetVersion() antlr.Token

	// SetVersion sets the version token.
	SetVersion(antlr.Token)

	// Getter signatures
	AS() antlr.TerminalNode
	OF() antlr.TerminalNode
	VERSION() antlr.TerminalNode
	RetainTime() IRetainTimeContext
	RetentionSnapshot() IRetentionSnapshotContext
	INTEGER_VALUE() antlr.TerminalNode

	// IsBranchOptionsContext differentiates from other interfaces.
	IsBranchOptionsContext()
}

type BranchOptionsContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	version antlr.Token
}

func NewEmptyBranchOptionsContext() *BranchOptionsContext {
	var p = new(BranchOptionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_branchOptions
	return p
}

func InitEmptyBranchOptionsContext(p *BranchOptionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_branchOptions
}

func (*BranchOptionsContext) IsBranchOptionsContext() {}

func NewBranchOptionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BranchOptionsContext {
	var p = new(BranchOptionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_branchOptions

	return p
}

func (s *BranchOptionsContext) GetParser() antlr.Parser { return s.parser }

func (s *BranchOptionsContext) GetVersion() antlr.Token { return s.version }

func (s *BranchOptionsContext) SetVersion(v antlr.Token) { s.version = v }

func (s *BranchOptionsContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserAS, 0)
}

func (s *BranchOptionsContext) OF() antlr.TerminalNode {
	return s.GetToken(DorisParserParserOF, 0)
}

func (s *BranchOptionsContext) VERSION() antlr.TerminalNode {
	return s.GetToken(DorisParserParserVERSION, 0)
}

func (s *BranchOptionsContext) RetainTime() IRetainTimeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRetainTimeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRetainTimeContext)
}

func (s *BranchOptionsContext) RetentionSnapshot() IRetentionSnapshotContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRetentionSnapshotContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRetentionSnapshotContext)
}

func (s *BranchOptionsContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserINTEGER_VALUE, 0)
}

func (s *BranchOptionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BranchOptionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BranchOptionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitBranchOptions(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) BranchOptions() (localctx IBranchOptionsContext) {
	localctx = NewBranchOptionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, DorisParserParserRULE_branchOptions)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3847)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserParserAS {
		{
			p.SetState(3843)
			p.Match(DorisParserParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3844)
			p.Match(DorisParserParserOF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3845)
			p.Match(DorisParserParserVERSION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3846)

			var _m = p.Match(DorisParserParserINTEGER_VALUE)

			localctx.(*BranchOptionsContext).version = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(3850)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserParserRETAIN {
		{
			p.SetState(3849)
			p.RetainTime()
		}

	}
	p.SetState(3853)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserParserWITH {
		{
			p.SetState(3852)
			p.RetentionSnapshot()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRetainTimeContext is an interface to support dynamic dispatch.
type IRetainTimeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RETAIN() antlr.TerminalNode
	TimeValueWithUnit() ITimeValueWithUnitContext

	// IsRetainTimeContext differentiates from other interfaces.
	IsRetainTimeContext()
}

type RetainTimeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRetainTimeContext() *RetainTimeContext {
	var p = new(RetainTimeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_retainTime
	return p
}

func InitEmptyRetainTimeContext(p *RetainTimeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_retainTime
}

func (*RetainTimeContext) IsRetainTimeContext() {}

func NewRetainTimeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RetainTimeContext {
	var p = new(RetainTimeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_retainTime

	return p
}

func (s *RetainTimeContext) GetParser() antlr.Parser { return s.parser }

func (s *RetainTimeContext) RETAIN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRETAIN, 0)
}

func (s *RetainTimeContext) TimeValueWithUnit() ITimeValueWithUnitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITimeValueWithUnitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITimeValueWithUnitContext)
}

func (s *RetainTimeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RetainTimeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RetainTimeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitRetainTime(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) RetainTime() (localctx IRetainTimeContext) {
	localctx = NewRetainTimeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, DorisParserParserRULE_retainTime)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3855)
		p.Match(DorisParserParserRETAIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3856)
		p.TimeValueWithUnit()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRetentionSnapshotContext is an interface to support dynamic dispatch.
type IRetentionSnapshotContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WITH() antlr.TerminalNode
	SNAPSHOT() antlr.TerminalNode
	RETENTION() antlr.TerminalNode
	MinSnapshotsToKeep() IMinSnapshotsToKeepContext
	TimeValueWithUnit() ITimeValueWithUnitContext

	// IsRetentionSnapshotContext differentiates from other interfaces.
	IsRetentionSnapshotContext()
}

type RetentionSnapshotContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRetentionSnapshotContext() *RetentionSnapshotContext {
	var p = new(RetentionSnapshotContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_retentionSnapshot
	return p
}

func InitEmptyRetentionSnapshotContext(p *RetentionSnapshotContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_retentionSnapshot
}

func (*RetentionSnapshotContext) IsRetentionSnapshotContext() {}

func NewRetentionSnapshotContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RetentionSnapshotContext {
	var p = new(RetentionSnapshotContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_retentionSnapshot

	return p
}

func (s *RetentionSnapshotContext) GetParser() antlr.Parser { return s.parser }

func (s *RetentionSnapshotContext) WITH() antlr.TerminalNode {
	return s.GetToken(DorisParserParserWITH, 0)
}

func (s *RetentionSnapshotContext) SNAPSHOT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSNAPSHOT, 0)
}

func (s *RetentionSnapshotContext) RETENTION() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRETENTION, 0)
}

func (s *RetentionSnapshotContext) MinSnapshotsToKeep() IMinSnapshotsToKeepContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMinSnapshotsToKeepContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMinSnapshotsToKeepContext)
}

func (s *RetentionSnapshotContext) TimeValueWithUnit() ITimeValueWithUnitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITimeValueWithUnitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITimeValueWithUnitContext)
}

func (s *RetentionSnapshotContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RetentionSnapshotContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RetentionSnapshotContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitRetentionSnapshot(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) RetentionSnapshot() (localctx IRetentionSnapshotContext) {
	localctx = NewRetentionSnapshotContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, DorisParserParserRULE_retentionSnapshot)
	p.SetState(3872)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 532, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3858)
			p.Match(DorisParserParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3859)
			p.Match(DorisParserParserSNAPSHOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3860)
			p.Match(DorisParserParserRETENTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3861)
			p.MinSnapshotsToKeep()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3862)
			p.Match(DorisParserParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3863)
			p.Match(DorisParserParserSNAPSHOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3864)
			p.Match(DorisParserParserRETENTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3865)
			p.TimeValueWithUnit()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3866)
			p.Match(DorisParserParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3867)
			p.Match(DorisParserParserSNAPSHOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3868)
			p.Match(DorisParserParserRETENTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3869)
			p.MinSnapshotsToKeep()
		}
		{
			p.SetState(3870)
			p.TimeValueWithUnit()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMinSnapshotsToKeepContext is an interface to support dynamic dispatch.
type IMinSnapshotsToKeepContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetValue returns the value token.
	GetValue() antlr.Token

	// SetValue sets the value token.
	SetValue(antlr.Token)

	// Getter signatures
	SNAPSHOTS() antlr.TerminalNode
	INTEGER_VALUE() antlr.TerminalNode

	// IsMinSnapshotsToKeepContext differentiates from other interfaces.
	IsMinSnapshotsToKeepContext()
}

type MinSnapshotsToKeepContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	value  antlr.Token
}

func NewEmptyMinSnapshotsToKeepContext() *MinSnapshotsToKeepContext {
	var p = new(MinSnapshotsToKeepContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_minSnapshotsToKeep
	return p
}

func InitEmptyMinSnapshotsToKeepContext(p *MinSnapshotsToKeepContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_minSnapshotsToKeep
}

func (*MinSnapshotsToKeepContext) IsMinSnapshotsToKeepContext() {}

func NewMinSnapshotsToKeepContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MinSnapshotsToKeepContext {
	var p = new(MinSnapshotsToKeepContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_minSnapshotsToKeep

	return p
}

func (s *MinSnapshotsToKeepContext) GetParser() antlr.Parser { return s.parser }

func (s *MinSnapshotsToKeepContext) GetValue() antlr.Token { return s.value }

func (s *MinSnapshotsToKeepContext) SetValue(v antlr.Token) { s.value = v }

func (s *MinSnapshotsToKeepContext) SNAPSHOTS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSNAPSHOTS, 0)
}

func (s *MinSnapshotsToKeepContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserINTEGER_VALUE, 0)
}

func (s *MinSnapshotsToKeepContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MinSnapshotsToKeepContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MinSnapshotsToKeepContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitMinSnapshotsToKeep(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) MinSnapshotsToKeep() (localctx IMinSnapshotsToKeepContext) {
	localctx = NewMinSnapshotsToKeepContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, DorisParserParserRULE_minSnapshotsToKeep)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3874)

		var _m = p.Match(DorisParserParserINTEGER_VALUE)

		localctx.(*MinSnapshotsToKeepContext).value = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3875)
		p.Match(DorisParserParserSNAPSHOTS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITimeValueWithUnitContext is an interface to support dynamic dispatch.
type ITimeValueWithUnitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetTimeValue returns the timeValue token.
	GetTimeValue() antlr.Token

	// GetTimeUnit returns the timeUnit token.
	GetTimeUnit() antlr.Token

	// SetTimeValue sets the timeValue token.
	SetTimeValue(antlr.Token)

	// SetTimeUnit sets the timeUnit token.
	SetTimeUnit(antlr.Token)

	// Getter signatures
	INTEGER_VALUE() antlr.TerminalNode
	DAYS() antlr.TerminalNode
	HOURS() antlr.TerminalNode
	MINUTES() antlr.TerminalNode

	// IsTimeValueWithUnitContext differentiates from other interfaces.
	IsTimeValueWithUnitContext()
}

type TimeValueWithUnitContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	timeValue antlr.Token
	timeUnit  antlr.Token
}

func NewEmptyTimeValueWithUnitContext() *TimeValueWithUnitContext {
	var p = new(TimeValueWithUnitContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_timeValueWithUnit
	return p
}

func InitEmptyTimeValueWithUnitContext(p *TimeValueWithUnitContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_timeValueWithUnit
}

func (*TimeValueWithUnitContext) IsTimeValueWithUnitContext() {}

func NewTimeValueWithUnitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TimeValueWithUnitContext {
	var p = new(TimeValueWithUnitContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_timeValueWithUnit

	return p
}

func (s *TimeValueWithUnitContext) GetParser() antlr.Parser { return s.parser }

func (s *TimeValueWithUnitContext) GetTimeValue() antlr.Token { return s.timeValue }

func (s *TimeValueWithUnitContext) GetTimeUnit() antlr.Token { return s.timeUnit }

func (s *TimeValueWithUnitContext) SetTimeValue(v antlr.Token) { s.timeValue = v }

func (s *TimeValueWithUnitContext) SetTimeUnit(v antlr.Token) { s.timeUnit = v }

func (s *TimeValueWithUnitContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserINTEGER_VALUE, 0)
}

func (s *TimeValueWithUnitContext) DAYS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDAYS, 0)
}

func (s *TimeValueWithUnitContext) HOURS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserHOURS, 0)
}

func (s *TimeValueWithUnitContext) MINUTES() antlr.TerminalNode {
	return s.GetToken(DorisParserParserMINUTES, 0)
}

func (s *TimeValueWithUnitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TimeValueWithUnitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TimeValueWithUnitContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitTimeValueWithUnit(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) TimeValueWithUnit() (localctx ITimeValueWithUnitContext) {
	localctx = NewTimeValueWithUnitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, DorisParserParserRULE_timeValueWithUnit)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3877)

		var _m = p.Match(DorisParserParserINTEGER_VALUE)

		localctx.(*TimeValueWithUnitContext).timeValue = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3878)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*TimeValueWithUnitContext).timeUnit = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisParserParserDAYS || _la == DorisParserParserHOURS || _la == DorisParserParserMINUTES) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*TimeValueWithUnitContext).timeUnit = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropBranchClauseContext is an interface to support dynamic dispatch.
type IDropBranchClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name rule contexts.
	GetName() IIdentifierContext

	// SetName sets the name rule contexts.
	SetName(IIdentifierContext)

	// Getter signatures
	DROP() antlr.TerminalNode
	BRANCH() antlr.TerminalNode
	Identifier() IIdentifierContext
	IF() antlr.TerminalNode
	EXISTS() antlr.TerminalNode

	// IsDropBranchClauseContext differentiates from other interfaces.
	IsDropBranchClauseContext()
}

type DropBranchClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	name   IIdentifierContext
}

func NewEmptyDropBranchClauseContext() *DropBranchClauseContext {
	var p = new(DropBranchClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_dropBranchClause
	return p
}

func InitEmptyDropBranchClauseContext(p *DropBranchClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_dropBranchClause
}

func (*DropBranchClauseContext) IsDropBranchClauseContext() {}

func NewDropBranchClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropBranchClauseContext {
	var p = new(DropBranchClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_dropBranchClause

	return p
}

func (s *DropBranchClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DropBranchClauseContext) GetName() IIdentifierContext { return s.name }

func (s *DropBranchClauseContext) SetName(v IIdentifierContext) { s.name = v }

func (s *DropBranchClauseContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDROP, 0)
}

func (s *DropBranchClauseContext) BRANCH() antlr.TerminalNode {
	return s.GetToken(DorisParserParserBRANCH, 0)
}

func (s *DropBranchClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DropBranchClauseContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserParserIF, 0)
}

func (s *DropBranchClauseContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserEXISTS, 0)
}

func (s *DropBranchClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropBranchClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropBranchClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitDropBranchClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) DropBranchClause() (localctx IDropBranchClauseContext) {
	localctx = NewDropBranchClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, DorisParserParserRULE_dropBranchClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3880)
		p.Match(DorisParserParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3881)
		p.Match(DorisParserParserBRANCH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3884)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserParserIF {
		{
			p.SetState(3882)
			p.Match(DorisParserParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3883)
			p.Match(DorisParserParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(3886)

		var _x = p.Identifier()

		localctx.(*DropBranchClauseContext).name = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropTagClauseContext is an interface to support dynamic dispatch.
type IDropTagClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name rule contexts.
	GetName() IIdentifierContext

	// SetName sets the name rule contexts.
	SetName(IIdentifierContext)

	// Getter signatures
	DROP() antlr.TerminalNode
	TAG() antlr.TerminalNode
	Identifier() IIdentifierContext
	IF() antlr.TerminalNode
	EXISTS() antlr.TerminalNode

	// IsDropTagClauseContext differentiates from other interfaces.
	IsDropTagClauseContext()
}

type DropTagClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	name   IIdentifierContext
}

func NewEmptyDropTagClauseContext() *DropTagClauseContext {
	var p = new(DropTagClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_dropTagClause
	return p
}

func InitEmptyDropTagClauseContext(p *DropTagClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_dropTagClause
}

func (*DropTagClauseContext) IsDropTagClauseContext() {}

func NewDropTagClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropTagClauseContext {
	var p = new(DropTagClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_dropTagClause

	return p
}

func (s *DropTagClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DropTagClauseContext) GetName() IIdentifierContext { return s.name }

func (s *DropTagClauseContext) SetName(v IIdentifierContext) { s.name = v }

func (s *DropTagClauseContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDROP, 0)
}

func (s *DropTagClauseContext) TAG() antlr.TerminalNode {
	return s.GetToken(DorisParserParserTAG, 0)
}

func (s *DropTagClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DropTagClauseContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserParserIF, 0)
}

func (s *DropTagClauseContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserEXISTS, 0)
}

func (s *DropTagClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropTagClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropTagClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitDropTagClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) DropTagClause() (localctx IDropTagClauseContext) {
	localctx = NewDropTagClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, DorisParserParserRULE_dropTagClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3888)
		p.Match(DorisParserParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3889)
		p.Match(DorisParserParserTAG)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3892)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserParserIF {
		{
			p.SetState(3890)
			p.Match(DorisParserParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3891)
			p.Match(DorisParserParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(3894)

		var _x = p.Identifier()

		localctx.(*DropTagClauseContext).name = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnPositionContext is an interface to support dynamic dispatch.
type IColumnPositionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPosition returns the position rule contexts.
	GetPosition() IIdentifierContext

	// SetPosition sets the position rule contexts.
	SetPosition(IIdentifierContext)

	// Getter signatures
	FIRST() antlr.TerminalNode
	AFTER() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsColumnPositionContext differentiates from other interfaces.
	IsColumnPositionContext()
}

type ColumnPositionContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	position IIdentifierContext
}

func NewEmptyColumnPositionContext() *ColumnPositionContext {
	var p = new(ColumnPositionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_columnPosition
	return p
}

func InitEmptyColumnPositionContext(p *ColumnPositionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_columnPosition
}

func (*ColumnPositionContext) IsColumnPositionContext() {}

func NewColumnPositionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnPositionContext {
	var p = new(ColumnPositionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_columnPosition

	return p
}

func (s *ColumnPositionContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnPositionContext) GetPosition() IIdentifierContext { return s.position }

func (s *ColumnPositionContext) SetPosition(v IIdentifierContext) { s.position = v }

func (s *ColumnPositionContext) FIRST() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFIRST, 0)
}

func (s *ColumnPositionContext) AFTER() antlr.TerminalNode {
	return s.GetToken(DorisParserParserAFTER, 0)
}

func (s *ColumnPositionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ColumnPositionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnPositionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnPositionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitColumnPosition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) ColumnPosition() (localctx IColumnPositionContext) {
	localctx = NewColumnPositionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, DorisParserParserRULE_columnPosition)
	p.SetState(3899)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserParserFIRST:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3896)
			p.Match(DorisParserParserFIRST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserParserAFTER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3897)
			p.Match(DorisParserParserAFTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3898)

			var _x = p.Identifier()

			localctx.(*ColumnPositionContext).position = _x
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IToRollupContext is an interface to support dynamic dispatch.
type IToRollupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetRollup returns the rollup rule contexts.
	GetRollup() IIdentifierContext

	// SetRollup sets the rollup rule contexts.
	SetRollup(IIdentifierContext)

	// Getter signatures
	TO() antlr.TerminalNode
	IN() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsToRollupContext differentiates from other interfaces.
	IsToRollupContext()
}

type ToRollupContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	rollup IIdentifierContext
}

func NewEmptyToRollupContext() *ToRollupContext {
	var p = new(ToRollupContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_toRollup
	return p
}

func InitEmptyToRollupContext(p *ToRollupContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_toRollup
}

func (*ToRollupContext) IsToRollupContext() {}

func NewToRollupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ToRollupContext {
	var p = new(ToRollupContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_toRollup

	return p
}

func (s *ToRollupContext) GetParser() antlr.Parser { return s.parser }

func (s *ToRollupContext) GetRollup() IIdentifierContext { return s.rollup }

func (s *ToRollupContext) SetRollup(v IIdentifierContext) { s.rollup = v }

func (s *ToRollupContext) TO() antlr.TerminalNode {
	return s.GetToken(DorisParserParserTO, 0)
}

func (s *ToRollupContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserIN, 0)
}

func (s *ToRollupContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ToRollupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ToRollupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ToRollupContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitToRollup(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) ToRollup() (localctx IToRollupContext) {
	localctx = NewToRollupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, DorisParserParserRULE_toRollup)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3901)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisParserParserIN || _la == DorisParserParserTO) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(3902)

		var _x = p.Identifier()

		localctx.(*ToRollupContext).rollup = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFromRollupContext is an interface to support dynamic dispatch.
type IFromRollupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetRollup returns the rollup rule contexts.
	GetRollup() IIdentifierContext

	// SetRollup sets the rollup rule contexts.
	SetRollup(IIdentifierContext)

	// Getter signatures
	FROM() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsFromRollupContext differentiates from other interfaces.
	IsFromRollupContext()
}

type FromRollupContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	rollup IIdentifierContext
}

func NewEmptyFromRollupContext() *FromRollupContext {
	var p = new(FromRollupContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_fromRollup
	return p
}

func InitEmptyFromRollupContext(p *FromRollupContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_fromRollup
}

func (*FromRollupContext) IsFromRollupContext() {}

func NewFromRollupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FromRollupContext {
	var p = new(FromRollupContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_fromRollup

	return p
}

func (s *FromRollupContext) GetParser() antlr.Parser { return s.parser }

func (s *FromRollupContext) GetRollup() IIdentifierContext { return s.rollup }

func (s *FromRollupContext) SetRollup(v IIdentifierContext) { s.rollup = v }

func (s *FromRollupContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFROM, 0)
}

func (s *FromRollupContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *FromRollupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FromRollupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FromRollupContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitFromRollup(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) FromRollup() (localctx IFromRollupContext) {
	localctx = NewFromRollupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, DorisParserParserRULE_fromRollup)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3904)
		p.Match(DorisParserParserFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3905)

		var _x = p.Identifier()

		localctx.(*FromRollupContext).rollup = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISupportedStatsStatementContext is an interface to support dynamic dispatch.
type ISupportedStatsStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSupportedStatsStatementContext differentiates from other interfaces.
	IsSupportedStatsStatementContext()
}

type SupportedStatsStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySupportedStatsStatementContext() *SupportedStatsStatementContext {
	var p = new(SupportedStatsStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_supportedStatsStatement
	return p
}

func InitEmptySupportedStatsStatementContext(p *SupportedStatsStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_supportedStatsStatement
}

func (*SupportedStatsStatementContext) IsSupportedStatsStatementContext() {}

func NewSupportedStatsStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SupportedStatsStatementContext {
	var p = new(SupportedStatsStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_supportedStatsStatement

	return p
}

func (s *SupportedStatsStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SupportedStatsStatementContext) CopyAll(ctx *SupportedStatsStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *SupportedStatsStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedStatsStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ShowTableStatsContext struct {
	SupportedStatsStatementContext
	tableName  IMultipartIdentifierContext
	columnList IIdentifierListContext
	tableId    antlr.Token
}

func NewShowTableStatsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowTableStatsContext {
	var p = new(ShowTableStatsContext)

	InitEmptySupportedStatsStatementContext(&p.SupportedStatsStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedStatsStatementContext))

	return p
}

func (s *ShowTableStatsContext) GetTableId() antlr.Token { return s.tableId }

func (s *ShowTableStatsContext) SetTableId(v antlr.Token) { s.tableId = v }

func (s *ShowTableStatsContext) GetTableName() IMultipartIdentifierContext { return s.tableName }

func (s *ShowTableStatsContext) GetColumnList() IIdentifierListContext { return s.columnList }

func (s *ShowTableStatsContext) SetTableName(v IMultipartIdentifierContext) { s.tableName = v }

func (s *ShowTableStatsContext) SetColumnList(v IIdentifierListContext) { s.columnList = v }

func (s *ShowTableStatsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowTableStatsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSHOW, 0)
}

func (s *ShowTableStatsContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserTABLE, 0)
}

func (s *ShowTableStatsContext) STATS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTATS, 0)
}

func (s *ShowTableStatsContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowTableStatsContext) PartitionSpec() IPartitionSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionSpecContext)
}

func (s *ShowTableStatsContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *ShowTableStatsContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserINTEGER_VALUE, 0)
}

func (s *ShowTableStatsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitShowTableStats(s)

	default:
		return t.VisitChildren(s)
	}
}

type AnalyzeDatabaseContext struct {
	SupportedStatsStatementContext
	name IMultipartIdentifierContext
}

func NewAnalyzeDatabaseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AnalyzeDatabaseContext {
	var p = new(AnalyzeDatabaseContext)

	InitEmptySupportedStatsStatementContext(&p.SupportedStatsStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedStatsStatementContext))

	return p
}

func (s *AnalyzeDatabaseContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *AnalyzeDatabaseContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *AnalyzeDatabaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnalyzeDatabaseContext) ANALYZE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserANALYZE, 0)
}

func (s *AnalyzeDatabaseContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDATABASE, 0)
}

func (s *AnalyzeDatabaseContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *AnalyzeDatabaseContext) AllWITH() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserWITH)
}

func (s *AnalyzeDatabaseContext) WITH(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserWITH, i)
}

func (s *AnalyzeDatabaseContext) AllAnalyzeProperties() []IAnalyzePropertiesContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAnalyzePropertiesContext); ok {
			len++
		}
	}

	tst := make([]IAnalyzePropertiesContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAnalyzePropertiesContext); ok {
			tst[i] = t.(IAnalyzePropertiesContext)
			i++
		}
	}

	return tst
}

func (s *AnalyzeDatabaseContext) AnalyzeProperties(i int) IAnalyzePropertiesContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnalyzePropertiesContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnalyzePropertiesContext)
}

func (s *AnalyzeDatabaseContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *AnalyzeDatabaseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitAnalyzeDatabase(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowQueuedAnalyzeJobsContext struct {
	SupportedStatsStatementContext
	tableName  IMultipartIdentifierContext
	stateKey   IIdentifierContext
	stateValue antlr.Token
}

func NewShowQueuedAnalyzeJobsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowQueuedAnalyzeJobsContext {
	var p = new(ShowQueuedAnalyzeJobsContext)

	InitEmptySupportedStatsStatementContext(&p.SupportedStatsStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedStatsStatementContext))

	return p
}

func (s *ShowQueuedAnalyzeJobsContext) GetStateValue() antlr.Token { return s.stateValue }

func (s *ShowQueuedAnalyzeJobsContext) SetStateValue(v antlr.Token) { s.stateValue = v }

func (s *ShowQueuedAnalyzeJobsContext) GetTableName() IMultipartIdentifierContext { return s.tableName }

func (s *ShowQueuedAnalyzeJobsContext) GetStateKey() IIdentifierContext { return s.stateKey }

func (s *ShowQueuedAnalyzeJobsContext) SetTableName(v IMultipartIdentifierContext) { s.tableName = v }

func (s *ShowQueuedAnalyzeJobsContext) SetStateKey(v IIdentifierContext) { s.stateKey = v }

func (s *ShowQueuedAnalyzeJobsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowQueuedAnalyzeJobsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSHOW, 0)
}

func (s *ShowQueuedAnalyzeJobsContext) QUEUED() antlr.TerminalNode {
	return s.GetToken(DorisParserParserQUEUED, 0)
}

func (s *ShowQueuedAnalyzeJobsContext) ANALYZE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserANALYZE, 0)
}

func (s *ShowQueuedAnalyzeJobsContext) JOBS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserJOBS, 0)
}

func (s *ShowQueuedAnalyzeJobsContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserWHERE, 0)
}

func (s *ShowQueuedAnalyzeJobsContext) EQ() antlr.TerminalNode {
	return s.GetToken(DorisParserParserEQ, 0)
}

func (s *ShowQueuedAnalyzeJobsContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowQueuedAnalyzeJobsContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowQueuedAnalyzeJobsContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTRING_LITERAL, 0)
}

func (s *ShowQueuedAnalyzeJobsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitShowQueuedAnalyzeJobs(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowIndexStatsContext struct {
	SupportedStatsStatementContext
	tableName IMultipartIdentifierContext
	indexId   IIdentifierContext
}

func NewShowIndexStatsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowIndexStatsContext {
	var p = new(ShowIndexStatsContext)

	InitEmptySupportedStatsStatementContext(&p.SupportedStatsStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedStatsStatementContext))

	return p
}

func (s *ShowIndexStatsContext) GetTableName() IMultipartIdentifierContext { return s.tableName }

func (s *ShowIndexStatsContext) GetIndexId() IIdentifierContext { return s.indexId }

func (s *ShowIndexStatsContext) SetTableName(v IMultipartIdentifierContext) { s.tableName = v }

func (s *ShowIndexStatsContext) SetIndexId(v IIdentifierContext) { s.indexId = v }

func (s *ShowIndexStatsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowIndexStatsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSHOW, 0)
}

func (s *ShowIndexStatsContext) INDEX() antlr.TerminalNode {
	return s.GetToken(DorisParserParserINDEX, 0)
}

func (s *ShowIndexStatsContext) STATS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTATS, 0)
}

func (s *ShowIndexStatsContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowIndexStatsContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowIndexStatsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitShowIndexStats(s)

	default:
		return t.VisitChildren(s)
	}
}

type DropStatsContext struct {
	SupportedStatsStatementContext
	tableName IMultipartIdentifierContext
	columns   IIdentifierListContext
}

func NewDropStatsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropStatsContext {
	var p = new(DropStatsContext)

	InitEmptySupportedStatsStatementContext(&p.SupportedStatsStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedStatsStatementContext))

	return p
}

func (s *DropStatsContext) GetTableName() IMultipartIdentifierContext { return s.tableName }

func (s *DropStatsContext) GetColumns() IIdentifierListContext { return s.columns }

func (s *DropStatsContext) SetTableName(v IMultipartIdentifierContext) { s.tableName = v }

func (s *DropStatsContext) SetColumns(v IIdentifierListContext) { s.columns = v }

func (s *DropStatsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropStatsContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDROP, 0)
}

func (s *DropStatsContext) STATS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTATS, 0)
}

func (s *DropStatsContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *DropStatsContext) PartitionSpec() IPartitionSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionSpecContext)
}

func (s *DropStatsContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *DropStatsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitDropStats(s)

	default:
		return t.VisitChildren(s)
	}
}

type DropCachedStatsContext struct {
	SupportedStatsStatementContext
	tableName IMultipartIdentifierContext
}

func NewDropCachedStatsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropCachedStatsContext {
	var p = new(DropCachedStatsContext)

	InitEmptySupportedStatsStatementContext(&p.SupportedStatsStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedStatsStatementContext))

	return p
}

func (s *DropCachedStatsContext) GetTableName() IMultipartIdentifierContext { return s.tableName }

func (s *DropCachedStatsContext) SetTableName(v IMultipartIdentifierContext) { s.tableName = v }

func (s *DropCachedStatsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropCachedStatsContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDROP, 0)
}

func (s *DropCachedStatsContext) CACHED() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCACHED, 0)
}

func (s *DropCachedStatsContext) STATS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTATS, 0)
}

func (s *DropCachedStatsContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *DropCachedStatsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitDropCachedStats(s)

	default:
		return t.VisitChildren(s)
	}
}

type KillAnalyzeJobContext struct {
	SupportedStatsStatementContext
	jobId antlr.Token
}

func NewKillAnalyzeJobContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *KillAnalyzeJobContext {
	var p = new(KillAnalyzeJobContext)

	InitEmptySupportedStatsStatementContext(&p.SupportedStatsStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedStatsStatementContext))

	return p
}

func (s *KillAnalyzeJobContext) GetJobId() antlr.Token { return s.jobId }

func (s *KillAnalyzeJobContext) SetJobId(v antlr.Token) { s.jobId = v }

func (s *KillAnalyzeJobContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KillAnalyzeJobContext) KILL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserKILL, 0)
}

func (s *KillAnalyzeJobContext) ANALYZE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserANALYZE, 0)
}

func (s *KillAnalyzeJobContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserINTEGER_VALUE, 0)
}

func (s *KillAnalyzeJobContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitKillAnalyzeJob(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowAnalyzeContext struct {
	SupportedStatsStatementContext
	jobId      antlr.Token
	tableName  IMultipartIdentifierContext
	stateKey   IIdentifierContext
	stateValue antlr.Token
}

func NewShowAnalyzeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowAnalyzeContext {
	var p = new(ShowAnalyzeContext)

	InitEmptySupportedStatsStatementContext(&p.SupportedStatsStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedStatsStatementContext))

	return p
}

func (s *ShowAnalyzeContext) GetJobId() antlr.Token { return s.jobId }

func (s *ShowAnalyzeContext) GetStateValue() antlr.Token { return s.stateValue }

func (s *ShowAnalyzeContext) SetJobId(v antlr.Token) { s.jobId = v }

func (s *ShowAnalyzeContext) SetStateValue(v antlr.Token) { s.stateValue = v }

func (s *ShowAnalyzeContext) GetTableName() IMultipartIdentifierContext { return s.tableName }

func (s *ShowAnalyzeContext) GetStateKey() IIdentifierContext { return s.stateKey }

func (s *ShowAnalyzeContext) SetTableName(v IMultipartIdentifierContext) { s.tableName = v }

func (s *ShowAnalyzeContext) SetStateKey(v IIdentifierContext) { s.stateKey = v }

func (s *ShowAnalyzeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowAnalyzeContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSHOW, 0)
}

func (s *ShowAnalyzeContext) ANALYZE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserANALYZE, 0)
}

func (s *ShowAnalyzeContext) AUTO() antlr.TerminalNode {
	return s.GetToken(DorisParserParserAUTO, 0)
}

func (s *ShowAnalyzeContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserWHERE, 0)
}

func (s *ShowAnalyzeContext) EQ() antlr.TerminalNode {
	return s.GetToken(DorisParserParserEQ, 0)
}

func (s *ShowAnalyzeContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserINTEGER_VALUE, 0)
}

func (s *ShowAnalyzeContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowAnalyzeContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowAnalyzeContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTRING_LITERAL, 0)
}

func (s *ShowAnalyzeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitShowAnalyze(s)

	default:
		return t.VisitChildren(s)
	}
}

type DropAnalyzeJobContext struct {
	SupportedStatsStatementContext
}

func NewDropAnalyzeJobContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropAnalyzeJobContext {
	var p = new(DropAnalyzeJobContext)

	InitEmptySupportedStatsStatementContext(&p.SupportedStatsStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedStatsStatementContext))

	return p
}

func (s *DropAnalyzeJobContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropAnalyzeJobContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDROP, 0)
}

func (s *DropAnalyzeJobContext) ANALYZE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserANALYZE, 0)
}

func (s *DropAnalyzeJobContext) JOB() antlr.TerminalNode {
	return s.GetToken(DorisParserParserJOB, 0)
}

func (s *DropAnalyzeJobContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserINTEGER_VALUE, 0)
}

func (s *DropAnalyzeJobContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitDropAnalyzeJob(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterColumnStatsContext struct {
	SupportedStatsStatementContext
	name       IMultipartIdentifierContext
	indexName  IIdentifierContext
	columnName IIdentifierContext
}

func NewAlterColumnStatsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterColumnStatsContext {
	var p = new(AlterColumnStatsContext)

	InitEmptySupportedStatsStatementContext(&p.SupportedStatsStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedStatsStatementContext))

	return p
}

func (s *AlterColumnStatsContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *AlterColumnStatsContext) GetIndexName() IIdentifierContext { return s.indexName }

func (s *AlterColumnStatsContext) GetColumnName() IIdentifierContext { return s.columnName }

func (s *AlterColumnStatsContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *AlterColumnStatsContext) SetIndexName(v IIdentifierContext) { s.indexName = v }

func (s *AlterColumnStatsContext) SetColumnName(v IIdentifierContext) { s.columnName = v }

func (s *AlterColumnStatsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterColumnStatsContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserParserALTER, 0)
}

func (s *AlterColumnStatsContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserTABLE, 0)
}

func (s *AlterColumnStatsContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(DorisParserParserMODIFY, 0)
}

func (s *AlterColumnStatsContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOLUMN, 0)
}

func (s *AlterColumnStatsContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSET, 0)
}

func (s *AlterColumnStatsContext) STATS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTATS, 0)
}

func (s *AlterColumnStatsContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLEFT_PAREN, 0)
}

func (s *AlterColumnStatsContext) PropertyItemList() IPropertyItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyItemListContext)
}

func (s *AlterColumnStatsContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRIGHT_PAREN, 0)
}

func (s *AlterColumnStatsContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *AlterColumnStatsContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *AlterColumnStatsContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AlterColumnStatsContext) INDEX() antlr.TerminalNode {
	return s.GetToken(DorisParserParserINDEX, 0)
}

func (s *AlterColumnStatsContext) PartitionSpec() IPartitionSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionSpecContext)
}

func (s *AlterColumnStatsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitAlterColumnStats(s)

	default:
		return t.VisitChildren(s)
	}
}

type DropExpiredStatsContext struct {
	SupportedStatsStatementContext
}

func NewDropExpiredStatsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropExpiredStatsContext {
	var p = new(DropExpiredStatsContext)

	InitEmptySupportedStatsStatementContext(&p.SupportedStatsStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedStatsStatementContext))

	return p
}

func (s *DropExpiredStatsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropExpiredStatsContext) DROP() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDROP, 0)
}

func (s *DropExpiredStatsContext) EXPIRED() antlr.TerminalNode {
	return s.GetToken(DorisParserParserEXPIRED, 0)
}

func (s *DropExpiredStatsContext) STATS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTATS, 0)
}

func (s *DropExpiredStatsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitDropExpiredStats(s)

	default:
		return t.VisitChildren(s)
	}
}

type AnalyzeTableContext struct {
	SupportedStatsStatementContext
	name    IMultipartIdentifierContext
	columns IIdentifierListContext
}

func NewAnalyzeTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AnalyzeTableContext {
	var p = new(AnalyzeTableContext)

	InitEmptySupportedStatsStatementContext(&p.SupportedStatsStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedStatsStatementContext))

	return p
}

func (s *AnalyzeTableContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *AnalyzeTableContext) GetColumns() IIdentifierListContext { return s.columns }

func (s *AnalyzeTableContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *AnalyzeTableContext) SetColumns(v IIdentifierListContext) { s.columns = v }

func (s *AnalyzeTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnalyzeTableContext) ANALYZE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserANALYZE, 0)
}

func (s *AnalyzeTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserTABLE, 0)
}

func (s *AnalyzeTableContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *AnalyzeTableContext) PartitionSpec() IPartitionSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionSpecContext)
}

func (s *AnalyzeTableContext) AllWITH() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserWITH)
}

func (s *AnalyzeTableContext) WITH(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserWITH, i)
}

func (s *AnalyzeTableContext) AllAnalyzeProperties() []IAnalyzePropertiesContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAnalyzePropertiesContext); ok {
			len++
		}
	}

	tst := make([]IAnalyzePropertiesContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAnalyzePropertiesContext); ok {
			tst[i] = t.(IAnalyzePropertiesContext)
			i++
		}
	}

	return tst
}

func (s *AnalyzeTableContext) AnalyzeProperties(i int) IAnalyzePropertiesContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnalyzePropertiesContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnalyzePropertiesContext)
}

func (s *AnalyzeTableContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *AnalyzeTableContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *AnalyzeTableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitAnalyzeTable(s)

	default:
		return t.VisitChildren(s)
	}
}

type AlterTableStatsContext struct {
	SupportedStatsStatementContext
	name IMultipartIdentifierContext
}

func NewAlterTableStatsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterTableStatsContext {
	var p = new(AlterTableStatsContext)

	InitEmptySupportedStatsStatementContext(&p.SupportedStatsStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedStatsStatementContext))

	return p
}

func (s *AlterTableStatsContext) GetName() IMultipartIdentifierContext { return s.name }

func (s *AlterTableStatsContext) SetName(v IMultipartIdentifierContext) { s.name = v }

func (s *AlterTableStatsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableStatsContext) ALTER() antlr.TerminalNode {
	return s.GetToken(DorisParserParserALTER, 0)
}

func (s *AlterTableStatsContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserTABLE, 0)
}

func (s *AlterTableStatsContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSET, 0)
}

func (s *AlterTableStatsContext) STATS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTATS, 0)
}

func (s *AlterTableStatsContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLEFT_PAREN, 0)
}

func (s *AlterTableStatsContext) PropertyItemList() IPropertyItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyItemListContext)
}

func (s *AlterTableStatsContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRIGHT_PAREN, 0)
}

func (s *AlterTableStatsContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *AlterTableStatsContext) PartitionSpec() IPartitionSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionSpecContext)
}

func (s *AlterTableStatsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitAlterTableStats(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowColumnHistogramStatsContext struct {
	SupportedStatsStatementContext
	tableName  IMultipartIdentifierContext
	columnList IIdentifierListContext
}

func NewShowColumnHistogramStatsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowColumnHistogramStatsContext {
	var p = new(ShowColumnHistogramStatsContext)

	InitEmptySupportedStatsStatementContext(&p.SupportedStatsStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedStatsStatementContext))

	return p
}

func (s *ShowColumnHistogramStatsContext) GetTableName() IMultipartIdentifierContext {
	return s.tableName
}

func (s *ShowColumnHistogramStatsContext) GetColumnList() IIdentifierListContext { return s.columnList }

func (s *ShowColumnHistogramStatsContext) SetTableName(v IMultipartIdentifierContext) {
	s.tableName = v
}

func (s *ShowColumnHistogramStatsContext) SetColumnList(v IIdentifierListContext) { s.columnList = v }

func (s *ShowColumnHistogramStatsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowColumnHistogramStatsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSHOW, 0)
}

func (s *ShowColumnHistogramStatsContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOLUMN, 0)
}

func (s *ShowColumnHistogramStatsContext) HISTOGRAM() antlr.TerminalNode {
	return s.GetToken(DorisParserParserHISTOGRAM, 0)
}

func (s *ShowColumnHistogramStatsContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowColumnHistogramStatsContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *ShowColumnHistogramStatsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitShowColumnHistogramStats(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) SupportedStatsStatement() (localctx ISupportedStatsStatementContext) {
	localctx = NewSupportedStatsStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, DorisParserParserRULE_supportedStatsStatement)
	var _la int

	p.SetState(4047)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 554, p.GetParserRuleContext()) {
	case 1:
		localctx = NewShowAnalyzeContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3907)
			p.Match(DorisParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3909)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserAUTO {
			{
				p.SetState(3908)
				p.Match(DorisParserParserAUTO)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3911)
			p.Match(DorisParserParserANALYZE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3914)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		switch p.GetTokenStream().LA(1) {
		case DorisParserParserINTEGER_VALUE:
			{
				p.SetState(3912)

				var _m = p.Match(DorisParserParserINTEGER_VALUE)

				localctx.(*ShowAnalyzeContext).jobId = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserParserLEFT_BRACE, DorisParserParserRIGHT_BRACE, DorisParserParserACTIONS, DorisParserParserAFTER, DorisParserParserAGG_STATE, DorisParserParserAGGREGATE, DorisParserParserALIAS, DorisParserParserANALYZED, DorisParserParserARRAY, DorisParserParserAT, DorisParserParserAUTHORS, DorisParserParserAUTO_INCREMENT, DorisParserParserALWAYS, DorisParserParserBACKENDS, DorisParserParserBACKUP, DorisParserParserBEGIN, DorisParserParserBELONG, DorisParserParserBIN, DorisParserParserBITAND, DorisParserParserBITMAP, DorisParserParserBITMAP_EMPTY, DorisParserParserBITMAP_UNION, DorisParserParserBITOR, DorisParserParserBITXOR, DorisParserParserBLOB, DorisParserParserBOOLEAN, DorisParserParserBRANCH, DorisParserParserBRIEF, DorisParserParserBROKER, DorisParserParserBUCKETS, DorisParserParserBUILD, DorisParserParserBUILTIN, DorisParserParserBULK, DorisParserParserCACHE, DorisParserParserCACHED, DorisParserParserCALL, DorisParserParserCATALOG, DorisParserParserCATALOGS, DorisParserParserCHAIN, DorisParserParserCHAR, DorisParserParserCHARSET, DorisParserParserCHECK, DorisParserParserCLUSTER, DorisParserParserCLUSTERS, DorisParserParserCOLLATION, DorisParserParserCOLLECT, DorisParserParserCOLOCATE, DorisParserParserCOLUMNS, DorisParserParserCOMMENT, DorisParserParserCOMMIT, DorisParserParserCOMMITTED, DorisParserParserCOMPACT, DorisParserParserCOMPLETE, DorisParserParserCOMPRESS_TYPE, DorisParserParserCOMPUTE, DorisParserParserCONDITIONS, DorisParserParserCONFIG, DorisParserParserCONNECTION, DorisParserParserCONNECTION_ID, DorisParserParserCONSISTENT, DorisParserParserCONSTRAINTS, DorisParserParserCONVERT, DorisParserParserCONVERT_LSC, DorisParserParserCOPY, DorisParserParserCOUNT, DorisParserParserCREATION, DorisParserParserCRON, DorisParserParserCURRENT_CATALOG, DorisParserParserCURRENT_DATE, DorisParserParserCURRENT_TIME, DorisParserParserCURRENT_TIMESTAMP, DorisParserParserCURRENT_USER, DorisParserParserDATA, DorisParserParserDATE, DorisParserParserDATETIME, DorisParserParserDATETIMEV2, DorisParserParserDATEV2, DorisParserParserDATETIMEV1, DorisParserParserDATEV1, DorisParserParserDAY, DorisParserParserDAYS, DorisParserParserDECIMAL, DorisParserParserDECIMALV2, DorisParserParserDECIMALV3, DorisParserParserDEFERRED, DorisParserParserDEMAND, DorisParserParserDIAGNOSE, DorisParserParserDIAGNOSIS, DorisParserParserDICTIONARIES, DorisParserParserDICTIONARY, DorisParserParserDISTINCTPC, DorisParserParserDISTINCTPCSA, DorisParserParserDO, DorisParserParserDORIS_INTERNAL_TABLE_ID, DorisParserParserDUAL, DorisParserParserDYNAMIC, DorisParserParserE, DorisParserParserENABLE, DorisParserParserENCRYPTKEY, DorisParserParserENCRYPTKEYS, DorisParserParserEND, DorisParserParserENDS, DorisParserParserENGINE, DorisParserParserENGINES, DorisParserParserERRORS, DorisParserParserESCAPE, DorisParserParserEVENTS, DorisParserParserEVERY, DorisParserParserEXCLUDE, DorisParserParserEXPIRED, DorisParserParserEXTERNAL, DorisParserParserFAILED_LOGIN_ATTEMPTS, DorisParserParserFAST, DorisParserParserFEATURE, DorisParserParserFIELDS, DorisParserParserFILE, DorisParserParserFILTER, DorisParserParserFIRST, DorisParserParserFORMAT, DorisParserParserFREE, DorisParserParserFRONTENDS, DorisParserParserFUNCTION, DorisParserParserGENERATED, DorisParserParserGENERIC, DorisParserParserGLOBAL, DorisParserParserGRAPH, DorisParserParserGROUPING, DorisParserParserGROUPS, DorisParserParserHASH, DorisParserParserHASH_MAP, DorisParserParserHDFS, DorisParserParserHELP, DorisParserParserHISTOGRAM, DorisParserParserHLL_UNION, DorisParserParserHOSTNAME, DorisParserParserHOTSPOT, DorisParserParserHOUR, DorisParserParserHOURS, DorisParserParserHUB, DorisParserParserIDENTIFIED, DorisParserParserIGNORE, DorisParserParserIMMEDIATE, DorisParserParserINCREMENTAL, DorisParserParserINDEXES, DorisParserParserINVERTED, DorisParserParserIP_TRIE, DorisParserParserIPV4, DorisParserParserIPV6, DorisParserParserIS_NOT_NULL_PRED, DorisParserParserIS_NULL_PRED, DorisParserParserISNULL, DorisParserParserISOLATION, DorisParserParserJOB, DorisParserParserJOBS, DorisParserParserJSON, DorisParserParserJSONB, DorisParserParserLABEL, DorisParserParserLAST, DorisParserParserLDAP, DorisParserParserLDAP_ADMIN_PASSWORD, DorisParserParserLESS, DorisParserParserLEVEL, DorisParserParserLINES, DorisParserParserLINK, DorisParserParserLOCAL, DorisParserParserLOCALTIME, DorisParserParserLOCALTIMESTAMP, DorisParserParserLOCATION, DorisParserParserLOCK, DorisParserParserLOGICAL, DorisParserParserMANUAL, DorisParserParserMAP, DorisParserParserMATCH_ALL, DorisParserParserMATCH_ANY, DorisParserParserMATCH_PHRASE, DorisParserParserMATCH_PHRASE_EDGE, DorisParserParserMATCH_PHRASE_PREFIX, DorisParserParserMATCH_REGEXP, DorisParserParserMATERIALIZED, DorisParserParserMAX, DorisParserParserMEMO, DorisParserParserMERGE, DorisParserParserMIGRATE, DorisParserParserMIGRATIONS, DorisParserParserMIN, DorisParserParserMINUTE, DorisParserParserMINUTES, DorisParserParserMODIFY, DorisParserParserMONTH, DorisParserParserMTMV, DorisParserParserNAME, DorisParserParserNAMES, DorisParserParserNEGATIVE, DorisParserParserNEVER, DorisParserParserNEXT, DorisParserParserNGRAM_BF, DorisParserParserNO, DorisParserParserNON_NULLABLE, DorisParserParserNULLS, DorisParserParserOF, DorisParserParserOFFSET, DorisParserParserONLY, DorisParserParserOPEN, DorisParserParserOPTIMIZED, DorisParserParserPARAMETER, DorisParserParserPARSED, DorisParserParserPARTITIONS, DorisParserParserPASSWORD, DorisParserParserPASSWORD_EXPIRE, DorisParserParserPASSWORD_HISTORY, DorisParserParserPASSWORD_LOCK_TIME, DorisParserParserPASSWORD_REUSE, DorisParserParserPATH, DorisParserParserPAUSE, DorisParserParserPERCENT, DorisParserParserPERIOD, DorisParserParserPERMISSIVE, DorisParserParserPHYSICAL, DorisParserParserPI, DorisParserParserPLAN, DorisParserParserPRIVILEGES, DorisParserParserPROCESS, DorisParserParserPLUGIN, DorisParserParserPLUGINS, DorisParserParserPOLICY, DorisParserParserPROC, DorisParserParserPROCESSLIST, DorisParserParserPROFILE, DorisParserParserPROPERTIES, DorisParserParserPROPERTY, DorisParserParserQUANTILE_STATE, DorisParserParserQUANTILE_UNION, DorisParserParserQUERY, DorisParserParserQUEUED, DorisParserParserQUOTA, DorisParserParserQUALIFY, DorisParserParserQUARTER, DorisParserParserRANDOM, DorisParserParserRECENT, DorisParserParserRECOVER, DorisParserParserRECYCLE, DorisParserParserREFRESH, DorisParserParserREPEATABLE, DorisParserParserREPLACE, DorisParserParserREPLACE_IF_NOT_NULL, DorisParserParserREPLAYER, DorisParserParserREPOSITORIES, DorisParserParserREPOSITORY, DorisParserParserRESOURCE, DorisParserParserRESOURCES, DorisParserParserRESTORE, DorisParserParserRESTRICTIVE, DorisParserParserRESUME, DorisParserParserRETAIN, DorisParserParserRETENTION, DorisParserParserRETURNS, DorisParserParserREWRITTEN, DorisParserParserRLIKE, DorisParserParserROLLBACK, DorisParserParserROLLUP, DorisParserParserROUTINE, DorisParserParserS3, DorisParserParserSAMPLE, DorisParserParserSCHEDULE, DorisParserParserSCHEDULER, DorisParserParserSCHEMA, DorisParserParserSECOND, DorisParserParserSERIALIZABLE, DorisParserParserSESSION, DorisParserParserSESSION_USER, DorisParserParserSET_SESSION_VARIABLE, DorisParserParserSHAPE, DorisParserParserSKEW, DorisParserParserSNAPSHOT, DorisParserParserSNAPSHOTS, DorisParserParserSONAME, DorisParserParserSPLIT, DorisParserParserSQL, DorisParserParserSTAGE, DorisParserParserSTAGES, DorisParserParserSTART, DorisParserParserSTARTS, DorisParserParserSTATS, DorisParserParserSTATUS, DorisParserParserSTOP, DorisParserParserSTORAGE, DorisParserParserSTREAM, DorisParserParserSTREAMING, DorisParserParserSTRING, DorisParserParserSTRUCT, DorisParserParserSUM, DorisParserParserTABLES, DorisParserParserTAG, DorisParserParserTASK, DorisParserParserTASKS, DorisParserParserTEMPORARY, DorisParserParserTEXT, DorisParserParserTHAN, DorisParserParserTIME, DorisParserParserTIMESTAMP, DorisParserParserTRANSACTION, DorisParserParserTREE, DorisParserParserTRIGGERS, DorisParserParserTRUNCATE, DorisParserParserTYPE, DorisParserParserTYPES, DorisParserParserUNCOMMITTED, DorisParserParserUNLOCK, DorisParserParserUNSET, DorisParserParserUP, DorisParserParserUSER, DorisParserParserVALUE, DorisParserParserVARCHAR, DorisParserParserVARIABLE, DorisParserParserVARIABLES, DorisParserParserVARIANT, DorisParserParserVAULT, DorisParserParserVAULTS, DorisParserParserVERBOSE, DorisParserParserVERSION, DorisParserParserVIEW, DorisParserParserVIEWS, DorisParserParserWARM, DorisParserParserWARNINGS, DorisParserParserWEEK, DorisParserParserWORK, DorisParserParserYEAR, DorisParserParserHINT_START, DorisParserParserHINT_END, DorisParserParserCOMMENT_START, DorisParserParserIDENTIFIER, DorisParserParserBACKQUOTED_IDENTIFIER:
			{
				p.SetState(3913)

				var _x = p.MultipartIdentifier()

				localctx.(*ShowAnalyzeContext).tableName = _x
			}

		case DorisParserParserEOF, DorisParserParserSEMICOLON, DorisParserParserWHERE:

		default:
		}
		p.SetState(3921)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserWHERE {
			{
				p.SetState(3916)
				p.Match(DorisParserParserWHERE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			{
				p.SetState(3917)

				var _x = p.Identifier()

				localctx.(*ShowAnalyzeContext).stateKey = _x
			}

			{
				p.SetState(3918)
				p.Match(DorisParserParserEQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			{
				p.SetState(3919)

				var _m = p.Match(DorisParserParserSTRING_LITERAL)

				localctx.(*ShowAnalyzeContext).stateValue = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 2:
		localctx = NewShowQueuedAnalyzeJobsContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3923)
			p.Match(DorisParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3924)
			p.Match(DorisParserParserQUEUED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3925)
			p.Match(DorisParserParserANALYZE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3926)
			p.Match(DorisParserParserJOBS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3928)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-2305902462020672000) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&4609989332399152113) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-9080794533051819547) != 0) || ((int64((_la-192)) & ^0x3f) == 0 && ((int64(1)<<(_la-192))&2015220189171012521) != 0) || ((int64((_la-256)) & ^0x3f) == 0 && ((int64(1)<<(_la-256))&-5422616543060085911) != 0) || ((int64((_la-320)) & ^0x3f) == 0 && ((int64(1)<<(_la-320))&-4476015178520986877) != 0) || ((int64((_la-384)) & ^0x3f) == 0 && ((int64(1)<<(_la-384))&9222796779122679803) != 0) || ((int64((_la-452)) & ^0x3f) == 0 && ((int64(1)<<(_la-452))&2449945648119953137) != 0) || ((int64((_la-517)) & ^0x3f) == 0 && ((int64(1)<<(_la-517))&206187790337) != 0) {
			{
				p.SetState(3927)

				var _x = p.MultipartIdentifier()

				localctx.(*ShowQueuedAnalyzeJobsContext).tableName = _x
			}

		}
		p.SetState(3935)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserWHERE {
			{
				p.SetState(3930)
				p.Match(DorisParserParserWHERE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			{
				p.SetState(3931)

				var _x = p.Identifier()

				localctx.(*ShowQueuedAnalyzeJobsContext).stateKey = _x
			}

			{
				p.SetState(3932)
				p.Match(DorisParserParserEQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			{
				p.SetState(3933)

				var _m = p.Match(DorisParserParserSTRING_LITERAL)

				localctx.(*ShowQueuedAnalyzeJobsContext).stateValue = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 3:
		localctx = NewShowColumnHistogramStatsContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3937)
			p.Match(DorisParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3938)
			p.Match(DorisParserParserCOLUMN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3939)
			p.Match(DorisParserParserHISTOGRAM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3940)

			var _x = p.MultipartIdentifier()

			localctx.(*ShowColumnHistogramStatsContext).tableName = _x
		}
		{
			p.SetState(3941)

			var _x = p.IdentifierList()

			localctx.(*ShowColumnHistogramStatsContext).columnList = _x
		}

	case 4:
		localctx = NewAnalyzeDatabaseContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3943)
			p.Match(DorisParserParserANALYZE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3944)
			p.Match(DorisParserParserDATABASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3945)

			var _x = p.MultipartIdentifier()

			localctx.(*AnalyzeDatabaseContext).name = _x
		}
		p.SetState(3950)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserParserWITH {
			{
				p.SetState(3946)
				p.Match(DorisParserParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3947)
				p.AnalyzeProperties()
			}

			p.SetState(3952)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(3954)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserPROPERTIES {
			{
				p.SetState(3953)
				p.PropertyClause()
			}

		}

	case 5:
		localctx = NewAnalyzeTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(3956)
			p.Match(DorisParserParserANALYZE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3957)
			p.Match(DorisParserParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3958)

			var _x = p.MultipartIdentifier()

			localctx.(*AnalyzeTableContext).name = _x
		}
		p.SetState(3960)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserPARTITION || _la == DorisParserParserPARTITIONS || _la == DorisParserParserTEMPORARY {
			{
				p.SetState(3959)
				p.PartitionSpec()
			}

		}
		p.SetState(3963)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserLEFT_PAREN {
			{
				p.SetState(3962)

				var _x = p.IdentifierList()

				localctx.(*AnalyzeTableContext).columns = _x
			}

		}
		p.SetState(3969)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserParserWITH {
			{
				p.SetState(3965)
				p.Match(DorisParserParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3966)
				p.AnalyzeProperties()
			}

			p.SetState(3971)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(3973)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserPROPERTIES {
			{
				p.SetState(3972)
				p.PropertyClause()
			}

		}

	case 6:
		localctx = NewAlterTableStatsContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(3975)
			p.Match(DorisParserParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3976)
			p.Match(DorisParserParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3977)

			var _x = p.MultipartIdentifier()

			localctx.(*AlterTableStatsContext).name = _x
		}
		{
			p.SetState(3978)
			p.Match(DorisParserParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3979)
			p.Match(DorisParserParserSTATS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3980)
			p.Match(DorisParserParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3981)
			p.PropertyItemList()
		}
		{
			p.SetState(3982)
			p.Match(DorisParserParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3984)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserPARTITION || _la == DorisParserParserPARTITIONS || _la == DorisParserParserTEMPORARY {
			{
				p.SetState(3983)
				p.PartitionSpec()
			}

		}

	case 7:
		localctx = NewAlterColumnStatsContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(3986)
			p.Match(DorisParserParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3987)
			p.Match(DorisParserParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3988)

			var _x = p.MultipartIdentifier()

			localctx.(*AlterColumnStatsContext).name = _x
		}
		p.SetState(3991)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserINDEX {
			{
				p.SetState(3989)
				p.Match(DorisParserParserINDEX)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3990)

				var _x = p.Identifier()

				localctx.(*AlterColumnStatsContext).indexName = _x
			}

		}
		{
			p.SetState(3993)
			p.Match(DorisParserParserMODIFY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3994)
			p.Match(DorisParserParserCOLUMN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3995)

			var _x = p.Identifier()

			localctx.(*AlterColumnStatsContext).columnName = _x
		}
		{
			p.SetState(3996)
			p.Match(DorisParserParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3997)
			p.Match(DorisParserParserSTATS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3998)
			p.Match(DorisParserParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3999)
			p.PropertyItemList()
		}
		{
			p.SetState(4000)
			p.Match(DorisParserParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4002)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserPARTITION || _la == DorisParserParserPARTITIONS || _la == DorisParserParserTEMPORARY {
			{
				p.SetState(4001)
				p.PartitionSpec()
			}

		}

	case 8:
		localctx = NewShowIndexStatsContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(4004)
			p.Match(DorisParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4005)
			p.Match(DorisParserParserINDEX)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4006)
			p.Match(DorisParserParserSTATS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4007)

			var _x = p.MultipartIdentifier()

			localctx.(*ShowIndexStatsContext).tableName = _x
		}
		{
			p.SetState(4008)

			var _x = p.Identifier()

			localctx.(*ShowIndexStatsContext).indexId = _x
		}

	case 9:
		localctx = NewDropStatsContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(4010)
			p.Match(DorisParserParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4011)
			p.Match(DorisParserParserSTATS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4012)

			var _x = p.MultipartIdentifier()

			localctx.(*DropStatsContext).tableName = _x
		}
		p.SetState(4014)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserLEFT_PAREN {
			{
				p.SetState(4013)

				var _x = p.IdentifierList()

				localctx.(*DropStatsContext).columns = _x
			}

		}
		p.SetState(4017)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserPARTITION || _la == DorisParserParserPARTITIONS || _la == DorisParserParserTEMPORARY {
			{
				p.SetState(4016)
				p.PartitionSpec()
			}

		}

	case 10:
		localctx = NewDropCachedStatsContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(4019)
			p.Match(DorisParserParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4020)
			p.Match(DorisParserParserCACHED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4021)
			p.Match(DorisParserParserSTATS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4022)

			var _x = p.MultipartIdentifier()

			localctx.(*DropCachedStatsContext).tableName = _x
		}

	case 11:
		localctx = NewDropExpiredStatsContext(p, localctx)
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(4023)
			p.Match(DorisParserParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4024)
			p.Match(DorisParserParserEXPIRED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4025)
			p.Match(DorisParserParserSTATS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 12:
		localctx = NewKillAnalyzeJobContext(p, localctx)
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(4026)
			p.Match(DorisParserParserKILL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4027)
			p.Match(DorisParserParserANALYZE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4028)

			var _m = p.Match(DorisParserParserINTEGER_VALUE)

			localctx.(*KillAnalyzeJobContext).jobId = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 13:
		localctx = NewDropAnalyzeJobContext(p, localctx)
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(4029)
			p.Match(DorisParserParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4030)
			p.Match(DorisParserParserANALYZE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4031)
			p.Match(DorisParserParserJOB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4032)
			p.Match(DorisParserParserINTEGER_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 14:
		localctx = NewShowTableStatsContext(p, localctx)
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(4033)
			p.Match(DorisParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4034)
			p.Match(DorisParserParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4035)
			p.Match(DorisParserParserSTATS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4036)

			var _x = p.MultipartIdentifier()

			localctx.(*ShowTableStatsContext).tableName = _x
		}
		p.SetState(4038)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserPARTITION || _la == DorisParserParserPARTITIONS || _la == DorisParserParserTEMPORARY {
			{
				p.SetState(4037)
				p.PartitionSpec()
			}

		}
		p.SetState(4041)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserLEFT_PAREN {
			{
				p.SetState(4040)

				var _x = p.IdentifierList()

				localctx.(*ShowTableStatsContext).columnList = _x
			}

		}

	case 15:
		localctx = NewShowTableStatsContext(p, localctx)
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(4043)
			p.Match(DorisParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4044)
			p.Match(DorisParserParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4045)
			p.Match(DorisParserParserSTATS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4046)

			var _m = p.Match(DorisParserParserINTEGER_VALUE)

			localctx.(*ShowTableStatsContext).tableId = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnsupportedStatsStatementContext is an interface to support dynamic dispatch.
type IUnsupportedStatsStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsUnsupportedStatsStatementContext differentiates from other interfaces.
	IsUnsupportedStatsStatementContext()
}

type UnsupportedStatsStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnsupportedStatsStatementContext() *UnsupportedStatsStatementContext {
	var p = new(UnsupportedStatsStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_unsupportedStatsStatement
	return p
}

func InitEmptyUnsupportedStatsStatementContext(p *UnsupportedStatsStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_unsupportedStatsStatement
}

func (*UnsupportedStatsStatementContext) IsUnsupportedStatsStatementContext() {}

func NewUnsupportedStatsStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnsupportedStatsStatementContext {
	var p = new(UnsupportedStatsStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_unsupportedStatsStatement

	return p
}

func (s *UnsupportedStatsStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *UnsupportedStatsStatementContext) CopyAll(ctx *UnsupportedStatsStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *UnsupportedStatsStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnsupportedStatsStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ShowColumnStatsContext struct {
	UnsupportedStatsStatementContext
	tableName  IMultipartIdentifierContext
	columnList IIdentifierListContext
}

func NewShowColumnStatsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowColumnStatsContext {
	var p = new(ShowColumnStatsContext)

	InitEmptyUnsupportedStatsStatementContext(&p.UnsupportedStatsStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedStatsStatementContext))

	return p
}

func (s *ShowColumnStatsContext) GetTableName() IMultipartIdentifierContext { return s.tableName }

func (s *ShowColumnStatsContext) GetColumnList() IIdentifierListContext { return s.columnList }

func (s *ShowColumnStatsContext) SetTableName(v IMultipartIdentifierContext) { s.tableName = v }

func (s *ShowColumnStatsContext) SetColumnList(v IIdentifierListContext) { s.columnList = v }

func (s *ShowColumnStatsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowColumnStatsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSHOW, 0)
}

func (s *ShowColumnStatsContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOLUMN, 0)
}

func (s *ShowColumnStatsContext) STATS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTATS, 0)
}

func (s *ShowColumnStatsContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ShowColumnStatsContext) CACHED() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCACHED, 0)
}

func (s *ShowColumnStatsContext) PartitionSpec() IPartitionSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionSpecContext)
}

func (s *ShowColumnStatsContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *ShowColumnStatsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitShowColumnStats(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShowAnalyzeTaskContext struct {
	UnsupportedStatsStatementContext
	jobId antlr.Token
}

func NewShowAnalyzeTaskContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowAnalyzeTaskContext {
	var p = new(ShowAnalyzeTaskContext)

	InitEmptyUnsupportedStatsStatementContext(&p.UnsupportedStatsStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnsupportedStatsStatementContext))

	return p
}

func (s *ShowAnalyzeTaskContext) GetJobId() antlr.Token { return s.jobId }

func (s *ShowAnalyzeTaskContext) SetJobId(v antlr.Token) { s.jobId = v }

func (s *ShowAnalyzeTaskContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowAnalyzeTaskContext) SHOW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSHOW, 0)
}

func (s *ShowAnalyzeTaskContext) ANALYZE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserANALYZE, 0)
}

func (s *ShowAnalyzeTaskContext) TASK() antlr.TerminalNode {
	return s.GetToken(DorisParserParserTASK, 0)
}

func (s *ShowAnalyzeTaskContext) STATUS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTATUS, 0)
}

func (s *ShowAnalyzeTaskContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserINTEGER_VALUE, 0)
}

func (s *ShowAnalyzeTaskContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitShowAnalyzeTask(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) UnsupportedStatsStatement() (localctx IUnsupportedStatsStatementContext) {
	localctx = NewUnsupportedStatsStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, DorisParserParserRULE_unsupportedStatsStatement)
	var _la int

	p.SetState(4067)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 558, p.GetParserRuleContext()) {
	case 1:
		localctx = NewShowColumnStatsContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4049)
			p.Match(DorisParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4050)
			p.Match(DorisParserParserCOLUMN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4052)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserCACHED {
			{
				p.SetState(4051)
				p.Match(DorisParserParserCACHED)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4054)
			p.Match(DorisParserParserSTATS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4055)

			var _x = p.MultipartIdentifier()

			localctx.(*ShowColumnStatsContext).tableName = _x
		}
		p.SetState(4057)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserLEFT_PAREN {
			{
				p.SetState(4056)

				var _x = p.IdentifierList()

				localctx.(*ShowColumnStatsContext).columnList = _x
			}

		}
		p.SetState(4060)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserPARTITION || _la == DorisParserParserPARTITIONS || _la == DorisParserParserTEMPORARY {
			{
				p.SetState(4059)
				p.PartitionSpec()
			}

		}

	case 2:
		localctx = NewShowAnalyzeTaskContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4062)
			p.Match(DorisParserParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4063)
			p.Match(DorisParserParserANALYZE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4064)
			p.Match(DorisParserParserTASK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4065)
			p.Match(DorisParserParserSTATUS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4066)

			var _m = p.Match(DorisParserParserINTEGER_VALUE)

			localctx.(*ShowAnalyzeTaskContext).jobId = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAnalyzePropertiesContext is an interface to support dynamic dispatch.
type IAnalyzePropertiesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetRows returns the rows token.
	GetRows() antlr.Token

	// GetPercent returns the percent token.
	GetPercent() antlr.Token

	// GetBucket returns the bucket token.
	GetBucket() antlr.Token

	// GetPeriodInSecond returns the periodInSecond token.
	GetPeriodInSecond() antlr.Token

	// GetCrontabExpr returns the crontabExpr token.
	GetCrontabExpr() antlr.Token

	// SetRows sets the rows token.
	SetRows(antlr.Token)

	// SetPercent sets the percent token.
	SetPercent(antlr.Token)

	// SetBucket sets the bucket token.
	SetBucket(antlr.Token)

	// SetPeriodInSecond sets the periodInSecond token.
	SetPeriodInSecond(antlr.Token)

	// SetCrontabExpr sets the crontabExpr token.
	SetCrontabExpr(antlr.Token)

	// Getter signatures
	SYNC() antlr.TerminalNode
	INCREMENTAL() antlr.TerminalNode
	FULL() antlr.TerminalNode
	SQL() antlr.TerminalNode
	HISTOGRAM() antlr.TerminalNode
	SAMPLE() antlr.TerminalNode
	ROWS() antlr.TerminalNode
	PERCENT() antlr.TerminalNode
	INTEGER_VALUE() antlr.TerminalNode
	BUCKETS() antlr.TerminalNode
	PERIOD() antlr.TerminalNode
	CRON() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode

	// IsAnalyzePropertiesContext differentiates from other interfaces.
	IsAnalyzePropertiesContext()
}

type AnalyzePropertiesContext struct {
	antlr.BaseParserRuleContext
	parser         antlr.Parser
	rows           antlr.Token
	percent        antlr.Token
	bucket         antlr.Token
	periodInSecond antlr.Token
	crontabExpr    antlr.Token
}

func NewEmptyAnalyzePropertiesContext() *AnalyzePropertiesContext {
	var p = new(AnalyzePropertiesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_analyzeProperties
	return p
}

func InitEmptyAnalyzePropertiesContext(p *AnalyzePropertiesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_analyzeProperties
}

func (*AnalyzePropertiesContext) IsAnalyzePropertiesContext() {}

func NewAnalyzePropertiesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnalyzePropertiesContext {
	var p = new(AnalyzePropertiesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_analyzeProperties

	return p
}

func (s *AnalyzePropertiesContext) GetParser() antlr.Parser { return s.parser }

func (s *AnalyzePropertiesContext) GetRows() antlr.Token { return s.rows }

func (s *AnalyzePropertiesContext) GetPercent() antlr.Token { return s.percent }

func (s *AnalyzePropertiesContext) GetBucket() antlr.Token { return s.bucket }

func (s *AnalyzePropertiesContext) GetPeriodInSecond() antlr.Token { return s.periodInSecond }

func (s *AnalyzePropertiesContext) GetCrontabExpr() antlr.Token { return s.crontabExpr }

func (s *AnalyzePropertiesContext) SetRows(v antlr.Token) { s.rows = v }

func (s *AnalyzePropertiesContext) SetPercent(v antlr.Token) { s.percent = v }

func (s *AnalyzePropertiesContext) SetBucket(v antlr.Token) { s.bucket = v }

func (s *AnalyzePropertiesContext) SetPeriodInSecond(v antlr.Token) { s.periodInSecond = v }

func (s *AnalyzePropertiesContext) SetCrontabExpr(v antlr.Token) { s.crontabExpr = v }

func (s *AnalyzePropertiesContext) SYNC() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSYNC, 0)
}

func (s *AnalyzePropertiesContext) INCREMENTAL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserINCREMENTAL, 0)
}

func (s *AnalyzePropertiesContext) FULL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFULL, 0)
}

func (s *AnalyzePropertiesContext) SQL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSQL, 0)
}

func (s *AnalyzePropertiesContext) HISTOGRAM() antlr.TerminalNode {
	return s.GetToken(DorisParserParserHISTOGRAM, 0)
}

func (s *AnalyzePropertiesContext) SAMPLE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSAMPLE, 0)
}

func (s *AnalyzePropertiesContext) ROWS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserROWS, 0)
}

func (s *AnalyzePropertiesContext) PERCENT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserPERCENT, 0)
}

func (s *AnalyzePropertiesContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserINTEGER_VALUE, 0)
}

func (s *AnalyzePropertiesContext) BUCKETS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserBUCKETS, 0)
}

func (s *AnalyzePropertiesContext) PERIOD() antlr.TerminalNode {
	return s.GetToken(DorisParserParserPERIOD, 0)
}

func (s *AnalyzePropertiesContext) CRON() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCRON, 0)
}

func (s *AnalyzePropertiesContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTRING_LITERAL, 0)
}

func (s *AnalyzePropertiesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnalyzePropertiesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnalyzePropertiesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitAnalyzeProperties(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) AnalyzeProperties() (localctx IAnalyzePropertiesContext) {
	localctx = NewAnalyzePropertiesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, DorisParserParserRULE_analyzeProperties)
	p.SetState(4087)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserParserSYNC:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4069)
			p.Match(DorisParserParserSYNC)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserParserINCREMENTAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4070)
			p.Match(DorisParserParserINCREMENTAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserParserFULL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4071)
			p.Match(DorisParserParserFULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserParserSQL:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4072)
			p.Match(DorisParserParserSQL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserParserHISTOGRAM:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4073)
			p.Match(DorisParserParserHISTOGRAM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserParserSAMPLE:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(4074)
			p.Match(DorisParserParserSAMPLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4079)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserParserROWS:
			{
				p.SetState(4075)
				p.Match(DorisParserParserROWS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4076)

				var _m = p.Match(DorisParserParserINTEGER_VALUE)

				localctx.(*AnalyzePropertiesContext).rows = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserParserPERCENT:
			{
				p.SetState(4077)
				p.Match(DorisParserParserPERCENT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4078)

				var _m = p.Match(DorisParserParserINTEGER_VALUE)

				localctx.(*AnalyzePropertiesContext).percent = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case DorisParserParserBUCKETS:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(4081)
			p.Match(DorisParserParserBUCKETS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4082)

			var _m = p.Match(DorisParserParserINTEGER_VALUE)

			localctx.(*AnalyzePropertiesContext).bucket = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserParserPERIOD:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(4083)
			p.Match(DorisParserParserPERIOD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4084)

			var _m = p.Match(DorisParserParserINTEGER_VALUE)

			localctx.(*AnalyzePropertiesContext).periodInSecond = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserParserCRON:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(4085)
			p.Match(DorisParserParserCRON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4086)

			var _m = p.Match(DorisParserParserSTRING_LITERAL)

			localctx.(*AnalyzePropertiesContext).crontabExpr = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWorkloadPolicyActionsContext is an interface to support dynamic dispatch.
type IWorkloadPolicyActionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllWorkloadPolicyAction() []IWorkloadPolicyActionContext
	WorkloadPolicyAction(i int) IWorkloadPolicyActionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsWorkloadPolicyActionsContext differentiates from other interfaces.
	IsWorkloadPolicyActionsContext()
}

type WorkloadPolicyActionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWorkloadPolicyActionsContext() *WorkloadPolicyActionsContext {
	var p = new(WorkloadPolicyActionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_workloadPolicyActions
	return p
}

func InitEmptyWorkloadPolicyActionsContext(p *WorkloadPolicyActionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_workloadPolicyActions
}

func (*WorkloadPolicyActionsContext) IsWorkloadPolicyActionsContext() {}

func NewWorkloadPolicyActionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WorkloadPolicyActionsContext {
	var p = new(WorkloadPolicyActionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_workloadPolicyActions

	return p
}

func (s *WorkloadPolicyActionsContext) GetParser() antlr.Parser { return s.parser }

func (s *WorkloadPolicyActionsContext) AllWorkloadPolicyAction() []IWorkloadPolicyActionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IWorkloadPolicyActionContext); ok {
			len++
		}
	}

	tst := make([]IWorkloadPolicyActionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IWorkloadPolicyActionContext); ok {
			tst[i] = t.(IWorkloadPolicyActionContext)
			i++
		}
	}

	return tst
}

func (s *WorkloadPolicyActionsContext) WorkloadPolicyAction(i int) IWorkloadPolicyActionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWorkloadPolicyActionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWorkloadPolicyActionContext)
}

func (s *WorkloadPolicyActionsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserCOMMA)
}

func (s *WorkloadPolicyActionsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOMMA, i)
}

func (s *WorkloadPolicyActionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WorkloadPolicyActionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WorkloadPolicyActionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitWorkloadPolicyActions(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) WorkloadPolicyActions() (localctx IWorkloadPolicyActionsContext) {
	localctx = NewWorkloadPolicyActionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, DorisParserParserRULE_workloadPolicyActions)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4089)
		p.WorkloadPolicyAction()
	}
	p.SetState(4094)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisParserParserCOMMA {
		{
			p.SetState(4090)
			p.Match(DorisParserParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4091)
			p.WorkloadPolicyAction()
		}

		p.SetState(4096)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWorkloadPolicyActionContext is an interface to support dynamic dispatch.
type IWorkloadPolicyActionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SET_SESSION_VARIABLE() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsWorkloadPolicyActionContext differentiates from other interfaces.
	IsWorkloadPolicyActionContext()
}

type WorkloadPolicyActionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWorkloadPolicyActionContext() *WorkloadPolicyActionContext {
	var p = new(WorkloadPolicyActionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_workloadPolicyAction
	return p
}

func InitEmptyWorkloadPolicyActionContext(p *WorkloadPolicyActionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_workloadPolicyAction
}

func (*WorkloadPolicyActionContext) IsWorkloadPolicyActionContext() {}

func NewWorkloadPolicyActionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WorkloadPolicyActionContext {
	var p = new(WorkloadPolicyActionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_workloadPolicyAction

	return p
}

func (s *WorkloadPolicyActionContext) GetParser() antlr.Parser { return s.parser }

func (s *WorkloadPolicyActionContext) SET_SESSION_VARIABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSET_SESSION_VARIABLE, 0)
}

func (s *WorkloadPolicyActionContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTRING_LITERAL, 0)
}

func (s *WorkloadPolicyActionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *WorkloadPolicyActionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WorkloadPolicyActionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WorkloadPolicyActionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitWorkloadPolicyAction(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) WorkloadPolicyAction() (localctx IWorkloadPolicyActionContext) {
	localctx = NewWorkloadPolicyActionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, DorisParserParserRULE_workloadPolicyAction)
	var _la int

	p.SetState(4103)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 563, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4097)
			p.Match(DorisParserParserSET_SESSION_VARIABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4098)
			p.Match(DorisParserParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4099)
			p.Identifier()
		}
		p.SetState(4101)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserSTRING_LITERAL {
			{
				p.SetState(4100)
				p.Match(DorisParserParserSTRING_LITERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWorkloadPolicyConditionsContext is an interface to support dynamic dispatch.
type IWorkloadPolicyConditionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllWorkloadPolicyCondition() []IWorkloadPolicyConditionContext
	WorkloadPolicyCondition(i int) IWorkloadPolicyConditionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsWorkloadPolicyConditionsContext differentiates from other interfaces.
	IsWorkloadPolicyConditionsContext()
}

type WorkloadPolicyConditionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWorkloadPolicyConditionsContext() *WorkloadPolicyConditionsContext {
	var p = new(WorkloadPolicyConditionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_workloadPolicyConditions
	return p
}

func InitEmptyWorkloadPolicyConditionsContext(p *WorkloadPolicyConditionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_workloadPolicyConditions
}

func (*WorkloadPolicyConditionsContext) IsWorkloadPolicyConditionsContext() {}

func NewWorkloadPolicyConditionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WorkloadPolicyConditionsContext {
	var p = new(WorkloadPolicyConditionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_workloadPolicyConditions

	return p
}

func (s *WorkloadPolicyConditionsContext) GetParser() antlr.Parser { return s.parser }

func (s *WorkloadPolicyConditionsContext) AllWorkloadPolicyCondition() []IWorkloadPolicyConditionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IWorkloadPolicyConditionContext); ok {
			len++
		}
	}

	tst := make([]IWorkloadPolicyConditionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IWorkloadPolicyConditionContext); ok {
			tst[i] = t.(IWorkloadPolicyConditionContext)
			i++
		}
	}

	return tst
}

func (s *WorkloadPolicyConditionsContext) WorkloadPolicyCondition(i int) IWorkloadPolicyConditionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWorkloadPolicyConditionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWorkloadPolicyConditionContext)
}

func (s *WorkloadPolicyConditionsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserCOMMA)
}

func (s *WorkloadPolicyConditionsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOMMA, i)
}

func (s *WorkloadPolicyConditionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WorkloadPolicyConditionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WorkloadPolicyConditionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitWorkloadPolicyConditions(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) WorkloadPolicyConditions() (localctx IWorkloadPolicyConditionsContext) {
	localctx = NewWorkloadPolicyConditionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, DorisParserParserRULE_workloadPolicyConditions)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4105)
		p.WorkloadPolicyCondition()
	}
	p.SetState(4110)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisParserParserCOMMA {
		{
			p.SetState(4106)
			p.Match(DorisParserParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4107)
			p.WorkloadPolicyCondition()
		}

		p.SetState(4112)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWorkloadPolicyConditionContext is an interface to support dynamic dispatch.
type IWorkloadPolicyConditionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetMetricName returns the metricName rule contexts.
	GetMetricName() IIdentifierContext

	// SetMetricName sets the metricName rule contexts.
	SetMetricName(IIdentifierContext)

	// Getter signatures
	ComparisonOperator() IComparisonOperatorContext
	Identifier() IIdentifierContext
	Number() INumberContext
	STRING_LITERAL() antlr.TerminalNode

	// IsWorkloadPolicyConditionContext differentiates from other interfaces.
	IsWorkloadPolicyConditionContext()
}

type WorkloadPolicyConditionContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	metricName IIdentifierContext
}

func NewEmptyWorkloadPolicyConditionContext() *WorkloadPolicyConditionContext {
	var p = new(WorkloadPolicyConditionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_workloadPolicyCondition
	return p
}

func InitEmptyWorkloadPolicyConditionContext(p *WorkloadPolicyConditionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_workloadPolicyCondition
}

func (*WorkloadPolicyConditionContext) IsWorkloadPolicyConditionContext() {}

func NewWorkloadPolicyConditionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WorkloadPolicyConditionContext {
	var p = new(WorkloadPolicyConditionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_workloadPolicyCondition

	return p
}

func (s *WorkloadPolicyConditionContext) GetParser() antlr.Parser { return s.parser }

func (s *WorkloadPolicyConditionContext) GetMetricName() IIdentifierContext { return s.metricName }

func (s *WorkloadPolicyConditionContext) SetMetricName(v IIdentifierContext) { s.metricName = v }

func (s *WorkloadPolicyConditionContext) ComparisonOperator() IComparisonOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComparisonOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComparisonOperatorContext)
}

func (s *WorkloadPolicyConditionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *WorkloadPolicyConditionContext) Number() INumberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *WorkloadPolicyConditionContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTRING_LITERAL, 0)
}

func (s *WorkloadPolicyConditionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WorkloadPolicyConditionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WorkloadPolicyConditionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitWorkloadPolicyCondition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) WorkloadPolicyCondition() (localctx IWorkloadPolicyConditionContext) {
	localctx = NewWorkloadPolicyConditionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, DorisParserParserRULE_workloadPolicyCondition)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4113)

		var _x = p.Identifier()

		localctx.(*WorkloadPolicyConditionContext).metricName = _x
	}
	{
		p.SetState(4114)
		p.ComparisonOperator()
	}
	p.SetState(4117)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserParserSUBTRACT, DorisParserParserINTEGER_VALUE, DorisParserParserEXPONENT_VALUE, DorisParserParserDECIMAL_VALUE:
		{
			p.SetState(4115)
			p.Number()
		}

	case DorisParserParserSTRING_LITERAL:
		{
			p.SetState(4116)
			p.Match(DorisParserParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStorageBackendContext is an interface to support dynamic dispatch.
type IStorageBackendContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetBrokerName returns the brokerName rule contexts.
	GetBrokerName() IIdentifierContext

	// GetProperties returns the properties rule contexts.
	GetProperties() IPropertyClauseContext

	// SetBrokerName sets the brokerName rule contexts.
	SetBrokerName(IIdentifierContext)

	// SetProperties sets the properties rule contexts.
	SetProperties(IPropertyClauseContext)

	// Getter signatures
	ON() antlr.TerminalNode
	LOCATION() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode
	BROKER() antlr.TerminalNode
	S3() antlr.TerminalNode
	HDFS() antlr.TerminalNode
	LOCAL() antlr.TerminalNode
	Identifier() IIdentifierContext
	PropertyClause() IPropertyClauseContext

	// IsStorageBackendContext differentiates from other interfaces.
	IsStorageBackendContext()
}

type StorageBackendContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	brokerName IIdentifierContext
	properties IPropertyClauseContext
}

func NewEmptyStorageBackendContext() *StorageBackendContext {
	var p = new(StorageBackendContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_storageBackend
	return p
}

func InitEmptyStorageBackendContext(p *StorageBackendContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_storageBackend
}

func (*StorageBackendContext) IsStorageBackendContext() {}

func NewStorageBackendContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StorageBackendContext {
	var p = new(StorageBackendContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_storageBackend

	return p
}

func (s *StorageBackendContext) GetParser() antlr.Parser { return s.parser }

func (s *StorageBackendContext) GetBrokerName() IIdentifierContext { return s.brokerName }

func (s *StorageBackendContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *StorageBackendContext) SetBrokerName(v IIdentifierContext) { s.brokerName = v }

func (s *StorageBackendContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *StorageBackendContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisParserParserON, 0)
}

func (s *StorageBackendContext) LOCATION() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLOCATION, 0)
}

func (s *StorageBackendContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTRING_LITERAL, 0)
}

func (s *StorageBackendContext) BROKER() antlr.TerminalNode {
	return s.GetToken(DorisParserParserBROKER, 0)
}

func (s *StorageBackendContext) S3() antlr.TerminalNode {
	return s.GetToken(DorisParserParserS3, 0)
}

func (s *StorageBackendContext) HDFS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserHDFS, 0)
}

func (s *StorageBackendContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLOCAL, 0)
}

func (s *StorageBackendContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *StorageBackendContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *StorageBackendContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StorageBackendContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StorageBackendContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitStorageBackend(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) StorageBackend() (localctx IStorageBackendContext) {
	localctx = NewStorageBackendContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, DorisParserParserRULE_storageBackend)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4119)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisParserParserBROKER || _la == DorisParserParserHDFS || _la == DorisParserParserLOCAL || _la == DorisParserParserS3) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(4121)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-2305902462020672000) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&4609989332399152113) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-9080794533051819547) != 0) || ((int64((_la-192)) & ^0x3f) == 0 && ((int64(1)<<(_la-192))&2015220189171012521) != 0) || ((int64((_la-256)) & ^0x3f) == 0 && ((int64(1)<<(_la-256))&-5422616543060085911) != 0) || ((int64((_la-320)) & ^0x3f) == 0 && ((int64(1)<<(_la-320))&-4476015178520986877) != 0) || ((int64((_la-384)) & ^0x3f) == 0 && ((int64(1)<<(_la-384))&9222796779122679803) != 0) || ((int64((_la-452)) & ^0x3f) == 0 && ((int64(1)<<(_la-452))&2449945648119953137) != 0) || ((int64((_la-517)) & ^0x3f) == 0 && ((int64(1)<<(_la-517))&206187790337) != 0) {
		{
			p.SetState(4120)

			var _x = p.Identifier()

			localctx.(*StorageBackendContext).brokerName = _x
		}

	}
	{
		p.SetState(4123)
		p.Match(DorisParserParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4124)
		p.Match(DorisParserParserLOCATION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4125)
		p.Match(DorisParserParserSTRING_LITERAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4127)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserParserPROPERTIES {
		{
			p.SetState(4126)

			var _x = p.PropertyClause()

			localctx.(*StorageBackendContext).properties = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPasswordOptionContext is an interface to support dynamic dispatch.
type IPasswordOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetHistoryDefault returns the historyDefault token.
	GetHistoryDefault() antlr.Token

	// GetHistoryValue returns the historyValue token.
	GetHistoryValue() antlr.Token

	// GetExpireDefault returns the expireDefault token.
	GetExpireDefault() antlr.Token

	// GetExpireNever returns the expireNever token.
	GetExpireNever() antlr.Token

	// GetExpireValue returns the expireValue token.
	GetExpireValue() antlr.Token

	// GetExpireTimeUnit returns the expireTimeUnit token.
	GetExpireTimeUnit() antlr.Token

	// GetReuseDefault returns the reuseDefault token.
	GetReuseDefault() antlr.Token

	// GetReuseValue returns the reuseValue token.
	GetReuseValue() antlr.Token

	// GetAttemptsValue returns the attemptsValue token.
	GetAttemptsValue() antlr.Token

	// GetLockUnbounded returns the lockUnbounded token.
	GetLockUnbounded() antlr.Token

	// GetLockValue returns the lockValue token.
	GetLockValue() antlr.Token

	// GetLockTimeUint returns the lockTimeUint token.
	GetLockTimeUint() antlr.Token

	// SetHistoryDefault sets the historyDefault token.
	SetHistoryDefault(antlr.Token)

	// SetHistoryValue sets the historyValue token.
	SetHistoryValue(antlr.Token)

	// SetExpireDefault sets the expireDefault token.
	SetExpireDefault(antlr.Token)

	// SetExpireNever sets the expireNever token.
	SetExpireNever(antlr.Token)

	// SetExpireValue sets the expireValue token.
	SetExpireValue(antlr.Token)

	// SetExpireTimeUnit sets the expireTimeUnit token.
	SetExpireTimeUnit(antlr.Token)

	// SetReuseDefault sets the reuseDefault token.
	SetReuseDefault(antlr.Token)

	// SetReuseValue sets the reuseValue token.
	SetReuseValue(antlr.Token)

	// SetAttemptsValue sets the attemptsValue token.
	SetAttemptsValue(antlr.Token)

	// SetLockUnbounded sets the lockUnbounded token.
	SetLockUnbounded(antlr.Token)

	// SetLockValue sets the lockValue token.
	SetLockValue(antlr.Token)

	// SetLockTimeUint sets the lockTimeUint token.
	SetLockTimeUint(antlr.Token)

	// Getter signatures
	PASSWORD_HISTORY() antlr.TerminalNode
	PASSWORD_EXPIRE() antlr.TerminalNode
	PASSWORD_REUSE() antlr.TerminalNode
	AllINTERVAL() []antlr.TerminalNode
	INTERVAL(i int) antlr.TerminalNode
	FAILED_LOGIN_ATTEMPTS() antlr.TerminalNode
	PASSWORD_LOCK_TIME() antlr.TerminalNode
	AllINTEGER_VALUE() []antlr.TerminalNode
	INTEGER_VALUE(i int) antlr.TerminalNode
	ACCOUNT_LOCK() antlr.TerminalNode
	ACCOUNT_UNLOCK() antlr.TerminalNode
	AllDAY() []antlr.TerminalNode
	DAY(i int) antlr.TerminalNode
	AllDEFAULT() []antlr.TerminalNode
	DEFAULT(i int) antlr.TerminalNode
	NEVER() antlr.TerminalNode
	UNBOUNDED() antlr.TerminalNode
	AllHOUR() []antlr.TerminalNode
	HOUR(i int) antlr.TerminalNode
	AllSECOND() []antlr.TerminalNode
	SECOND(i int) antlr.TerminalNode

	// IsPasswordOptionContext differentiates from other interfaces.
	IsPasswordOptionContext()
}

type PasswordOptionContext struct {
	antlr.BaseParserRuleContext
	parser         antlr.Parser
	historyDefault antlr.Token
	historyValue   antlr.Token
	expireDefault  antlr.Token
	expireNever    antlr.Token
	expireValue    antlr.Token
	expireTimeUnit antlr.Token
	reuseDefault   antlr.Token
	reuseValue     antlr.Token
	attemptsValue  antlr.Token
	lockUnbounded  antlr.Token
	lockValue      antlr.Token
	lockTimeUint   antlr.Token
}

func NewEmptyPasswordOptionContext() *PasswordOptionContext {
	var p = new(PasswordOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_passwordOption
	return p
}

func InitEmptyPasswordOptionContext(p *PasswordOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_passwordOption
}

func (*PasswordOptionContext) IsPasswordOptionContext() {}

func NewPasswordOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PasswordOptionContext {
	var p = new(PasswordOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_passwordOption

	return p
}

func (s *PasswordOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *PasswordOptionContext) GetHistoryDefault() antlr.Token { return s.historyDefault }

func (s *PasswordOptionContext) GetHistoryValue() antlr.Token { return s.historyValue }

func (s *PasswordOptionContext) GetExpireDefault() antlr.Token { return s.expireDefault }

func (s *PasswordOptionContext) GetExpireNever() antlr.Token { return s.expireNever }

func (s *PasswordOptionContext) GetExpireValue() antlr.Token { return s.expireValue }

func (s *PasswordOptionContext) GetExpireTimeUnit() antlr.Token { return s.expireTimeUnit }

func (s *PasswordOptionContext) GetReuseDefault() antlr.Token { return s.reuseDefault }

func (s *PasswordOptionContext) GetReuseValue() antlr.Token { return s.reuseValue }

func (s *PasswordOptionContext) GetAttemptsValue() antlr.Token { return s.attemptsValue }

func (s *PasswordOptionContext) GetLockUnbounded() antlr.Token { return s.lockUnbounded }

func (s *PasswordOptionContext) GetLockValue() antlr.Token { return s.lockValue }

func (s *PasswordOptionContext) GetLockTimeUint() antlr.Token { return s.lockTimeUint }

func (s *PasswordOptionContext) SetHistoryDefault(v antlr.Token) { s.historyDefault = v }

func (s *PasswordOptionContext) SetHistoryValue(v antlr.Token) { s.historyValue = v }

func (s *PasswordOptionContext) SetExpireDefault(v antlr.Token) { s.expireDefault = v }

func (s *PasswordOptionContext) SetExpireNever(v antlr.Token) { s.expireNever = v }

func (s *PasswordOptionContext) SetExpireValue(v antlr.Token) { s.expireValue = v }

func (s *PasswordOptionContext) SetExpireTimeUnit(v antlr.Token) { s.expireTimeUnit = v }

func (s *PasswordOptionContext) SetReuseDefault(v antlr.Token) { s.reuseDefault = v }

func (s *PasswordOptionContext) SetReuseValue(v antlr.Token) { s.reuseValue = v }

func (s *PasswordOptionContext) SetAttemptsValue(v antlr.Token) { s.attemptsValue = v }

func (s *PasswordOptionContext) SetLockUnbounded(v antlr.Token) { s.lockUnbounded = v }

func (s *PasswordOptionContext) SetLockValue(v antlr.Token) { s.lockValue = v }

func (s *PasswordOptionContext) SetLockTimeUint(v antlr.Token) { s.lockTimeUint = v }

func (s *PasswordOptionContext) PASSWORD_HISTORY() antlr.TerminalNode {
	return s.GetToken(DorisParserParserPASSWORD_HISTORY, 0)
}

func (s *PasswordOptionContext) PASSWORD_EXPIRE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserPASSWORD_EXPIRE, 0)
}

func (s *PasswordOptionContext) PASSWORD_REUSE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserPASSWORD_REUSE, 0)
}

func (s *PasswordOptionContext) AllINTERVAL() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserINTERVAL)
}

func (s *PasswordOptionContext) INTERVAL(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserINTERVAL, i)
}

func (s *PasswordOptionContext) FAILED_LOGIN_ATTEMPTS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFAILED_LOGIN_ATTEMPTS, 0)
}

func (s *PasswordOptionContext) PASSWORD_LOCK_TIME() antlr.TerminalNode {
	return s.GetToken(DorisParserParserPASSWORD_LOCK_TIME, 0)
}

func (s *PasswordOptionContext) AllINTEGER_VALUE() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserINTEGER_VALUE)
}

func (s *PasswordOptionContext) INTEGER_VALUE(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserINTEGER_VALUE, i)
}

func (s *PasswordOptionContext) ACCOUNT_LOCK() antlr.TerminalNode {
	return s.GetToken(DorisParserParserACCOUNT_LOCK, 0)
}

func (s *PasswordOptionContext) ACCOUNT_UNLOCK() antlr.TerminalNode {
	return s.GetToken(DorisParserParserACCOUNT_UNLOCK, 0)
}

func (s *PasswordOptionContext) AllDAY() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserDAY)
}

func (s *PasswordOptionContext) DAY(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserDAY, i)
}

func (s *PasswordOptionContext) AllDEFAULT() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserDEFAULT)
}

func (s *PasswordOptionContext) DEFAULT(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserDEFAULT, i)
}

func (s *PasswordOptionContext) NEVER() antlr.TerminalNode {
	return s.GetToken(DorisParserParserNEVER, 0)
}

func (s *PasswordOptionContext) UNBOUNDED() antlr.TerminalNode {
	return s.GetToken(DorisParserParserUNBOUNDED, 0)
}

func (s *PasswordOptionContext) AllHOUR() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserHOUR)
}

func (s *PasswordOptionContext) HOUR(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserHOUR, i)
}

func (s *PasswordOptionContext) AllSECOND() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserSECOND)
}

func (s *PasswordOptionContext) SECOND(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserSECOND, i)
}

func (s *PasswordOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PasswordOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PasswordOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitPasswordOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) PasswordOption() (localctx IPasswordOptionContext) {
	localctx = NewPasswordOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, DorisParserParserRULE_passwordOption)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4134)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserParserPASSWORD_HISTORY {
		{
			p.SetState(4129)
			p.Match(DorisParserParserPASSWORD_HISTORY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4132)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserParserDEFAULT:
			{
				p.SetState(4130)

				var _m = p.Match(DorisParserParserDEFAULT)

				localctx.(*PasswordOptionContext).historyDefault = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserParserINTEGER_VALUE:
			{
				p.SetState(4131)

				var _m = p.Match(DorisParserParserINTEGER_VALUE)

				localctx.(*PasswordOptionContext).historyValue = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	}
	p.SetState(4144)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserParserPASSWORD_EXPIRE {
		{
			p.SetState(4136)
			p.Match(DorisParserParserPASSWORD_EXPIRE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4142)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserParserDEFAULT:
			{
				p.SetState(4137)

				var _m = p.Match(DorisParserParserDEFAULT)

				localctx.(*PasswordOptionContext).expireDefault = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserParserNEVER:
			{
				p.SetState(4138)

				var _m = p.Match(DorisParserParserNEVER)

				localctx.(*PasswordOptionContext).expireNever = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserParserINTERVAL:
			{
				p.SetState(4139)
				p.Match(DorisParserParserINTERVAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4140)

				var _m = p.Match(DorisParserParserINTEGER_VALUE)

				localctx.(*PasswordOptionContext).expireValue = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4141)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*PasswordOptionContext).expireTimeUnit = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserParserDAY || _la == DorisParserParserHOUR || _la == DorisParserParserSECOND) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*PasswordOptionContext).expireTimeUnit = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	}
	p.SetState(4153)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserParserPASSWORD_REUSE {
		{
			p.SetState(4146)
			p.Match(DorisParserParserPASSWORD_REUSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4147)
			p.Match(DorisParserParserINTERVAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4151)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserParserDEFAULT:
			{
				p.SetState(4148)

				var _m = p.Match(DorisParserParserDEFAULT)

				localctx.(*PasswordOptionContext).reuseDefault = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserParserINTEGER_VALUE:
			{
				p.SetState(4149)

				var _m = p.Match(DorisParserParserINTEGER_VALUE)

				localctx.(*PasswordOptionContext).reuseValue = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4150)
				p.Match(DorisParserParserDAY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	}
	p.SetState(4157)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserParserFAILED_LOGIN_ATTEMPTS {
		{
			p.SetState(4155)
			p.Match(DorisParserParserFAILED_LOGIN_ATTEMPTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4156)

			var _m = p.Match(DorisParserParserINTEGER_VALUE)

			localctx.(*PasswordOptionContext).attemptsValue = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(4165)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserParserPASSWORD_LOCK_TIME {
		{
			p.SetState(4159)
			p.Match(DorisParserParserPASSWORD_LOCK_TIME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4163)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserParserUNBOUNDED:
			{
				p.SetState(4160)

				var _m = p.Match(DorisParserParserUNBOUNDED)

				localctx.(*PasswordOptionContext).lockUnbounded = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserParserINTEGER_VALUE:
			{
				p.SetState(4161)

				var _m = p.Match(DorisParserParserINTEGER_VALUE)

				localctx.(*PasswordOptionContext).lockValue = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4162)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*PasswordOptionContext).lockTimeUint = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserParserDAY || _la == DorisParserParserHOUR || _la == DorisParserParserSECOND) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*PasswordOptionContext).lockTimeUint = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	}
	p.SetState(4168)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserParserACCOUNT_LOCK || _la == DorisParserParserACCOUNT_UNLOCK {
		{
			p.SetState(4167)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserParserACCOUNT_LOCK || _la == DorisParserParserACCOUNT_UNLOCK) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionArgumentsContext is an interface to support dynamic dispatch.
type IFunctionArgumentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DOTDOTDOT() antlr.TerminalNode
	DataTypeList() IDataTypeListContext
	COMMA() antlr.TerminalNode

	// IsFunctionArgumentsContext differentiates from other interfaces.
	IsFunctionArgumentsContext()
}

type FunctionArgumentsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionArgumentsContext() *FunctionArgumentsContext {
	var p = new(FunctionArgumentsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_functionArguments
	return p
}

func InitEmptyFunctionArgumentsContext(p *FunctionArgumentsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_functionArguments
}

func (*FunctionArgumentsContext) IsFunctionArgumentsContext() {}

func NewFunctionArgumentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionArgumentsContext {
	var p = new(FunctionArgumentsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_functionArguments

	return p
}

func (s *FunctionArgumentsContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionArgumentsContext) DOTDOTDOT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDOTDOTDOT, 0)
}

func (s *FunctionArgumentsContext) DataTypeList() IDataTypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeListContext)
}

func (s *FunctionArgumentsContext) COMMA() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOMMA, 0)
}

func (s *FunctionArgumentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionArgumentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionArgumentsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitFunctionArguments(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) FunctionArguments() (localctx IFunctionArgumentsContext) {
	localctx = NewFunctionArgumentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, DorisParserParserRULE_functionArguments)
	p.SetState(4176)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 578, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4170)
			p.Match(DorisParserParserDOTDOTDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4171)
			p.DataTypeList()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4172)
			p.DataTypeList()
		}
		{
			p.SetState(4173)
			p.Match(DorisParserParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4174)
			p.Match(DorisParserParserDOTDOTDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDataTypeListContext is an interface to support dynamic dispatch.
type IDataTypeListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllDataType() []IDataTypeContext
	DataType(i int) IDataTypeContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsDataTypeListContext differentiates from other interfaces.
	IsDataTypeListContext()
}

type DataTypeListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataTypeListContext() *DataTypeListContext {
	var p = new(DataTypeListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_dataTypeList
	return p
}

func InitEmptyDataTypeListContext(p *DataTypeListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_dataTypeList
}

func (*DataTypeListContext) IsDataTypeListContext() {}

func NewDataTypeListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataTypeListContext {
	var p = new(DataTypeListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_dataTypeList

	return p
}

func (s *DataTypeListContext) GetParser() antlr.Parser { return s.parser }

func (s *DataTypeListContext) AllDataType() []IDataTypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDataTypeContext); ok {
			len++
		}
	}

	tst := make([]IDataTypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDataTypeContext); ok {
			tst[i] = t.(IDataTypeContext)
			i++
		}
	}

	return tst
}

func (s *DataTypeListContext) DataType(i int) IDataTypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *DataTypeListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserCOMMA)
}

func (s *DataTypeListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOMMA, i)
}

func (s *DataTypeListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataTypeListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataTypeListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitDataTypeList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) DataTypeList() (localctx IDataTypeListContext) {
	localctx = NewDataTypeListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, DorisParserParserRULE_dataTypeList)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4178)
		p.DataType()
	}
	p.SetState(4183)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 579, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(4179)
				p.Match(DorisParserParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4180)
				p.DataType()
			}

		}
		p.SetState(4185)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 579, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISupportedSetStatementContext is an interface to support dynamic dispatch.
type ISupportedSetStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSupportedSetStatementContext differentiates from other interfaces.
	IsSupportedSetStatementContext()
}

type SupportedSetStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySupportedSetStatementContext() *SupportedSetStatementContext {
	var p = new(SupportedSetStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_supportedSetStatement
	return p
}

func InitEmptySupportedSetStatementContext(p *SupportedSetStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_supportedSetStatement
}

func (*SupportedSetStatementContext) IsSupportedSetStatementContext() {}

func NewSupportedSetStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SupportedSetStatementContext {
	var p = new(SupportedSetStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_supportedSetStatement

	return p
}

func (s *SupportedSetStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SupportedSetStatementContext) CopyAll(ctx *SupportedSetStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *SupportedSetStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedSetStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SetTransactionContext struct {
	SupportedSetStatementContext
}

func NewSetTransactionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetTransactionContext {
	var p = new(SetTransactionContext)

	InitEmptySupportedSetStatementContext(&p.SupportedSetStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedSetStatementContext))

	return p
}

func (s *SetTransactionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetTransactionContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSET, 0)
}

func (s *SetTransactionContext) TRANSACTION() antlr.TerminalNode {
	return s.GetToken(DorisParserParserTRANSACTION, 0)
}

func (s *SetTransactionContext) TransactionAccessMode() ITransactionAccessModeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITransactionAccessModeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITransactionAccessModeContext)
}

func (s *SetTransactionContext) IsolationLevel() IIsolationLevelContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIsolationLevelContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIsolationLevelContext)
}

func (s *SetTransactionContext) COMMA() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOMMA, 0)
}

func (s *SetTransactionContext) StatementScope() IStatementScopeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementScopeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementScopeContext)
}

func (s *SetTransactionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitSetTransaction(s)

	default:
		return t.VisitChildren(s)
	}
}

type SetUserPropertiesContext struct {
	SupportedSetStatementContext
	user IIdentifierOrTextContext
}

func NewSetUserPropertiesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetUserPropertiesContext {
	var p = new(SetUserPropertiesContext)

	InitEmptySupportedSetStatementContext(&p.SupportedSetStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedSetStatementContext))

	return p
}

func (s *SetUserPropertiesContext) GetUser() IIdentifierOrTextContext { return s.user }

func (s *SetUserPropertiesContext) SetUser(v IIdentifierOrTextContext) { s.user = v }

func (s *SetUserPropertiesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetUserPropertiesContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSET, 0)
}

func (s *SetUserPropertiesContext) PROPERTY() antlr.TerminalNode {
	return s.GetToken(DorisParserParserPROPERTY, 0)
}

func (s *SetUserPropertiesContext) PropertyItemList() IPropertyItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyItemListContext)
}

func (s *SetUserPropertiesContext) FOR() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFOR, 0)
}

func (s *SetUserPropertiesContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *SetUserPropertiesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitSetUserProperties(s)

	default:
		return t.VisitChildren(s)
	}
}

type SetDefaultStorageVaultContext struct {
	SupportedSetStatementContext
}

func NewSetDefaultStorageVaultContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetDefaultStorageVaultContext {
	var p = new(SetDefaultStorageVaultContext)

	InitEmptySupportedSetStatementContext(&p.SupportedSetStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedSetStatementContext))

	return p
}

func (s *SetDefaultStorageVaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetDefaultStorageVaultContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSET, 0)
}

func (s *SetDefaultStorageVaultContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SetDefaultStorageVaultContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserAS, 0)
}

func (s *SetDefaultStorageVaultContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDEFAULT, 0)
}

func (s *SetDefaultStorageVaultContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTORAGE, 0)
}

func (s *SetDefaultStorageVaultContext) VAULT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserVAULT, 0)
}

func (s *SetDefaultStorageVaultContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitSetDefaultStorageVault(s)

	default:
		return t.VisitChildren(s)
	}
}

type SetOptionsContext struct {
	SupportedSetStatementContext
}

func NewSetOptionsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetOptionsContext {
	var p = new(SetOptionsContext)

	InitEmptySupportedSetStatementContext(&p.SupportedSetStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedSetStatementContext))

	return p
}

func (s *SetOptionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetOptionsContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSET, 0)
}

func (s *SetOptionsContext) AllOptionWithType() []IOptionWithTypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOptionWithTypeContext); ok {
			len++
		}
	}

	tst := make([]IOptionWithTypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOptionWithTypeContext); ok {
			tst[i] = t.(IOptionWithTypeContext)
			i++
		}
	}

	return tst
}

func (s *SetOptionsContext) OptionWithType(i int) IOptionWithTypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOptionWithTypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOptionWithTypeContext)
}

func (s *SetOptionsContext) AllOptionWithoutType() []IOptionWithoutTypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOptionWithoutTypeContext); ok {
			len++
		}
	}

	tst := make([]IOptionWithoutTypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOptionWithoutTypeContext); ok {
			tst[i] = t.(IOptionWithoutTypeContext)
			i++
		}
	}

	return tst
}

func (s *SetOptionsContext) OptionWithoutType(i int) IOptionWithoutTypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOptionWithoutTypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOptionWithoutTypeContext)
}

func (s *SetOptionsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserCOMMA)
}

func (s *SetOptionsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOMMA, i)
}

func (s *SetOptionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitSetOptions(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) SupportedSetStatement() (localctx ISupportedSetStatementContext) {
	localctx = NewSupportedSetStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, DorisParserParserRULE_supportedSetStatement)
	var _la int

	p.SetState(4232)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 586, p.GetParserRuleContext()) {
	case 1:
		localctx = NewSetOptionsContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4186)
			p.Match(DorisParserParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4189)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 580, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(4187)
				p.OptionWithType()
			}

		case 2:
			{
				p.SetState(4188)
				p.OptionWithoutType()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		p.SetState(4198)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserParserCOMMA {
			{
				p.SetState(4191)
				p.Match(DorisParserParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(4194)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 581, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(4192)
					p.OptionWithType()
				}

			case 2:
				{
					p.SetState(4193)
					p.OptionWithoutType()
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

			p.SetState(4200)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		localctx = NewSetDefaultStorageVaultContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4201)
			p.Match(DorisParserParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4202)
			p.Identifier()
		}
		{
			p.SetState(4203)
			p.Match(DorisParserParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4204)
			p.Match(DorisParserParserDEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4205)
			p.Match(DorisParserParserSTORAGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4206)
			p.Match(DorisParserParserVAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		localctx = NewSetUserPropertiesContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4208)
			p.Match(DorisParserParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4209)
			p.Match(DorisParserParserPROPERTY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4212)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserFOR {
			{
				p.SetState(4210)
				p.Match(DorisParserParserFOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4211)

				var _x = p.IdentifierOrText()

				localctx.(*SetUserPropertiesContext).user = _x
			}

		}
		{
			p.SetState(4214)
			p.PropertyItemList()
		}

	case 4:
		localctx = NewSetTransactionContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4215)
			p.Match(DorisParserParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4217)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserGLOBAL || _la == DorisParserParserLOCAL || _la == DorisParserParserSESSION {
			{
				p.SetState(4216)
				p.StatementScope()
			}

		}
		{
			p.SetState(4219)
			p.Match(DorisParserParserTRANSACTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4230)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 585, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(4220)
				p.TransactionAccessMode()
			}

		case 2:
			{
				p.SetState(4221)
				p.IsolationLevel()
			}

		case 3:
			{
				p.SetState(4222)
				p.TransactionAccessMode()
			}
			{
				p.SetState(4223)
				p.Match(DorisParserParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4224)
				p.IsolationLevel()
			}

		case 4:
			{
				p.SetState(4226)
				p.IsolationLevel()
			}
			{
				p.SetState(4227)
				p.Match(DorisParserParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4228)
				p.TransactionAccessMode()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOptionWithTypeContext is an interface to support dynamic dispatch.
type IOptionWithTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsOptionWithTypeContext differentiates from other interfaces.
	IsOptionWithTypeContext()
}

type OptionWithTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOptionWithTypeContext() *OptionWithTypeContext {
	var p = new(OptionWithTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_optionWithType
	return p
}

func InitEmptyOptionWithTypeContext(p *OptionWithTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_optionWithType
}

func (*OptionWithTypeContext) IsOptionWithTypeContext() {}

func NewOptionWithTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OptionWithTypeContext {
	var p = new(OptionWithTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_optionWithType

	return p
}

func (s *OptionWithTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *OptionWithTypeContext) CopyAll(ctx *OptionWithTypeContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *OptionWithTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OptionWithTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SetVariableWithTypeContext struct {
	OptionWithTypeContext
}

func NewSetVariableWithTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetVariableWithTypeContext {
	var p = new(SetVariableWithTypeContext)

	InitEmptyOptionWithTypeContext(&p.OptionWithTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*OptionWithTypeContext))

	return p
}

func (s *SetVariableWithTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetVariableWithTypeContext) StatementScope() IStatementScopeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementScopeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementScopeContext)
}

func (s *SetVariableWithTypeContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SetVariableWithTypeContext) EQ() antlr.TerminalNode {
	return s.GetToken(DorisParserParserEQ, 0)
}

func (s *SetVariableWithTypeContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SetVariableWithTypeContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDEFAULT, 0)
}

func (s *SetVariableWithTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitSetVariableWithType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) OptionWithType() (localctx IOptionWithTypeContext) {
	localctx = NewOptionWithTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, DorisParserParserRULE_optionWithType)
	localctx = NewSetVariableWithTypeContext(p, localctx)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4234)
		p.StatementScope()
	}
	{
		p.SetState(4235)
		p.Identifier()
	}
	{
		p.SetState(4236)
		p.Match(DorisParserParserEQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4239)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserParserLEFT_PAREN, DorisParserParserLEFT_BRACKET, DorisParserParserLEFT_BRACE, DorisParserParserRIGHT_BRACE, DorisParserParserACTIONS, DorisParserParserADD, DorisParserParserAFTER, DorisParserParserAGG_STATE, DorisParserParserAGGREGATE, DorisParserParserALIAS, DorisParserParserANALYZED, DorisParserParserARRAY, DorisParserParserAT, DorisParserParserAUTHORS, DorisParserParserAUTO_INCREMENT, DorisParserParserALWAYS, DorisParserParserBACKENDS, DorisParserParserBACKUP, DorisParserParserBEGIN, DorisParserParserBELONG, DorisParserParserBIN, DorisParserParserBINARY, DorisParserParserBITAND, DorisParserParserBITMAP, DorisParserParserBITMAP_EMPTY, DorisParserParserBITMAP_UNION, DorisParserParserBITOR, DorisParserParserBITXOR, DorisParserParserBLOB, DorisParserParserBOOLEAN, DorisParserParserBRANCH, DorisParserParserBRIEF, DorisParserParserBROKER, DorisParserParserBUCKETS, DorisParserParserBUILD, DorisParserParserBUILTIN, DorisParserParserBULK, DorisParserParserCACHE, DorisParserParserCACHED, DorisParserParserCALL, DorisParserParserCASE, DorisParserParserCAST, DorisParserParserCATALOG, DorisParserParserCATALOGS, DorisParserParserCHAIN, DorisParserParserCHAR, DorisParserParserCHARSET, DorisParserParserCHECK, DorisParserParserCLUSTER, DorisParserParserCLUSTERS, DorisParserParserCOLLATION, DorisParserParserCOLLECT, DorisParserParserCOLOCATE, DorisParserParserCOLUMNS, DorisParserParserCOMMENT, DorisParserParserCOMMIT, DorisParserParserCOMMITTED, DorisParserParserCOMPACT, DorisParserParserCOMPLETE, DorisParserParserCOMPRESS_TYPE, DorisParserParserCOMPUTE, DorisParserParserCONDITIONS, DorisParserParserCONFIG, DorisParserParserCONNECTION, DorisParserParserCONNECTION_ID, DorisParserParserCONSISTENT, DorisParserParserCONSTRAINTS, DorisParserParserCONVERT, DorisParserParserCONVERT_LSC, DorisParserParserCOPY, DorisParserParserCOUNT, DorisParserParserCREATION, DorisParserParserCRON, DorisParserParserCURRENT_CATALOG, DorisParserParserCURRENT_DATE, DorisParserParserCURRENT_TIME, DorisParserParserCURRENT_TIMESTAMP, DorisParserParserCURRENT_USER, DorisParserParserDATA, DorisParserParserDATABASE, DorisParserParserDATE, DorisParserParserDATETIME, DorisParserParserDATETIMEV2, DorisParserParserDATEV2, DorisParserParserDATETIMEV1, DorisParserParserDATEV1, DorisParserParserDAY, DorisParserParserDAYS, DorisParserParserDECIMAL, DorisParserParserDECIMALV2, DorisParserParserDECIMALV3, DorisParserParserDEFERRED, DorisParserParserDEMAND, DorisParserParserDIAGNOSE, DorisParserParserDIAGNOSIS, DorisParserParserDICTIONARIES, DorisParserParserDICTIONARY, DorisParserParserDISTINCTPC, DorisParserParserDISTINCTPCSA, DorisParserParserDO, DorisParserParserDORIS_INTERNAL_TABLE_ID, DorisParserParserDUAL, DorisParserParserDYNAMIC, DorisParserParserE, DorisParserParserENABLE, DorisParserParserENCRYPTKEY, DorisParserParserENCRYPTKEYS, DorisParserParserEND, DorisParserParserENDS, DorisParserParserENGINE, DorisParserParserENGINES, DorisParserParserERRORS, DorisParserParserESCAPE, DorisParserParserEVENTS, DorisParserParserEVERY, DorisParserParserEXCLUDE, DorisParserParserEXISTS, DorisParserParserEXPIRED, DorisParserParserEXTERNAL, DorisParserParserEXTRACT, DorisParserParserFAILED_LOGIN_ATTEMPTS, DorisParserParserFALSE, DorisParserParserFAST, DorisParserParserFEATURE, DorisParserParserFIELDS, DorisParserParserFILE, DorisParserParserFILTER, DorisParserParserFIRST, DorisParserParserFORMAT, DorisParserParserFREE, DorisParserParserFRONTENDS, DorisParserParserFUNCTION, DorisParserParserGENERATED, DorisParserParserGENERIC, DorisParserParserGLOBAL, DorisParserParserGRAPH, DorisParserParserGROUPING, DorisParserParserGROUPS, DorisParserParserHASH, DorisParserParserHASH_MAP, DorisParserParserHDFS, DorisParserParserHELP, DorisParserParserHISTOGRAM, DorisParserParserHLL_UNION, DorisParserParserHOSTNAME, DorisParserParserHOTSPOT, DorisParserParserHOUR, DorisParserParserHOURS, DorisParserParserHUB, DorisParserParserIDENTIFIED, DorisParserParserIF, DorisParserParserIGNORE, DorisParserParserIMMEDIATE, DorisParserParserINCREMENTAL, DorisParserParserINDEXES, DorisParserParserINTERVAL, DorisParserParserINVERTED, DorisParserParserIP_TRIE, DorisParserParserIPV4, DorisParserParserIPV6, DorisParserParserIS_NOT_NULL_PRED, DorisParserParserIS_NULL_PRED, DorisParserParserISNULL, DorisParserParserISOLATION, DorisParserParserJOB, DorisParserParserJOBS, DorisParserParserJSON, DorisParserParserJSONB, DorisParserParserKEY, DorisParserParserLABEL, DorisParserParserLAST, DorisParserParserLDAP, DorisParserParserLDAP_ADMIN_PASSWORD, DorisParserParserLEFT, DorisParserParserLESS, DorisParserParserLEVEL, DorisParserParserLIKE, DorisParserParserLINES, DorisParserParserLINK, DorisParserParserLOCAL, DorisParserParserLOCALTIME, DorisParserParserLOCALTIMESTAMP, DorisParserParserLOCATION, DorisParserParserLOCK, DorisParserParserLOGICAL, DorisParserParserMANUAL, DorisParserParserMAP, DorisParserParserMATCH_ALL, DorisParserParserMATCH_ANY, DorisParserParserMATCH_PHRASE, DorisParserParserMATCH_PHRASE_EDGE, DorisParserParserMATCH_PHRASE_PREFIX, DorisParserParserMATCH_REGEXP, DorisParserParserMATERIALIZED, DorisParserParserMAX, DorisParserParserMEMO, DorisParserParserMERGE, DorisParserParserMIGRATE, DorisParserParserMIGRATIONS, DorisParserParserMIN, DorisParserParserMINUTE, DorisParserParserMINUTES, DorisParserParserMODIFY, DorisParserParserMONTH, DorisParserParserMTMV, DorisParserParserNAME, DorisParserParserNAMES, DorisParserParserNEGATIVE, DorisParserParserNEVER, DorisParserParserNEXT, DorisParserParserNGRAM_BF, DorisParserParserNO, DorisParserParserNON_NULLABLE, DorisParserParserNOT, DorisParserParserNULL, DorisParserParserNULLS, DorisParserParserOF, DorisParserParserOFFSET, DorisParserParserONLY, DorisParserParserOPEN, DorisParserParserOPTIMIZED, DorisParserParserPARAMETER, DorisParserParserPARSED, DorisParserParserPARTITIONS, DorisParserParserPASSWORD, DorisParserParserPASSWORD_EXPIRE, DorisParserParserPASSWORD_HISTORY, DorisParserParserPASSWORD_LOCK_TIME, DorisParserParserPASSWORD_REUSE, DorisParserParserPATH, DorisParserParserPAUSE, DorisParserParserPERCENT, DorisParserParserPERIOD, DorisParserParserPERMISSIVE, DorisParserParserPHYSICAL, DorisParserParserPI, DorisParserParserPLACEHOLDER, DorisParserParserPLAN, DorisParserParserPRIVILEGES, DorisParserParserPROCESS, DorisParserParserPLUGIN, DorisParserParserPLUGINS, DorisParserParserPOLICY, DorisParserParserPROC, DorisParserParserPROCESSLIST, DorisParserParserPROFILE, DorisParserParserPROPERTIES, DorisParserParserPROPERTY, DorisParserParserQUANTILE_STATE, DorisParserParserQUANTILE_UNION, DorisParserParserQUERY, DorisParserParserQUEUED, DorisParserParserQUOTA, DorisParserParserQUALIFY, DorisParserParserQUARTER, DorisParserParserRANDOM, DorisParserParserRECENT, DorisParserParserRECOVER, DorisParserParserRECYCLE, DorisParserParserREFRESH, DorisParserParserREGEXP, DorisParserParserREPEATABLE, DorisParserParserREPLACE, DorisParserParserREPLACE_IF_NOT_NULL, DorisParserParserREPLAYER, DorisParserParserREPOSITORIES, DorisParserParserREPOSITORY, DorisParserParserRESOURCE, DorisParserParserRESOURCES, DorisParserParserRESTORE, DorisParserParserRESTRICTIVE, DorisParserParserRESUME, DorisParserParserRETAIN, DorisParserParserRETENTION, DorisParserParserRETURNS, DorisParserParserREWRITTEN, DorisParserParserRIGHT, DorisParserParserRLIKE, DorisParserParserROLLBACK, DorisParserParserROLLUP, DorisParserParserROUTINE, DorisParserParserS3, DorisParserParserSAMPLE, DorisParserParserSCHEDULE, DorisParserParserSCHEDULER, DorisParserParserSCHEMA, DorisParserParserSECOND, DorisParserParserSERIALIZABLE, DorisParserParserSESSION, DorisParserParserSESSION_USER, DorisParserParserSET_SESSION_VARIABLE, DorisParserParserSHAPE, DorisParserParserSKEW, DorisParserParserSNAPSHOT, DorisParserParserSNAPSHOTS, DorisParserParserSONAME, DorisParserParserSPLIT, DorisParserParserSQL, DorisParserParserSTAGE, DorisParserParserSTAGES, DorisParserParserSTART, DorisParserParserSTARTS, DorisParserParserSTATS, DorisParserParserSTATUS, DorisParserParserSTOP, DorisParserParserSTORAGE, DorisParserParserSTREAM, DorisParserParserSTREAMING, DorisParserParserSTRING, DorisParserParserSTRUCT, DorisParserParserSUM, DorisParserParserTABLES, DorisParserParserTAG, DorisParserParserTASK, DorisParserParserTASKS, DorisParserParserTEMPORARY, DorisParserParserTEXT, DorisParserParserTHAN, DorisParserParserTIME, DorisParserParserTIMESTAMP, DorisParserParserTRANSACTION, DorisParserParserTREE, DorisParserParserTRIGGERS, DorisParserParserTRIM, DorisParserParserTRUE, DorisParserParserTRUNCATE, DorisParserParserTYPE, DorisParserParserTYPES, DorisParserParserUNCOMMITTED, DorisParserParserUNLOCK, DorisParserParserUNSET, DorisParserParserUP, DorisParserParserUSER, DorisParserParserVALUE, DorisParserParserVARCHAR, DorisParserParserVARIABLE, DorisParserParserVARIABLES, DorisParserParserVARIANT, DorisParserParserVAULT, DorisParserParserVAULTS, DorisParserParserVERBOSE, DorisParserParserVERSION, DorisParserParserVIEW, DorisParserParserVIEWS, DorisParserParserWARM, DorisParserParserWARNINGS, DorisParserParserWEEK, DorisParserParserWORK, DorisParserParserYEAR, DorisParserParserPLUS, DorisParserParserSUBTRACT, DorisParserParserASTERISK, DorisParserParserTILDE, DorisParserParserLOGICALNOT, DorisParserParserHINT_START, DorisParserParserHINT_END, DorisParserParserCOMMENT_START, DorisParserParserATSIGN, DorisParserParserDOUBLEATSIGN, DorisParserParserSTRING_LITERAL, DorisParserParserINTEGER_VALUE, DorisParserParserEXPONENT_VALUE, DorisParserParserDECIMAL_VALUE, DorisParserParserIDENTIFIER, DorisParserParserBACKQUOTED_IDENTIFIER:
		{
			p.SetState(4237)
			p.Expression()
		}

	case DorisParserParserDEFAULT:
		{
			p.SetState(4238)
			p.Match(DorisParserParserDEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOptionWithoutTypeContext is an interface to support dynamic dispatch.
type IOptionWithoutTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsOptionWithoutTypeContext differentiates from other interfaces.
	IsOptionWithoutTypeContext()
}

type OptionWithoutTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOptionWithoutTypeContext() *OptionWithoutTypeContext {
	var p = new(OptionWithoutTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_optionWithoutType
	return p
}

func InitEmptyOptionWithoutTypeContext(p *OptionWithoutTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_optionWithoutType
}

func (*OptionWithoutTypeContext) IsOptionWithoutTypeContext() {}

func NewOptionWithoutTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OptionWithoutTypeContext {
	var p = new(OptionWithoutTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_optionWithoutType

	return p
}

func (s *OptionWithoutTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *OptionWithoutTypeContext) CopyAll(ctx *OptionWithoutTypeContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *OptionWithoutTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OptionWithoutTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SetNamesContext struct {
	OptionWithoutTypeContext
}

func NewSetNamesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetNamesContext {
	var p = new(SetNamesContext)

	InitEmptyOptionWithoutTypeContext(&p.OptionWithoutTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*OptionWithoutTypeContext))

	return p
}

func (s *SetNamesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetNamesContext) NAMES() antlr.TerminalNode {
	return s.GetToken(DorisParserParserNAMES, 0)
}

func (s *SetNamesContext) EQ() antlr.TerminalNode {
	return s.GetToken(DorisParserParserEQ, 0)
}

func (s *SetNamesContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SetNamesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitSetNames(s)

	default:
		return t.VisitChildren(s)
	}
}

type SetCharsetContext struct {
	OptionWithoutTypeContext
	charsetName IIdentifierOrTextContext
}

func NewSetCharsetContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetCharsetContext {
	var p = new(SetCharsetContext)

	InitEmptyOptionWithoutTypeContext(&p.OptionWithoutTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*OptionWithoutTypeContext))

	return p
}

func (s *SetCharsetContext) GetCharsetName() IIdentifierOrTextContext { return s.charsetName }

func (s *SetCharsetContext) SetCharsetName(v IIdentifierOrTextContext) { s.charsetName = v }

func (s *SetCharsetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetCharsetContext) CHAR() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCHAR, 0)
}

func (s *SetCharsetContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSET, 0)
}

func (s *SetCharsetContext) CHARSET() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCHARSET, 0)
}

func (s *SetCharsetContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDEFAULT, 0)
}

func (s *SetCharsetContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *SetCharsetContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitSetCharset(s)

	default:
		return t.VisitChildren(s)
	}
}

type SetCollateContext struct {
	OptionWithoutTypeContext
	charsetName IIdentifierOrTextContext
	collateName IIdentifierOrTextContext
}

func NewSetCollateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetCollateContext {
	var p = new(SetCollateContext)

	InitEmptyOptionWithoutTypeContext(&p.OptionWithoutTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*OptionWithoutTypeContext))

	return p
}

func (s *SetCollateContext) GetCharsetName() IIdentifierOrTextContext { return s.charsetName }

func (s *SetCollateContext) GetCollateName() IIdentifierOrTextContext { return s.collateName }

func (s *SetCollateContext) SetCharsetName(v IIdentifierOrTextContext) { s.charsetName = v }

func (s *SetCollateContext) SetCollateName(v IIdentifierOrTextContext) { s.collateName = v }

func (s *SetCollateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetCollateContext) NAMES() antlr.TerminalNode {
	return s.GetToken(DorisParserParserNAMES, 0)
}

func (s *SetCollateContext) AllDEFAULT() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserDEFAULT)
}

func (s *SetCollateContext) DEFAULT(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserDEFAULT, i)
}

func (s *SetCollateContext) AllIdentifierOrText() []IIdentifierOrTextContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierOrTextContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierOrTextContext); ok {
			tst[i] = t.(IIdentifierOrTextContext)
			i++
		}
	}

	return tst
}

func (s *SetCollateContext) IdentifierOrText(i int) IIdentifierOrTextContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *SetCollateContext) COLLATE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOLLATE, 0)
}

func (s *SetCollateContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitSetCollate(s)

	default:
		return t.VisitChildren(s)
	}
}

type SetPasswordContext struct {
	OptionWithoutTypeContext
	pwd     antlr.Token
	isPlain antlr.Token
}

func NewSetPasswordContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetPasswordContext {
	var p = new(SetPasswordContext)

	InitEmptyOptionWithoutTypeContext(&p.OptionWithoutTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*OptionWithoutTypeContext))

	return p
}

func (s *SetPasswordContext) GetPwd() antlr.Token { return s.pwd }

func (s *SetPasswordContext) GetIsPlain() antlr.Token { return s.isPlain }

func (s *SetPasswordContext) SetPwd(v antlr.Token) { s.pwd = v }

func (s *SetPasswordContext) SetIsPlain(v antlr.Token) { s.isPlain = v }

func (s *SetPasswordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetPasswordContext) AllPASSWORD() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserPASSWORD)
}

func (s *SetPasswordContext) PASSWORD(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserPASSWORD, i)
}

func (s *SetPasswordContext) EQ() antlr.TerminalNode {
	return s.GetToken(DorisParserParserEQ, 0)
}

func (s *SetPasswordContext) FOR() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFOR, 0)
}

func (s *SetPasswordContext) UserIdentify() IUserIdentifyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserIdentifyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserIdentifyContext)
}

func (s *SetPasswordContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTRING_LITERAL, 0)
}

func (s *SetPasswordContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLEFT_PAREN, 0)
}

func (s *SetPasswordContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRIGHT_PAREN, 0)
}

func (s *SetPasswordContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitSetPassword(s)

	default:
		return t.VisitChildren(s)
	}
}

type SetVariableWithoutTypeContext struct {
	OptionWithoutTypeContext
}

func NewSetVariableWithoutTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetVariableWithoutTypeContext {
	var p = new(SetVariableWithoutTypeContext)

	InitEmptyOptionWithoutTypeContext(&p.OptionWithoutTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*OptionWithoutTypeContext))

	return p
}

func (s *SetVariableWithoutTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetVariableWithoutTypeContext) Variable() IVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *SetVariableWithoutTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitSetVariableWithoutType(s)

	default:
		return t.VisitChildren(s)
	}
}

type SetLdapAdminPasswordContext struct {
	OptionWithoutTypeContext
	pwd antlr.Token
}

func NewSetLdapAdminPasswordContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetLdapAdminPasswordContext {
	var p = new(SetLdapAdminPasswordContext)

	InitEmptyOptionWithoutTypeContext(&p.OptionWithoutTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*OptionWithoutTypeContext))

	return p
}

func (s *SetLdapAdminPasswordContext) GetPwd() antlr.Token { return s.pwd }

func (s *SetLdapAdminPasswordContext) SetPwd(v antlr.Token) { s.pwd = v }

func (s *SetLdapAdminPasswordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetLdapAdminPasswordContext) LDAP_ADMIN_PASSWORD() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLDAP_ADMIN_PASSWORD, 0)
}

func (s *SetLdapAdminPasswordContext) EQ() antlr.TerminalNode {
	return s.GetToken(DorisParserParserEQ, 0)
}

func (s *SetLdapAdminPasswordContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTRING_LITERAL, 0)
}

func (s *SetLdapAdminPasswordContext) PASSWORD() antlr.TerminalNode {
	return s.GetToken(DorisParserParserPASSWORD, 0)
}

func (s *SetLdapAdminPasswordContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLEFT_PAREN, 0)
}

func (s *SetLdapAdminPasswordContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRIGHT_PAREN, 0)
}

func (s *SetLdapAdminPasswordContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitSetLdapAdminPassword(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) OptionWithoutType() (localctx IOptionWithoutTypeContext) {
	localctx = NewOptionWithoutTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, DorisParserParserRULE_optionWithoutType)
	var _la int

	p.SetState(4286)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 595, p.GetParserRuleContext()) {
	case 1:
		localctx = NewSetNamesContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4241)
			p.Match(DorisParserParserNAMES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4242)
			p.Match(DorisParserParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4243)
			p.Expression()
		}

	case 2:
		localctx = NewSetCharsetContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		p.SetState(4247)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserParserCHAR:
			{
				p.SetState(4244)
				p.Match(DorisParserParserCHAR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4245)
				p.Match(DorisParserParserSET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserParserCHARSET:
			{
				p.SetState(4246)
				p.Match(DorisParserParserCHARSET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		p.SetState(4251)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserParserLEFT_BRACE, DorisParserParserRIGHT_BRACE, DorisParserParserACTIONS, DorisParserParserAFTER, DorisParserParserAGG_STATE, DorisParserParserAGGREGATE, DorisParserParserALIAS, DorisParserParserANALYZED, DorisParserParserARRAY, DorisParserParserAT, DorisParserParserAUTHORS, DorisParserParserAUTO_INCREMENT, DorisParserParserALWAYS, DorisParserParserBACKENDS, DorisParserParserBACKUP, DorisParserParserBEGIN, DorisParserParserBELONG, DorisParserParserBIN, DorisParserParserBITAND, DorisParserParserBITMAP, DorisParserParserBITMAP_EMPTY, DorisParserParserBITMAP_UNION, DorisParserParserBITOR, DorisParserParserBITXOR, DorisParserParserBLOB, DorisParserParserBOOLEAN, DorisParserParserBRANCH, DorisParserParserBRIEF, DorisParserParserBROKER, DorisParserParserBUCKETS, DorisParserParserBUILD, DorisParserParserBUILTIN, DorisParserParserBULK, DorisParserParserCACHE, DorisParserParserCACHED, DorisParserParserCALL, DorisParserParserCATALOG, DorisParserParserCATALOGS, DorisParserParserCHAIN, DorisParserParserCHAR, DorisParserParserCHARSET, DorisParserParserCHECK, DorisParserParserCLUSTER, DorisParserParserCLUSTERS, DorisParserParserCOLLATION, DorisParserParserCOLLECT, DorisParserParserCOLOCATE, DorisParserParserCOLUMNS, DorisParserParserCOMMENT, DorisParserParserCOMMIT, DorisParserParserCOMMITTED, DorisParserParserCOMPACT, DorisParserParserCOMPLETE, DorisParserParserCOMPRESS_TYPE, DorisParserParserCOMPUTE, DorisParserParserCONDITIONS, DorisParserParserCONFIG, DorisParserParserCONNECTION, DorisParserParserCONNECTION_ID, DorisParserParserCONSISTENT, DorisParserParserCONSTRAINTS, DorisParserParserCONVERT, DorisParserParserCONVERT_LSC, DorisParserParserCOPY, DorisParserParserCOUNT, DorisParserParserCREATION, DorisParserParserCRON, DorisParserParserCURRENT_CATALOG, DorisParserParserCURRENT_DATE, DorisParserParserCURRENT_TIME, DorisParserParserCURRENT_TIMESTAMP, DorisParserParserCURRENT_USER, DorisParserParserDATA, DorisParserParserDATE, DorisParserParserDATETIME, DorisParserParserDATETIMEV2, DorisParserParserDATEV2, DorisParserParserDATETIMEV1, DorisParserParserDATEV1, DorisParserParserDAY, DorisParserParserDAYS, DorisParserParserDECIMAL, DorisParserParserDECIMALV2, DorisParserParserDECIMALV3, DorisParserParserDEFERRED, DorisParserParserDEMAND, DorisParserParserDIAGNOSE, DorisParserParserDIAGNOSIS, DorisParserParserDICTIONARIES, DorisParserParserDICTIONARY, DorisParserParserDISTINCTPC, DorisParserParserDISTINCTPCSA, DorisParserParserDO, DorisParserParserDORIS_INTERNAL_TABLE_ID, DorisParserParserDUAL, DorisParserParserDYNAMIC, DorisParserParserE, DorisParserParserENABLE, DorisParserParserENCRYPTKEY, DorisParserParserENCRYPTKEYS, DorisParserParserEND, DorisParserParserENDS, DorisParserParserENGINE, DorisParserParserENGINES, DorisParserParserERRORS, DorisParserParserESCAPE, DorisParserParserEVENTS, DorisParserParserEVERY, DorisParserParserEXCLUDE, DorisParserParserEXPIRED, DorisParserParserEXTERNAL, DorisParserParserFAILED_LOGIN_ATTEMPTS, DorisParserParserFAST, DorisParserParserFEATURE, DorisParserParserFIELDS, DorisParserParserFILE, DorisParserParserFILTER, DorisParserParserFIRST, DorisParserParserFORMAT, DorisParserParserFREE, DorisParserParserFRONTENDS, DorisParserParserFUNCTION, DorisParserParserGENERATED, DorisParserParserGENERIC, DorisParserParserGLOBAL, DorisParserParserGRAPH, DorisParserParserGROUPING, DorisParserParserGROUPS, DorisParserParserHASH, DorisParserParserHASH_MAP, DorisParserParserHDFS, DorisParserParserHELP, DorisParserParserHISTOGRAM, DorisParserParserHLL_UNION, DorisParserParserHOSTNAME, DorisParserParserHOTSPOT, DorisParserParserHOUR, DorisParserParserHOURS, DorisParserParserHUB, DorisParserParserIDENTIFIED, DorisParserParserIGNORE, DorisParserParserIMMEDIATE, DorisParserParserINCREMENTAL, DorisParserParserINDEXES, DorisParserParserINVERTED, DorisParserParserIP_TRIE, DorisParserParserIPV4, DorisParserParserIPV6, DorisParserParserIS_NOT_NULL_PRED, DorisParserParserIS_NULL_PRED, DorisParserParserISNULL, DorisParserParserISOLATION, DorisParserParserJOB, DorisParserParserJOBS, DorisParserParserJSON, DorisParserParserJSONB, DorisParserParserLABEL, DorisParserParserLAST, DorisParserParserLDAP, DorisParserParserLDAP_ADMIN_PASSWORD, DorisParserParserLESS, DorisParserParserLEVEL, DorisParserParserLINES, DorisParserParserLINK, DorisParserParserLOCAL, DorisParserParserLOCALTIME, DorisParserParserLOCALTIMESTAMP, DorisParserParserLOCATION, DorisParserParserLOCK, DorisParserParserLOGICAL, DorisParserParserMANUAL, DorisParserParserMAP, DorisParserParserMATCH_ALL, DorisParserParserMATCH_ANY, DorisParserParserMATCH_PHRASE, DorisParserParserMATCH_PHRASE_EDGE, DorisParserParserMATCH_PHRASE_PREFIX, DorisParserParserMATCH_REGEXP, DorisParserParserMATERIALIZED, DorisParserParserMAX, DorisParserParserMEMO, DorisParserParserMERGE, DorisParserParserMIGRATE, DorisParserParserMIGRATIONS, DorisParserParserMIN, DorisParserParserMINUTE, DorisParserParserMINUTES, DorisParserParserMODIFY, DorisParserParserMONTH, DorisParserParserMTMV, DorisParserParserNAME, DorisParserParserNAMES, DorisParserParserNEGATIVE, DorisParserParserNEVER, DorisParserParserNEXT, DorisParserParserNGRAM_BF, DorisParserParserNO, DorisParserParserNON_NULLABLE, DorisParserParserNULLS, DorisParserParserOF, DorisParserParserOFFSET, DorisParserParserONLY, DorisParserParserOPEN, DorisParserParserOPTIMIZED, DorisParserParserPARAMETER, DorisParserParserPARSED, DorisParserParserPARTITIONS, DorisParserParserPASSWORD, DorisParserParserPASSWORD_EXPIRE, DorisParserParserPASSWORD_HISTORY, DorisParserParserPASSWORD_LOCK_TIME, DorisParserParserPASSWORD_REUSE, DorisParserParserPATH, DorisParserParserPAUSE, DorisParserParserPERCENT, DorisParserParserPERIOD, DorisParserParserPERMISSIVE, DorisParserParserPHYSICAL, DorisParserParserPI, DorisParserParserPLAN, DorisParserParserPRIVILEGES, DorisParserParserPROCESS, DorisParserParserPLUGIN, DorisParserParserPLUGINS, DorisParserParserPOLICY, DorisParserParserPROC, DorisParserParserPROCESSLIST, DorisParserParserPROFILE, DorisParserParserPROPERTIES, DorisParserParserPROPERTY, DorisParserParserQUANTILE_STATE, DorisParserParserQUANTILE_UNION, DorisParserParserQUERY, DorisParserParserQUEUED, DorisParserParserQUOTA, DorisParserParserQUALIFY, DorisParserParserQUARTER, DorisParserParserRANDOM, DorisParserParserRECENT, DorisParserParserRECOVER, DorisParserParserRECYCLE, DorisParserParserREFRESH, DorisParserParserREPEATABLE, DorisParserParserREPLACE, DorisParserParserREPLACE_IF_NOT_NULL, DorisParserParserREPLAYER, DorisParserParserREPOSITORIES, DorisParserParserREPOSITORY, DorisParserParserRESOURCE, DorisParserParserRESOURCES, DorisParserParserRESTORE, DorisParserParserRESTRICTIVE, DorisParserParserRESUME, DorisParserParserRETAIN, DorisParserParserRETENTION, DorisParserParserRETURNS, DorisParserParserREWRITTEN, DorisParserParserRLIKE, DorisParserParserROLLBACK, DorisParserParserROLLUP, DorisParserParserROUTINE, DorisParserParserS3, DorisParserParserSAMPLE, DorisParserParserSCHEDULE, DorisParserParserSCHEDULER, DorisParserParserSCHEMA, DorisParserParserSECOND, DorisParserParserSERIALIZABLE, DorisParserParserSESSION, DorisParserParserSESSION_USER, DorisParserParserSET_SESSION_VARIABLE, DorisParserParserSHAPE, DorisParserParserSKEW, DorisParserParserSNAPSHOT, DorisParserParserSNAPSHOTS, DorisParserParserSONAME, DorisParserParserSPLIT, DorisParserParserSQL, DorisParserParserSTAGE, DorisParserParserSTAGES, DorisParserParserSTART, DorisParserParserSTARTS, DorisParserParserSTATS, DorisParserParserSTATUS, DorisParserParserSTOP, DorisParserParserSTORAGE, DorisParserParserSTREAM, DorisParserParserSTREAMING, DorisParserParserSTRING, DorisParserParserSTRUCT, DorisParserParserSUM, DorisParserParserTABLES, DorisParserParserTAG, DorisParserParserTASK, DorisParserParserTASKS, DorisParserParserTEMPORARY, DorisParserParserTEXT, DorisParserParserTHAN, DorisParserParserTIME, DorisParserParserTIMESTAMP, DorisParserParserTRANSACTION, DorisParserParserTREE, DorisParserParserTRIGGERS, DorisParserParserTRUNCATE, DorisParserParserTYPE, DorisParserParserTYPES, DorisParserParserUNCOMMITTED, DorisParserParserUNLOCK, DorisParserParserUNSET, DorisParserParserUP, DorisParserParserUSER, DorisParserParserVALUE, DorisParserParserVARCHAR, DorisParserParserVARIABLE, DorisParserParserVARIABLES, DorisParserParserVARIANT, DorisParserParserVAULT, DorisParserParserVAULTS, DorisParserParserVERBOSE, DorisParserParserVERSION, DorisParserParserVIEW, DorisParserParserVIEWS, DorisParserParserWARM, DorisParserParserWARNINGS, DorisParserParserWEEK, DorisParserParserWORK, DorisParserParserYEAR, DorisParserParserHINT_START, DorisParserParserHINT_END, DorisParserParserCOMMENT_START, DorisParserParserSTRING_LITERAL, DorisParserParserIDENTIFIER, DorisParserParserBACKQUOTED_IDENTIFIER:
			{
				p.SetState(4249)

				var _x = p.IdentifierOrText()

				localctx.(*SetCharsetContext).charsetName = _x
			}

		case DorisParserParserDEFAULT:
			{
				p.SetState(4250)
				p.Match(DorisParserParserDEFAULT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 3:
		localctx = NewSetCollateContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4253)
			p.Match(DorisParserParserNAMES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4256)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserParserLEFT_BRACE, DorisParserParserRIGHT_BRACE, DorisParserParserACTIONS, DorisParserParserAFTER, DorisParserParserAGG_STATE, DorisParserParserAGGREGATE, DorisParserParserALIAS, DorisParserParserANALYZED, DorisParserParserARRAY, DorisParserParserAT, DorisParserParserAUTHORS, DorisParserParserAUTO_INCREMENT, DorisParserParserALWAYS, DorisParserParserBACKENDS, DorisParserParserBACKUP, DorisParserParserBEGIN, DorisParserParserBELONG, DorisParserParserBIN, DorisParserParserBITAND, DorisParserParserBITMAP, DorisParserParserBITMAP_EMPTY, DorisParserParserBITMAP_UNION, DorisParserParserBITOR, DorisParserParserBITXOR, DorisParserParserBLOB, DorisParserParserBOOLEAN, DorisParserParserBRANCH, DorisParserParserBRIEF, DorisParserParserBROKER, DorisParserParserBUCKETS, DorisParserParserBUILD, DorisParserParserBUILTIN, DorisParserParserBULK, DorisParserParserCACHE, DorisParserParserCACHED, DorisParserParserCALL, DorisParserParserCATALOG, DorisParserParserCATALOGS, DorisParserParserCHAIN, DorisParserParserCHAR, DorisParserParserCHARSET, DorisParserParserCHECK, DorisParserParserCLUSTER, DorisParserParserCLUSTERS, DorisParserParserCOLLATION, DorisParserParserCOLLECT, DorisParserParserCOLOCATE, DorisParserParserCOLUMNS, DorisParserParserCOMMENT, DorisParserParserCOMMIT, DorisParserParserCOMMITTED, DorisParserParserCOMPACT, DorisParserParserCOMPLETE, DorisParserParserCOMPRESS_TYPE, DorisParserParserCOMPUTE, DorisParserParserCONDITIONS, DorisParserParserCONFIG, DorisParserParserCONNECTION, DorisParserParserCONNECTION_ID, DorisParserParserCONSISTENT, DorisParserParserCONSTRAINTS, DorisParserParserCONVERT, DorisParserParserCONVERT_LSC, DorisParserParserCOPY, DorisParserParserCOUNT, DorisParserParserCREATION, DorisParserParserCRON, DorisParserParserCURRENT_CATALOG, DorisParserParserCURRENT_DATE, DorisParserParserCURRENT_TIME, DorisParserParserCURRENT_TIMESTAMP, DorisParserParserCURRENT_USER, DorisParserParserDATA, DorisParserParserDATE, DorisParserParserDATETIME, DorisParserParserDATETIMEV2, DorisParserParserDATEV2, DorisParserParserDATETIMEV1, DorisParserParserDATEV1, DorisParserParserDAY, DorisParserParserDAYS, DorisParserParserDECIMAL, DorisParserParserDECIMALV2, DorisParserParserDECIMALV3, DorisParserParserDEFERRED, DorisParserParserDEMAND, DorisParserParserDIAGNOSE, DorisParserParserDIAGNOSIS, DorisParserParserDICTIONARIES, DorisParserParserDICTIONARY, DorisParserParserDISTINCTPC, DorisParserParserDISTINCTPCSA, DorisParserParserDO, DorisParserParserDORIS_INTERNAL_TABLE_ID, DorisParserParserDUAL, DorisParserParserDYNAMIC, DorisParserParserE, DorisParserParserENABLE, DorisParserParserENCRYPTKEY, DorisParserParserENCRYPTKEYS, DorisParserParserEND, DorisParserParserENDS, DorisParserParserENGINE, DorisParserParserENGINES, DorisParserParserERRORS, DorisParserParserESCAPE, DorisParserParserEVENTS, DorisParserParserEVERY, DorisParserParserEXCLUDE, DorisParserParserEXPIRED, DorisParserParserEXTERNAL, DorisParserParserFAILED_LOGIN_ATTEMPTS, DorisParserParserFAST, DorisParserParserFEATURE, DorisParserParserFIELDS, DorisParserParserFILE, DorisParserParserFILTER, DorisParserParserFIRST, DorisParserParserFORMAT, DorisParserParserFREE, DorisParserParserFRONTENDS, DorisParserParserFUNCTION, DorisParserParserGENERATED, DorisParserParserGENERIC, DorisParserParserGLOBAL, DorisParserParserGRAPH, DorisParserParserGROUPING, DorisParserParserGROUPS, DorisParserParserHASH, DorisParserParserHASH_MAP, DorisParserParserHDFS, DorisParserParserHELP, DorisParserParserHISTOGRAM, DorisParserParserHLL_UNION, DorisParserParserHOSTNAME, DorisParserParserHOTSPOT, DorisParserParserHOUR, DorisParserParserHOURS, DorisParserParserHUB, DorisParserParserIDENTIFIED, DorisParserParserIGNORE, DorisParserParserIMMEDIATE, DorisParserParserINCREMENTAL, DorisParserParserINDEXES, DorisParserParserINVERTED, DorisParserParserIP_TRIE, DorisParserParserIPV4, DorisParserParserIPV6, DorisParserParserIS_NOT_NULL_PRED, DorisParserParserIS_NULL_PRED, DorisParserParserISNULL, DorisParserParserISOLATION, DorisParserParserJOB, DorisParserParserJOBS, DorisParserParserJSON, DorisParserParserJSONB, DorisParserParserLABEL, DorisParserParserLAST, DorisParserParserLDAP, DorisParserParserLDAP_ADMIN_PASSWORD, DorisParserParserLESS, DorisParserParserLEVEL, DorisParserParserLINES, DorisParserParserLINK, DorisParserParserLOCAL, DorisParserParserLOCALTIME, DorisParserParserLOCALTIMESTAMP, DorisParserParserLOCATION, DorisParserParserLOCK, DorisParserParserLOGICAL, DorisParserParserMANUAL, DorisParserParserMAP, DorisParserParserMATCH_ALL, DorisParserParserMATCH_ANY, DorisParserParserMATCH_PHRASE, DorisParserParserMATCH_PHRASE_EDGE, DorisParserParserMATCH_PHRASE_PREFIX, DorisParserParserMATCH_REGEXP, DorisParserParserMATERIALIZED, DorisParserParserMAX, DorisParserParserMEMO, DorisParserParserMERGE, DorisParserParserMIGRATE, DorisParserParserMIGRATIONS, DorisParserParserMIN, DorisParserParserMINUTE, DorisParserParserMINUTES, DorisParserParserMODIFY, DorisParserParserMONTH, DorisParserParserMTMV, DorisParserParserNAME, DorisParserParserNAMES, DorisParserParserNEGATIVE, DorisParserParserNEVER, DorisParserParserNEXT, DorisParserParserNGRAM_BF, DorisParserParserNO, DorisParserParserNON_NULLABLE, DorisParserParserNULLS, DorisParserParserOF, DorisParserParserOFFSET, DorisParserParserONLY, DorisParserParserOPEN, DorisParserParserOPTIMIZED, DorisParserParserPARAMETER, DorisParserParserPARSED, DorisParserParserPARTITIONS, DorisParserParserPASSWORD, DorisParserParserPASSWORD_EXPIRE, DorisParserParserPASSWORD_HISTORY, DorisParserParserPASSWORD_LOCK_TIME, DorisParserParserPASSWORD_REUSE, DorisParserParserPATH, DorisParserParserPAUSE, DorisParserParserPERCENT, DorisParserParserPERIOD, DorisParserParserPERMISSIVE, DorisParserParserPHYSICAL, DorisParserParserPI, DorisParserParserPLAN, DorisParserParserPRIVILEGES, DorisParserParserPROCESS, DorisParserParserPLUGIN, DorisParserParserPLUGINS, DorisParserParserPOLICY, DorisParserParserPROC, DorisParserParserPROCESSLIST, DorisParserParserPROFILE, DorisParserParserPROPERTIES, DorisParserParserPROPERTY, DorisParserParserQUANTILE_STATE, DorisParserParserQUANTILE_UNION, DorisParserParserQUERY, DorisParserParserQUEUED, DorisParserParserQUOTA, DorisParserParserQUALIFY, DorisParserParserQUARTER, DorisParserParserRANDOM, DorisParserParserRECENT, DorisParserParserRECOVER, DorisParserParserRECYCLE, DorisParserParserREFRESH, DorisParserParserREPEATABLE, DorisParserParserREPLACE, DorisParserParserREPLACE_IF_NOT_NULL, DorisParserParserREPLAYER, DorisParserParserREPOSITORIES, DorisParserParserREPOSITORY, DorisParserParserRESOURCE, DorisParserParserRESOURCES, DorisParserParserRESTORE, DorisParserParserRESTRICTIVE, DorisParserParserRESUME, DorisParserParserRETAIN, DorisParserParserRETENTION, DorisParserParserRETURNS, DorisParserParserREWRITTEN, DorisParserParserRLIKE, DorisParserParserROLLBACK, DorisParserParserROLLUP, DorisParserParserROUTINE, DorisParserParserS3, DorisParserParserSAMPLE, DorisParserParserSCHEDULE, DorisParserParserSCHEDULER, DorisParserParserSCHEMA, DorisParserParserSECOND, DorisParserParserSERIALIZABLE, DorisParserParserSESSION, DorisParserParserSESSION_USER, DorisParserParserSET_SESSION_VARIABLE, DorisParserParserSHAPE, DorisParserParserSKEW, DorisParserParserSNAPSHOT, DorisParserParserSNAPSHOTS, DorisParserParserSONAME, DorisParserParserSPLIT, DorisParserParserSQL, DorisParserParserSTAGE, DorisParserParserSTAGES, DorisParserParserSTART, DorisParserParserSTARTS, DorisParserParserSTATS, DorisParserParserSTATUS, DorisParserParserSTOP, DorisParserParserSTORAGE, DorisParserParserSTREAM, DorisParserParserSTREAMING, DorisParserParserSTRING, DorisParserParserSTRUCT, DorisParserParserSUM, DorisParserParserTABLES, DorisParserParserTAG, DorisParserParserTASK, DorisParserParserTASKS, DorisParserParserTEMPORARY, DorisParserParserTEXT, DorisParserParserTHAN, DorisParserParserTIME, DorisParserParserTIMESTAMP, DorisParserParserTRANSACTION, DorisParserParserTREE, DorisParserParserTRIGGERS, DorisParserParserTRUNCATE, DorisParserParserTYPE, DorisParserParserTYPES, DorisParserParserUNCOMMITTED, DorisParserParserUNLOCK, DorisParserParserUNSET, DorisParserParserUP, DorisParserParserUSER, DorisParserParserVALUE, DorisParserParserVARCHAR, DorisParserParserVARIABLE, DorisParserParserVARIABLES, DorisParserParserVARIANT, DorisParserParserVAULT, DorisParserParserVAULTS, DorisParserParserVERBOSE, DorisParserParserVERSION, DorisParserParserVIEW, DorisParserParserVIEWS, DorisParserParserWARM, DorisParserParserWARNINGS, DorisParserParserWEEK, DorisParserParserWORK, DorisParserParserYEAR, DorisParserParserHINT_START, DorisParserParserHINT_END, DorisParserParserCOMMENT_START, DorisParserParserSTRING_LITERAL, DorisParserParserIDENTIFIER, DorisParserParserBACKQUOTED_IDENTIFIER:
			{
				p.SetState(4254)

				var _x = p.IdentifierOrText()

				localctx.(*SetCollateContext).charsetName = _x
			}

		case DorisParserParserDEFAULT:
			{
				p.SetState(4255)
				p.Match(DorisParserParserDEFAULT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		p.SetState(4261)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		switch p.GetTokenStream().LA(1) {
		case DorisParserParserCOLLATE:
			{
				p.SetState(4258)
				p.Match(DorisParserParserCOLLATE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4259)

				var _x = p.IdentifierOrText()

				localctx.(*SetCollateContext).collateName = _x
			}

		case DorisParserParserDEFAULT:
			{
				p.SetState(4260)
				p.Match(DorisParserParserDEFAULT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserParserEOF, DorisParserParserSEMICOLON, DorisParserParserCOMMA:

		default:
		}

	case 4:
		localctx = NewSetPasswordContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4263)
			p.Match(DorisParserParserPASSWORD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4266)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserFOR {
			{
				p.SetState(4264)
				p.Match(DorisParserParserFOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4265)
				p.UserIdentify()
			}

		}
		{
			p.SetState(4268)
			p.Match(DorisParserParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4274)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserParserSTRING_LITERAL:
			{
				p.SetState(4269)

				var _m = p.Match(DorisParserParserSTRING_LITERAL)

				localctx.(*SetPasswordContext).pwd = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserParserPASSWORD:
			{
				p.SetState(4270)

				var _m = p.Match(DorisParserParserPASSWORD)

				localctx.(*SetPasswordContext).isPlain = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4271)
				p.Match(DorisParserParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4272)

				var _m = p.Match(DorisParserParserSTRING_LITERAL)

				localctx.(*SetPasswordContext).pwd = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4273)
				p.Match(DorisParserParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 5:
		localctx = NewSetLdapAdminPasswordContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4276)
			p.Match(DorisParserParserLDAP_ADMIN_PASSWORD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4277)
			p.Match(DorisParserParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4283)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserParserSTRING_LITERAL:
			{
				p.SetState(4278)

				var _m = p.Match(DorisParserParserSTRING_LITERAL)

				localctx.(*SetLdapAdminPasswordContext).pwd = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserParserPASSWORD:
			{
				p.SetState(4279)
				p.Match(DorisParserParserPASSWORD)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4280)
				p.Match(DorisParserParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4281)

				var _m = p.Match(DorisParserParserSTRING_LITERAL)

				localctx.(*SetLdapAdminPasswordContext).pwd = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4282)
				p.Match(DorisParserParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 6:
		localctx = NewSetVariableWithoutTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(4285)
			p.Variable()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVariableContext is an interface to support dynamic dispatch.
type IVariableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsVariableContext differentiates from other interfaces.
	IsVariableContext()
}

type VariableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableContext() *VariableContext {
	var p = new(VariableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_variable
	return p
}

func InitEmptyVariableContext(p *VariableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_variable
}

func (*VariableContext) IsVariableContext() {}

func NewVariableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableContext {
	var p = new(VariableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_variable

	return p
}

func (s *VariableContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableContext) CopyAll(ctx *VariableContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *VariableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SetUserVariableContext struct {
	VariableContext
}

func NewSetUserVariableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetUserVariableContext {
	var p = new(SetUserVariableContext)

	InitEmptyVariableContext(&p.VariableContext)
	p.parser = parser
	p.CopyAll(ctx.(*VariableContext))

	return p
}

func (s *SetUserVariableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetUserVariableContext) ATSIGN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserATSIGN, 0)
}

func (s *SetUserVariableContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SetUserVariableContext) EQ() antlr.TerminalNode {
	return s.GetToken(DorisParserParserEQ, 0)
}

func (s *SetUserVariableContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SetUserVariableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitSetUserVariable(s)

	default:
		return t.VisitChildren(s)
	}
}

type SetSystemVariableContext struct {
	VariableContext
}

func NewSetSystemVariableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetSystemVariableContext {
	var p = new(SetSystemVariableContext)

	InitEmptyVariableContext(&p.VariableContext)
	p.parser = parser
	p.CopyAll(ctx.(*VariableContext))

	return p
}

func (s *SetSystemVariableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetSystemVariableContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SetSystemVariableContext) EQ() antlr.TerminalNode {
	return s.GetToken(DorisParserParserEQ, 0)
}

func (s *SetSystemVariableContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SetSystemVariableContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDEFAULT, 0)
}

func (s *SetSystemVariableContext) DOUBLEATSIGN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDOUBLEATSIGN, 0)
}

func (s *SetSystemVariableContext) StatementScope() IStatementScopeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementScopeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementScopeContext)
}

func (s *SetSystemVariableContext) DOT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDOT, 0)
}

func (s *SetSystemVariableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitSetSystemVariable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) Variable() (localctx IVariableContext) {
	localctx = NewVariableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, DorisParserParserRULE_variable)
	var _la int

	p.SetState(4307)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserParserLEFT_BRACE, DorisParserParserRIGHT_BRACE, DorisParserParserACTIONS, DorisParserParserAFTER, DorisParserParserAGG_STATE, DorisParserParserAGGREGATE, DorisParserParserALIAS, DorisParserParserANALYZED, DorisParserParserARRAY, DorisParserParserAT, DorisParserParserAUTHORS, DorisParserParserAUTO_INCREMENT, DorisParserParserALWAYS, DorisParserParserBACKENDS, DorisParserParserBACKUP, DorisParserParserBEGIN, DorisParserParserBELONG, DorisParserParserBIN, DorisParserParserBITAND, DorisParserParserBITMAP, DorisParserParserBITMAP_EMPTY, DorisParserParserBITMAP_UNION, DorisParserParserBITOR, DorisParserParserBITXOR, DorisParserParserBLOB, DorisParserParserBOOLEAN, DorisParserParserBRANCH, DorisParserParserBRIEF, DorisParserParserBROKER, DorisParserParserBUCKETS, DorisParserParserBUILD, DorisParserParserBUILTIN, DorisParserParserBULK, DorisParserParserCACHE, DorisParserParserCACHED, DorisParserParserCALL, DorisParserParserCATALOG, DorisParserParserCATALOGS, DorisParserParserCHAIN, DorisParserParserCHAR, DorisParserParserCHARSET, DorisParserParserCHECK, DorisParserParserCLUSTER, DorisParserParserCLUSTERS, DorisParserParserCOLLATION, DorisParserParserCOLLECT, DorisParserParserCOLOCATE, DorisParserParserCOLUMNS, DorisParserParserCOMMENT, DorisParserParserCOMMIT, DorisParserParserCOMMITTED, DorisParserParserCOMPACT, DorisParserParserCOMPLETE, DorisParserParserCOMPRESS_TYPE, DorisParserParserCOMPUTE, DorisParserParserCONDITIONS, DorisParserParserCONFIG, DorisParserParserCONNECTION, DorisParserParserCONNECTION_ID, DorisParserParserCONSISTENT, DorisParserParserCONSTRAINTS, DorisParserParserCONVERT, DorisParserParserCONVERT_LSC, DorisParserParserCOPY, DorisParserParserCOUNT, DorisParserParserCREATION, DorisParserParserCRON, DorisParserParserCURRENT_CATALOG, DorisParserParserCURRENT_DATE, DorisParserParserCURRENT_TIME, DorisParserParserCURRENT_TIMESTAMP, DorisParserParserCURRENT_USER, DorisParserParserDATA, DorisParserParserDATE, DorisParserParserDATETIME, DorisParserParserDATETIMEV2, DorisParserParserDATEV2, DorisParserParserDATETIMEV1, DorisParserParserDATEV1, DorisParserParserDAY, DorisParserParserDAYS, DorisParserParserDECIMAL, DorisParserParserDECIMALV2, DorisParserParserDECIMALV3, DorisParserParserDEFERRED, DorisParserParserDEMAND, DorisParserParserDIAGNOSE, DorisParserParserDIAGNOSIS, DorisParserParserDICTIONARIES, DorisParserParserDICTIONARY, DorisParserParserDISTINCTPC, DorisParserParserDISTINCTPCSA, DorisParserParserDO, DorisParserParserDORIS_INTERNAL_TABLE_ID, DorisParserParserDUAL, DorisParserParserDYNAMIC, DorisParserParserE, DorisParserParserENABLE, DorisParserParserENCRYPTKEY, DorisParserParserENCRYPTKEYS, DorisParserParserEND, DorisParserParserENDS, DorisParserParserENGINE, DorisParserParserENGINES, DorisParserParserERRORS, DorisParserParserESCAPE, DorisParserParserEVENTS, DorisParserParserEVERY, DorisParserParserEXCLUDE, DorisParserParserEXPIRED, DorisParserParserEXTERNAL, DorisParserParserFAILED_LOGIN_ATTEMPTS, DorisParserParserFAST, DorisParserParserFEATURE, DorisParserParserFIELDS, DorisParserParserFILE, DorisParserParserFILTER, DorisParserParserFIRST, DorisParserParserFORMAT, DorisParserParserFREE, DorisParserParserFRONTENDS, DorisParserParserFUNCTION, DorisParserParserGENERATED, DorisParserParserGENERIC, DorisParserParserGLOBAL, DorisParserParserGRAPH, DorisParserParserGROUPING, DorisParserParserGROUPS, DorisParserParserHASH, DorisParserParserHASH_MAP, DorisParserParserHDFS, DorisParserParserHELP, DorisParserParserHISTOGRAM, DorisParserParserHLL_UNION, DorisParserParserHOSTNAME, DorisParserParserHOTSPOT, DorisParserParserHOUR, DorisParserParserHOURS, DorisParserParserHUB, DorisParserParserIDENTIFIED, DorisParserParserIGNORE, DorisParserParserIMMEDIATE, DorisParserParserINCREMENTAL, DorisParserParserINDEXES, DorisParserParserINVERTED, DorisParserParserIP_TRIE, DorisParserParserIPV4, DorisParserParserIPV6, DorisParserParserIS_NOT_NULL_PRED, DorisParserParserIS_NULL_PRED, DorisParserParserISNULL, DorisParserParserISOLATION, DorisParserParserJOB, DorisParserParserJOBS, DorisParserParserJSON, DorisParserParserJSONB, DorisParserParserLABEL, DorisParserParserLAST, DorisParserParserLDAP, DorisParserParserLDAP_ADMIN_PASSWORD, DorisParserParserLESS, DorisParserParserLEVEL, DorisParserParserLINES, DorisParserParserLINK, DorisParserParserLOCAL, DorisParserParserLOCALTIME, DorisParserParserLOCALTIMESTAMP, DorisParserParserLOCATION, DorisParserParserLOCK, DorisParserParserLOGICAL, DorisParserParserMANUAL, DorisParserParserMAP, DorisParserParserMATCH_ALL, DorisParserParserMATCH_ANY, DorisParserParserMATCH_PHRASE, DorisParserParserMATCH_PHRASE_EDGE, DorisParserParserMATCH_PHRASE_PREFIX, DorisParserParserMATCH_REGEXP, DorisParserParserMATERIALIZED, DorisParserParserMAX, DorisParserParserMEMO, DorisParserParserMERGE, DorisParserParserMIGRATE, DorisParserParserMIGRATIONS, DorisParserParserMIN, DorisParserParserMINUTE, DorisParserParserMINUTES, DorisParserParserMODIFY, DorisParserParserMONTH, DorisParserParserMTMV, DorisParserParserNAME, DorisParserParserNAMES, DorisParserParserNEGATIVE, DorisParserParserNEVER, DorisParserParserNEXT, DorisParserParserNGRAM_BF, DorisParserParserNO, DorisParserParserNON_NULLABLE, DorisParserParserNULLS, DorisParserParserOF, DorisParserParserOFFSET, DorisParserParserONLY, DorisParserParserOPEN, DorisParserParserOPTIMIZED, DorisParserParserPARAMETER, DorisParserParserPARSED, DorisParserParserPARTITIONS, DorisParserParserPASSWORD, DorisParserParserPASSWORD_EXPIRE, DorisParserParserPASSWORD_HISTORY, DorisParserParserPASSWORD_LOCK_TIME, DorisParserParserPASSWORD_REUSE, DorisParserParserPATH, DorisParserParserPAUSE, DorisParserParserPERCENT, DorisParserParserPERIOD, DorisParserParserPERMISSIVE, DorisParserParserPHYSICAL, DorisParserParserPI, DorisParserParserPLAN, DorisParserParserPRIVILEGES, DorisParserParserPROCESS, DorisParserParserPLUGIN, DorisParserParserPLUGINS, DorisParserParserPOLICY, DorisParserParserPROC, DorisParserParserPROCESSLIST, DorisParserParserPROFILE, DorisParserParserPROPERTIES, DorisParserParserPROPERTY, DorisParserParserQUANTILE_STATE, DorisParserParserQUANTILE_UNION, DorisParserParserQUERY, DorisParserParserQUEUED, DorisParserParserQUOTA, DorisParserParserQUALIFY, DorisParserParserQUARTER, DorisParserParserRANDOM, DorisParserParserRECENT, DorisParserParserRECOVER, DorisParserParserRECYCLE, DorisParserParserREFRESH, DorisParserParserREPEATABLE, DorisParserParserREPLACE, DorisParserParserREPLACE_IF_NOT_NULL, DorisParserParserREPLAYER, DorisParserParserREPOSITORIES, DorisParserParserREPOSITORY, DorisParserParserRESOURCE, DorisParserParserRESOURCES, DorisParserParserRESTORE, DorisParserParserRESTRICTIVE, DorisParserParserRESUME, DorisParserParserRETAIN, DorisParserParserRETENTION, DorisParserParserRETURNS, DorisParserParserREWRITTEN, DorisParserParserRLIKE, DorisParserParserROLLBACK, DorisParserParserROLLUP, DorisParserParserROUTINE, DorisParserParserS3, DorisParserParserSAMPLE, DorisParserParserSCHEDULE, DorisParserParserSCHEDULER, DorisParserParserSCHEMA, DorisParserParserSECOND, DorisParserParserSERIALIZABLE, DorisParserParserSESSION, DorisParserParserSESSION_USER, DorisParserParserSET_SESSION_VARIABLE, DorisParserParserSHAPE, DorisParserParserSKEW, DorisParserParserSNAPSHOT, DorisParserParserSNAPSHOTS, DorisParserParserSONAME, DorisParserParserSPLIT, DorisParserParserSQL, DorisParserParserSTAGE, DorisParserParserSTAGES, DorisParserParserSTART, DorisParserParserSTARTS, DorisParserParserSTATS, DorisParserParserSTATUS, DorisParserParserSTOP, DorisParserParserSTORAGE, DorisParserParserSTREAM, DorisParserParserSTREAMING, DorisParserParserSTRING, DorisParserParserSTRUCT, DorisParserParserSUM, DorisParserParserTABLES, DorisParserParserTAG, DorisParserParserTASK, DorisParserParserTASKS, DorisParserParserTEMPORARY, DorisParserParserTEXT, DorisParserParserTHAN, DorisParserParserTIME, DorisParserParserTIMESTAMP, DorisParserParserTRANSACTION, DorisParserParserTREE, DorisParserParserTRIGGERS, DorisParserParserTRUNCATE, DorisParserParserTYPE, DorisParserParserTYPES, DorisParserParserUNCOMMITTED, DorisParserParserUNLOCK, DorisParserParserUNSET, DorisParserParserUP, DorisParserParserUSER, DorisParserParserVALUE, DorisParserParserVARCHAR, DorisParserParserVARIABLE, DorisParserParserVARIABLES, DorisParserParserVARIANT, DorisParserParserVAULT, DorisParserParserVAULTS, DorisParserParserVERBOSE, DorisParserParserVERSION, DorisParserParserVIEW, DorisParserParserVIEWS, DorisParserParserWARM, DorisParserParserWARNINGS, DorisParserParserWEEK, DorisParserParserWORK, DorisParserParserYEAR, DorisParserParserHINT_START, DorisParserParserHINT_END, DorisParserParserCOMMENT_START, DorisParserParserDOUBLEATSIGN, DorisParserParserIDENTIFIER, DorisParserParserBACKQUOTED_IDENTIFIER:
		localctx = NewSetSystemVariableContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		p.SetState(4294)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserDOUBLEATSIGN {
			{
				p.SetState(4288)
				p.Match(DorisParserParserDOUBLEATSIGN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(4292)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 596, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(4289)
					p.StatementScope()
				}
				{
					p.SetState(4290)
					p.Match(DorisParserParserDOT)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}

		}
		{
			p.SetState(4296)
			p.Identifier()
		}
		{
			p.SetState(4297)
			p.Match(DorisParserParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4300)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserParserLEFT_PAREN, DorisParserParserLEFT_BRACKET, DorisParserParserLEFT_BRACE, DorisParserParserRIGHT_BRACE, DorisParserParserACTIONS, DorisParserParserADD, DorisParserParserAFTER, DorisParserParserAGG_STATE, DorisParserParserAGGREGATE, DorisParserParserALIAS, DorisParserParserANALYZED, DorisParserParserARRAY, DorisParserParserAT, DorisParserParserAUTHORS, DorisParserParserAUTO_INCREMENT, DorisParserParserALWAYS, DorisParserParserBACKENDS, DorisParserParserBACKUP, DorisParserParserBEGIN, DorisParserParserBELONG, DorisParserParserBIN, DorisParserParserBINARY, DorisParserParserBITAND, DorisParserParserBITMAP, DorisParserParserBITMAP_EMPTY, DorisParserParserBITMAP_UNION, DorisParserParserBITOR, DorisParserParserBITXOR, DorisParserParserBLOB, DorisParserParserBOOLEAN, DorisParserParserBRANCH, DorisParserParserBRIEF, DorisParserParserBROKER, DorisParserParserBUCKETS, DorisParserParserBUILD, DorisParserParserBUILTIN, DorisParserParserBULK, DorisParserParserCACHE, DorisParserParserCACHED, DorisParserParserCALL, DorisParserParserCASE, DorisParserParserCAST, DorisParserParserCATALOG, DorisParserParserCATALOGS, DorisParserParserCHAIN, DorisParserParserCHAR, DorisParserParserCHARSET, DorisParserParserCHECK, DorisParserParserCLUSTER, DorisParserParserCLUSTERS, DorisParserParserCOLLATION, DorisParserParserCOLLECT, DorisParserParserCOLOCATE, DorisParserParserCOLUMNS, DorisParserParserCOMMENT, DorisParserParserCOMMIT, DorisParserParserCOMMITTED, DorisParserParserCOMPACT, DorisParserParserCOMPLETE, DorisParserParserCOMPRESS_TYPE, DorisParserParserCOMPUTE, DorisParserParserCONDITIONS, DorisParserParserCONFIG, DorisParserParserCONNECTION, DorisParserParserCONNECTION_ID, DorisParserParserCONSISTENT, DorisParserParserCONSTRAINTS, DorisParserParserCONVERT, DorisParserParserCONVERT_LSC, DorisParserParserCOPY, DorisParserParserCOUNT, DorisParserParserCREATION, DorisParserParserCRON, DorisParserParserCURRENT_CATALOG, DorisParserParserCURRENT_DATE, DorisParserParserCURRENT_TIME, DorisParserParserCURRENT_TIMESTAMP, DorisParserParserCURRENT_USER, DorisParserParserDATA, DorisParserParserDATABASE, DorisParserParserDATE, DorisParserParserDATETIME, DorisParserParserDATETIMEV2, DorisParserParserDATEV2, DorisParserParserDATETIMEV1, DorisParserParserDATEV1, DorisParserParserDAY, DorisParserParserDAYS, DorisParserParserDECIMAL, DorisParserParserDECIMALV2, DorisParserParserDECIMALV3, DorisParserParserDEFERRED, DorisParserParserDEMAND, DorisParserParserDIAGNOSE, DorisParserParserDIAGNOSIS, DorisParserParserDICTIONARIES, DorisParserParserDICTIONARY, DorisParserParserDISTINCTPC, DorisParserParserDISTINCTPCSA, DorisParserParserDO, DorisParserParserDORIS_INTERNAL_TABLE_ID, DorisParserParserDUAL, DorisParserParserDYNAMIC, DorisParserParserE, DorisParserParserENABLE, DorisParserParserENCRYPTKEY, DorisParserParserENCRYPTKEYS, DorisParserParserEND, DorisParserParserENDS, DorisParserParserENGINE, DorisParserParserENGINES, DorisParserParserERRORS, DorisParserParserESCAPE, DorisParserParserEVENTS, DorisParserParserEVERY, DorisParserParserEXCLUDE, DorisParserParserEXISTS, DorisParserParserEXPIRED, DorisParserParserEXTERNAL, DorisParserParserEXTRACT, DorisParserParserFAILED_LOGIN_ATTEMPTS, DorisParserParserFALSE, DorisParserParserFAST, DorisParserParserFEATURE, DorisParserParserFIELDS, DorisParserParserFILE, DorisParserParserFILTER, DorisParserParserFIRST, DorisParserParserFORMAT, DorisParserParserFREE, DorisParserParserFRONTENDS, DorisParserParserFUNCTION, DorisParserParserGENERATED, DorisParserParserGENERIC, DorisParserParserGLOBAL, DorisParserParserGRAPH, DorisParserParserGROUPING, DorisParserParserGROUPS, DorisParserParserHASH, DorisParserParserHASH_MAP, DorisParserParserHDFS, DorisParserParserHELP, DorisParserParserHISTOGRAM, DorisParserParserHLL_UNION, DorisParserParserHOSTNAME, DorisParserParserHOTSPOT, DorisParserParserHOUR, DorisParserParserHOURS, DorisParserParserHUB, DorisParserParserIDENTIFIED, DorisParserParserIF, DorisParserParserIGNORE, DorisParserParserIMMEDIATE, DorisParserParserINCREMENTAL, DorisParserParserINDEXES, DorisParserParserINTERVAL, DorisParserParserINVERTED, DorisParserParserIP_TRIE, DorisParserParserIPV4, DorisParserParserIPV6, DorisParserParserIS_NOT_NULL_PRED, DorisParserParserIS_NULL_PRED, DorisParserParserISNULL, DorisParserParserISOLATION, DorisParserParserJOB, DorisParserParserJOBS, DorisParserParserJSON, DorisParserParserJSONB, DorisParserParserKEY, DorisParserParserLABEL, DorisParserParserLAST, DorisParserParserLDAP, DorisParserParserLDAP_ADMIN_PASSWORD, DorisParserParserLEFT, DorisParserParserLESS, DorisParserParserLEVEL, DorisParserParserLIKE, DorisParserParserLINES, DorisParserParserLINK, DorisParserParserLOCAL, DorisParserParserLOCALTIME, DorisParserParserLOCALTIMESTAMP, DorisParserParserLOCATION, DorisParserParserLOCK, DorisParserParserLOGICAL, DorisParserParserMANUAL, DorisParserParserMAP, DorisParserParserMATCH_ALL, DorisParserParserMATCH_ANY, DorisParserParserMATCH_PHRASE, DorisParserParserMATCH_PHRASE_EDGE, DorisParserParserMATCH_PHRASE_PREFIX, DorisParserParserMATCH_REGEXP, DorisParserParserMATERIALIZED, DorisParserParserMAX, DorisParserParserMEMO, DorisParserParserMERGE, DorisParserParserMIGRATE, DorisParserParserMIGRATIONS, DorisParserParserMIN, DorisParserParserMINUTE, DorisParserParserMINUTES, DorisParserParserMODIFY, DorisParserParserMONTH, DorisParserParserMTMV, DorisParserParserNAME, DorisParserParserNAMES, DorisParserParserNEGATIVE, DorisParserParserNEVER, DorisParserParserNEXT, DorisParserParserNGRAM_BF, DorisParserParserNO, DorisParserParserNON_NULLABLE, DorisParserParserNOT, DorisParserParserNULL, DorisParserParserNULLS, DorisParserParserOF, DorisParserParserOFFSET, DorisParserParserONLY, DorisParserParserOPEN, DorisParserParserOPTIMIZED, DorisParserParserPARAMETER, DorisParserParserPARSED, DorisParserParserPARTITIONS, DorisParserParserPASSWORD, DorisParserParserPASSWORD_EXPIRE, DorisParserParserPASSWORD_HISTORY, DorisParserParserPASSWORD_LOCK_TIME, DorisParserParserPASSWORD_REUSE, DorisParserParserPATH, DorisParserParserPAUSE, DorisParserParserPERCENT, DorisParserParserPERIOD, DorisParserParserPERMISSIVE, DorisParserParserPHYSICAL, DorisParserParserPI, DorisParserParserPLACEHOLDER, DorisParserParserPLAN, DorisParserParserPRIVILEGES, DorisParserParserPROCESS, DorisParserParserPLUGIN, DorisParserParserPLUGINS, DorisParserParserPOLICY, DorisParserParserPROC, DorisParserParserPROCESSLIST, DorisParserParserPROFILE, DorisParserParserPROPERTIES, DorisParserParserPROPERTY, DorisParserParserQUANTILE_STATE, DorisParserParserQUANTILE_UNION, DorisParserParserQUERY, DorisParserParserQUEUED, DorisParserParserQUOTA, DorisParserParserQUALIFY, DorisParserParserQUARTER, DorisParserParserRANDOM, DorisParserParserRECENT, DorisParserParserRECOVER, DorisParserParserRECYCLE, DorisParserParserREFRESH, DorisParserParserREGEXP, DorisParserParserREPEATABLE, DorisParserParserREPLACE, DorisParserParserREPLACE_IF_NOT_NULL, DorisParserParserREPLAYER, DorisParserParserREPOSITORIES, DorisParserParserREPOSITORY, DorisParserParserRESOURCE, DorisParserParserRESOURCES, DorisParserParserRESTORE, DorisParserParserRESTRICTIVE, DorisParserParserRESUME, DorisParserParserRETAIN, DorisParserParserRETENTION, DorisParserParserRETURNS, DorisParserParserREWRITTEN, DorisParserParserRIGHT, DorisParserParserRLIKE, DorisParserParserROLLBACK, DorisParserParserROLLUP, DorisParserParserROUTINE, DorisParserParserS3, DorisParserParserSAMPLE, DorisParserParserSCHEDULE, DorisParserParserSCHEDULER, DorisParserParserSCHEMA, DorisParserParserSECOND, DorisParserParserSERIALIZABLE, DorisParserParserSESSION, DorisParserParserSESSION_USER, DorisParserParserSET_SESSION_VARIABLE, DorisParserParserSHAPE, DorisParserParserSKEW, DorisParserParserSNAPSHOT, DorisParserParserSNAPSHOTS, DorisParserParserSONAME, DorisParserParserSPLIT, DorisParserParserSQL, DorisParserParserSTAGE, DorisParserParserSTAGES, DorisParserParserSTART, DorisParserParserSTARTS, DorisParserParserSTATS, DorisParserParserSTATUS, DorisParserParserSTOP, DorisParserParserSTORAGE, DorisParserParserSTREAM, DorisParserParserSTREAMING, DorisParserParserSTRING, DorisParserParserSTRUCT, DorisParserParserSUM, DorisParserParserTABLES, DorisParserParserTAG, DorisParserParserTASK, DorisParserParserTASKS, DorisParserParserTEMPORARY, DorisParserParserTEXT, DorisParserParserTHAN, DorisParserParserTIME, DorisParserParserTIMESTAMP, DorisParserParserTRANSACTION, DorisParserParserTREE, DorisParserParserTRIGGERS, DorisParserParserTRIM, DorisParserParserTRUE, DorisParserParserTRUNCATE, DorisParserParserTYPE, DorisParserParserTYPES, DorisParserParserUNCOMMITTED, DorisParserParserUNLOCK, DorisParserParserUNSET, DorisParserParserUP, DorisParserParserUSER, DorisParserParserVALUE, DorisParserParserVARCHAR, DorisParserParserVARIABLE, DorisParserParserVARIABLES, DorisParserParserVARIANT, DorisParserParserVAULT, DorisParserParserVAULTS, DorisParserParserVERBOSE, DorisParserParserVERSION, DorisParserParserVIEW, DorisParserParserVIEWS, DorisParserParserWARM, DorisParserParserWARNINGS, DorisParserParserWEEK, DorisParserParserWORK, DorisParserParserYEAR, DorisParserParserPLUS, DorisParserParserSUBTRACT, DorisParserParserASTERISK, DorisParserParserTILDE, DorisParserParserLOGICALNOT, DorisParserParserHINT_START, DorisParserParserHINT_END, DorisParserParserCOMMENT_START, DorisParserParserATSIGN, DorisParserParserDOUBLEATSIGN, DorisParserParserSTRING_LITERAL, DorisParserParserINTEGER_VALUE, DorisParserParserEXPONENT_VALUE, DorisParserParserDECIMAL_VALUE, DorisParserParserIDENTIFIER, DorisParserParserBACKQUOTED_IDENTIFIER:
			{
				p.SetState(4298)
				p.Expression()
			}

		case DorisParserParserDEFAULT:
			{
				p.SetState(4299)
				p.Match(DorisParserParserDEFAULT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case DorisParserParserATSIGN:
		localctx = NewSetUserVariableContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4302)
			p.Match(DorisParserParserATSIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4303)
			p.Identifier()
		}
		{
			p.SetState(4304)
			p.Match(DorisParserParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4305)
			p.Expression()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITransactionAccessModeContext is an interface to support dynamic dispatch.
type ITransactionAccessModeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	READ() antlr.TerminalNode
	ONLY() antlr.TerminalNode
	WRITE() antlr.TerminalNode

	// IsTransactionAccessModeContext differentiates from other interfaces.
	IsTransactionAccessModeContext()
}

type TransactionAccessModeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTransactionAccessModeContext() *TransactionAccessModeContext {
	var p = new(TransactionAccessModeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_transactionAccessMode
	return p
}

func InitEmptyTransactionAccessModeContext(p *TransactionAccessModeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_transactionAccessMode
}

func (*TransactionAccessModeContext) IsTransactionAccessModeContext() {}

func NewTransactionAccessModeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TransactionAccessModeContext {
	var p = new(TransactionAccessModeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_transactionAccessMode

	return p
}

func (s *TransactionAccessModeContext) GetParser() antlr.Parser { return s.parser }

func (s *TransactionAccessModeContext) READ() antlr.TerminalNode {
	return s.GetToken(DorisParserParserREAD, 0)
}

func (s *TransactionAccessModeContext) ONLY() antlr.TerminalNode {
	return s.GetToken(DorisParserParserONLY, 0)
}

func (s *TransactionAccessModeContext) WRITE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserWRITE, 0)
}

func (s *TransactionAccessModeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TransactionAccessModeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TransactionAccessModeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitTransactionAccessMode(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) TransactionAccessMode() (localctx ITransactionAccessModeContext) {
	localctx = NewTransactionAccessModeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, DorisParserParserRULE_transactionAccessMode)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4309)
		p.Match(DorisParserParserREAD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4310)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisParserParserONLY || _la == DorisParserParserWRITE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIsolationLevelContext is an interface to support dynamic dispatch.
type IIsolationLevelContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ISOLATION() antlr.TerminalNode
	LEVEL() antlr.TerminalNode
	READ() antlr.TerminalNode
	UNCOMMITTED() antlr.TerminalNode
	COMMITTED() antlr.TerminalNode
	REPEATABLE() antlr.TerminalNode
	SERIALIZABLE() antlr.TerminalNode

	// IsIsolationLevelContext differentiates from other interfaces.
	IsIsolationLevelContext()
}

type IsolationLevelContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIsolationLevelContext() *IsolationLevelContext {
	var p = new(IsolationLevelContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_isolationLevel
	return p
}

func InitEmptyIsolationLevelContext(p *IsolationLevelContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_isolationLevel
}

func (*IsolationLevelContext) IsIsolationLevelContext() {}

func NewIsolationLevelContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IsolationLevelContext {
	var p = new(IsolationLevelContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_isolationLevel

	return p
}

func (s *IsolationLevelContext) GetParser() antlr.Parser { return s.parser }

func (s *IsolationLevelContext) ISOLATION() antlr.TerminalNode {
	return s.GetToken(DorisParserParserISOLATION, 0)
}

func (s *IsolationLevelContext) LEVEL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLEVEL, 0)
}

func (s *IsolationLevelContext) READ() antlr.TerminalNode {
	return s.GetToken(DorisParserParserREAD, 0)
}

func (s *IsolationLevelContext) UNCOMMITTED() antlr.TerminalNode {
	return s.GetToken(DorisParserParserUNCOMMITTED, 0)
}

func (s *IsolationLevelContext) COMMITTED() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOMMITTED, 0)
}

func (s *IsolationLevelContext) REPEATABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserREPEATABLE, 0)
}

func (s *IsolationLevelContext) SERIALIZABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSERIALIZABLE, 0)
}

func (s *IsolationLevelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IsolationLevelContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IsolationLevelContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitIsolationLevel(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) IsolationLevel() (localctx IIsolationLevelContext) {
	localctx = NewIsolationLevelContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, DorisParserParserRULE_isolationLevel)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4312)
		p.Match(DorisParserParserISOLATION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4313)
		p.Match(DorisParserParserLEVEL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4321)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 600, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4314)
			p.Match(DorisParserParserREAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4315)
			p.Match(DorisParserParserUNCOMMITTED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		{
			p.SetState(4316)
			p.Match(DorisParserParserREAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4317)
			p.Match(DorisParserParserCOMMITTED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		{
			p.SetState(4318)
			p.Match(DorisParserParserREPEATABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4319)
			p.Match(DorisParserParserREAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		{
			p.SetState(4320)
			p.Match(DorisParserParserSERIALIZABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISupportedUnsetStatementContext is an interface to support dynamic dispatch.
type ISupportedUnsetStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UNSET() antlr.TerminalNode
	VARIABLE() antlr.TerminalNode
	ALL() antlr.TerminalNode
	Identifier() IIdentifierContext
	StatementScope() IStatementScopeContext
	DEFAULT() antlr.TerminalNode
	STORAGE() antlr.TerminalNode
	VAULT() antlr.TerminalNode

	// IsSupportedUnsetStatementContext differentiates from other interfaces.
	IsSupportedUnsetStatementContext()
}

type SupportedUnsetStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySupportedUnsetStatementContext() *SupportedUnsetStatementContext {
	var p = new(SupportedUnsetStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_supportedUnsetStatement
	return p
}

func InitEmptySupportedUnsetStatementContext(p *SupportedUnsetStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_supportedUnsetStatement
}

func (*SupportedUnsetStatementContext) IsSupportedUnsetStatementContext() {}

func NewSupportedUnsetStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SupportedUnsetStatementContext {
	var p = new(SupportedUnsetStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_supportedUnsetStatement

	return p
}

func (s *SupportedUnsetStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SupportedUnsetStatementContext) UNSET() antlr.TerminalNode {
	return s.GetToken(DorisParserParserUNSET, 0)
}

func (s *SupportedUnsetStatementContext) VARIABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserVARIABLE, 0)
}

func (s *SupportedUnsetStatementContext) ALL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserALL, 0)
}

func (s *SupportedUnsetStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SupportedUnsetStatementContext) StatementScope() IStatementScopeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementScopeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementScopeContext)
}

func (s *SupportedUnsetStatementContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDEFAULT, 0)
}

func (s *SupportedUnsetStatementContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTORAGE, 0)
}

func (s *SupportedUnsetStatementContext) VAULT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserVAULT, 0)
}

func (s *SupportedUnsetStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedUnsetStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SupportedUnsetStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitSupportedUnsetStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) SupportedUnsetStatement() (localctx ISupportedUnsetStatementContext) {
	localctx = NewSupportedUnsetStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, DorisParserParserRULE_supportedUnsetStatement)
	var _la int

	p.SetState(4336)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 603, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4323)
			p.Match(DorisParserParserUNSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4325)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserGLOBAL || _la == DorisParserParserLOCAL || _la == DorisParserParserSESSION {
			{
				p.SetState(4324)
				p.StatementScope()
			}

		}
		{
			p.SetState(4327)
			p.Match(DorisParserParserVARIABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4330)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserParserALL:
			{
				p.SetState(4328)
				p.Match(DorisParserParserALL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case DorisParserParserLEFT_BRACE, DorisParserParserRIGHT_BRACE, DorisParserParserACTIONS, DorisParserParserAFTER, DorisParserParserAGG_STATE, DorisParserParserAGGREGATE, DorisParserParserALIAS, DorisParserParserANALYZED, DorisParserParserARRAY, DorisParserParserAT, DorisParserParserAUTHORS, DorisParserParserAUTO_INCREMENT, DorisParserParserALWAYS, DorisParserParserBACKENDS, DorisParserParserBACKUP, DorisParserParserBEGIN, DorisParserParserBELONG, DorisParserParserBIN, DorisParserParserBITAND, DorisParserParserBITMAP, DorisParserParserBITMAP_EMPTY, DorisParserParserBITMAP_UNION, DorisParserParserBITOR, DorisParserParserBITXOR, DorisParserParserBLOB, DorisParserParserBOOLEAN, DorisParserParserBRANCH, DorisParserParserBRIEF, DorisParserParserBROKER, DorisParserParserBUCKETS, DorisParserParserBUILD, DorisParserParserBUILTIN, DorisParserParserBULK, DorisParserParserCACHE, DorisParserParserCACHED, DorisParserParserCALL, DorisParserParserCATALOG, DorisParserParserCATALOGS, DorisParserParserCHAIN, DorisParserParserCHAR, DorisParserParserCHARSET, DorisParserParserCHECK, DorisParserParserCLUSTER, DorisParserParserCLUSTERS, DorisParserParserCOLLATION, DorisParserParserCOLLECT, DorisParserParserCOLOCATE, DorisParserParserCOLUMNS, DorisParserParserCOMMENT, DorisParserParserCOMMIT, DorisParserParserCOMMITTED, DorisParserParserCOMPACT, DorisParserParserCOMPLETE, DorisParserParserCOMPRESS_TYPE, DorisParserParserCOMPUTE, DorisParserParserCONDITIONS, DorisParserParserCONFIG, DorisParserParserCONNECTION, DorisParserParserCONNECTION_ID, DorisParserParserCONSISTENT, DorisParserParserCONSTRAINTS, DorisParserParserCONVERT, DorisParserParserCONVERT_LSC, DorisParserParserCOPY, DorisParserParserCOUNT, DorisParserParserCREATION, DorisParserParserCRON, DorisParserParserCURRENT_CATALOG, DorisParserParserCURRENT_DATE, DorisParserParserCURRENT_TIME, DorisParserParserCURRENT_TIMESTAMP, DorisParserParserCURRENT_USER, DorisParserParserDATA, DorisParserParserDATE, DorisParserParserDATETIME, DorisParserParserDATETIMEV2, DorisParserParserDATEV2, DorisParserParserDATETIMEV1, DorisParserParserDATEV1, DorisParserParserDAY, DorisParserParserDAYS, DorisParserParserDECIMAL, DorisParserParserDECIMALV2, DorisParserParserDECIMALV3, DorisParserParserDEFERRED, DorisParserParserDEMAND, DorisParserParserDIAGNOSE, DorisParserParserDIAGNOSIS, DorisParserParserDICTIONARIES, DorisParserParserDICTIONARY, DorisParserParserDISTINCTPC, DorisParserParserDISTINCTPCSA, DorisParserParserDO, DorisParserParserDORIS_INTERNAL_TABLE_ID, DorisParserParserDUAL, DorisParserParserDYNAMIC, DorisParserParserE, DorisParserParserENABLE, DorisParserParserENCRYPTKEY, DorisParserParserENCRYPTKEYS, DorisParserParserEND, DorisParserParserENDS, DorisParserParserENGINE, DorisParserParserENGINES, DorisParserParserERRORS, DorisParserParserESCAPE, DorisParserParserEVENTS, DorisParserParserEVERY, DorisParserParserEXCLUDE, DorisParserParserEXPIRED, DorisParserParserEXTERNAL, DorisParserParserFAILED_LOGIN_ATTEMPTS, DorisParserParserFAST, DorisParserParserFEATURE, DorisParserParserFIELDS, DorisParserParserFILE, DorisParserParserFILTER, DorisParserParserFIRST, DorisParserParserFORMAT, DorisParserParserFREE, DorisParserParserFRONTENDS, DorisParserParserFUNCTION, DorisParserParserGENERATED, DorisParserParserGENERIC, DorisParserParserGLOBAL, DorisParserParserGRAPH, DorisParserParserGROUPING, DorisParserParserGROUPS, DorisParserParserHASH, DorisParserParserHASH_MAP, DorisParserParserHDFS, DorisParserParserHELP, DorisParserParserHISTOGRAM, DorisParserParserHLL_UNION, DorisParserParserHOSTNAME, DorisParserParserHOTSPOT, DorisParserParserHOUR, DorisParserParserHOURS, DorisParserParserHUB, DorisParserParserIDENTIFIED, DorisParserParserIGNORE, DorisParserParserIMMEDIATE, DorisParserParserINCREMENTAL, DorisParserParserINDEXES, DorisParserParserINVERTED, DorisParserParserIP_TRIE, DorisParserParserIPV4, DorisParserParserIPV6, DorisParserParserIS_NOT_NULL_PRED, DorisParserParserIS_NULL_PRED, DorisParserParserISNULL, DorisParserParserISOLATION, DorisParserParserJOB, DorisParserParserJOBS, DorisParserParserJSON, DorisParserParserJSONB, DorisParserParserLABEL, DorisParserParserLAST, DorisParserParserLDAP, DorisParserParserLDAP_ADMIN_PASSWORD, DorisParserParserLESS, DorisParserParserLEVEL, DorisParserParserLINES, DorisParserParserLINK, DorisParserParserLOCAL, DorisParserParserLOCALTIME, DorisParserParserLOCALTIMESTAMP, DorisParserParserLOCATION, DorisParserParserLOCK, DorisParserParserLOGICAL, DorisParserParserMANUAL, DorisParserParserMAP, DorisParserParserMATCH_ALL, DorisParserParserMATCH_ANY, DorisParserParserMATCH_PHRASE, DorisParserParserMATCH_PHRASE_EDGE, DorisParserParserMATCH_PHRASE_PREFIX, DorisParserParserMATCH_REGEXP, DorisParserParserMATERIALIZED, DorisParserParserMAX, DorisParserParserMEMO, DorisParserParserMERGE, DorisParserParserMIGRATE, DorisParserParserMIGRATIONS, DorisParserParserMIN, DorisParserParserMINUTE, DorisParserParserMINUTES, DorisParserParserMODIFY, DorisParserParserMONTH, DorisParserParserMTMV, DorisParserParserNAME, DorisParserParserNAMES, DorisParserParserNEGATIVE, DorisParserParserNEVER, DorisParserParserNEXT, DorisParserParserNGRAM_BF, DorisParserParserNO, DorisParserParserNON_NULLABLE, DorisParserParserNULLS, DorisParserParserOF, DorisParserParserOFFSET, DorisParserParserONLY, DorisParserParserOPEN, DorisParserParserOPTIMIZED, DorisParserParserPARAMETER, DorisParserParserPARSED, DorisParserParserPARTITIONS, DorisParserParserPASSWORD, DorisParserParserPASSWORD_EXPIRE, DorisParserParserPASSWORD_HISTORY, DorisParserParserPASSWORD_LOCK_TIME, DorisParserParserPASSWORD_REUSE, DorisParserParserPATH, DorisParserParserPAUSE, DorisParserParserPERCENT, DorisParserParserPERIOD, DorisParserParserPERMISSIVE, DorisParserParserPHYSICAL, DorisParserParserPI, DorisParserParserPLAN, DorisParserParserPRIVILEGES, DorisParserParserPROCESS, DorisParserParserPLUGIN, DorisParserParserPLUGINS, DorisParserParserPOLICY, DorisParserParserPROC, DorisParserParserPROCESSLIST, DorisParserParserPROFILE, DorisParserParserPROPERTIES, DorisParserParserPROPERTY, DorisParserParserQUANTILE_STATE, DorisParserParserQUANTILE_UNION, DorisParserParserQUERY, DorisParserParserQUEUED, DorisParserParserQUOTA, DorisParserParserQUALIFY, DorisParserParserQUARTER, DorisParserParserRANDOM, DorisParserParserRECENT, DorisParserParserRECOVER, DorisParserParserRECYCLE, DorisParserParserREFRESH, DorisParserParserREPEATABLE, DorisParserParserREPLACE, DorisParserParserREPLACE_IF_NOT_NULL, DorisParserParserREPLAYER, DorisParserParserREPOSITORIES, DorisParserParserREPOSITORY, DorisParserParserRESOURCE, DorisParserParserRESOURCES, DorisParserParserRESTORE, DorisParserParserRESTRICTIVE, DorisParserParserRESUME, DorisParserParserRETAIN, DorisParserParserRETENTION, DorisParserParserRETURNS, DorisParserParserREWRITTEN, DorisParserParserRLIKE, DorisParserParserROLLBACK, DorisParserParserROLLUP, DorisParserParserROUTINE, DorisParserParserS3, DorisParserParserSAMPLE, DorisParserParserSCHEDULE, DorisParserParserSCHEDULER, DorisParserParserSCHEMA, DorisParserParserSECOND, DorisParserParserSERIALIZABLE, DorisParserParserSESSION, DorisParserParserSESSION_USER, DorisParserParserSET_SESSION_VARIABLE, DorisParserParserSHAPE, DorisParserParserSKEW, DorisParserParserSNAPSHOT, DorisParserParserSNAPSHOTS, DorisParserParserSONAME, DorisParserParserSPLIT, DorisParserParserSQL, DorisParserParserSTAGE, DorisParserParserSTAGES, DorisParserParserSTART, DorisParserParserSTARTS, DorisParserParserSTATS, DorisParserParserSTATUS, DorisParserParserSTOP, DorisParserParserSTORAGE, DorisParserParserSTREAM, DorisParserParserSTREAMING, DorisParserParserSTRING, DorisParserParserSTRUCT, DorisParserParserSUM, DorisParserParserTABLES, DorisParserParserTAG, DorisParserParserTASK, DorisParserParserTASKS, DorisParserParserTEMPORARY, DorisParserParserTEXT, DorisParserParserTHAN, DorisParserParserTIME, DorisParserParserTIMESTAMP, DorisParserParserTRANSACTION, DorisParserParserTREE, DorisParserParserTRIGGERS, DorisParserParserTRUNCATE, DorisParserParserTYPE, DorisParserParserTYPES, DorisParserParserUNCOMMITTED, DorisParserParserUNLOCK, DorisParserParserUNSET, DorisParserParserUP, DorisParserParserUSER, DorisParserParserVALUE, DorisParserParserVARCHAR, DorisParserParserVARIABLE, DorisParserParserVARIABLES, DorisParserParserVARIANT, DorisParserParserVAULT, DorisParserParserVAULTS, DorisParserParserVERBOSE, DorisParserParserVERSION, DorisParserParserVIEW, DorisParserParserVIEWS, DorisParserParserWARM, DorisParserParserWARNINGS, DorisParserParserWEEK, DorisParserParserWORK, DorisParserParserYEAR, DorisParserParserHINT_START, DorisParserParserHINT_END, DorisParserParserCOMMENT_START, DorisParserParserIDENTIFIER, DorisParserParserBACKQUOTED_IDENTIFIER:
			{
				p.SetState(4329)
				p.Identifier()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4332)
			p.Match(DorisParserParserUNSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4333)
			p.Match(DorisParserParserDEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4334)
			p.Match(DorisParserParserSTORAGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4335)
			p.Match(DorisParserParserVAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISupportedUseStatementContext is an interface to support dynamic dispatch.
type ISupportedUseStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSupportedUseStatementContext differentiates from other interfaces.
	IsSupportedUseStatementContext()
}

type SupportedUseStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySupportedUseStatementContext() *SupportedUseStatementContext {
	var p = new(SupportedUseStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_supportedUseStatement
	return p
}

func InitEmptySupportedUseStatementContext(p *SupportedUseStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_supportedUseStatement
}

func (*SupportedUseStatementContext) IsSupportedUseStatementContext() {}

func NewSupportedUseStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SupportedUseStatementContext {
	var p = new(SupportedUseStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_supportedUseStatement

	return p
}

func (s *SupportedUseStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SupportedUseStatementContext) CopyAll(ctx *SupportedUseStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *SupportedUseStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedUseStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type UseCloudClusterContext struct {
	SupportedUseStatementContext
	catalog  IIdentifierContext
	database IIdentifierContext
	cluster  IIdentifierContext
}

func NewUseCloudClusterContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UseCloudClusterContext {
	var p = new(UseCloudClusterContext)

	InitEmptySupportedUseStatementContext(&p.SupportedUseStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedUseStatementContext))

	return p
}

func (s *UseCloudClusterContext) GetCatalog() IIdentifierContext { return s.catalog }

func (s *UseCloudClusterContext) GetDatabase() IIdentifierContext { return s.database }

func (s *UseCloudClusterContext) GetCluster() IIdentifierContext { return s.cluster }

func (s *UseCloudClusterContext) SetCatalog(v IIdentifierContext) { s.catalog = v }

func (s *UseCloudClusterContext) SetDatabase(v IIdentifierContext) { s.database = v }

func (s *UseCloudClusterContext) SetCluster(v IIdentifierContext) { s.cluster = v }

func (s *UseCloudClusterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UseCloudClusterContext) USE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserUSE, 0)
}

func (s *UseCloudClusterContext) ATSIGN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserATSIGN, 0)
}

func (s *UseCloudClusterContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *UseCloudClusterContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *UseCloudClusterContext) DOT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDOT, 0)
}

func (s *UseCloudClusterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitUseCloudCluster(s)

	default:
		return t.VisitChildren(s)
	}
}

type UseDatabaseContext struct {
	SupportedUseStatementContext
	catalog  IIdentifierContext
	database IIdentifierContext
}

func NewUseDatabaseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UseDatabaseContext {
	var p = new(UseDatabaseContext)

	InitEmptySupportedUseStatementContext(&p.SupportedUseStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedUseStatementContext))

	return p
}

func (s *UseDatabaseContext) GetCatalog() IIdentifierContext { return s.catalog }

func (s *UseDatabaseContext) GetDatabase() IIdentifierContext { return s.database }

func (s *UseDatabaseContext) SetCatalog(v IIdentifierContext) { s.catalog = v }

func (s *UseDatabaseContext) SetDatabase(v IIdentifierContext) { s.database = v }

func (s *UseDatabaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UseDatabaseContext) USE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserUSE, 0)
}

func (s *UseDatabaseContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *UseDatabaseContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *UseDatabaseContext) DOT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDOT, 0)
}

func (s *UseDatabaseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitUseDatabase(s)

	default:
		return t.VisitChildren(s)
	}
}

type SwitchCatalogContext struct {
	SupportedUseStatementContext
	catalog IIdentifierContext
}

func NewSwitchCatalogContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SwitchCatalogContext {
	var p = new(SwitchCatalogContext)

	InitEmptySupportedUseStatementContext(&p.SupportedUseStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedUseStatementContext))

	return p
}

func (s *SwitchCatalogContext) GetCatalog() IIdentifierContext { return s.catalog }

func (s *SwitchCatalogContext) SetCatalog(v IIdentifierContext) { s.catalog = v }

func (s *SwitchCatalogContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SwitchCatalogContext) SWITCH() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSWITCH, 0)
}

func (s *SwitchCatalogContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SwitchCatalogContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitSwitchCatalog(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) SupportedUseStatement() (localctx ISupportedUseStatementContext) {
	localctx = NewSupportedUseStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, DorisParserParserRULE_supportedUseStatement)
	var _la int

	p.SetState(4358)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 607, p.GetParserRuleContext()) {
	case 1:
		localctx = NewSwitchCatalogContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4338)
			p.Match(DorisParserParserSWITCH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4339)

			var _x = p.Identifier()

			localctx.(*SwitchCatalogContext).catalog = _x
		}

	case 2:
		localctx = NewUseDatabaseContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4340)
			p.Match(DorisParserParserUSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4344)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 604, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4341)

				var _x = p.Identifier()

				localctx.(*UseDatabaseContext).catalog = _x
			}
			{
				p.SetState(4342)
				p.Match(DorisParserParserDOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(4346)

			var _x = p.Identifier()

			localctx.(*UseDatabaseContext).database = _x
		}

	case 3:
		localctx = NewUseCloudClusterContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4347)
			p.Match(DorisParserParserUSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4354)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-2305902462020672000) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&4609989332399152113) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-9080794533051819547) != 0) || ((int64((_la-192)) & ^0x3f) == 0 && ((int64(1)<<(_la-192))&2015220189171012521) != 0) || ((int64((_la-256)) & ^0x3f) == 0 && ((int64(1)<<(_la-256))&-5422616543060085911) != 0) || ((int64((_la-320)) & ^0x3f) == 0 && ((int64(1)<<(_la-320))&-4476015178520986877) != 0) || ((int64((_la-384)) & ^0x3f) == 0 && ((int64(1)<<(_la-384))&9222796779122679803) != 0) || ((int64((_la-452)) & ^0x3f) == 0 && ((int64(1)<<(_la-452))&2449945648119953137) != 0) || ((int64((_la-517)) & ^0x3f) == 0 && ((int64(1)<<(_la-517))&206187790337) != 0) {
			p.SetState(4351)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 605, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(4348)

					var _x = p.Identifier()

					localctx.(*UseCloudClusterContext).catalog = _x
				}
				{
					p.SetState(4349)
					p.Match(DorisParserParserDOT)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}
			{
				p.SetState(4353)

				var _x = p.Identifier()

				localctx.(*UseCloudClusterContext).database = _x
			}

		}
		{
			p.SetState(4356)
			p.Match(DorisParserParserATSIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4357)

			var _x = p.Identifier()

			localctx.(*UseCloudClusterContext).cluster = _x
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStageAndPatternContext is an interface to support dynamic dispatch.
type IStageAndPatternContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPattern returns the pattern token.
	GetPattern() antlr.Token

	// SetPattern sets the pattern token.
	SetPattern(antlr.Token)

	// GetStage returns the stage rule contexts.
	GetStage() IIdentifierContext

	// SetStage sets the stage rule contexts.
	SetStage(IIdentifierContext)

	// Getter signatures
	ATSIGN() antlr.TerminalNode
	TILDE() antlr.TerminalNode
	Identifier() IIdentifierContext
	LEFT_PAREN() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode

	// IsStageAndPatternContext differentiates from other interfaces.
	IsStageAndPatternContext()
}

type StageAndPatternContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	stage   IIdentifierContext
	pattern antlr.Token
}

func NewEmptyStageAndPatternContext() *StageAndPatternContext {
	var p = new(StageAndPatternContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_stageAndPattern
	return p
}

func InitEmptyStageAndPatternContext(p *StageAndPatternContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_stageAndPattern
}

func (*StageAndPatternContext) IsStageAndPatternContext() {}

func NewStageAndPatternContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StageAndPatternContext {
	var p = new(StageAndPatternContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_stageAndPattern

	return p
}

func (s *StageAndPatternContext) GetParser() antlr.Parser { return s.parser }

func (s *StageAndPatternContext) GetPattern() antlr.Token { return s.pattern }

func (s *StageAndPatternContext) SetPattern(v antlr.Token) { s.pattern = v }

func (s *StageAndPatternContext) GetStage() IIdentifierContext { return s.stage }

func (s *StageAndPatternContext) SetStage(v IIdentifierContext) { s.stage = v }

func (s *StageAndPatternContext) ATSIGN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserATSIGN, 0)
}

func (s *StageAndPatternContext) TILDE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserTILDE, 0)
}

func (s *StageAndPatternContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *StageAndPatternContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLEFT_PAREN, 0)
}

func (s *StageAndPatternContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRIGHT_PAREN, 0)
}

func (s *StageAndPatternContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTRING_LITERAL, 0)
}

func (s *StageAndPatternContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StageAndPatternContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StageAndPatternContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitStageAndPattern(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) StageAndPattern() (localctx IStageAndPatternContext) {
	localctx = NewStageAndPatternContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, DorisParserParserRULE_stageAndPattern)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4360)
		p.Match(DorisParserParserATSIGN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4363)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserParserLEFT_BRACE, DorisParserParserRIGHT_BRACE, DorisParserParserACTIONS, DorisParserParserAFTER, DorisParserParserAGG_STATE, DorisParserParserAGGREGATE, DorisParserParserALIAS, DorisParserParserANALYZED, DorisParserParserARRAY, DorisParserParserAT, DorisParserParserAUTHORS, DorisParserParserAUTO_INCREMENT, DorisParserParserALWAYS, DorisParserParserBACKENDS, DorisParserParserBACKUP, DorisParserParserBEGIN, DorisParserParserBELONG, DorisParserParserBIN, DorisParserParserBITAND, DorisParserParserBITMAP, DorisParserParserBITMAP_EMPTY, DorisParserParserBITMAP_UNION, DorisParserParserBITOR, DorisParserParserBITXOR, DorisParserParserBLOB, DorisParserParserBOOLEAN, DorisParserParserBRANCH, DorisParserParserBRIEF, DorisParserParserBROKER, DorisParserParserBUCKETS, DorisParserParserBUILD, DorisParserParserBUILTIN, DorisParserParserBULK, DorisParserParserCACHE, DorisParserParserCACHED, DorisParserParserCALL, DorisParserParserCATALOG, DorisParserParserCATALOGS, DorisParserParserCHAIN, DorisParserParserCHAR, DorisParserParserCHARSET, DorisParserParserCHECK, DorisParserParserCLUSTER, DorisParserParserCLUSTERS, DorisParserParserCOLLATION, DorisParserParserCOLLECT, DorisParserParserCOLOCATE, DorisParserParserCOLUMNS, DorisParserParserCOMMENT, DorisParserParserCOMMIT, DorisParserParserCOMMITTED, DorisParserParserCOMPACT, DorisParserParserCOMPLETE, DorisParserParserCOMPRESS_TYPE, DorisParserParserCOMPUTE, DorisParserParserCONDITIONS, DorisParserParserCONFIG, DorisParserParserCONNECTION, DorisParserParserCONNECTION_ID, DorisParserParserCONSISTENT, DorisParserParserCONSTRAINTS, DorisParserParserCONVERT, DorisParserParserCONVERT_LSC, DorisParserParserCOPY, DorisParserParserCOUNT, DorisParserParserCREATION, DorisParserParserCRON, DorisParserParserCURRENT_CATALOG, DorisParserParserCURRENT_DATE, DorisParserParserCURRENT_TIME, DorisParserParserCURRENT_TIMESTAMP, DorisParserParserCURRENT_USER, DorisParserParserDATA, DorisParserParserDATE, DorisParserParserDATETIME, DorisParserParserDATETIMEV2, DorisParserParserDATEV2, DorisParserParserDATETIMEV1, DorisParserParserDATEV1, DorisParserParserDAY, DorisParserParserDAYS, DorisParserParserDECIMAL, DorisParserParserDECIMALV2, DorisParserParserDECIMALV3, DorisParserParserDEFERRED, DorisParserParserDEMAND, DorisParserParserDIAGNOSE, DorisParserParserDIAGNOSIS, DorisParserParserDICTIONARIES, DorisParserParserDICTIONARY, DorisParserParserDISTINCTPC, DorisParserParserDISTINCTPCSA, DorisParserParserDO, DorisParserParserDORIS_INTERNAL_TABLE_ID, DorisParserParserDUAL, DorisParserParserDYNAMIC, DorisParserParserE, DorisParserParserENABLE, DorisParserParserENCRYPTKEY, DorisParserParserENCRYPTKEYS, DorisParserParserEND, DorisParserParserENDS, DorisParserParserENGINE, DorisParserParserENGINES, DorisParserParserERRORS, DorisParserParserESCAPE, DorisParserParserEVENTS, DorisParserParserEVERY, DorisParserParserEXCLUDE, DorisParserParserEXPIRED, DorisParserParserEXTERNAL, DorisParserParserFAILED_LOGIN_ATTEMPTS, DorisParserParserFAST, DorisParserParserFEATURE, DorisParserParserFIELDS, DorisParserParserFILE, DorisParserParserFILTER, DorisParserParserFIRST, DorisParserParserFORMAT, DorisParserParserFREE, DorisParserParserFRONTENDS, DorisParserParserFUNCTION, DorisParserParserGENERATED, DorisParserParserGENERIC, DorisParserParserGLOBAL, DorisParserParserGRAPH, DorisParserParserGROUPING, DorisParserParserGROUPS, DorisParserParserHASH, DorisParserParserHASH_MAP, DorisParserParserHDFS, DorisParserParserHELP, DorisParserParserHISTOGRAM, DorisParserParserHLL_UNION, DorisParserParserHOSTNAME, DorisParserParserHOTSPOT, DorisParserParserHOUR, DorisParserParserHOURS, DorisParserParserHUB, DorisParserParserIDENTIFIED, DorisParserParserIGNORE, DorisParserParserIMMEDIATE, DorisParserParserINCREMENTAL, DorisParserParserINDEXES, DorisParserParserINVERTED, DorisParserParserIP_TRIE, DorisParserParserIPV4, DorisParserParserIPV6, DorisParserParserIS_NOT_NULL_PRED, DorisParserParserIS_NULL_PRED, DorisParserParserISNULL, DorisParserParserISOLATION, DorisParserParserJOB, DorisParserParserJOBS, DorisParserParserJSON, DorisParserParserJSONB, DorisParserParserLABEL, DorisParserParserLAST, DorisParserParserLDAP, DorisParserParserLDAP_ADMIN_PASSWORD, DorisParserParserLESS, DorisParserParserLEVEL, DorisParserParserLINES, DorisParserParserLINK, DorisParserParserLOCAL, DorisParserParserLOCALTIME, DorisParserParserLOCALTIMESTAMP, DorisParserParserLOCATION, DorisParserParserLOCK, DorisParserParserLOGICAL, DorisParserParserMANUAL, DorisParserParserMAP, DorisParserParserMATCH_ALL, DorisParserParserMATCH_ANY, DorisParserParserMATCH_PHRASE, DorisParserParserMATCH_PHRASE_EDGE, DorisParserParserMATCH_PHRASE_PREFIX, DorisParserParserMATCH_REGEXP, DorisParserParserMATERIALIZED, DorisParserParserMAX, DorisParserParserMEMO, DorisParserParserMERGE, DorisParserParserMIGRATE, DorisParserParserMIGRATIONS, DorisParserParserMIN, DorisParserParserMINUTE, DorisParserParserMINUTES, DorisParserParserMODIFY, DorisParserParserMONTH, DorisParserParserMTMV, DorisParserParserNAME, DorisParserParserNAMES, DorisParserParserNEGATIVE, DorisParserParserNEVER, DorisParserParserNEXT, DorisParserParserNGRAM_BF, DorisParserParserNO, DorisParserParserNON_NULLABLE, DorisParserParserNULLS, DorisParserParserOF, DorisParserParserOFFSET, DorisParserParserONLY, DorisParserParserOPEN, DorisParserParserOPTIMIZED, DorisParserParserPARAMETER, DorisParserParserPARSED, DorisParserParserPARTITIONS, DorisParserParserPASSWORD, DorisParserParserPASSWORD_EXPIRE, DorisParserParserPASSWORD_HISTORY, DorisParserParserPASSWORD_LOCK_TIME, DorisParserParserPASSWORD_REUSE, DorisParserParserPATH, DorisParserParserPAUSE, DorisParserParserPERCENT, DorisParserParserPERIOD, DorisParserParserPERMISSIVE, DorisParserParserPHYSICAL, DorisParserParserPI, DorisParserParserPLAN, DorisParserParserPRIVILEGES, DorisParserParserPROCESS, DorisParserParserPLUGIN, DorisParserParserPLUGINS, DorisParserParserPOLICY, DorisParserParserPROC, DorisParserParserPROCESSLIST, DorisParserParserPROFILE, DorisParserParserPROPERTIES, DorisParserParserPROPERTY, DorisParserParserQUANTILE_STATE, DorisParserParserQUANTILE_UNION, DorisParserParserQUERY, DorisParserParserQUEUED, DorisParserParserQUOTA, DorisParserParserQUALIFY, DorisParserParserQUARTER, DorisParserParserRANDOM, DorisParserParserRECENT, DorisParserParserRECOVER, DorisParserParserRECYCLE, DorisParserParserREFRESH, DorisParserParserREPEATABLE, DorisParserParserREPLACE, DorisParserParserREPLACE_IF_NOT_NULL, DorisParserParserREPLAYER, DorisParserParserREPOSITORIES, DorisParserParserREPOSITORY, DorisParserParserRESOURCE, DorisParserParserRESOURCES, DorisParserParserRESTORE, DorisParserParserRESTRICTIVE, DorisParserParserRESUME, DorisParserParserRETAIN, DorisParserParserRETENTION, DorisParserParserRETURNS, DorisParserParserREWRITTEN, DorisParserParserRLIKE, DorisParserParserROLLBACK, DorisParserParserROLLUP, DorisParserParserROUTINE, DorisParserParserS3, DorisParserParserSAMPLE, DorisParserParserSCHEDULE, DorisParserParserSCHEDULER, DorisParserParserSCHEMA, DorisParserParserSECOND, DorisParserParserSERIALIZABLE, DorisParserParserSESSION, DorisParserParserSESSION_USER, DorisParserParserSET_SESSION_VARIABLE, DorisParserParserSHAPE, DorisParserParserSKEW, DorisParserParserSNAPSHOT, DorisParserParserSNAPSHOTS, DorisParserParserSONAME, DorisParserParserSPLIT, DorisParserParserSQL, DorisParserParserSTAGE, DorisParserParserSTAGES, DorisParserParserSTART, DorisParserParserSTARTS, DorisParserParserSTATS, DorisParserParserSTATUS, DorisParserParserSTOP, DorisParserParserSTORAGE, DorisParserParserSTREAM, DorisParserParserSTREAMING, DorisParserParserSTRING, DorisParserParserSTRUCT, DorisParserParserSUM, DorisParserParserTABLES, DorisParserParserTAG, DorisParserParserTASK, DorisParserParserTASKS, DorisParserParserTEMPORARY, DorisParserParserTEXT, DorisParserParserTHAN, DorisParserParserTIME, DorisParserParserTIMESTAMP, DorisParserParserTRANSACTION, DorisParserParserTREE, DorisParserParserTRIGGERS, DorisParserParserTRUNCATE, DorisParserParserTYPE, DorisParserParserTYPES, DorisParserParserUNCOMMITTED, DorisParserParserUNLOCK, DorisParserParserUNSET, DorisParserParserUP, DorisParserParserUSER, DorisParserParserVALUE, DorisParserParserVARCHAR, DorisParserParserVARIABLE, DorisParserParserVARIABLES, DorisParserParserVARIANT, DorisParserParserVAULT, DorisParserParserVAULTS, DorisParserParserVERBOSE, DorisParserParserVERSION, DorisParserParserVIEW, DorisParserParserVIEWS, DorisParserParserWARM, DorisParserParserWARNINGS, DorisParserParserWEEK, DorisParserParserWORK, DorisParserParserYEAR, DorisParserParserHINT_START, DorisParserParserHINT_END, DorisParserParserCOMMENT_START, DorisParserParserIDENTIFIER, DorisParserParserBACKQUOTED_IDENTIFIER:
		{
			p.SetState(4361)

			var _x = p.Identifier()

			localctx.(*StageAndPatternContext).stage = _x
		}

	case DorisParserParserTILDE:
		{
			p.SetState(4362)
			p.Match(DorisParserParserTILDE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(4368)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserParserLEFT_PAREN {
		{
			p.SetState(4365)
			p.Match(DorisParserParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4366)

			var _m = p.Match(DorisParserParserSTRING_LITERAL)

			localctx.(*StageAndPatternContext).pattern = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4367)
			p.Match(DorisParserParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISupportedDescribeStatementContext is an interface to support dynamic dispatch.
type ISupportedDescribeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSupportedDescribeStatementContext differentiates from other interfaces.
	IsSupportedDescribeStatementContext()
}

type SupportedDescribeStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySupportedDescribeStatementContext() *SupportedDescribeStatementContext {
	var p = new(SupportedDescribeStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_supportedDescribeStatement
	return p
}

func InitEmptySupportedDescribeStatementContext(p *SupportedDescribeStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_supportedDescribeStatement
}

func (*SupportedDescribeStatementContext) IsSupportedDescribeStatementContext() {}

func NewSupportedDescribeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SupportedDescribeStatementContext {
	var p = new(SupportedDescribeStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_supportedDescribeStatement

	return p
}

func (s *SupportedDescribeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SupportedDescribeStatementContext) CopyAll(ctx *SupportedDescribeStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *SupportedDescribeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SupportedDescribeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type DescribeTableValuedFunctionContext struct {
	SupportedDescribeStatementContext
	tvfName    IIdentifierContext
	properties IPropertyItemListContext
}

func NewDescribeTableValuedFunctionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DescribeTableValuedFunctionContext {
	var p = new(DescribeTableValuedFunctionContext)

	InitEmptySupportedDescribeStatementContext(&p.SupportedDescribeStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedDescribeStatementContext))

	return p
}

func (s *DescribeTableValuedFunctionContext) GetTvfName() IIdentifierContext { return s.tvfName }

func (s *DescribeTableValuedFunctionContext) GetProperties() IPropertyItemListContext {
	return s.properties
}

func (s *DescribeTableValuedFunctionContext) SetTvfName(v IIdentifierContext) { s.tvfName = v }

func (s *DescribeTableValuedFunctionContext) SetProperties(v IPropertyItemListContext) {
	s.properties = v
}

func (s *DescribeTableValuedFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DescribeTableValuedFunctionContext) ExplainCommand() IExplainCommandContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExplainCommandContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExplainCommandContext)
}

func (s *DescribeTableValuedFunctionContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFUNCTION, 0)
}

func (s *DescribeTableValuedFunctionContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLEFT_PAREN, 0)
}

func (s *DescribeTableValuedFunctionContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRIGHT_PAREN, 0)
}

func (s *DescribeTableValuedFunctionContext) TableAlias() ITableAliasContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableAliasContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableAliasContext)
}

func (s *DescribeTableValuedFunctionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DescribeTableValuedFunctionContext) PropertyItemList() IPropertyItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyItemListContext)
}

func (s *DescribeTableValuedFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitDescribeTableValuedFunction(s)

	default:
		return t.VisitChildren(s)
	}
}

type DescribeTableContext struct {
	SupportedDescribeStatementContext
}

func NewDescribeTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DescribeTableContext {
	var p = new(DescribeTableContext)

	InitEmptySupportedDescribeStatementContext(&p.SupportedDescribeStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedDescribeStatementContext))

	return p
}

func (s *DescribeTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DescribeTableContext) ExplainCommand() IExplainCommandContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExplainCommandContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExplainCommandContext)
}

func (s *DescribeTableContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *DescribeTableContext) SpecifiedPartition() ISpecifiedPartitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISpecifiedPartitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISpecifiedPartitionContext)
}

func (s *DescribeTableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitDescribeTable(s)

	default:
		return t.VisitChildren(s)
	}
}

type DescribeTableAllContext struct {
	SupportedDescribeStatementContext
}

func NewDescribeTableAllContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DescribeTableAllContext {
	var p = new(DescribeTableAllContext)

	InitEmptySupportedDescribeStatementContext(&p.SupportedDescribeStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedDescribeStatementContext))

	return p
}

func (s *DescribeTableAllContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DescribeTableAllContext) ExplainCommand() IExplainCommandContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExplainCommandContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExplainCommandContext)
}

func (s *DescribeTableAllContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *DescribeTableAllContext) ALL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserALL, 0)
}

func (s *DescribeTableAllContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitDescribeTableAll(s)

	default:
		return t.VisitChildren(s)
	}
}

type DescribeDictionaryContext struct {
	SupportedDescribeStatementContext
}

func NewDescribeDictionaryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DescribeDictionaryContext {
	var p = new(DescribeDictionaryContext)

	InitEmptySupportedDescribeStatementContext(&p.SupportedDescribeStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*SupportedDescribeStatementContext))

	return p
}

func (s *DescribeDictionaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DescribeDictionaryContext) ExplainCommand() IExplainCommandContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExplainCommandContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExplainCommandContext)
}

func (s *DescribeDictionaryContext) DICTIONARY() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDICTIONARY, 0)
}

func (s *DescribeDictionaryContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *DescribeDictionaryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitDescribeDictionary(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) SupportedDescribeStatement() (localctx ISupportedDescribeStatementContext) {
	localctx = NewSupportedDescribeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, DorisParserParserRULE_supportedDescribeStatement)
	var _la int

	p.SetState(4393)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 612, p.GetParserRuleContext()) {
	case 1:
		localctx = NewDescribeTableValuedFunctionContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4370)
			p.ExplainCommand()
		}
		{
			p.SetState(4371)
			p.Match(DorisParserParserFUNCTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4372)

			var _x = p.Identifier()

			localctx.(*DescribeTableValuedFunctionContext).tvfName = _x
		}
		{
			p.SetState(4373)
			p.Match(DorisParserParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4375)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-2305884869834627456) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&4609989332399152113) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-9079668633144976923) != 0) || ((int64((_la-192)) & ^0x3f) == 0 && ((int64(1)<<(_la-192))&2015220189171012521) != 0) || ((int64((_la-256)) & ^0x3f) == 0 && ((int64(1)<<(_la-256))&-5278501354984230039) != 0) || ((int64((_la-320)) & ^0x3f) == 0 && ((int64(1)<<(_la-320))&-4476015178504209661) != 0) || ((int64((_la-384)) & ^0x3f) == 0 && ((int64(1)<<(_la-384))&9222796779122679803) != 0) || ((int64((_la-452)) & ^0x3f) == 0 && ((int64(1)<<(_la-452))&2449945648128341745) != 0) || ((int64((_la-517)) & ^0x3f) == 0 && ((int64(1)<<(_la-517))&236386779649) != 0) {
			{
				p.SetState(4374)

				var _x = p.PropertyItemList()

				localctx.(*DescribeTableValuedFunctionContext).properties = _x
			}

		}
		{
			p.SetState(4377)
			p.Match(DorisParserParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4378)
			p.TableAlias()
		}

	case 2:
		localctx = NewDescribeTableAllContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4380)
			p.ExplainCommand()
		}
		{
			p.SetState(4381)
			p.MultipartIdentifier()
		}
		{
			p.SetState(4382)
			p.Match(DorisParserParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		localctx = NewDescribeTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4384)
			p.ExplainCommand()
		}
		{
			p.SetState(4385)
			p.MultipartIdentifier()
		}
		p.SetState(4387)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserPARTITION || _la == DorisParserParserPARTITIONS || _la == DorisParserParserTEMPORARY {
			{
				p.SetState(4386)
				p.SpecifiedPartition()
			}

		}

	case 4:
		localctx = NewDescribeDictionaryContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4389)
			p.ExplainCommand()
		}
		{
			p.SetState(4390)
			p.Match(DorisParserParserDICTIONARY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4391)
			p.MultipartIdentifier()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConstraintContext is an interface to support dynamic dispatch.
type IConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetSlots returns the slots rule contexts.
	GetSlots() IIdentifierListContext

	// GetReferenceTable returns the referenceTable rule contexts.
	GetReferenceTable() IMultipartIdentifierContext

	// GetReferencedSlots returns the referencedSlots rule contexts.
	GetReferencedSlots() IIdentifierListContext

	// SetSlots sets the slots rule contexts.
	SetSlots(IIdentifierListContext)

	// SetReferenceTable sets the referenceTable rule contexts.
	SetReferenceTable(IMultipartIdentifierContext)

	// SetReferencedSlots sets the referencedSlots rule contexts.
	SetReferencedSlots(IIdentifierListContext)

	// Getter signatures
	PRIMARY() antlr.TerminalNode
	KEY() antlr.TerminalNode
	AllIdentifierList() []IIdentifierListContext
	IdentifierList(i int) IIdentifierListContext
	UNIQUE() antlr.TerminalNode
	FOREIGN() antlr.TerminalNode
	REFERENCES() antlr.TerminalNode
	MultipartIdentifier() IMultipartIdentifierContext

	// IsConstraintContext differentiates from other interfaces.
	IsConstraintContext()
}

type ConstraintContext struct {
	antlr.BaseParserRuleContext
	parser          antlr.Parser
	slots           IIdentifierListContext
	referenceTable  IMultipartIdentifierContext
	referencedSlots IIdentifierListContext
}

func NewEmptyConstraintContext() *ConstraintContext {
	var p = new(ConstraintContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_constraint
	return p
}

func InitEmptyConstraintContext(p *ConstraintContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_constraint
}

func (*ConstraintContext) IsConstraintContext() {}

func NewConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstraintContext {
	var p = new(ConstraintContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_constraint

	return p
}

func (s *ConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstraintContext) GetSlots() IIdentifierListContext { return s.slots }

func (s *ConstraintContext) GetReferenceTable() IMultipartIdentifierContext { return s.referenceTable }

func (s *ConstraintContext) GetReferencedSlots() IIdentifierListContext { return s.referencedSlots }

func (s *ConstraintContext) SetSlots(v IIdentifierListContext) { s.slots = v }

func (s *ConstraintContext) SetReferenceTable(v IMultipartIdentifierContext) { s.referenceTable = v }

func (s *ConstraintContext) SetReferencedSlots(v IIdentifierListContext) { s.referencedSlots = v }

func (s *ConstraintContext) PRIMARY() antlr.TerminalNode {
	return s.GetToken(DorisParserParserPRIMARY, 0)
}

func (s *ConstraintContext) KEY() antlr.TerminalNode {
	return s.GetToken(DorisParserParserKEY, 0)
}

func (s *ConstraintContext) AllIdentifierList() []IIdentifierListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierListContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierListContext); ok {
			tst[i] = t.(IIdentifierListContext)
			i++
		}
	}

	return tst
}

func (s *ConstraintContext) IdentifierList(i int) IIdentifierListContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *ConstraintContext) UNIQUE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserUNIQUE, 0)
}

func (s *ConstraintContext) FOREIGN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFOREIGN, 0)
}

func (s *ConstraintContext) REFERENCES() antlr.TerminalNode {
	return s.GetToken(DorisParserParserREFERENCES, 0)
}

func (s *ConstraintContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *ConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) Constraint() (localctx IConstraintContext) {
	localctx = NewConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, DorisParserParserRULE_constraint)
	p.SetState(4407)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserParserPRIMARY:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4395)
			p.Match(DorisParserParserPRIMARY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4396)
			p.Match(DorisParserParserKEY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4397)

			var _x = p.IdentifierList()

			localctx.(*ConstraintContext).slots = _x
		}

	case DorisParserParserUNIQUE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4398)
			p.Match(DorisParserParserUNIQUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4399)

			var _x = p.IdentifierList()

			localctx.(*ConstraintContext).slots = _x
		}

	case DorisParserParserFOREIGN:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4400)
			p.Match(DorisParserParserFOREIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4401)
			p.Match(DorisParserParserKEY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4402)

			var _x = p.IdentifierList()

			localctx.(*ConstraintContext).slots = _x
		}
		{
			p.SetState(4403)
			p.Match(DorisParserParserREFERENCES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4404)

			var _x = p.MultipartIdentifier()

			localctx.(*ConstraintContext).referenceTable = _x
		}
		{
			p.SetState(4405)

			var _x = p.IdentifierList()

			localctx.(*ConstraintContext).referencedSlots = _x
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionSpecContext is an interface to support dynamic dispatch.
type IPartitionSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPartitions returns the partitions rule contexts.
	GetPartitions() IIdentifierListContext

	// GetPartition returns the partition rule contexts.
	GetPartition() IErrorCapturingIdentifierContext

	// SetPartitions sets the partitions rule contexts.
	SetPartitions(IIdentifierListContext)

	// SetPartition sets the partition rule contexts.
	SetPartition(IErrorCapturingIdentifierContext)

	// Getter signatures
	PARTITION() antlr.TerminalNode
	PARTITIONS() antlr.TerminalNode
	IdentifierList() IIdentifierListContext
	TEMPORARY() antlr.TerminalNode
	ErrorCapturingIdentifier() IErrorCapturingIdentifierContext
	LEFT_PAREN() antlr.TerminalNode
	ASTERISK() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode

	// IsPartitionSpecContext differentiates from other interfaces.
	IsPartitionSpecContext()
}

type PartitionSpecContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	partitions IIdentifierListContext
	partition  IErrorCapturingIdentifierContext
}

func NewEmptyPartitionSpecContext() *PartitionSpecContext {
	var p = new(PartitionSpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_partitionSpec
	return p
}

func InitEmptyPartitionSpecContext(p *PartitionSpecContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_partitionSpec
}

func (*PartitionSpecContext) IsPartitionSpecContext() {}

func NewPartitionSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionSpecContext {
	var p = new(PartitionSpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_partitionSpec

	return p
}

func (s *PartitionSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionSpecContext) GetPartitions() IIdentifierListContext { return s.partitions }

func (s *PartitionSpecContext) GetPartition() IErrorCapturingIdentifierContext { return s.partition }

func (s *PartitionSpecContext) SetPartitions(v IIdentifierListContext) { s.partitions = v }

func (s *PartitionSpecContext) SetPartition(v IErrorCapturingIdentifierContext) { s.partition = v }

func (s *PartitionSpecContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(DorisParserParserPARTITION, 0)
}

func (s *PartitionSpecContext) PARTITIONS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserPARTITIONS, 0)
}

func (s *PartitionSpecContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *PartitionSpecContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(DorisParserParserTEMPORARY, 0)
}

func (s *PartitionSpecContext) ErrorCapturingIdentifier() IErrorCapturingIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IErrorCapturingIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IErrorCapturingIdentifierContext)
}

func (s *PartitionSpecContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLEFT_PAREN, 0)
}

func (s *PartitionSpecContext) ASTERISK() antlr.TerminalNode {
	return s.GetToken(DorisParserParserASTERISK, 0)
}

func (s *PartitionSpecContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRIGHT_PAREN, 0)
}

func (s *PartitionSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionSpecContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitPartitionSpec(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) PartitionSpec() (localctx IPartitionSpecContext) {
	localctx = NewPartitionSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, DorisParserParserRULE_partitionSpec)
	var _la int

	p.SetState(4423)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 616, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(4410)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserTEMPORARY {
			{
				p.SetState(4409)
				p.Match(DorisParserParserTEMPORARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4412)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserParserPARTITION || _la == DorisParserParserPARTITIONS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(4413)

			var _x = p.IdentifierList()

			localctx.(*PartitionSpecContext).partitions = _x
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(4415)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserTEMPORARY {
			{
				p.SetState(4414)
				p.Match(DorisParserParserTEMPORARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4417)
			p.Match(DorisParserParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4418)

			var _x = p.ErrorCapturingIdentifier()

			localctx.(*PartitionSpecContext).partition = _x
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4419)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserParserPARTITION || _la == DorisParserParserPARTITIONS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(4420)
			p.Match(DorisParserParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4421)
			p.Match(DorisParserParserASTERISK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4422)
			p.Match(DorisParserParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionTableContext is an interface to support dynamic dispatch.
type IPartitionTableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetAutoPartition returns the autoPartition token.
	GetAutoPartition() antlr.Token

	// SetAutoPartition sets the autoPartition token.
	SetAutoPartition(antlr.Token)

	// GetPartitionList returns the partitionList rule contexts.
	GetPartitionList() IIdentityOrFunctionListContext

	// GetPartitions returns the partitions rule contexts.
	GetPartitions() IPartitionsDefContext

	// SetPartitionList sets the partitionList rule contexts.
	SetPartitionList(IIdentityOrFunctionListContext)

	// SetPartitions sets the partitions rule contexts.
	SetPartitions(IPartitionsDefContext)

	// Getter signatures
	PARTITION() antlr.TerminalNode
	BY() antlr.TerminalNode
	IdentityOrFunctionList() IIdentityOrFunctionListContext
	LEFT_PAREN() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode
	AUTO() antlr.TerminalNode
	RANGE() antlr.TerminalNode
	LIST() antlr.TerminalNode
	PartitionsDef() IPartitionsDefContext

	// IsPartitionTableContext differentiates from other interfaces.
	IsPartitionTableContext()
}

type PartitionTableContext struct {
	antlr.BaseParserRuleContext
	parser        antlr.Parser
	autoPartition antlr.Token
	partitionList IIdentityOrFunctionListContext
	partitions    IPartitionsDefContext
}

func NewEmptyPartitionTableContext() *PartitionTableContext {
	var p = new(PartitionTableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_partitionTable
	return p
}

func InitEmptyPartitionTableContext(p *PartitionTableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_partitionTable
}

func (*PartitionTableContext) IsPartitionTableContext() {}

func NewPartitionTableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionTableContext {
	var p = new(PartitionTableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_partitionTable

	return p
}

func (s *PartitionTableContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionTableContext) GetAutoPartition() antlr.Token { return s.autoPartition }

func (s *PartitionTableContext) SetAutoPartition(v antlr.Token) { s.autoPartition = v }

func (s *PartitionTableContext) GetPartitionList() IIdentityOrFunctionListContext {
	return s.partitionList
}

func (s *PartitionTableContext) GetPartitions() IPartitionsDefContext { return s.partitions }

func (s *PartitionTableContext) SetPartitionList(v IIdentityOrFunctionListContext) {
	s.partitionList = v
}

func (s *PartitionTableContext) SetPartitions(v IPartitionsDefContext) { s.partitions = v }

func (s *PartitionTableContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(DorisParserParserPARTITION, 0)
}

func (s *PartitionTableContext) BY() antlr.TerminalNode {
	return s.GetToken(DorisParserParserBY, 0)
}

func (s *PartitionTableContext) IdentityOrFunctionList() IIdentityOrFunctionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentityOrFunctionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentityOrFunctionListContext)
}

func (s *PartitionTableContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLEFT_PAREN, 0)
}

func (s *PartitionTableContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRIGHT_PAREN, 0)
}

func (s *PartitionTableContext) AUTO() antlr.TerminalNode {
	return s.GetToken(DorisParserParserAUTO, 0)
}

func (s *PartitionTableContext) RANGE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRANGE, 0)
}

func (s *PartitionTableContext) LIST() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLIST, 0)
}

func (s *PartitionTableContext) PartitionsDef() IPartitionsDefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionsDefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionsDefContext)
}

func (s *PartitionTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionTableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionTableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitPartitionTable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) PartitionTable() (localctx IPartitionTableContext) {
	localctx = NewPartitionTableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, DorisParserParserRULE_partitionTable)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4426)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserParserAUTO {
		{
			p.SetState(4425)

			var _m = p.Match(DorisParserParserAUTO)

			localctx.(*PartitionTableContext).autoPartition = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(4428)
		p.Match(DorisParserParserPARTITION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4429)
		p.Match(DorisParserParserBY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4431)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserParserLIST || _la == DorisParserParserRANGE {
		{
			p.SetState(4430)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserParserLIST || _la == DorisParserParserRANGE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(4433)

		var _x = p.IdentityOrFunctionList()

		localctx.(*PartitionTableContext).partitionList = _x
	}

	{
		p.SetState(4434)
		p.Match(DorisParserParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4436)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserParserFROM || _la == DorisParserParserPARTITION {
		{
			p.SetState(4435)

			var _x = p.PartitionsDef()

			localctx.(*PartitionTableContext).partitions = _x
		}

	}
	{
		p.SetState(4438)
		p.Match(DorisParserParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentityOrFunctionListContext is an interface to support dynamic dispatch.
type IIdentityOrFunctionListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_identityOrFunction returns the _identityOrFunction rule contexts.
	Get_identityOrFunction() IIdentityOrFunctionContext

	// Set_identityOrFunction sets the _identityOrFunction rule contexts.
	Set_identityOrFunction(IIdentityOrFunctionContext)

	// GetPartitions returns the partitions rule context list.
	GetPartitions() []IIdentityOrFunctionContext

	// SetPartitions sets the partitions rule context list.
	SetPartitions([]IIdentityOrFunctionContext)

	// Getter signatures
	LEFT_PAREN() antlr.TerminalNode
	AllIdentityOrFunction() []IIdentityOrFunctionContext
	IdentityOrFunction(i int) IIdentityOrFunctionContext
	RIGHT_PAREN() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsIdentityOrFunctionListContext differentiates from other interfaces.
	IsIdentityOrFunctionListContext()
}

type IdentityOrFunctionListContext struct {
	antlr.BaseParserRuleContext
	parser              antlr.Parser
	_identityOrFunction IIdentityOrFunctionContext
	partitions          []IIdentityOrFunctionContext
}

func NewEmptyIdentityOrFunctionListContext() *IdentityOrFunctionListContext {
	var p = new(IdentityOrFunctionListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_identityOrFunctionList
	return p
}

func InitEmptyIdentityOrFunctionListContext(p *IdentityOrFunctionListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_identityOrFunctionList
}

func (*IdentityOrFunctionListContext) IsIdentityOrFunctionListContext() {}

func NewIdentityOrFunctionListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentityOrFunctionListContext {
	var p = new(IdentityOrFunctionListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_identityOrFunctionList

	return p
}

func (s *IdentityOrFunctionListContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentityOrFunctionListContext) Get_identityOrFunction() IIdentityOrFunctionContext {
	return s._identityOrFunction
}

func (s *IdentityOrFunctionListContext) Set_identityOrFunction(v IIdentityOrFunctionContext) {
	s._identityOrFunction = v
}

func (s *IdentityOrFunctionListContext) GetPartitions() []IIdentityOrFunctionContext {
	return s.partitions
}

func (s *IdentityOrFunctionListContext) SetPartitions(v []IIdentityOrFunctionContext) {
	s.partitions = v
}

func (s *IdentityOrFunctionListContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLEFT_PAREN, 0)
}

func (s *IdentityOrFunctionListContext) AllIdentityOrFunction() []IIdentityOrFunctionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentityOrFunctionContext); ok {
			len++
		}
	}

	tst := make([]IIdentityOrFunctionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentityOrFunctionContext); ok {
			tst[i] = t.(IIdentityOrFunctionContext)
			i++
		}
	}

	return tst
}

func (s *IdentityOrFunctionListContext) IdentityOrFunction(i int) IIdentityOrFunctionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentityOrFunctionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentityOrFunctionContext)
}

func (s *IdentityOrFunctionListContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRIGHT_PAREN, 0)
}

func (s *IdentityOrFunctionListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserCOMMA)
}

func (s *IdentityOrFunctionListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOMMA, i)
}

func (s *IdentityOrFunctionListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentityOrFunctionListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentityOrFunctionListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitIdentityOrFunctionList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) IdentityOrFunctionList() (localctx IIdentityOrFunctionListContext) {
	localctx = NewIdentityOrFunctionListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, DorisParserParserRULE_identityOrFunctionList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4440)
		p.Match(DorisParserParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4441)
		p.IdentityOrFunction()
	}
	p.SetState(4446)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisParserParserCOMMA {
		{
			p.SetState(4442)
			p.Match(DorisParserParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4443)

			var _x = p.IdentityOrFunction()

			localctx.(*IdentityOrFunctionListContext)._identityOrFunction = _x
		}
		localctx.(*IdentityOrFunctionListContext).partitions = append(localctx.(*IdentityOrFunctionListContext).partitions, localctx.(*IdentityOrFunctionListContext)._identityOrFunction)

		p.SetState(4448)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(4449)
		p.Match(DorisParserParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentityOrFunctionContext is an interface to support dynamic dispatch.
type IIdentityOrFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	FunctionCallExpression() IFunctionCallExpressionContext

	// IsIdentityOrFunctionContext differentiates from other interfaces.
	IsIdentityOrFunctionContext()
}

type IdentityOrFunctionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentityOrFunctionContext() *IdentityOrFunctionContext {
	var p = new(IdentityOrFunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_identityOrFunction
	return p
}

func InitEmptyIdentityOrFunctionContext(p *IdentityOrFunctionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_identityOrFunction
}

func (*IdentityOrFunctionContext) IsIdentityOrFunctionContext() {}

func NewIdentityOrFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentityOrFunctionContext {
	var p = new(IdentityOrFunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_identityOrFunction

	return p
}

func (s *IdentityOrFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentityOrFunctionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *IdentityOrFunctionContext) FunctionCallExpression() IFunctionCallExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionCallExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionCallExpressionContext)
}

func (s *IdentityOrFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentityOrFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentityOrFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitIdentityOrFunction(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) IdentityOrFunction() (localctx IIdentityOrFunctionContext) {
	localctx = NewIdentityOrFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, DorisParserParserRULE_identityOrFunction)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(4453)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 621, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4451)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(4452)
			p.FunctionCallExpression()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDataDescContext is an interface to support dynamic dispatch.
type IDataDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_STRING_LITERAL returns the _STRING_LITERAL token.
	Get_STRING_LITERAL() antlr.Token

	// GetComma returns the comma token.
	GetComma() antlr.Token

	// GetSeparator returns the separator token.
	GetSeparator() antlr.Token

	// Set_STRING_LITERAL sets the _STRING_LITERAL token.
	Set_STRING_LITERAL(antlr.Token)

	// SetComma sets the comma token.
	SetComma(antlr.Token)

	// SetSeparator sets the separator token.
	SetSeparator(antlr.Token)

	// GetFilePaths returns the filePaths token list.
	GetFilePaths() []antlr.Token

	// GetFilePath returns the filePath token list.
	GetFilePath() []antlr.Token

	// SetFilePaths sets the filePaths token list.
	SetFilePaths([]antlr.Token)

	// SetFilePath sets the filePath token list.
	SetFilePath([]antlr.Token)

	// GetTargetTableName returns the targetTableName rule contexts.
	GetTargetTableName() IIdentifierContext

	// GetFormat returns the format rule contexts.
	GetFormat() IIdentifierOrTextContext

	// GetCompressType returns the compressType rule contexts.
	GetCompressType() IIdentifierOrTextContext

	// GetColumns returns the columns rule contexts.
	GetColumns() IIdentifierListContext

	// GetColumnsFromPath returns the columnsFromPath rule contexts.
	GetColumnsFromPath() IColFromPathContext

	// GetColumnMapping returns the columnMapping rule contexts.
	GetColumnMapping() IColMappingListContext

	// GetPreFilter returns the preFilter rule contexts.
	GetPreFilter() IPreFilterClauseContext

	// GetWhere returns the where rule contexts.
	GetWhere() IWhereClauseContext

	// GetDeleteOn returns the deleteOn rule contexts.
	GetDeleteOn() IDeleteOnClauseContext

	// GetSequenceColumn returns the sequenceColumn rule contexts.
	GetSequenceColumn() ISequenceColClauseContext

	// GetSourceTableName returns the sourceTableName rule contexts.
	GetSourceTableName() IIdentifierContext

	// GetPartition returns the partition rule contexts.
	GetPartition() IIdentifierListContext

	// SetTargetTableName sets the targetTableName rule contexts.
	SetTargetTableName(IIdentifierContext)

	// SetFormat sets the format rule contexts.
	SetFormat(IIdentifierOrTextContext)

	// SetCompressType sets the compressType rule contexts.
	SetCompressType(IIdentifierOrTextContext)

	// SetColumns sets the columns rule contexts.
	SetColumns(IIdentifierListContext)

	// SetColumnsFromPath sets the columnsFromPath rule contexts.
	SetColumnsFromPath(IColFromPathContext)

	// SetColumnMapping sets the columnMapping rule contexts.
	SetColumnMapping(IColMappingListContext)

	// SetPreFilter sets the preFilter rule contexts.
	SetPreFilter(IPreFilterClauseContext)

	// SetWhere sets the where rule contexts.
	SetWhere(IWhereClauseContext)

	// SetDeleteOn sets the deleteOn rule contexts.
	SetDeleteOn(IDeleteOnClauseContext)

	// SetSequenceColumn sets the sequenceColumn rule contexts.
	SetSequenceColumn(ISequenceColClauseContext)

	// SetSourceTableName sets the sourceTableName rule contexts.
	SetSourceTableName(IIdentifierContext)

	// SetPartition sets the partition rule contexts.
	SetPartition(IIdentifierListContext)

	// Getter signatures
	DATA() antlr.TerminalNode
	INFILE() antlr.TerminalNode
	LEFT_PAREN() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode
	INTO() antlr.TerminalNode
	AllTABLE() []antlr.TerminalNode
	TABLE(i int) antlr.TerminalNode
	AllSTRING_LITERAL() []antlr.TerminalNode
	STRING_LITERAL(i int) antlr.TerminalNode
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	MergeType() IMergeTypeContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	PartitionSpec() IPartitionSpecContext
	COLUMNS() antlr.TerminalNode
	AllTERMINATED() []antlr.TerminalNode
	TERMINATED(i int) antlr.TerminalNode
	AllBY() []antlr.TerminalNode
	BY(i int) antlr.TerminalNode
	LINES() antlr.TerminalNode
	FORMAT() antlr.TerminalNode
	AllAS() []antlr.TerminalNode
	AS(i int) antlr.TerminalNode
	COMPRESS_TYPE() antlr.TerminalNode
	PropertyClause() IPropertyClauseContext
	AllIdentifierOrText() []IIdentifierOrTextContext
	IdentifierOrText(i int) IIdentifierOrTextContext
	IdentifierList() IIdentifierListContext
	ColFromPath() IColFromPathContext
	ColMappingList() IColMappingListContext
	PreFilterClause() IPreFilterClauseContext
	WhereClause() IWhereClauseContext
	DeleteOnClause() IDeleteOnClauseContext
	SequenceColClause() ISequenceColClauseContext
	WITH() antlr.TerminalNode
	FROM() antlr.TerminalNode
	PARTITION() antlr.TerminalNode

	// IsDataDescContext differentiates from other interfaces.
	IsDataDescContext()
}

type DataDescContext struct {
	antlr.BaseParserRuleContext
	parser          antlr.Parser
	_STRING_LITERAL antlr.Token
	filePaths       []antlr.Token
	filePath        []antlr.Token
	targetTableName IIdentifierContext
	comma           antlr.Token
	separator       antlr.Token
	format          IIdentifierOrTextContext
	compressType    IIdentifierOrTextContext
	columns         IIdentifierListContext
	columnsFromPath IColFromPathContext
	columnMapping   IColMappingListContext
	preFilter       IPreFilterClauseContext
	where           IWhereClauseContext
	deleteOn        IDeleteOnClauseContext
	sequenceColumn  ISequenceColClauseContext
	sourceTableName IIdentifierContext
	partition       IIdentifierListContext
}

func NewEmptyDataDescContext() *DataDescContext {
	var p = new(DataDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_dataDesc
	return p
}

func InitEmptyDataDescContext(p *DataDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_dataDesc
}

func (*DataDescContext) IsDataDescContext() {}

func NewDataDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataDescContext {
	var p = new(DataDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_dataDesc

	return p
}

func (s *DataDescContext) GetParser() antlr.Parser { return s.parser }

func (s *DataDescContext) Get_STRING_LITERAL() antlr.Token { return s._STRING_LITERAL }

func (s *DataDescContext) GetComma() antlr.Token { return s.comma }

func (s *DataDescContext) GetSeparator() antlr.Token { return s.separator }

func (s *DataDescContext) Set_STRING_LITERAL(v antlr.Token) { s._STRING_LITERAL = v }

func (s *DataDescContext) SetComma(v antlr.Token) { s.comma = v }

func (s *DataDescContext) SetSeparator(v antlr.Token) { s.separator = v }

func (s *DataDescContext) GetFilePaths() []antlr.Token { return s.filePaths }

func (s *DataDescContext) GetFilePath() []antlr.Token { return s.filePath }

func (s *DataDescContext) SetFilePaths(v []antlr.Token) { s.filePaths = v }

func (s *DataDescContext) SetFilePath(v []antlr.Token) { s.filePath = v }

func (s *DataDescContext) GetTargetTableName() IIdentifierContext { return s.targetTableName }

func (s *DataDescContext) GetFormat() IIdentifierOrTextContext { return s.format }

func (s *DataDescContext) GetCompressType() IIdentifierOrTextContext { return s.compressType }

func (s *DataDescContext) GetColumns() IIdentifierListContext { return s.columns }

func (s *DataDescContext) GetColumnsFromPath() IColFromPathContext { return s.columnsFromPath }

func (s *DataDescContext) GetColumnMapping() IColMappingListContext { return s.columnMapping }

func (s *DataDescContext) GetPreFilter() IPreFilterClauseContext { return s.preFilter }

func (s *DataDescContext) GetWhere() IWhereClauseContext { return s.where }

func (s *DataDescContext) GetDeleteOn() IDeleteOnClauseContext { return s.deleteOn }

func (s *DataDescContext) GetSequenceColumn() ISequenceColClauseContext { return s.sequenceColumn }

func (s *DataDescContext) GetSourceTableName() IIdentifierContext { return s.sourceTableName }

func (s *DataDescContext) GetPartition() IIdentifierListContext { return s.partition }

func (s *DataDescContext) SetTargetTableName(v IIdentifierContext) { s.targetTableName = v }

func (s *DataDescContext) SetFormat(v IIdentifierOrTextContext) { s.format = v }

func (s *DataDescContext) SetCompressType(v IIdentifierOrTextContext) { s.compressType = v }

func (s *DataDescContext) SetColumns(v IIdentifierListContext) { s.columns = v }

func (s *DataDescContext) SetColumnsFromPath(v IColFromPathContext) { s.columnsFromPath = v }

func (s *DataDescContext) SetColumnMapping(v IColMappingListContext) { s.columnMapping = v }

func (s *DataDescContext) SetPreFilter(v IPreFilterClauseContext) { s.preFilter = v }

func (s *DataDescContext) SetWhere(v IWhereClauseContext) { s.where = v }

func (s *DataDescContext) SetDeleteOn(v IDeleteOnClauseContext) { s.deleteOn = v }

func (s *DataDescContext) SetSequenceColumn(v ISequenceColClauseContext) { s.sequenceColumn = v }

func (s *DataDescContext) SetSourceTableName(v IIdentifierContext) { s.sourceTableName = v }

func (s *DataDescContext) SetPartition(v IIdentifierListContext) { s.partition = v }

func (s *DataDescContext) DATA() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDATA, 0)
}

func (s *DataDescContext) INFILE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserINFILE, 0)
}

func (s *DataDescContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLEFT_PAREN, 0)
}

func (s *DataDescContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRIGHT_PAREN, 0)
}

func (s *DataDescContext) INTO() antlr.TerminalNode {
	return s.GetToken(DorisParserParserINTO, 0)
}

func (s *DataDescContext) AllTABLE() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserTABLE)
}

func (s *DataDescContext) TABLE(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserTABLE, i)
}

func (s *DataDescContext) AllSTRING_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserSTRING_LITERAL)
}

func (s *DataDescContext) STRING_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTRING_LITERAL, i)
}

func (s *DataDescContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *DataDescContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DataDescContext) MergeType() IMergeTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMergeTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMergeTypeContext)
}

func (s *DataDescContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserCOMMA)
}

func (s *DataDescContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOMMA, i)
}

func (s *DataDescContext) PartitionSpec() IPartitionSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionSpecContext)
}

func (s *DataDescContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOLUMNS, 0)
}

func (s *DataDescContext) AllTERMINATED() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserTERMINATED)
}

func (s *DataDescContext) TERMINATED(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserTERMINATED, i)
}

func (s *DataDescContext) AllBY() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserBY)
}

func (s *DataDescContext) BY(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserBY, i)
}

func (s *DataDescContext) LINES() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLINES, 0)
}

func (s *DataDescContext) FORMAT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFORMAT, 0)
}

func (s *DataDescContext) AllAS() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserAS)
}

func (s *DataDescContext) AS(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserAS, i)
}

func (s *DataDescContext) COMPRESS_TYPE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOMPRESS_TYPE, 0)
}

func (s *DataDescContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *DataDescContext) AllIdentifierOrText() []IIdentifierOrTextContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierOrTextContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierOrTextContext); ok {
			tst[i] = t.(IIdentifierOrTextContext)
			i++
		}
	}

	return tst
}

func (s *DataDescContext) IdentifierOrText(i int) IIdentifierOrTextContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *DataDescContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *DataDescContext) ColFromPath() IColFromPathContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColFromPathContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColFromPathContext)
}

func (s *DataDescContext) ColMappingList() IColMappingListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColMappingListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColMappingListContext)
}

func (s *DataDescContext) PreFilterClause() IPreFilterClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPreFilterClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPreFilterClauseContext)
}

func (s *DataDescContext) WhereClause() IWhereClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhereClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhereClauseContext)
}

func (s *DataDescContext) DeleteOnClause() IDeleteOnClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeleteOnClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeleteOnClauseContext)
}

func (s *DataDescContext) SequenceColClause() ISequenceColClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISequenceColClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISequenceColClauseContext)
}

func (s *DataDescContext) WITH() antlr.TerminalNode {
	return s.GetToken(DorisParserParserWITH, 0)
}

func (s *DataDescContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFROM, 0)
}

func (s *DataDescContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(DorisParserParserPARTITION, 0)
}

func (s *DataDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataDescContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitDataDesc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) DataDesc() (localctx IDataDescContext) {
	localctx = NewDataDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, DorisParserParserRULE_dataDesc)
	var _la int

	p.SetState(4554)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 645, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(4459)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserAPPEND || _la == DorisParserParserDELETE || _la == DorisParserParserMERGE || _la == DorisParserParserWITH {
			p.SetState(4456)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserParserWITH {
				{
					p.SetState(4455)
					p.Match(DorisParserParserWITH)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(4458)
				p.MergeType()
			}

		}
		{
			p.SetState(4461)
			p.Match(DorisParserParserDATA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4462)
			p.Match(DorisParserParserINFILE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4463)
			p.Match(DorisParserParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4464)

			var _m = p.Match(DorisParserParserSTRING_LITERAL)

			localctx.(*DataDescContext)._STRING_LITERAL = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*DataDescContext).filePaths = append(localctx.(*DataDescContext).filePaths, localctx.(*DataDescContext)._STRING_LITERAL)
		p.SetState(4469)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserParserCOMMA {
			{
				p.SetState(4465)
				p.Match(DorisParserParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4466)

				var _m = p.Match(DorisParserParserSTRING_LITERAL)

				localctx.(*DataDescContext)._STRING_LITERAL = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			localctx.(*DataDescContext).filePath = append(localctx.(*DataDescContext).filePath, localctx.(*DataDescContext)._STRING_LITERAL)

			p.SetState(4471)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(4472)
			p.Match(DorisParserParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4473)
			p.Match(DorisParserParserINTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4474)
			p.Match(DorisParserParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4475)

			var _x = p.Identifier()

			localctx.(*DataDescContext).targetTableName = _x
		}
		p.SetState(4477)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserPARTITION || _la == DorisParserParserPARTITIONS || _la == DorisParserParserTEMPORARY {
			{
				p.SetState(4476)
				p.PartitionSpec()
			}

		}
		p.SetState(4483)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 626, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4479)
				p.Match(DorisParserParserCOLUMNS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4480)
				p.Match(DorisParserParserTERMINATED)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4481)
				p.Match(DorisParserParserBY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4482)

				var _m = p.Match(DorisParserParserSTRING_LITERAL)

				localctx.(*DataDescContext).comma = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(4489)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserLINES {
			{
				p.SetState(4485)
				p.Match(DorisParserParserLINES)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4486)
				p.Match(DorisParserParserTERMINATED)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4487)
				p.Match(DorisParserParserBY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4488)

				var _m = p.Match(DorisParserParserSTRING_LITERAL)

				localctx.(*DataDescContext).separator = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(4494)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserFORMAT {
			{
				p.SetState(4491)
				p.Match(DorisParserParserFORMAT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4492)
				p.Match(DorisParserParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4493)

				var _x = p.IdentifierOrText()

				localctx.(*DataDescContext).format = _x
			}

		}
		p.SetState(4499)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserCOMPRESS_TYPE {
			{
				p.SetState(4496)
				p.Match(DorisParserParserCOMPRESS_TYPE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4497)
				p.Match(DorisParserParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4498)

				var _x = p.IdentifierOrText()

				localctx.(*DataDescContext).compressType = _x
			}

		}
		p.SetState(4502)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserLEFT_PAREN {
			{
				p.SetState(4501)

				var _x = p.IdentifierList()

				localctx.(*DataDescContext).columns = _x
			}

		}
		p.SetState(4505)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserCOLUMNS {
			{
				p.SetState(4504)

				var _x = p.ColFromPath()

				localctx.(*DataDescContext).columnsFromPath = _x
			}

		}
		p.SetState(4508)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserSET {
			{
				p.SetState(4507)

				var _x = p.ColMappingList()

				localctx.(*DataDescContext).columnMapping = _x
			}

		}
		p.SetState(4511)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserPRECEDING {
			{
				p.SetState(4510)

				var _x = p.PreFilterClause()

				localctx.(*DataDescContext).preFilter = _x
			}

		}
		p.SetState(4514)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserWHERE {
			{
				p.SetState(4513)

				var _x = p.WhereClause()

				localctx.(*DataDescContext).where = _x
			}

		}
		p.SetState(4517)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserDELETE {
			{
				p.SetState(4516)

				var _x = p.DeleteOnClause()

				localctx.(*DataDescContext).deleteOn = _x
			}

		}
		p.SetState(4520)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserORDER {
			{
				p.SetState(4519)

				var _x = p.SequenceColClause()

				localctx.(*DataDescContext).sequenceColumn = _x
			}

		}
		p.SetState(4523)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserPROPERTIES {
			{
				p.SetState(4522)
				p.PropertyClause()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(4529)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserAPPEND || _la == DorisParserParserDELETE || _la == DorisParserParserMERGE || _la == DorisParserParserWITH {
			p.SetState(4526)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserParserWITH {
				{
					p.SetState(4525)
					p.Match(DorisParserParserWITH)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(4528)
				p.MergeType()
			}

		}
		{
			p.SetState(4531)
			p.Match(DorisParserParserDATA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4532)
			p.Match(DorisParserParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4533)
			p.Match(DorisParserParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4534)

			var _x = p.Identifier()

			localctx.(*DataDescContext).sourceTableName = _x
		}
		{
			p.SetState(4535)
			p.Match(DorisParserParserINTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4536)
			p.Match(DorisParserParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4537)

			var _x = p.Identifier()

			localctx.(*DataDescContext).targetTableName = _x
		}
		p.SetState(4540)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserPARTITION {
			{
				p.SetState(4538)
				p.Match(DorisParserParserPARTITION)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4539)

				var _x = p.IdentifierList()

				localctx.(*DataDescContext).partition = _x
			}

		}
		p.SetState(4543)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserSET {
			{
				p.SetState(4542)

				var _x = p.ColMappingList()

				localctx.(*DataDescContext).columnMapping = _x
			}

		}
		p.SetState(4546)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserWHERE {
			{
				p.SetState(4545)

				var _x = p.WhereClause()

				localctx.(*DataDescContext).where = _x
			}

		}
		p.SetState(4549)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserDELETE {
			{
				p.SetState(4548)

				var _x = p.DeleteOnClause()

				localctx.(*DataDescContext).deleteOn = _x
			}

		}
		p.SetState(4552)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserPROPERTIES {
			{
				p.SetState(4551)
				p.PropertyClause()
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStatementScopeContext is an interface to support dynamic dispatch.
type IStatementScopeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GLOBAL() antlr.TerminalNode
	SESSION() antlr.TerminalNode
	LOCAL() antlr.TerminalNode

	// IsStatementScopeContext differentiates from other interfaces.
	IsStatementScopeContext()
}

type StatementScopeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementScopeContext() *StatementScopeContext {
	var p = new(StatementScopeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_statementScope
	return p
}

func InitEmptyStatementScopeContext(p *StatementScopeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_statementScope
}

func (*StatementScopeContext) IsStatementScopeContext() {}

func NewStatementScopeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementScopeContext {
	var p = new(StatementScopeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_statementScope

	return p
}

func (s *StatementScopeContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementScopeContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserGLOBAL, 0)
}

func (s *StatementScopeContext) SESSION() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSESSION, 0)
}

func (s *StatementScopeContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLOCAL, 0)
}

func (s *StatementScopeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementScopeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementScopeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitStatementScope(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) StatementScope() (localctx IStatementScopeContext) {
	localctx = NewStatementScopeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, DorisParserParserRULE_statementScope)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4556)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisParserParserGLOBAL || _la == DorisParserParserLOCAL || _la == DorisParserParserSESSION) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBuildModeContext is an interface to support dynamic dispatch.
type IBuildModeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BUILD() antlr.TerminalNode
	IMMEDIATE() antlr.TerminalNode
	DEFERRED() antlr.TerminalNode

	// IsBuildModeContext differentiates from other interfaces.
	IsBuildModeContext()
}

type BuildModeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBuildModeContext() *BuildModeContext {
	var p = new(BuildModeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_buildMode
	return p
}

func InitEmptyBuildModeContext(p *BuildModeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_buildMode
}

func (*BuildModeContext) IsBuildModeContext() {}

func NewBuildModeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BuildModeContext {
	var p = new(BuildModeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_buildMode

	return p
}

func (s *BuildModeContext) GetParser() antlr.Parser { return s.parser }

func (s *BuildModeContext) BUILD() antlr.TerminalNode {
	return s.GetToken(DorisParserParserBUILD, 0)
}

func (s *BuildModeContext) IMMEDIATE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserIMMEDIATE, 0)
}

func (s *BuildModeContext) DEFERRED() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDEFERRED, 0)
}

func (s *BuildModeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BuildModeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BuildModeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitBuildMode(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) BuildMode() (localctx IBuildModeContext) {
	localctx = NewBuildModeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, DorisParserParserRULE_buildMode)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4558)
		p.Match(DorisParserParserBUILD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4559)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisParserParserDEFERRED || _la == DorisParserParserIMMEDIATE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRefreshTriggerContext is an interface to support dynamic dispatch.
type IRefreshTriggerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ON() antlr.TerminalNode
	MANUAL() antlr.TerminalNode
	SCHEDULE() antlr.TerminalNode
	RefreshSchedule() IRefreshScheduleContext
	COMMIT() antlr.TerminalNode

	// IsRefreshTriggerContext differentiates from other interfaces.
	IsRefreshTriggerContext()
}

type RefreshTriggerContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRefreshTriggerContext() *RefreshTriggerContext {
	var p = new(RefreshTriggerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_refreshTrigger
	return p
}

func InitEmptyRefreshTriggerContext(p *RefreshTriggerContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_refreshTrigger
}

func (*RefreshTriggerContext) IsRefreshTriggerContext() {}

func NewRefreshTriggerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RefreshTriggerContext {
	var p = new(RefreshTriggerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_refreshTrigger

	return p
}

func (s *RefreshTriggerContext) GetParser() antlr.Parser { return s.parser }

func (s *RefreshTriggerContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisParserParserON, 0)
}

func (s *RefreshTriggerContext) MANUAL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserMANUAL, 0)
}

func (s *RefreshTriggerContext) SCHEDULE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSCHEDULE, 0)
}

func (s *RefreshTriggerContext) RefreshSchedule() IRefreshScheduleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRefreshScheduleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRefreshScheduleContext)
}

func (s *RefreshTriggerContext) COMMIT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOMMIT, 0)
}

func (s *RefreshTriggerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RefreshTriggerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RefreshTriggerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitRefreshTrigger(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) RefreshTrigger() (localctx IRefreshTriggerContext) {
	localctx = NewRefreshTriggerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, DorisParserParserRULE_refreshTrigger)
	p.SetState(4568)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 646, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4561)
			p.Match(DorisParserParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4562)
			p.Match(DorisParserParserMANUAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4563)
			p.Match(DorisParserParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4564)
			p.Match(DorisParserParserSCHEDULE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4565)
			p.RefreshSchedule()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4566)
			p.Match(DorisParserParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4567)
			p.Match(DorisParserParserCOMMIT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRefreshScheduleContext is an interface to support dynamic dispatch.
type IRefreshScheduleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetRefreshUnit returns the refreshUnit rule contexts.
	GetRefreshUnit() IIdentifierContext

	// SetRefreshUnit sets the refreshUnit rule contexts.
	SetRefreshUnit(IIdentifierContext)

	// Getter signatures
	EVERY() antlr.TerminalNode
	INTEGER_VALUE() antlr.TerminalNode
	Identifier() IIdentifierContext
	STARTS() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode

	// IsRefreshScheduleContext differentiates from other interfaces.
	IsRefreshScheduleContext()
}

type RefreshScheduleContext struct {
	antlr.BaseParserRuleContext
	parser      antlr.Parser
	refreshUnit IIdentifierContext
}

func NewEmptyRefreshScheduleContext() *RefreshScheduleContext {
	var p = new(RefreshScheduleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_refreshSchedule
	return p
}

func InitEmptyRefreshScheduleContext(p *RefreshScheduleContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_refreshSchedule
}

func (*RefreshScheduleContext) IsRefreshScheduleContext() {}

func NewRefreshScheduleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RefreshScheduleContext {
	var p = new(RefreshScheduleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_refreshSchedule

	return p
}

func (s *RefreshScheduleContext) GetParser() antlr.Parser { return s.parser }

func (s *RefreshScheduleContext) GetRefreshUnit() IIdentifierContext { return s.refreshUnit }

func (s *RefreshScheduleContext) SetRefreshUnit(v IIdentifierContext) { s.refreshUnit = v }

func (s *RefreshScheduleContext) EVERY() antlr.TerminalNode {
	return s.GetToken(DorisParserParserEVERY, 0)
}

func (s *RefreshScheduleContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserINTEGER_VALUE, 0)
}

func (s *RefreshScheduleContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *RefreshScheduleContext) STARTS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTARTS, 0)
}

func (s *RefreshScheduleContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTRING_LITERAL, 0)
}

func (s *RefreshScheduleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RefreshScheduleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RefreshScheduleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitRefreshSchedule(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) RefreshSchedule() (localctx IRefreshScheduleContext) {
	localctx = NewRefreshScheduleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, DorisParserParserRULE_refreshSchedule)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4570)
		p.Match(DorisParserParserEVERY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4571)
		p.Match(DorisParserParserINTEGER_VALUE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4572)

		var _x = p.Identifier()

		localctx.(*RefreshScheduleContext).refreshUnit = _x
	}
	p.SetState(4575)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserParserSTARTS {
		{
			p.SetState(4573)
			p.Match(DorisParserParserSTARTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4574)
			p.Match(DorisParserParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRefreshMethodContext is an interface to support dynamic dispatch.
type IRefreshMethodContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COMPLETE() antlr.TerminalNode
	AUTO() antlr.TerminalNode

	// IsRefreshMethodContext differentiates from other interfaces.
	IsRefreshMethodContext()
}

type RefreshMethodContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRefreshMethodContext() *RefreshMethodContext {
	var p = new(RefreshMethodContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_refreshMethod
	return p
}

func InitEmptyRefreshMethodContext(p *RefreshMethodContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_refreshMethod
}

func (*RefreshMethodContext) IsRefreshMethodContext() {}

func NewRefreshMethodContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RefreshMethodContext {
	var p = new(RefreshMethodContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_refreshMethod

	return p
}

func (s *RefreshMethodContext) GetParser() antlr.Parser { return s.parser }

func (s *RefreshMethodContext) COMPLETE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOMPLETE, 0)
}

func (s *RefreshMethodContext) AUTO() antlr.TerminalNode {
	return s.GetToken(DorisParserParserAUTO, 0)
}

func (s *RefreshMethodContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RefreshMethodContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RefreshMethodContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitRefreshMethod(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) RefreshMethod() (localctx IRefreshMethodContext) {
	localctx = NewRefreshMethodContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, DorisParserParserRULE_refreshMethod)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4577)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisParserParserAUTO || _la == DorisParserParserCOMPLETE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMvPartitionContext is an interface to support dynamic dispatch.
type IMvPartitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPartitionKey returns the partitionKey rule contexts.
	GetPartitionKey() IIdentifierContext

	// GetPartitionExpr returns the partitionExpr rule contexts.
	GetPartitionExpr() IFunctionCallExpressionContext

	// SetPartitionKey sets the partitionKey rule contexts.
	SetPartitionKey(IIdentifierContext)

	// SetPartitionExpr sets the partitionExpr rule contexts.
	SetPartitionExpr(IFunctionCallExpressionContext)

	// Getter signatures
	Identifier() IIdentifierContext
	FunctionCallExpression() IFunctionCallExpressionContext

	// IsMvPartitionContext differentiates from other interfaces.
	IsMvPartitionContext()
}

type MvPartitionContext struct {
	antlr.BaseParserRuleContext
	parser        antlr.Parser
	partitionKey  IIdentifierContext
	partitionExpr IFunctionCallExpressionContext
}

func NewEmptyMvPartitionContext() *MvPartitionContext {
	var p = new(MvPartitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_mvPartition
	return p
}

func InitEmptyMvPartitionContext(p *MvPartitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_mvPartition
}

func (*MvPartitionContext) IsMvPartitionContext() {}

func NewMvPartitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MvPartitionContext {
	var p = new(MvPartitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_mvPartition

	return p
}

func (s *MvPartitionContext) GetParser() antlr.Parser { return s.parser }

func (s *MvPartitionContext) GetPartitionKey() IIdentifierContext { return s.partitionKey }

func (s *MvPartitionContext) GetPartitionExpr() IFunctionCallExpressionContext {
	return s.partitionExpr
}

func (s *MvPartitionContext) SetPartitionKey(v IIdentifierContext) { s.partitionKey = v }

func (s *MvPartitionContext) SetPartitionExpr(v IFunctionCallExpressionContext) { s.partitionExpr = v }

func (s *MvPartitionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *MvPartitionContext) FunctionCallExpression() IFunctionCallExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionCallExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionCallExpressionContext)
}

func (s *MvPartitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MvPartitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MvPartitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitMvPartition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) MvPartition() (localctx IMvPartitionContext) {
	localctx = NewMvPartitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, DorisParserParserRULE_mvPartition)
	p.SetState(4581)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 648, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4579)

			var _x = p.Identifier()

			localctx.(*MvPartitionContext).partitionKey = _x
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4580)

			var _x = p.FunctionCallExpression()

			localctx.(*MvPartitionContext).partitionExpr = _x
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierOrTextContext is an interface to support dynamic dispatch.
type IIdentifierOrTextContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	STRING_LITERAL() antlr.TerminalNode

	// IsIdentifierOrTextContext differentiates from other interfaces.
	IsIdentifierOrTextContext()
}

type IdentifierOrTextContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierOrTextContext() *IdentifierOrTextContext {
	var p = new(IdentifierOrTextContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_identifierOrText
	return p
}

func InitEmptyIdentifierOrTextContext(p *IdentifierOrTextContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_identifierOrText
}

func (*IdentifierOrTextContext) IsIdentifierOrTextContext() {}

func NewIdentifierOrTextContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierOrTextContext {
	var p = new(IdentifierOrTextContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_identifierOrText

	return p
}

func (s *IdentifierOrTextContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierOrTextContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *IdentifierOrTextContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTRING_LITERAL, 0)
}

func (s *IdentifierOrTextContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierOrTextContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierOrTextContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitIdentifierOrText(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) IdentifierOrText() (localctx IIdentifierOrTextContext) {
	localctx = NewIdentifierOrTextContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, DorisParserParserRULE_identifierOrText)
	p.SetState(4585)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserParserLEFT_BRACE, DorisParserParserRIGHT_BRACE, DorisParserParserACTIONS, DorisParserParserAFTER, DorisParserParserAGG_STATE, DorisParserParserAGGREGATE, DorisParserParserALIAS, DorisParserParserANALYZED, DorisParserParserARRAY, DorisParserParserAT, DorisParserParserAUTHORS, DorisParserParserAUTO_INCREMENT, DorisParserParserALWAYS, DorisParserParserBACKENDS, DorisParserParserBACKUP, DorisParserParserBEGIN, DorisParserParserBELONG, DorisParserParserBIN, DorisParserParserBITAND, DorisParserParserBITMAP, DorisParserParserBITMAP_EMPTY, DorisParserParserBITMAP_UNION, DorisParserParserBITOR, DorisParserParserBITXOR, DorisParserParserBLOB, DorisParserParserBOOLEAN, DorisParserParserBRANCH, DorisParserParserBRIEF, DorisParserParserBROKER, DorisParserParserBUCKETS, DorisParserParserBUILD, DorisParserParserBUILTIN, DorisParserParserBULK, DorisParserParserCACHE, DorisParserParserCACHED, DorisParserParserCALL, DorisParserParserCATALOG, DorisParserParserCATALOGS, DorisParserParserCHAIN, DorisParserParserCHAR, DorisParserParserCHARSET, DorisParserParserCHECK, DorisParserParserCLUSTER, DorisParserParserCLUSTERS, DorisParserParserCOLLATION, DorisParserParserCOLLECT, DorisParserParserCOLOCATE, DorisParserParserCOLUMNS, DorisParserParserCOMMENT, DorisParserParserCOMMIT, DorisParserParserCOMMITTED, DorisParserParserCOMPACT, DorisParserParserCOMPLETE, DorisParserParserCOMPRESS_TYPE, DorisParserParserCOMPUTE, DorisParserParserCONDITIONS, DorisParserParserCONFIG, DorisParserParserCONNECTION, DorisParserParserCONNECTION_ID, DorisParserParserCONSISTENT, DorisParserParserCONSTRAINTS, DorisParserParserCONVERT, DorisParserParserCONVERT_LSC, DorisParserParserCOPY, DorisParserParserCOUNT, DorisParserParserCREATION, DorisParserParserCRON, DorisParserParserCURRENT_CATALOG, DorisParserParserCURRENT_DATE, DorisParserParserCURRENT_TIME, DorisParserParserCURRENT_TIMESTAMP, DorisParserParserCURRENT_USER, DorisParserParserDATA, DorisParserParserDATE, DorisParserParserDATETIME, DorisParserParserDATETIMEV2, DorisParserParserDATEV2, DorisParserParserDATETIMEV1, DorisParserParserDATEV1, DorisParserParserDAY, DorisParserParserDAYS, DorisParserParserDECIMAL, DorisParserParserDECIMALV2, DorisParserParserDECIMALV3, DorisParserParserDEFERRED, DorisParserParserDEMAND, DorisParserParserDIAGNOSE, DorisParserParserDIAGNOSIS, DorisParserParserDICTIONARIES, DorisParserParserDICTIONARY, DorisParserParserDISTINCTPC, DorisParserParserDISTINCTPCSA, DorisParserParserDO, DorisParserParserDORIS_INTERNAL_TABLE_ID, DorisParserParserDUAL, DorisParserParserDYNAMIC, DorisParserParserE, DorisParserParserENABLE, DorisParserParserENCRYPTKEY, DorisParserParserENCRYPTKEYS, DorisParserParserEND, DorisParserParserENDS, DorisParserParserENGINE, DorisParserParserENGINES, DorisParserParserERRORS, DorisParserParserESCAPE, DorisParserParserEVENTS, DorisParserParserEVERY, DorisParserParserEXCLUDE, DorisParserParserEXPIRED, DorisParserParserEXTERNAL, DorisParserParserFAILED_LOGIN_ATTEMPTS, DorisParserParserFAST, DorisParserParserFEATURE, DorisParserParserFIELDS, DorisParserParserFILE, DorisParserParserFILTER, DorisParserParserFIRST, DorisParserParserFORMAT, DorisParserParserFREE, DorisParserParserFRONTENDS, DorisParserParserFUNCTION, DorisParserParserGENERATED, DorisParserParserGENERIC, DorisParserParserGLOBAL, DorisParserParserGRAPH, DorisParserParserGROUPING, DorisParserParserGROUPS, DorisParserParserHASH, DorisParserParserHASH_MAP, DorisParserParserHDFS, DorisParserParserHELP, DorisParserParserHISTOGRAM, DorisParserParserHLL_UNION, DorisParserParserHOSTNAME, DorisParserParserHOTSPOT, DorisParserParserHOUR, DorisParserParserHOURS, DorisParserParserHUB, DorisParserParserIDENTIFIED, DorisParserParserIGNORE, DorisParserParserIMMEDIATE, DorisParserParserINCREMENTAL, DorisParserParserINDEXES, DorisParserParserINVERTED, DorisParserParserIP_TRIE, DorisParserParserIPV4, DorisParserParserIPV6, DorisParserParserIS_NOT_NULL_PRED, DorisParserParserIS_NULL_PRED, DorisParserParserISNULL, DorisParserParserISOLATION, DorisParserParserJOB, DorisParserParserJOBS, DorisParserParserJSON, DorisParserParserJSONB, DorisParserParserLABEL, DorisParserParserLAST, DorisParserParserLDAP, DorisParserParserLDAP_ADMIN_PASSWORD, DorisParserParserLESS, DorisParserParserLEVEL, DorisParserParserLINES, DorisParserParserLINK, DorisParserParserLOCAL, DorisParserParserLOCALTIME, DorisParserParserLOCALTIMESTAMP, DorisParserParserLOCATION, DorisParserParserLOCK, DorisParserParserLOGICAL, DorisParserParserMANUAL, DorisParserParserMAP, DorisParserParserMATCH_ALL, DorisParserParserMATCH_ANY, DorisParserParserMATCH_PHRASE, DorisParserParserMATCH_PHRASE_EDGE, DorisParserParserMATCH_PHRASE_PREFIX, DorisParserParserMATCH_REGEXP, DorisParserParserMATERIALIZED, DorisParserParserMAX, DorisParserParserMEMO, DorisParserParserMERGE, DorisParserParserMIGRATE, DorisParserParserMIGRATIONS, DorisParserParserMIN, DorisParserParserMINUTE, DorisParserParserMINUTES, DorisParserParserMODIFY, DorisParserParserMONTH, DorisParserParserMTMV, DorisParserParserNAME, DorisParserParserNAMES, DorisParserParserNEGATIVE, DorisParserParserNEVER, DorisParserParserNEXT, DorisParserParserNGRAM_BF, DorisParserParserNO, DorisParserParserNON_NULLABLE, DorisParserParserNULLS, DorisParserParserOF, DorisParserParserOFFSET, DorisParserParserONLY, DorisParserParserOPEN, DorisParserParserOPTIMIZED, DorisParserParserPARAMETER, DorisParserParserPARSED, DorisParserParserPARTITIONS, DorisParserParserPASSWORD, DorisParserParserPASSWORD_EXPIRE, DorisParserParserPASSWORD_HISTORY, DorisParserParserPASSWORD_LOCK_TIME, DorisParserParserPASSWORD_REUSE, DorisParserParserPATH, DorisParserParserPAUSE, DorisParserParserPERCENT, DorisParserParserPERIOD, DorisParserParserPERMISSIVE, DorisParserParserPHYSICAL, DorisParserParserPI, DorisParserParserPLAN, DorisParserParserPRIVILEGES, DorisParserParserPROCESS, DorisParserParserPLUGIN, DorisParserParserPLUGINS, DorisParserParserPOLICY, DorisParserParserPROC, DorisParserParserPROCESSLIST, DorisParserParserPROFILE, DorisParserParserPROPERTIES, DorisParserParserPROPERTY, DorisParserParserQUANTILE_STATE, DorisParserParserQUANTILE_UNION, DorisParserParserQUERY, DorisParserParserQUEUED, DorisParserParserQUOTA, DorisParserParserQUALIFY, DorisParserParserQUARTER, DorisParserParserRANDOM, DorisParserParserRECENT, DorisParserParserRECOVER, DorisParserParserRECYCLE, DorisParserParserREFRESH, DorisParserParserREPEATABLE, DorisParserParserREPLACE, DorisParserParserREPLACE_IF_NOT_NULL, DorisParserParserREPLAYER, DorisParserParserREPOSITORIES, DorisParserParserREPOSITORY, DorisParserParserRESOURCE, DorisParserParserRESOURCES, DorisParserParserRESTORE, DorisParserParserRESTRICTIVE, DorisParserParserRESUME, DorisParserParserRETAIN, DorisParserParserRETENTION, DorisParserParserRETURNS, DorisParserParserREWRITTEN, DorisParserParserRLIKE, DorisParserParserROLLBACK, DorisParserParserROLLUP, DorisParserParserROUTINE, DorisParserParserS3, DorisParserParserSAMPLE, DorisParserParserSCHEDULE, DorisParserParserSCHEDULER, DorisParserParserSCHEMA, DorisParserParserSECOND, DorisParserParserSERIALIZABLE, DorisParserParserSESSION, DorisParserParserSESSION_USER, DorisParserParserSET_SESSION_VARIABLE, DorisParserParserSHAPE, DorisParserParserSKEW, DorisParserParserSNAPSHOT, DorisParserParserSNAPSHOTS, DorisParserParserSONAME, DorisParserParserSPLIT, DorisParserParserSQL, DorisParserParserSTAGE, DorisParserParserSTAGES, DorisParserParserSTART, DorisParserParserSTARTS, DorisParserParserSTATS, DorisParserParserSTATUS, DorisParserParserSTOP, DorisParserParserSTORAGE, DorisParserParserSTREAM, DorisParserParserSTREAMING, DorisParserParserSTRING, DorisParserParserSTRUCT, DorisParserParserSUM, DorisParserParserTABLES, DorisParserParserTAG, DorisParserParserTASK, DorisParserParserTASKS, DorisParserParserTEMPORARY, DorisParserParserTEXT, DorisParserParserTHAN, DorisParserParserTIME, DorisParserParserTIMESTAMP, DorisParserParserTRANSACTION, DorisParserParserTREE, DorisParserParserTRIGGERS, DorisParserParserTRUNCATE, DorisParserParserTYPE, DorisParserParserTYPES, DorisParserParserUNCOMMITTED, DorisParserParserUNLOCK, DorisParserParserUNSET, DorisParserParserUP, DorisParserParserUSER, DorisParserParserVALUE, DorisParserParserVARCHAR, DorisParserParserVARIABLE, DorisParserParserVARIABLES, DorisParserParserVARIANT, DorisParserParserVAULT, DorisParserParserVAULTS, DorisParserParserVERBOSE, DorisParserParserVERSION, DorisParserParserVIEW, DorisParserParserVIEWS, DorisParserParserWARM, DorisParserParserWARNINGS, DorisParserParserWEEK, DorisParserParserWORK, DorisParserParserYEAR, DorisParserParserHINT_START, DorisParserParserHINT_END, DorisParserParserCOMMENT_START, DorisParserParserIDENTIFIER, DorisParserParserBACKQUOTED_IDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4583)
			p.Identifier()
		}

	case DorisParserParserSTRING_LITERAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4584)
			p.Match(DorisParserParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierOrTextOrAsteriskContext is an interface to support dynamic dispatch.
type IIdentifierOrTextOrAsteriskContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	STRING_LITERAL() antlr.TerminalNode
	ASTERISK() antlr.TerminalNode

	// IsIdentifierOrTextOrAsteriskContext differentiates from other interfaces.
	IsIdentifierOrTextOrAsteriskContext()
}

type IdentifierOrTextOrAsteriskContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierOrTextOrAsteriskContext() *IdentifierOrTextOrAsteriskContext {
	var p = new(IdentifierOrTextOrAsteriskContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_identifierOrTextOrAsterisk
	return p
}

func InitEmptyIdentifierOrTextOrAsteriskContext(p *IdentifierOrTextOrAsteriskContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_identifierOrTextOrAsterisk
}

func (*IdentifierOrTextOrAsteriskContext) IsIdentifierOrTextOrAsteriskContext() {}

func NewIdentifierOrTextOrAsteriskContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierOrTextOrAsteriskContext {
	var p = new(IdentifierOrTextOrAsteriskContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_identifierOrTextOrAsterisk

	return p
}

func (s *IdentifierOrTextOrAsteriskContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierOrTextOrAsteriskContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *IdentifierOrTextOrAsteriskContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTRING_LITERAL, 0)
}

func (s *IdentifierOrTextOrAsteriskContext) ASTERISK() antlr.TerminalNode {
	return s.GetToken(DorisParserParserASTERISK, 0)
}

func (s *IdentifierOrTextOrAsteriskContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierOrTextOrAsteriskContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierOrTextOrAsteriskContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitIdentifierOrTextOrAsterisk(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) IdentifierOrTextOrAsterisk() (localctx IIdentifierOrTextOrAsteriskContext) {
	localctx = NewIdentifierOrTextOrAsteriskContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, DorisParserParserRULE_identifierOrTextOrAsterisk)
	p.SetState(4590)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserParserLEFT_BRACE, DorisParserParserRIGHT_BRACE, DorisParserParserACTIONS, DorisParserParserAFTER, DorisParserParserAGG_STATE, DorisParserParserAGGREGATE, DorisParserParserALIAS, DorisParserParserANALYZED, DorisParserParserARRAY, DorisParserParserAT, DorisParserParserAUTHORS, DorisParserParserAUTO_INCREMENT, DorisParserParserALWAYS, DorisParserParserBACKENDS, DorisParserParserBACKUP, DorisParserParserBEGIN, DorisParserParserBELONG, DorisParserParserBIN, DorisParserParserBITAND, DorisParserParserBITMAP, DorisParserParserBITMAP_EMPTY, DorisParserParserBITMAP_UNION, DorisParserParserBITOR, DorisParserParserBITXOR, DorisParserParserBLOB, DorisParserParserBOOLEAN, DorisParserParserBRANCH, DorisParserParserBRIEF, DorisParserParserBROKER, DorisParserParserBUCKETS, DorisParserParserBUILD, DorisParserParserBUILTIN, DorisParserParserBULK, DorisParserParserCACHE, DorisParserParserCACHED, DorisParserParserCALL, DorisParserParserCATALOG, DorisParserParserCATALOGS, DorisParserParserCHAIN, DorisParserParserCHAR, DorisParserParserCHARSET, DorisParserParserCHECK, DorisParserParserCLUSTER, DorisParserParserCLUSTERS, DorisParserParserCOLLATION, DorisParserParserCOLLECT, DorisParserParserCOLOCATE, DorisParserParserCOLUMNS, DorisParserParserCOMMENT, DorisParserParserCOMMIT, DorisParserParserCOMMITTED, DorisParserParserCOMPACT, DorisParserParserCOMPLETE, DorisParserParserCOMPRESS_TYPE, DorisParserParserCOMPUTE, DorisParserParserCONDITIONS, DorisParserParserCONFIG, DorisParserParserCONNECTION, DorisParserParserCONNECTION_ID, DorisParserParserCONSISTENT, DorisParserParserCONSTRAINTS, DorisParserParserCONVERT, DorisParserParserCONVERT_LSC, DorisParserParserCOPY, DorisParserParserCOUNT, DorisParserParserCREATION, DorisParserParserCRON, DorisParserParserCURRENT_CATALOG, DorisParserParserCURRENT_DATE, DorisParserParserCURRENT_TIME, DorisParserParserCURRENT_TIMESTAMP, DorisParserParserCURRENT_USER, DorisParserParserDATA, DorisParserParserDATE, DorisParserParserDATETIME, DorisParserParserDATETIMEV2, DorisParserParserDATEV2, DorisParserParserDATETIMEV1, DorisParserParserDATEV1, DorisParserParserDAY, DorisParserParserDAYS, DorisParserParserDECIMAL, DorisParserParserDECIMALV2, DorisParserParserDECIMALV3, DorisParserParserDEFERRED, DorisParserParserDEMAND, DorisParserParserDIAGNOSE, DorisParserParserDIAGNOSIS, DorisParserParserDICTIONARIES, DorisParserParserDICTIONARY, DorisParserParserDISTINCTPC, DorisParserParserDISTINCTPCSA, DorisParserParserDO, DorisParserParserDORIS_INTERNAL_TABLE_ID, DorisParserParserDUAL, DorisParserParserDYNAMIC, DorisParserParserE, DorisParserParserENABLE, DorisParserParserENCRYPTKEY, DorisParserParserENCRYPTKEYS, DorisParserParserEND, DorisParserParserENDS, DorisParserParserENGINE, DorisParserParserENGINES, DorisParserParserERRORS, DorisParserParserESCAPE, DorisParserParserEVENTS, DorisParserParserEVERY, DorisParserParserEXCLUDE, DorisParserParserEXPIRED, DorisParserParserEXTERNAL, DorisParserParserFAILED_LOGIN_ATTEMPTS, DorisParserParserFAST, DorisParserParserFEATURE, DorisParserParserFIELDS, DorisParserParserFILE, DorisParserParserFILTER, DorisParserParserFIRST, DorisParserParserFORMAT, DorisParserParserFREE, DorisParserParserFRONTENDS, DorisParserParserFUNCTION, DorisParserParserGENERATED, DorisParserParserGENERIC, DorisParserParserGLOBAL, DorisParserParserGRAPH, DorisParserParserGROUPING, DorisParserParserGROUPS, DorisParserParserHASH, DorisParserParserHASH_MAP, DorisParserParserHDFS, DorisParserParserHELP, DorisParserParserHISTOGRAM, DorisParserParserHLL_UNION, DorisParserParserHOSTNAME, DorisParserParserHOTSPOT, DorisParserParserHOUR, DorisParserParserHOURS, DorisParserParserHUB, DorisParserParserIDENTIFIED, DorisParserParserIGNORE, DorisParserParserIMMEDIATE, DorisParserParserINCREMENTAL, DorisParserParserINDEXES, DorisParserParserINVERTED, DorisParserParserIP_TRIE, DorisParserParserIPV4, DorisParserParserIPV6, DorisParserParserIS_NOT_NULL_PRED, DorisParserParserIS_NULL_PRED, DorisParserParserISNULL, DorisParserParserISOLATION, DorisParserParserJOB, DorisParserParserJOBS, DorisParserParserJSON, DorisParserParserJSONB, DorisParserParserLABEL, DorisParserParserLAST, DorisParserParserLDAP, DorisParserParserLDAP_ADMIN_PASSWORD, DorisParserParserLESS, DorisParserParserLEVEL, DorisParserParserLINES, DorisParserParserLINK, DorisParserParserLOCAL, DorisParserParserLOCALTIME, DorisParserParserLOCALTIMESTAMP, DorisParserParserLOCATION, DorisParserParserLOCK, DorisParserParserLOGICAL, DorisParserParserMANUAL, DorisParserParserMAP, DorisParserParserMATCH_ALL, DorisParserParserMATCH_ANY, DorisParserParserMATCH_PHRASE, DorisParserParserMATCH_PHRASE_EDGE, DorisParserParserMATCH_PHRASE_PREFIX, DorisParserParserMATCH_REGEXP, DorisParserParserMATERIALIZED, DorisParserParserMAX, DorisParserParserMEMO, DorisParserParserMERGE, DorisParserParserMIGRATE, DorisParserParserMIGRATIONS, DorisParserParserMIN, DorisParserParserMINUTE, DorisParserParserMINUTES, DorisParserParserMODIFY, DorisParserParserMONTH, DorisParserParserMTMV, DorisParserParserNAME, DorisParserParserNAMES, DorisParserParserNEGATIVE, DorisParserParserNEVER, DorisParserParserNEXT, DorisParserParserNGRAM_BF, DorisParserParserNO, DorisParserParserNON_NULLABLE, DorisParserParserNULLS, DorisParserParserOF, DorisParserParserOFFSET, DorisParserParserONLY, DorisParserParserOPEN, DorisParserParserOPTIMIZED, DorisParserParserPARAMETER, DorisParserParserPARSED, DorisParserParserPARTITIONS, DorisParserParserPASSWORD, DorisParserParserPASSWORD_EXPIRE, DorisParserParserPASSWORD_HISTORY, DorisParserParserPASSWORD_LOCK_TIME, DorisParserParserPASSWORD_REUSE, DorisParserParserPATH, DorisParserParserPAUSE, DorisParserParserPERCENT, DorisParserParserPERIOD, DorisParserParserPERMISSIVE, DorisParserParserPHYSICAL, DorisParserParserPI, DorisParserParserPLAN, DorisParserParserPRIVILEGES, DorisParserParserPROCESS, DorisParserParserPLUGIN, DorisParserParserPLUGINS, DorisParserParserPOLICY, DorisParserParserPROC, DorisParserParserPROCESSLIST, DorisParserParserPROFILE, DorisParserParserPROPERTIES, DorisParserParserPROPERTY, DorisParserParserQUANTILE_STATE, DorisParserParserQUANTILE_UNION, DorisParserParserQUERY, DorisParserParserQUEUED, DorisParserParserQUOTA, DorisParserParserQUALIFY, DorisParserParserQUARTER, DorisParserParserRANDOM, DorisParserParserRECENT, DorisParserParserRECOVER, DorisParserParserRECYCLE, DorisParserParserREFRESH, DorisParserParserREPEATABLE, DorisParserParserREPLACE, DorisParserParserREPLACE_IF_NOT_NULL, DorisParserParserREPLAYER, DorisParserParserREPOSITORIES, DorisParserParserREPOSITORY, DorisParserParserRESOURCE, DorisParserParserRESOURCES, DorisParserParserRESTORE, DorisParserParserRESTRICTIVE, DorisParserParserRESUME, DorisParserParserRETAIN, DorisParserParserRETENTION, DorisParserParserRETURNS, DorisParserParserREWRITTEN, DorisParserParserRLIKE, DorisParserParserROLLBACK, DorisParserParserROLLUP, DorisParserParserROUTINE, DorisParserParserS3, DorisParserParserSAMPLE, DorisParserParserSCHEDULE, DorisParserParserSCHEDULER, DorisParserParserSCHEMA, DorisParserParserSECOND, DorisParserParserSERIALIZABLE, DorisParserParserSESSION, DorisParserParserSESSION_USER, DorisParserParserSET_SESSION_VARIABLE, DorisParserParserSHAPE, DorisParserParserSKEW, DorisParserParserSNAPSHOT, DorisParserParserSNAPSHOTS, DorisParserParserSONAME, DorisParserParserSPLIT, DorisParserParserSQL, DorisParserParserSTAGE, DorisParserParserSTAGES, DorisParserParserSTART, DorisParserParserSTARTS, DorisParserParserSTATS, DorisParserParserSTATUS, DorisParserParserSTOP, DorisParserParserSTORAGE, DorisParserParserSTREAM, DorisParserParserSTREAMING, DorisParserParserSTRING, DorisParserParserSTRUCT, DorisParserParserSUM, DorisParserParserTABLES, DorisParserParserTAG, DorisParserParserTASK, DorisParserParserTASKS, DorisParserParserTEMPORARY, DorisParserParserTEXT, DorisParserParserTHAN, DorisParserParserTIME, DorisParserParserTIMESTAMP, DorisParserParserTRANSACTION, DorisParserParserTREE, DorisParserParserTRIGGERS, DorisParserParserTRUNCATE, DorisParserParserTYPE, DorisParserParserTYPES, DorisParserParserUNCOMMITTED, DorisParserParserUNLOCK, DorisParserParserUNSET, DorisParserParserUP, DorisParserParserUSER, DorisParserParserVALUE, DorisParserParserVARCHAR, DorisParserParserVARIABLE, DorisParserParserVARIABLES, DorisParserParserVARIANT, DorisParserParserVAULT, DorisParserParserVAULTS, DorisParserParserVERBOSE, DorisParserParserVERSION, DorisParserParserVIEW, DorisParserParserVIEWS, DorisParserParserWARM, DorisParserParserWARNINGS, DorisParserParserWEEK, DorisParserParserWORK, DorisParserParserYEAR, DorisParserParserHINT_START, DorisParserParserHINT_END, DorisParserParserCOMMENT_START, DorisParserParserIDENTIFIER, DorisParserParserBACKQUOTED_IDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4587)
			p.Identifier()
		}

	case DorisParserParserSTRING_LITERAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4588)
			p.Match(DorisParserParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserParserASTERISK:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4589)
			p.Match(DorisParserParserASTERISK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMultipartIdentifierOrAsteriskContext is an interface to support dynamic dispatch.
type IMultipartIdentifierOrAsteriskContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_identifierOrAsterisk returns the _identifierOrAsterisk rule contexts.
	Get_identifierOrAsterisk() IIdentifierOrAsteriskContext

	// Set_identifierOrAsterisk sets the _identifierOrAsterisk rule contexts.
	Set_identifierOrAsterisk(IIdentifierOrAsteriskContext)

	// GetParts returns the parts rule context list.
	GetParts() []IIdentifierOrAsteriskContext

	// SetParts sets the parts rule context list.
	SetParts([]IIdentifierOrAsteriskContext)

	// Getter signatures
	AllIdentifierOrAsterisk() []IIdentifierOrAsteriskContext
	IdentifierOrAsterisk(i int) IIdentifierOrAsteriskContext
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode

	// IsMultipartIdentifierOrAsteriskContext differentiates from other interfaces.
	IsMultipartIdentifierOrAsteriskContext()
}

type MultipartIdentifierOrAsteriskContext struct {
	antlr.BaseParserRuleContext
	parser                antlr.Parser
	_identifierOrAsterisk IIdentifierOrAsteriskContext
	parts                 []IIdentifierOrAsteriskContext
}

func NewEmptyMultipartIdentifierOrAsteriskContext() *MultipartIdentifierOrAsteriskContext {
	var p = new(MultipartIdentifierOrAsteriskContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_multipartIdentifierOrAsterisk
	return p
}

func InitEmptyMultipartIdentifierOrAsteriskContext(p *MultipartIdentifierOrAsteriskContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_multipartIdentifierOrAsterisk
}

func (*MultipartIdentifierOrAsteriskContext) IsMultipartIdentifierOrAsteriskContext() {}

func NewMultipartIdentifierOrAsteriskContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultipartIdentifierOrAsteriskContext {
	var p = new(MultipartIdentifierOrAsteriskContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_multipartIdentifierOrAsterisk

	return p
}

func (s *MultipartIdentifierOrAsteriskContext) GetParser() antlr.Parser { return s.parser }

func (s *MultipartIdentifierOrAsteriskContext) Get_identifierOrAsterisk() IIdentifierOrAsteriskContext {
	return s._identifierOrAsterisk
}

func (s *MultipartIdentifierOrAsteriskContext) Set_identifierOrAsterisk(v IIdentifierOrAsteriskContext) {
	s._identifierOrAsterisk = v
}

func (s *MultipartIdentifierOrAsteriskContext) GetParts() []IIdentifierOrAsteriskContext {
	return s.parts
}

func (s *MultipartIdentifierOrAsteriskContext) SetParts(v []IIdentifierOrAsteriskContext) {
	s.parts = v
}

func (s *MultipartIdentifierOrAsteriskContext) AllIdentifierOrAsterisk() []IIdentifierOrAsteriskContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierOrAsteriskContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierOrAsteriskContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierOrAsteriskContext); ok {
			tst[i] = t.(IIdentifierOrAsteriskContext)
			i++
		}
	}

	return tst
}

func (s *MultipartIdentifierOrAsteriskContext) IdentifierOrAsterisk(i int) IIdentifierOrAsteriskContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrAsteriskContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrAsteriskContext)
}

func (s *MultipartIdentifierOrAsteriskContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserDOT)
}

func (s *MultipartIdentifierOrAsteriskContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserDOT, i)
}

func (s *MultipartIdentifierOrAsteriskContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultipartIdentifierOrAsteriskContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultipartIdentifierOrAsteriskContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitMultipartIdentifierOrAsterisk(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) MultipartIdentifierOrAsterisk() (localctx IMultipartIdentifierOrAsteriskContext) {
	localctx = NewMultipartIdentifierOrAsteriskContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, DorisParserParserRULE_multipartIdentifierOrAsterisk)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4592)

		var _x = p.IdentifierOrAsterisk()

		localctx.(*MultipartIdentifierOrAsteriskContext)._identifierOrAsterisk = _x
	}
	localctx.(*MultipartIdentifierOrAsteriskContext).parts = append(localctx.(*MultipartIdentifierOrAsteriskContext).parts, localctx.(*MultipartIdentifierOrAsteriskContext)._identifierOrAsterisk)
	p.SetState(4597)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisParserParserDOT {
		{
			p.SetState(4593)
			p.Match(DorisParserParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4594)

			var _x = p.IdentifierOrAsterisk()

			localctx.(*MultipartIdentifierOrAsteriskContext)._identifierOrAsterisk = _x
		}
		localctx.(*MultipartIdentifierOrAsteriskContext).parts = append(localctx.(*MultipartIdentifierOrAsteriskContext).parts, localctx.(*MultipartIdentifierOrAsteriskContext)._identifierOrAsterisk)

		p.SetState(4599)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierOrAsteriskContext is an interface to support dynamic dispatch.
type IIdentifierOrAsteriskContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IdentifierOrText() IIdentifierOrTextContext
	ASTERISK() antlr.TerminalNode

	// IsIdentifierOrAsteriskContext differentiates from other interfaces.
	IsIdentifierOrAsteriskContext()
}

type IdentifierOrAsteriskContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierOrAsteriskContext() *IdentifierOrAsteriskContext {
	var p = new(IdentifierOrAsteriskContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_identifierOrAsterisk
	return p
}

func InitEmptyIdentifierOrAsteriskContext(p *IdentifierOrAsteriskContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_identifierOrAsterisk
}

func (*IdentifierOrAsteriskContext) IsIdentifierOrAsteriskContext() {}

func NewIdentifierOrAsteriskContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierOrAsteriskContext {
	var p = new(IdentifierOrAsteriskContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_identifierOrAsterisk

	return p
}

func (s *IdentifierOrAsteriskContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierOrAsteriskContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *IdentifierOrAsteriskContext) ASTERISK() antlr.TerminalNode {
	return s.GetToken(DorisParserParserASTERISK, 0)
}

func (s *IdentifierOrAsteriskContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierOrAsteriskContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierOrAsteriskContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitIdentifierOrAsterisk(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) IdentifierOrAsterisk() (localctx IIdentifierOrAsteriskContext) {
	localctx = NewIdentifierOrAsteriskContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, DorisParserParserRULE_identifierOrAsterisk)
	p.SetState(4602)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserParserLEFT_BRACE, DorisParserParserRIGHT_BRACE, DorisParserParserACTIONS, DorisParserParserAFTER, DorisParserParserAGG_STATE, DorisParserParserAGGREGATE, DorisParserParserALIAS, DorisParserParserANALYZED, DorisParserParserARRAY, DorisParserParserAT, DorisParserParserAUTHORS, DorisParserParserAUTO_INCREMENT, DorisParserParserALWAYS, DorisParserParserBACKENDS, DorisParserParserBACKUP, DorisParserParserBEGIN, DorisParserParserBELONG, DorisParserParserBIN, DorisParserParserBITAND, DorisParserParserBITMAP, DorisParserParserBITMAP_EMPTY, DorisParserParserBITMAP_UNION, DorisParserParserBITOR, DorisParserParserBITXOR, DorisParserParserBLOB, DorisParserParserBOOLEAN, DorisParserParserBRANCH, DorisParserParserBRIEF, DorisParserParserBROKER, DorisParserParserBUCKETS, DorisParserParserBUILD, DorisParserParserBUILTIN, DorisParserParserBULK, DorisParserParserCACHE, DorisParserParserCACHED, DorisParserParserCALL, DorisParserParserCATALOG, DorisParserParserCATALOGS, DorisParserParserCHAIN, DorisParserParserCHAR, DorisParserParserCHARSET, DorisParserParserCHECK, DorisParserParserCLUSTER, DorisParserParserCLUSTERS, DorisParserParserCOLLATION, DorisParserParserCOLLECT, DorisParserParserCOLOCATE, DorisParserParserCOLUMNS, DorisParserParserCOMMENT, DorisParserParserCOMMIT, DorisParserParserCOMMITTED, DorisParserParserCOMPACT, DorisParserParserCOMPLETE, DorisParserParserCOMPRESS_TYPE, DorisParserParserCOMPUTE, DorisParserParserCONDITIONS, DorisParserParserCONFIG, DorisParserParserCONNECTION, DorisParserParserCONNECTION_ID, DorisParserParserCONSISTENT, DorisParserParserCONSTRAINTS, DorisParserParserCONVERT, DorisParserParserCONVERT_LSC, DorisParserParserCOPY, DorisParserParserCOUNT, DorisParserParserCREATION, DorisParserParserCRON, DorisParserParserCURRENT_CATALOG, DorisParserParserCURRENT_DATE, DorisParserParserCURRENT_TIME, DorisParserParserCURRENT_TIMESTAMP, DorisParserParserCURRENT_USER, DorisParserParserDATA, DorisParserParserDATE, DorisParserParserDATETIME, DorisParserParserDATETIMEV2, DorisParserParserDATEV2, DorisParserParserDATETIMEV1, DorisParserParserDATEV1, DorisParserParserDAY, DorisParserParserDAYS, DorisParserParserDECIMAL, DorisParserParserDECIMALV2, DorisParserParserDECIMALV3, DorisParserParserDEFERRED, DorisParserParserDEMAND, DorisParserParserDIAGNOSE, DorisParserParserDIAGNOSIS, DorisParserParserDICTIONARIES, DorisParserParserDICTIONARY, DorisParserParserDISTINCTPC, DorisParserParserDISTINCTPCSA, DorisParserParserDO, DorisParserParserDORIS_INTERNAL_TABLE_ID, DorisParserParserDUAL, DorisParserParserDYNAMIC, DorisParserParserE, DorisParserParserENABLE, DorisParserParserENCRYPTKEY, DorisParserParserENCRYPTKEYS, DorisParserParserEND, DorisParserParserENDS, DorisParserParserENGINE, DorisParserParserENGINES, DorisParserParserERRORS, DorisParserParserESCAPE, DorisParserParserEVENTS, DorisParserParserEVERY, DorisParserParserEXCLUDE, DorisParserParserEXPIRED, DorisParserParserEXTERNAL, DorisParserParserFAILED_LOGIN_ATTEMPTS, DorisParserParserFAST, DorisParserParserFEATURE, DorisParserParserFIELDS, DorisParserParserFILE, DorisParserParserFILTER, DorisParserParserFIRST, DorisParserParserFORMAT, DorisParserParserFREE, DorisParserParserFRONTENDS, DorisParserParserFUNCTION, DorisParserParserGENERATED, DorisParserParserGENERIC, DorisParserParserGLOBAL, DorisParserParserGRAPH, DorisParserParserGROUPING, DorisParserParserGROUPS, DorisParserParserHASH, DorisParserParserHASH_MAP, DorisParserParserHDFS, DorisParserParserHELP, DorisParserParserHISTOGRAM, DorisParserParserHLL_UNION, DorisParserParserHOSTNAME, DorisParserParserHOTSPOT, DorisParserParserHOUR, DorisParserParserHOURS, DorisParserParserHUB, DorisParserParserIDENTIFIED, DorisParserParserIGNORE, DorisParserParserIMMEDIATE, DorisParserParserINCREMENTAL, DorisParserParserINDEXES, DorisParserParserINVERTED, DorisParserParserIP_TRIE, DorisParserParserIPV4, DorisParserParserIPV6, DorisParserParserIS_NOT_NULL_PRED, DorisParserParserIS_NULL_PRED, DorisParserParserISNULL, DorisParserParserISOLATION, DorisParserParserJOB, DorisParserParserJOBS, DorisParserParserJSON, DorisParserParserJSONB, DorisParserParserLABEL, DorisParserParserLAST, DorisParserParserLDAP, DorisParserParserLDAP_ADMIN_PASSWORD, DorisParserParserLESS, DorisParserParserLEVEL, DorisParserParserLINES, DorisParserParserLINK, DorisParserParserLOCAL, DorisParserParserLOCALTIME, DorisParserParserLOCALTIMESTAMP, DorisParserParserLOCATION, DorisParserParserLOCK, DorisParserParserLOGICAL, DorisParserParserMANUAL, DorisParserParserMAP, DorisParserParserMATCH_ALL, DorisParserParserMATCH_ANY, DorisParserParserMATCH_PHRASE, DorisParserParserMATCH_PHRASE_EDGE, DorisParserParserMATCH_PHRASE_PREFIX, DorisParserParserMATCH_REGEXP, DorisParserParserMATERIALIZED, DorisParserParserMAX, DorisParserParserMEMO, DorisParserParserMERGE, DorisParserParserMIGRATE, DorisParserParserMIGRATIONS, DorisParserParserMIN, DorisParserParserMINUTE, DorisParserParserMINUTES, DorisParserParserMODIFY, DorisParserParserMONTH, DorisParserParserMTMV, DorisParserParserNAME, DorisParserParserNAMES, DorisParserParserNEGATIVE, DorisParserParserNEVER, DorisParserParserNEXT, DorisParserParserNGRAM_BF, DorisParserParserNO, DorisParserParserNON_NULLABLE, DorisParserParserNULLS, DorisParserParserOF, DorisParserParserOFFSET, DorisParserParserONLY, DorisParserParserOPEN, DorisParserParserOPTIMIZED, DorisParserParserPARAMETER, DorisParserParserPARSED, DorisParserParserPARTITIONS, DorisParserParserPASSWORD, DorisParserParserPASSWORD_EXPIRE, DorisParserParserPASSWORD_HISTORY, DorisParserParserPASSWORD_LOCK_TIME, DorisParserParserPASSWORD_REUSE, DorisParserParserPATH, DorisParserParserPAUSE, DorisParserParserPERCENT, DorisParserParserPERIOD, DorisParserParserPERMISSIVE, DorisParserParserPHYSICAL, DorisParserParserPI, DorisParserParserPLAN, DorisParserParserPRIVILEGES, DorisParserParserPROCESS, DorisParserParserPLUGIN, DorisParserParserPLUGINS, DorisParserParserPOLICY, DorisParserParserPROC, DorisParserParserPROCESSLIST, DorisParserParserPROFILE, DorisParserParserPROPERTIES, DorisParserParserPROPERTY, DorisParserParserQUANTILE_STATE, DorisParserParserQUANTILE_UNION, DorisParserParserQUERY, DorisParserParserQUEUED, DorisParserParserQUOTA, DorisParserParserQUALIFY, DorisParserParserQUARTER, DorisParserParserRANDOM, DorisParserParserRECENT, DorisParserParserRECOVER, DorisParserParserRECYCLE, DorisParserParserREFRESH, DorisParserParserREPEATABLE, DorisParserParserREPLACE, DorisParserParserREPLACE_IF_NOT_NULL, DorisParserParserREPLAYER, DorisParserParserREPOSITORIES, DorisParserParserREPOSITORY, DorisParserParserRESOURCE, DorisParserParserRESOURCES, DorisParserParserRESTORE, DorisParserParserRESTRICTIVE, DorisParserParserRESUME, DorisParserParserRETAIN, DorisParserParserRETENTION, DorisParserParserRETURNS, DorisParserParserREWRITTEN, DorisParserParserRLIKE, DorisParserParserROLLBACK, DorisParserParserROLLUP, DorisParserParserROUTINE, DorisParserParserS3, DorisParserParserSAMPLE, DorisParserParserSCHEDULE, DorisParserParserSCHEDULER, DorisParserParserSCHEMA, DorisParserParserSECOND, DorisParserParserSERIALIZABLE, DorisParserParserSESSION, DorisParserParserSESSION_USER, DorisParserParserSET_SESSION_VARIABLE, DorisParserParserSHAPE, DorisParserParserSKEW, DorisParserParserSNAPSHOT, DorisParserParserSNAPSHOTS, DorisParserParserSONAME, DorisParserParserSPLIT, DorisParserParserSQL, DorisParserParserSTAGE, DorisParserParserSTAGES, DorisParserParserSTART, DorisParserParserSTARTS, DorisParserParserSTATS, DorisParserParserSTATUS, DorisParserParserSTOP, DorisParserParserSTORAGE, DorisParserParserSTREAM, DorisParserParserSTREAMING, DorisParserParserSTRING, DorisParserParserSTRUCT, DorisParserParserSUM, DorisParserParserTABLES, DorisParserParserTAG, DorisParserParserTASK, DorisParserParserTASKS, DorisParserParserTEMPORARY, DorisParserParserTEXT, DorisParserParserTHAN, DorisParserParserTIME, DorisParserParserTIMESTAMP, DorisParserParserTRANSACTION, DorisParserParserTREE, DorisParserParserTRIGGERS, DorisParserParserTRUNCATE, DorisParserParserTYPE, DorisParserParserTYPES, DorisParserParserUNCOMMITTED, DorisParserParserUNLOCK, DorisParserParserUNSET, DorisParserParserUP, DorisParserParserUSER, DorisParserParserVALUE, DorisParserParserVARCHAR, DorisParserParserVARIABLE, DorisParserParserVARIABLES, DorisParserParserVARIANT, DorisParserParserVAULT, DorisParserParserVAULTS, DorisParserParserVERBOSE, DorisParserParserVERSION, DorisParserParserVIEW, DorisParserParserVIEWS, DorisParserParserWARM, DorisParserParserWARNINGS, DorisParserParserWEEK, DorisParserParserWORK, DorisParserParserYEAR, DorisParserParserHINT_START, DorisParserParserHINT_END, DorisParserParserCOMMENT_START, DorisParserParserSTRING_LITERAL, DorisParserParserIDENTIFIER, DorisParserParserBACKQUOTED_IDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4600)
			p.IdentifierOrText()
		}

	case DorisParserParserASTERISK:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4601)
			p.Match(DorisParserParserASTERISK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUserIdentifyContext is an interface to support dynamic dispatch.
type IUserIdentifyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetUser returns the user rule contexts.
	GetUser() IIdentifierOrTextContext

	// GetHost returns the host rule contexts.
	GetHost() IIdentifierOrTextContext

	// SetUser sets the user rule contexts.
	SetUser(IIdentifierOrTextContext)

	// SetHost sets the host rule contexts.
	SetHost(IIdentifierOrTextContext)

	// Getter signatures
	AllIdentifierOrText() []IIdentifierOrTextContext
	IdentifierOrText(i int) IIdentifierOrTextContext
	ATSIGN() antlr.TerminalNode
	LEFT_PAREN() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode

	// IsUserIdentifyContext differentiates from other interfaces.
	IsUserIdentifyContext()
}

type UserIdentifyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	user   IIdentifierOrTextContext
	host   IIdentifierOrTextContext
}

func NewEmptyUserIdentifyContext() *UserIdentifyContext {
	var p = new(UserIdentifyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_userIdentify
	return p
}

func InitEmptyUserIdentifyContext(p *UserIdentifyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_userIdentify
}

func (*UserIdentifyContext) IsUserIdentifyContext() {}

func NewUserIdentifyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UserIdentifyContext {
	var p = new(UserIdentifyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_userIdentify

	return p
}

func (s *UserIdentifyContext) GetParser() antlr.Parser { return s.parser }

func (s *UserIdentifyContext) GetUser() IIdentifierOrTextContext { return s.user }

func (s *UserIdentifyContext) GetHost() IIdentifierOrTextContext { return s.host }

func (s *UserIdentifyContext) SetUser(v IIdentifierOrTextContext) { s.user = v }

func (s *UserIdentifyContext) SetHost(v IIdentifierOrTextContext) { s.host = v }

func (s *UserIdentifyContext) AllIdentifierOrText() []IIdentifierOrTextContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierOrTextContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierOrTextContext); ok {
			tst[i] = t.(IIdentifierOrTextContext)
			i++
		}
	}

	return tst
}

func (s *UserIdentifyContext) IdentifierOrText(i int) IIdentifierOrTextContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *UserIdentifyContext) ATSIGN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserATSIGN, 0)
}

func (s *UserIdentifyContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLEFT_PAREN, 0)
}

func (s *UserIdentifyContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRIGHT_PAREN, 0)
}

func (s *UserIdentifyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UserIdentifyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UserIdentifyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitUserIdentify(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) UserIdentify() (localctx IUserIdentifyContext) {
	localctx = NewUserIdentifyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, DorisParserParserRULE_userIdentify)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4604)

		var _x = p.IdentifierOrText()

		localctx.(*UserIdentifyContext).user = _x
	}
	p.SetState(4613)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserParserATSIGN {
		{
			p.SetState(4605)
			p.Match(DorisParserParserATSIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4611)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserParserLEFT_BRACE, DorisParserParserRIGHT_BRACE, DorisParserParserACTIONS, DorisParserParserAFTER, DorisParserParserAGG_STATE, DorisParserParserAGGREGATE, DorisParserParserALIAS, DorisParserParserANALYZED, DorisParserParserARRAY, DorisParserParserAT, DorisParserParserAUTHORS, DorisParserParserAUTO_INCREMENT, DorisParserParserALWAYS, DorisParserParserBACKENDS, DorisParserParserBACKUP, DorisParserParserBEGIN, DorisParserParserBELONG, DorisParserParserBIN, DorisParserParserBITAND, DorisParserParserBITMAP, DorisParserParserBITMAP_EMPTY, DorisParserParserBITMAP_UNION, DorisParserParserBITOR, DorisParserParserBITXOR, DorisParserParserBLOB, DorisParserParserBOOLEAN, DorisParserParserBRANCH, DorisParserParserBRIEF, DorisParserParserBROKER, DorisParserParserBUCKETS, DorisParserParserBUILD, DorisParserParserBUILTIN, DorisParserParserBULK, DorisParserParserCACHE, DorisParserParserCACHED, DorisParserParserCALL, DorisParserParserCATALOG, DorisParserParserCATALOGS, DorisParserParserCHAIN, DorisParserParserCHAR, DorisParserParserCHARSET, DorisParserParserCHECK, DorisParserParserCLUSTER, DorisParserParserCLUSTERS, DorisParserParserCOLLATION, DorisParserParserCOLLECT, DorisParserParserCOLOCATE, DorisParserParserCOLUMNS, DorisParserParserCOMMENT, DorisParserParserCOMMIT, DorisParserParserCOMMITTED, DorisParserParserCOMPACT, DorisParserParserCOMPLETE, DorisParserParserCOMPRESS_TYPE, DorisParserParserCOMPUTE, DorisParserParserCONDITIONS, DorisParserParserCONFIG, DorisParserParserCONNECTION, DorisParserParserCONNECTION_ID, DorisParserParserCONSISTENT, DorisParserParserCONSTRAINTS, DorisParserParserCONVERT, DorisParserParserCONVERT_LSC, DorisParserParserCOPY, DorisParserParserCOUNT, DorisParserParserCREATION, DorisParserParserCRON, DorisParserParserCURRENT_CATALOG, DorisParserParserCURRENT_DATE, DorisParserParserCURRENT_TIME, DorisParserParserCURRENT_TIMESTAMP, DorisParserParserCURRENT_USER, DorisParserParserDATA, DorisParserParserDATE, DorisParserParserDATETIME, DorisParserParserDATETIMEV2, DorisParserParserDATEV2, DorisParserParserDATETIMEV1, DorisParserParserDATEV1, DorisParserParserDAY, DorisParserParserDAYS, DorisParserParserDECIMAL, DorisParserParserDECIMALV2, DorisParserParserDECIMALV3, DorisParserParserDEFERRED, DorisParserParserDEMAND, DorisParserParserDIAGNOSE, DorisParserParserDIAGNOSIS, DorisParserParserDICTIONARIES, DorisParserParserDICTIONARY, DorisParserParserDISTINCTPC, DorisParserParserDISTINCTPCSA, DorisParserParserDO, DorisParserParserDORIS_INTERNAL_TABLE_ID, DorisParserParserDUAL, DorisParserParserDYNAMIC, DorisParserParserE, DorisParserParserENABLE, DorisParserParserENCRYPTKEY, DorisParserParserENCRYPTKEYS, DorisParserParserEND, DorisParserParserENDS, DorisParserParserENGINE, DorisParserParserENGINES, DorisParserParserERRORS, DorisParserParserESCAPE, DorisParserParserEVENTS, DorisParserParserEVERY, DorisParserParserEXCLUDE, DorisParserParserEXPIRED, DorisParserParserEXTERNAL, DorisParserParserFAILED_LOGIN_ATTEMPTS, DorisParserParserFAST, DorisParserParserFEATURE, DorisParserParserFIELDS, DorisParserParserFILE, DorisParserParserFILTER, DorisParserParserFIRST, DorisParserParserFORMAT, DorisParserParserFREE, DorisParserParserFRONTENDS, DorisParserParserFUNCTION, DorisParserParserGENERATED, DorisParserParserGENERIC, DorisParserParserGLOBAL, DorisParserParserGRAPH, DorisParserParserGROUPING, DorisParserParserGROUPS, DorisParserParserHASH, DorisParserParserHASH_MAP, DorisParserParserHDFS, DorisParserParserHELP, DorisParserParserHISTOGRAM, DorisParserParserHLL_UNION, DorisParserParserHOSTNAME, DorisParserParserHOTSPOT, DorisParserParserHOUR, DorisParserParserHOURS, DorisParserParserHUB, DorisParserParserIDENTIFIED, DorisParserParserIGNORE, DorisParserParserIMMEDIATE, DorisParserParserINCREMENTAL, DorisParserParserINDEXES, DorisParserParserINVERTED, DorisParserParserIP_TRIE, DorisParserParserIPV4, DorisParserParserIPV6, DorisParserParserIS_NOT_NULL_PRED, DorisParserParserIS_NULL_PRED, DorisParserParserISNULL, DorisParserParserISOLATION, DorisParserParserJOB, DorisParserParserJOBS, DorisParserParserJSON, DorisParserParserJSONB, DorisParserParserLABEL, DorisParserParserLAST, DorisParserParserLDAP, DorisParserParserLDAP_ADMIN_PASSWORD, DorisParserParserLESS, DorisParserParserLEVEL, DorisParserParserLINES, DorisParserParserLINK, DorisParserParserLOCAL, DorisParserParserLOCALTIME, DorisParserParserLOCALTIMESTAMP, DorisParserParserLOCATION, DorisParserParserLOCK, DorisParserParserLOGICAL, DorisParserParserMANUAL, DorisParserParserMAP, DorisParserParserMATCH_ALL, DorisParserParserMATCH_ANY, DorisParserParserMATCH_PHRASE, DorisParserParserMATCH_PHRASE_EDGE, DorisParserParserMATCH_PHRASE_PREFIX, DorisParserParserMATCH_REGEXP, DorisParserParserMATERIALIZED, DorisParserParserMAX, DorisParserParserMEMO, DorisParserParserMERGE, DorisParserParserMIGRATE, DorisParserParserMIGRATIONS, DorisParserParserMIN, DorisParserParserMINUTE, DorisParserParserMINUTES, DorisParserParserMODIFY, DorisParserParserMONTH, DorisParserParserMTMV, DorisParserParserNAME, DorisParserParserNAMES, DorisParserParserNEGATIVE, DorisParserParserNEVER, DorisParserParserNEXT, DorisParserParserNGRAM_BF, DorisParserParserNO, DorisParserParserNON_NULLABLE, DorisParserParserNULLS, DorisParserParserOF, DorisParserParserOFFSET, DorisParserParserONLY, DorisParserParserOPEN, DorisParserParserOPTIMIZED, DorisParserParserPARAMETER, DorisParserParserPARSED, DorisParserParserPARTITIONS, DorisParserParserPASSWORD, DorisParserParserPASSWORD_EXPIRE, DorisParserParserPASSWORD_HISTORY, DorisParserParserPASSWORD_LOCK_TIME, DorisParserParserPASSWORD_REUSE, DorisParserParserPATH, DorisParserParserPAUSE, DorisParserParserPERCENT, DorisParserParserPERIOD, DorisParserParserPERMISSIVE, DorisParserParserPHYSICAL, DorisParserParserPI, DorisParserParserPLAN, DorisParserParserPRIVILEGES, DorisParserParserPROCESS, DorisParserParserPLUGIN, DorisParserParserPLUGINS, DorisParserParserPOLICY, DorisParserParserPROC, DorisParserParserPROCESSLIST, DorisParserParserPROFILE, DorisParserParserPROPERTIES, DorisParserParserPROPERTY, DorisParserParserQUANTILE_STATE, DorisParserParserQUANTILE_UNION, DorisParserParserQUERY, DorisParserParserQUEUED, DorisParserParserQUOTA, DorisParserParserQUALIFY, DorisParserParserQUARTER, DorisParserParserRANDOM, DorisParserParserRECENT, DorisParserParserRECOVER, DorisParserParserRECYCLE, DorisParserParserREFRESH, DorisParserParserREPEATABLE, DorisParserParserREPLACE, DorisParserParserREPLACE_IF_NOT_NULL, DorisParserParserREPLAYER, DorisParserParserREPOSITORIES, DorisParserParserREPOSITORY, DorisParserParserRESOURCE, DorisParserParserRESOURCES, DorisParserParserRESTORE, DorisParserParserRESTRICTIVE, DorisParserParserRESUME, DorisParserParserRETAIN, DorisParserParserRETENTION, DorisParserParserRETURNS, DorisParserParserREWRITTEN, DorisParserParserRLIKE, DorisParserParserROLLBACK, DorisParserParserROLLUP, DorisParserParserROUTINE, DorisParserParserS3, DorisParserParserSAMPLE, DorisParserParserSCHEDULE, DorisParserParserSCHEDULER, DorisParserParserSCHEMA, DorisParserParserSECOND, DorisParserParserSERIALIZABLE, DorisParserParserSESSION, DorisParserParserSESSION_USER, DorisParserParserSET_SESSION_VARIABLE, DorisParserParserSHAPE, DorisParserParserSKEW, DorisParserParserSNAPSHOT, DorisParserParserSNAPSHOTS, DorisParserParserSONAME, DorisParserParserSPLIT, DorisParserParserSQL, DorisParserParserSTAGE, DorisParserParserSTAGES, DorisParserParserSTART, DorisParserParserSTARTS, DorisParserParserSTATS, DorisParserParserSTATUS, DorisParserParserSTOP, DorisParserParserSTORAGE, DorisParserParserSTREAM, DorisParserParserSTREAMING, DorisParserParserSTRING, DorisParserParserSTRUCT, DorisParserParserSUM, DorisParserParserTABLES, DorisParserParserTAG, DorisParserParserTASK, DorisParserParserTASKS, DorisParserParserTEMPORARY, DorisParserParserTEXT, DorisParserParserTHAN, DorisParserParserTIME, DorisParserParserTIMESTAMP, DorisParserParserTRANSACTION, DorisParserParserTREE, DorisParserParserTRIGGERS, DorisParserParserTRUNCATE, DorisParserParserTYPE, DorisParserParserTYPES, DorisParserParserUNCOMMITTED, DorisParserParserUNLOCK, DorisParserParserUNSET, DorisParserParserUP, DorisParserParserUSER, DorisParserParserVALUE, DorisParserParserVARCHAR, DorisParserParserVARIABLE, DorisParserParserVARIABLES, DorisParserParserVARIANT, DorisParserParserVAULT, DorisParserParserVAULTS, DorisParserParserVERBOSE, DorisParserParserVERSION, DorisParserParserVIEW, DorisParserParserVIEWS, DorisParserParserWARM, DorisParserParserWARNINGS, DorisParserParserWEEK, DorisParserParserWORK, DorisParserParserYEAR, DorisParserParserHINT_START, DorisParserParserHINT_END, DorisParserParserCOMMENT_START, DorisParserParserSTRING_LITERAL, DorisParserParserIDENTIFIER, DorisParserParserBACKQUOTED_IDENTIFIER:
			{
				p.SetState(4606)

				var _x = p.IdentifierOrText()

				localctx.(*UserIdentifyContext).host = _x
			}

		case DorisParserParserLEFT_PAREN:
			{
				p.SetState(4607)
				p.Match(DorisParserParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4608)

				var _x = p.IdentifierOrText()

				localctx.(*UserIdentifyContext).host = _x
			}
			{
				p.SetState(4609)
				p.Match(DorisParserParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGrantUserIdentifyContext is an interface to support dynamic dispatch.
type IGrantUserIdentifyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UserIdentify() IUserIdentifyContext
	IDENTIFIED() antlr.TerminalNode
	BY() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode
	PASSWORD() antlr.TerminalNode

	// IsGrantUserIdentifyContext differentiates from other interfaces.
	IsGrantUserIdentifyContext()
}

type GrantUserIdentifyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGrantUserIdentifyContext() *GrantUserIdentifyContext {
	var p = new(GrantUserIdentifyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_grantUserIdentify
	return p
}

func InitEmptyGrantUserIdentifyContext(p *GrantUserIdentifyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_grantUserIdentify
}

func (*GrantUserIdentifyContext) IsGrantUserIdentifyContext() {}

func NewGrantUserIdentifyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GrantUserIdentifyContext {
	var p = new(GrantUserIdentifyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_grantUserIdentify

	return p
}

func (s *GrantUserIdentifyContext) GetParser() antlr.Parser { return s.parser }

func (s *GrantUserIdentifyContext) UserIdentify() IUserIdentifyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserIdentifyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserIdentifyContext)
}

func (s *GrantUserIdentifyContext) IDENTIFIED() antlr.TerminalNode {
	return s.GetToken(DorisParserParserIDENTIFIED, 0)
}

func (s *GrantUserIdentifyContext) BY() antlr.TerminalNode {
	return s.GetToken(DorisParserParserBY, 0)
}

func (s *GrantUserIdentifyContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTRING_LITERAL, 0)
}

func (s *GrantUserIdentifyContext) PASSWORD() antlr.TerminalNode {
	return s.GetToken(DorisParserParserPASSWORD, 0)
}

func (s *GrantUserIdentifyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GrantUserIdentifyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GrantUserIdentifyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitGrantUserIdentify(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) GrantUserIdentify() (localctx IGrantUserIdentifyContext) {
	localctx = NewGrantUserIdentifyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, DorisParserParserRULE_grantUserIdentify)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4615)
		p.UserIdentify()
	}
	p.SetState(4622)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserParserIDENTIFIED {
		{
			p.SetState(4616)
			p.Match(DorisParserParserIDENTIFIED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4617)
			p.Match(DorisParserParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4619)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserPASSWORD {
			{
				p.SetState(4618)
				p.Match(DorisParserParserPASSWORD)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4621)
			p.Match(DorisParserParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExplainContext is an interface to support dynamic dispatch.
type IExplainContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetLevel returns the level token.
	GetLevel() antlr.Token

	// SetLevel sets the level token.
	SetLevel(antlr.Token)

	// Getter signatures
	ExplainCommand() IExplainCommandContext
	PlanType() IPlanTypeContext
	PROCESS() antlr.TerminalNode
	VERBOSE() antlr.TerminalNode
	TREE() antlr.TerminalNode
	GRAPH() antlr.TerminalNode
	PLAN() antlr.TerminalNode
	DUMP() antlr.TerminalNode

	// IsExplainContext differentiates from other interfaces.
	IsExplainContext()
}

type ExplainContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	level  antlr.Token
}

func NewEmptyExplainContext() *ExplainContext {
	var p = new(ExplainContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_explain
	return p
}

func InitEmptyExplainContext(p *ExplainContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_explain
}

func (*ExplainContext) IsExplainContext() {}

func NewExplainContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExplainContext {
	var p = new(ExplainContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_explain

	return p
}

func (s *ExplainContext) GetParser() antlr.Parser { return s.parser }

func (s *ExplainContext) GetLevel() antlr.Token { return s.level }

func (s *ExplainContext) SetLevel(v antlr.Token) { s.level = v }

func (s *ExplainContext) ExplainCommand() IExplainCommandContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExplainCommandContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExplainCommandContext)
}

func (s *ExplainContext) PlanType() IPlanTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPlanTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPlanTypeContext)
}

func (s *ExplainContext) PROCESS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserPROCESS, 0)
}

func (s *ExplainContext) VERBOSE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserVERBOSE, 0)
}

func (s *ExplainContext) TREE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserTREE, 0)
}

func (s *ExplainContext) GRAPH() antlr.TerminalNode {
	return s.GetToken(DorisParserParserGRAPH, 0)
}

func (s *ExplainContext) PLAN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserPLAN, 0)
}

func (s *ExplainContext) DUMP() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDUMP, 0)
}

func (s *ExplainContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExplainContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExplainContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitExplain(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) Explain() (localctx IExplainContext) {
	localctx = NewExplainContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, DorisParserParserRULE_explain)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4624)
		p.ExplainCommand()
	}
	p.SetState(4626)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserParserALL || _la == DorisParserParserANALYZED || _la == DorisParserParserDISTRIBUTED || ((int64((_la-277)) & ^0x3f) == 0 && ((int64(1)<<(_la-277))&4521191813431297) != 0) || _la == DorisParserParserPHYSICAL || _la == DorisParserParserREWRITTEN || _la == DorisParserParserSHAPE {
		{
			p.SetState(4625)
			p.PlanType()
		}

	}
	p.SetState(4629)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserParserDUMP || _la == DorisParserParserGRAPH || _la == DorisParserParserPLAN || _la == DorisParserParserTREE || _la == DorisParserParserVERBOSE {
		{
			p.SetState(4628)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ExplainContext).level = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserParserDUMP || _la == DorisParserParserGRAPH || _la == DorisParserParserPLAN || _la == DorisParserParserTREE || _la == DorisParserParserVERBOSE) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ExplainContext).level = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(4632)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserParserPROCESS {
		{
			p.SetState(4631)
			p.Match(DorisParserParserPROCESS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExplainCommandContext is an interface to support dynamic dispatch.
type IExplainCommandContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EXPLAIN() antlr.TerminalNode
	DESC() antlr.TerminalNode
	DESCRIBE() antlr.TerminalNode

	// IsExplainCommandContext differentiates from other interfaces.
	IsExplainCommandContext()
}

type ExplainCommandContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExplainCommandContext() *ExplainCommandContext {
	var p = new(ExplainCommandContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_explainCommand
	return p
}

func InitEmptyExplainCommandContext(p *ExplainCommandContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_explainCommand
}

func (*ExplainCommandContext) IsExplainCommandContext() {}

func NewExplainCommandContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExplainCommandContext {
	var p = new(ExplainCommandContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_explainCommand

	return p
}

func (s *ExplainCommandContext) GetParser() antlr.Parser { return s.parser }

func (s *ExplainCommandContext) EXPLAIN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserEXPLAIN, 0)
}

func (s *ExplainCommandContext) DESC() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDESC, 0)
}

func (s *ExplainCommandContext) DESCRIBE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDESCRIBE, 0)
}

func (s *ExplainCommandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExplainCommandContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExplainCommandContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitExplainCommand(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) ExplainCommand() (localctx IExplainCommandContext) {
	localctx = NewExplainCommandContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, DorisParserParserRULE_explainCommand)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4634)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-131)) & ^0x3f) == 0 && ((int64(1)<<(_la-131))&2199023255555) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPlanTypeContext is an interface to support dynamic dispatch.
type IPlanTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PARSED() antlr.TerminalNode
	ANALYZED() antlr.TerminalNode
	REWRITTEN() antlr.TerminalNode
	LOGICAL() antlr.TerminalNode
	OPTIMIZED() antlr.TerminalNode
	PHYSICAL() antlr.TerminalNode
	SHAPE() antlr.TerminalNode
	MEMO() antlr.TerminalNode
	DISTRIBUTED() antlr.TerminalNode
	ALL() antlr.TerminalNode

	// IsPlanTypeContext differentiates from other interfaces.
	IsPlanTypeContext()
}

type PlanTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPlanTypeContext() *PlanTypeContext {
	var p = new(PlanTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_planType
	return p
}

func InitEmptyPlanTypeContext(p *PlanTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_planType
}

func (*PlanTypeContext) IsPlanTypeContext() {}

func NewPlanTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PlanTypeContext {
	var p = new(PlanTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_planType

	return p
}

func (s *PlanTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *PlanTypeContext) PARSED() antlr.TerminalNode {
	return s.GetToken(DorisParserParserPARSED, 0)
}

func (s *PlanTypeContext) ANALYZED() antlr.TerminalNode {
	return s.GetToken(DorisParserParserANALYZED, 0)
}

func (s *PlanTypeContext) REWRITTEN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserREWRITTEN, 0)
}

func (s *PlanTypeContext) LOGICAL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLOGICAL, 0)
}

func (s *PlanTypeContext) OPTIMIZED() antlr.TerminalNode {
	return s.GetToken(DorisParserParserOPTIMIZED, 0)
}

func (s *PlanTypeContext) PHYSICAL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserPHYSICAL, 0)
}

func (s *PlanTypeContext) SHAPE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSHAPE, 0)
}

func (s *PlanTypeContext) MEMO() antlr.TerminalNode {
	return s.GetToken(DorisParserParserMEMO, 0)
}

func (s *PlanTypeContext) DISTRIBUTED() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDISTRIBUTED, 0)
}

func (s *PlanTypeContext) ALL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserALL, 0)
}

func (s *PlanTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PlanTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PlanTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitPlanType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) PlanType() (localctx IPlanTypeContext) {
	localctx = NewPlanTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, DorisParserParserRULE_planType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4636)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisParserParserALL || _la == DorisParserParserANALYZED || _la == DorisParserParserDISTRIBUTED || ((int64((_la-277)) & ^0x3f) == 0 && ((int64(1)<<(_la-277))&4521191813431297) != 0) || _la == DorisParserParserPHYSICAL || _la == DorisParserParserREWRITTEN || _la == DorisParserParserSHAPE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReplayCommandContext is an interface to support dynamic dispatch.
type IReplayCommandContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PLAN() antlr.TerminalNode
	REPLAYER() antlr.TerminalNode
	ReplayType() IReplayTypeContext

	// IsReplayCommandContext differentiates from other interfaces.
	IsReplayCommandContext()
}

type ReplayCommandContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReplayCommandContext() *ReplayCommandContext {
	var p = new(ReplayCommandContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_replayCommand
	return p
}

func InitEmptyReplayCommandContext(p *ReplayCommandContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_replayCommand
}

func (*ReplayCommandContext) IsReplayCommandContext() {}

func NewReplayCommandContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReplayCommandContext {
	var p = new(ReplayCommandContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_replayCommand

	return p
}

func (s *ReplayCommandContext) GetParser() antlr.Parser { return s.parser }

func (s *ReplayCommandContext) PLAN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserPLAN, 0)
}

func (s *ReplayCommandContext) REPLAYER() antlr.TerminalNode {
	return s.GetToken(DorisParserParserREPLAYER, 0)
}

func (s *ReplayCommandContext) ReplayType() IReplayTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReplayTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReplayTypeContext)
}

func (s *ReplayCommandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReplayCommandContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReplayCommandContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitReplayCommand(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) ReplayCommand() (localctx IReplayCommandContext) {
	localctx = NewReplayCommandContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, DorisParserParserRULE_replayCommand)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4638)
		p.Match(DorisParserParserPLAN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4639)
		p.Match(DorisParserParserREPLAYER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4640)
		p.ReplayType()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReplayTypeContext is an interface to support dynamic dispatch.
type IReplayTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetFilePath returns the filePath token.
	GetFilePath() antlr.Token

	// SetFilePath sets the filePath token.
	SetFilePath(antlr.Token)

	// Getter signatures
	DUMP() antlr.TerminalNode
	Query() IQueryContext
	PLAY() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode

	// IsReplayTypeContext differentiates from other interfaces.
	IsReplayTypeContext()
}

type ReplayTypeContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	filePath antlr.Token
}

func NewEmptyReplayTypeContext() *ReplayTypeContext {
	var p = new(ReplayTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_replayType
	return p
}

func InitEmptyReplayTypeContext(p *ReplayTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_replayType
}

func (*ReplayTypeContext) IsReplayTypeContext() {}

func NewReplayTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReplayTypeContext {
	var p = new(ReplayTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_replayType

	return p
}

func (s *ReplayTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ReplayTypeContext) GetFilePath() antlr.Token { return s.filePath }

func (s *ReplayTypeContext) SetFilePath(v antlr.Token) { s.filePath = v }

func (s *ReplayTypeContext) DUMP() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDUMP, 0)
}

func (s *ReplayTypeContext) Query() IQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *ReplayTypeContext) PLAY() antlr.TerminalNode {
	return s.GetToken(DorisParserParserPLAY, 0)
}

func (s *ReplayTypeContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTRING_LITERAL, 0)
}

func (s *ReplayTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReplayTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReplayTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitReplayType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) ReplayType() (localctx IReplayTypeContext) {
	localctx = NewReplayTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 204, DorisParserParserRULE_replayType)
	p.SetState(4646)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserParserDUMP:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4642)
			p.Match(DorisParserParserDUMP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4643)
			p.Query()
		}

	case DorisParserParserPLAY:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4644)
			p.Match(DorisParserParserPLAY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4645)

			var _m = p.Match(DorisParserParserSTRING_LITERAL)

			localctx.(*ReplayTypeContext).filePath = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMergeTypeContext is an interface to support dynamic dispatch.
type IMergeTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	APPEND() antlr.TerminalNode
	DELETE() antlr.TerminalNode
	MERGE() antlr.TerminalNode

	// IsMergeTypeContext differentiates from other interfaces.
	IsMergeTypeContext()
}

type MergeTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMergeTypeContext() *MergeTypeContext {
	var p = new(MergeTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_mergeType
	return p
}

func InitEmptyMergeTypeContext(p *MergeTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_mergeType
}

func (*MergeTypeContext) IsMergeTypeContext() {}

func NewMergeTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MergeTypeContext {
	var p = new(MergeTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_mergeType

	return p
}

func (s *MergeTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *MergeTypeContext) APPEND() antlr.TerminalNode {
	return s.GetToken(DorisParserParserAPPEND, 0)
}

func (s *MergeTypeContext) DELETE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDELETE, 0)
}

func (s *MergeTypeContext) MERGE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserMERGE, 0)
}

func (s *MergeTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MergeTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MergeTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitMergeType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) MergeType() (localctx IMergeTypeContext) {
	localctx = NewMergeTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 206, DorisParserParserRULE_mergeType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4648)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisParserParserAPPEND || _la == DorisParserParserDELETE || _la == DorisParserParserMERGE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPreFilterClauseContext is an interface to support dynamic dispatch.
type IPreFilterClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PRECEDING() antlr.TerminalNode
	FILTER() antlr.TerminalNode
	Expression() IExpressionContext

	// IsPreFilterClauseContext differentiates from other interfaces.
	IsPreFilterClauseContext()
}

type PreFilterClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPreFilterClauseContext() *PreFilterClauseContext {
	var p = new(PreFilterClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_preFilterClause
	return p
}

func InitEmptyPreFilterClauseContext(p *PreFilterClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_preFilterClause
}

func (*PreFilterClauseContext) IsPreFilterClauseContext() {}

func NewPreFilterClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PreFilterClauseContext {
	var p = new(PreFilterClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_preFilterClause

	return p
}

func (s *PreFilterClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *PreFilterClauseContext) PRECEDING() antlr.TerminalNode {
	return s.GetToken(DorisParserParserPRECEDING, 0)
}

func (s *PreFilterClauseContext) FILTER() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFILTER, 0)
}

func (s *PreFilterClauseContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PreFilterClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PreFilterClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PreFilterClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitPreFilterClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) PreFilterClause() (localctx IPreFilterClauseContext) {
	localctx = NewPreFilterClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 208, DorisParserParserRULE_preFilterClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4650)
		p.Match(DorisParserParserPRECEDING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4651)
		p.Match(DorisParserParserFILTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4652)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDeleteOnClauseContext is an interface to support dynamic dispatch.
type IDeleteOnClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DELETE() antlr.TerminalNode
	ON() antlr.TerminalNode
	Expression() IExpressionContext

	// IsDeleteOnClauseContext differentiates from other interfaces.
	IsDeleteOnClauseContext()
}

type DeleteOnClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeleteOnClauseContext() *DeleteOnClauseContext {
	var p = new(DeleteOnClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_deleteOnClause
	return p
}

func InitEmptyDeleteOnClauseContext(p *DeleteOnClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_deleteOnClause
}

func (*DeleteOnClauseContext) IsDeleteOnClauseContext() {}

func NewDeleteOnClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeleteOnClauseContext {
	var p = new(DeleteOnClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_deleteOnClause

	return p
}

func (s *DeleteOnClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DeleteOnClauseContext) DELETE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDELETE, 0)
}

func (s *DeleteOnClauseContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisParserParserON, 0)
}

func (s *DeleteOnClauseContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *DeleteOnClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeleteOnClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeleteOnClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitDeleteOnClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) DeleteOnClause() (localctx IDeleteOnClauseContext) {
	localctx = NewDeleteOnClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 210, DorisParserParserRULE_deleteOnClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4654)
		p.Match(DorisParserParserDELETE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4655)
		p.Match(DorisParserParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4656)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISequenceColClauseContext is an interface to support dynamic dispatch.
type ISequenceColClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ORDER() antlr.TerminalNode
	BY() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsSequenceColClauseContext differentiates from other interfaces.
	IsSequenceColClauseContext()
}

type SequenceColClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySequenceColClauseContext() *SequenceColClauseContext {
	var p = new(SequenceColClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_sequenceColClause
	return p
}

func InitEmptySequenceColClauseContext(p *SequenceColClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_sequenceColClause
}

func (*SequenceColClauseContext) IsSequenceColClauseContext() {}

func NewSequenceColClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SequenceColClauseContext {
	var p = new(SequenceColClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_sequenceColClause

	return p
}

func (s *SequenceColClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *SequenceColClauseContext) ORDER() antlr.TerminalNode {
	return s.GetToken(DorisParserParserORDER, 0)
}

func (s *SequenceColClauseContext) BY() antlr.TerminalNode {
	return s.GetToken(DorisParserParserBY, 0)
}

func (s *SequenceColClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SequenceColClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SequenceColClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SequenceColClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitSequenceColClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) SequenceColClause() (localctx ISequenceColClauseContext) {
	localctx = NewSequenceColClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 212, DorisParserParserRULE_sequenceColClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4658)
		p.Match(DorisParserParserORDER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4659)
		p.Match(DorisParserParserBY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4660)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColFromPathContext is an interface to support dynamic dispatch.
type IColFromPathContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COLUMNS() antlr.TerminalNode
	FROM() antlr.TerminalNode
	PATH() antlr.TerminalNode
	AS() antlr.TerminalNode
	IdentifierList() IIdentifierListContext

	// IsColFromPathContext differentiates from other interfaces.
	IsColFromPathContext()
}

type ColFromPathContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColFromPathContext() *ColFromPathContext {
	var p = new(ColFromPathContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_colFromPath
	return p
}

func InitEmptyColFromPathContext(p *ColFromPathContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_colFromPath
}

func (*ColFromPathContext) IsColFromPathContext() {}

func NewColFromPathContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColFromPathContext {
	var p = new(ColFromPathContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_colFromPath

	return p
}

func (s *ColFromPathContext) GetParser() antlr.Parser { return s.parser }

func (s *ColFromPathContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOLUMNS, 0)
}

func (s *ColFromPathContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFROM, 0)
}

func (s *ColFromPathContext) PATH() antlr.TerminalNode {
	return s.GetToken(DorisParserParserPATH, 0)
}

func (s *ColFromPathContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserAS, 0)
}

func (s *ColFromPathContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *ColFromPathContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColFromPathContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColFromPathContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitColFromPath(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) ColFromPath() (localctx IColFromPathContext) {
	localctx = NewColFromPathContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 214, DorisParserParserRULE_colFromPath)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4662)
		p.Match(DorisParserParserCOLUMNS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4663)
		p.Match(DorisParserParserFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4664)
		p.Match(DorisParserParserPATH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4665)
		p.Match(DorisParserParserAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4666)
		p.IdentifierList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColMappingListContext is an interface to support dynamic dispatch.
type IColMappingListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_mappingExpr returns the _mappingExpr rule contexts.
	Get_mappingExpr() IMappingExprContext

	// Set_mappingExpr sets the _mappingExpr rule contexts.
	Set_mappingExpr(IMappingExprContext)

	// GetMappingSet returns the mappingSet rule context list.
	GetMappingSet() []IMappingExprContext

	// SetMappingSet sets the mappingSet rule context list.
	SetMappingSet([]IMappingExprContext)

	// Getter signatures
	SET() antlr.TerminalNode
	LEFT_PAREN() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode
	AllMappingExpr() []IMappingExprContext
	MappingExpr(i int) IMappingExprContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsColMappingListContext differentiates from other interfaces.
	IsColMappingListContext()
}

type ColMappingListContext struct {
	antlr.BaseParserRuleContext
	parser       antlr.Parser
	_mappingExpr IMappingExprContext
	mappingSet   []IMappingExprContext
}

func NewEmptyColMappingListContext() *ColMappingListContext {
	var p = new(ColMappingListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_colMappingList
	return p
}

func InitEmptyColMappingListContext(p *ColMappingListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_colMappingList
}

func (*ColMappingListContext) IsColMappingListContext() {}

func NewColMappingListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColMappingListContext {
	var p = new(ColMappingListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_colMappingList

	return p
}

func (s *ColMappingListContext) GetParser() antlr.Parser { return s.parser }

func (s *ColMappingListContext) Get_mappingExpr() IMappingExprContext { return s._mappingExpr }

func (s *ColMappingListContext) Set_mappingExpr(v IMappingExprContext) { s._mappingExpr = v }

func (s *ColMappingListContext) GetMappingSet() []IMappingExprContext { return s.mappingSet }

func (s *ColMappingListContext) SetMappingSet(v []IMappingExprContext) { s.mappingSet = v }

func (s *ColMappingListContext) SET() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSET, 0)
}

func (s *ColMappingListContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLEFT_PAREN, 0)
}

func (s *ColMappingListContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRIGHT_PAREN, 0)
}

func (s *ColMappingListContext) AllMappingExpr() []IMappingExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMappingExprContext); ok {
			len++
		}
	}

	tst := make([]IMappingExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMappingExprContext); ok {
			tst[i] = t.(IMappingExprContext)
			i++
		}
	}

	return tst
}

func (s *ColMappingListContext) MappingExpr(i int) IMappingExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMappingExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMappingExprContext)
}

func (s *ColMappingListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserCOMMA)
}

func (s *ColMappingListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOMMA, i)
}

func (s *ColMappingListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColMappingListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColMappingListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitColMappingList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) ColMappingList() (localctx IColMappingListContext) {
	localctx = NewColMappingListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 216, DorisParserParserRULE_colMappingList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4668)
		p.Match(DorisParserParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4669)
		p.Match(DorisParserParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4670)

		var _x = p.MappingExpr()

		localctx.(*ColMappingListContext)._mappingExpr = _x
	}
	localctx.(*ColMappingListContext).mappingSet = append(localctx.(*ColMappingListContext).mappingSet, localctx.(*ColMappingListContext)._mappingExpr)
	p.SetState(4675)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisParserParserCOMMA {
		{
			p.SetState(4671)
			p.Match(DorisParserParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4672)

			var _x = p.MappingExpr()

			localctx.(*ColMappingListContext)._mappingExpr = _x
		}
		localctx.(*ColMappingListContext).mappingSet = append(localctx.(*ColMappingListContext).mappingSet, localctx.(*ColMappingListContext)._mappingExpr)

		p.SetState(4677)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(4678)
		p.Match(DorisParserParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMappingExprContext is an interface to support dynamic dispatch.
type IMappingExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetMappingCol returns the mappingCol rule contexts.
	GetMappingCol() IIdentifierContext

	// SetMappingCol sets the mappingCol rule contexts.
	SetMappingCol(IIdentifierContext)

	// Getter signatures
	EQ() antlr.TerminalNode
	Expression() IExpressionContext
	Identifier() IIdentifierContext

	// IsMappingExprContext differentiates from other interfaces.
	IsMappingExprContext()
}

type MappingExprContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	mappingCol IIdentifierContext
}

func NewEmptyMappingExprContext() *MappingExprContext {
	var p = new(MappingExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_mappingExpr
	return p
}

func InitEmptyMappingExprContext(p *MappingExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_mappingExpr
}

func (*MappingExprContext) IsMappingExprContext() {}

func NewMappingExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MappingExprContext {
	var p = new(MappingExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_mappingExpr

	return p
}

func (s *MappingExprContext) GetParser() antlr.Parser { return s.parser }

func (s *MappingExprContext) GetMappingCol() IIdentifierContext { return s.mappingCol }

func (s *MappingExprContext) SetMappingCol(v IIdentifierContext) { s.mappingCol = v }

func (s *MappingExprContext) EQ() antlr.TerminalNode {
	return s.GetToken(DorisParserParserEQ, 0)
}

func (s *MappingExprContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *MappingExprContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *MappingExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MappingExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MappingExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitMappingExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) MappingExpr() (localctx IMappingExprContext) {
	localctx = NewMappingExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 218, DorisParserParserRULE_mappingExpr)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4680)

		var _x = p.Identifier()

		localctx.(*MappingExprContext).mappingCol = _x
	}
	{
		p.SetState(4681)
		p.Match(DorisParserParserEQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4682)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWithRemoteStorageSystemContext is an interface to support dynamic dispatch.
type IWithRemoteStorageSystemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetBrokerProperties returns the brokerProperties rule contexts.
	GetBrokerProperties() IPropertyItemListContext

	// GetBrokerName returns the brokerName rule contexts.
	GetBrokerName() IIdentifierOrTextContext

	// SetBrokerProperties sets the brokerProperties rule contexts.
	SetBrokerProperties(IPropertyItemListContext)

	// SetBrokerName sets the brokerName rule contexts.
	SetBrokerName(IIdentifierOrTextContext)

	// Getter signatures
	ResourceDesc() IResourceDescContext
	WITH() antlr.TerminalNode
	S3() antlr.TerminalNode
	LEFT_PAREN() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode
	PropertyItemList() IPropertyItemListContext
	HDFS() antlr.TerminalNode
	LOCAL() antlr.TerminalNode
	BROKER() antlr.TerminalNode
	IdentifierOrText() IIdentifierOrTextContext

	// IsWithRemoteStorageSystemContext differentiates from other interfaces.
	IsWithRemoteStorageSystemContext()
}

type WithRemoteStorageSystemContext struct {
	antlr.BaseParserRuleContext
	parser           antlr.Parser
	brokerProperties IPropertyItemListContext
	brokerName       IIdentifierOrTextContext
}

func NewEmptyWithRemoteStorageSystemContext() *WithRemoteStorageSystemContext {
	var p = new(WithRemoteStorageSystemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_withRemoteStorageSystem
	return p
}

func InitEmptyWithRemoteStorageSystemContext(p *WithRemoteStorageSystemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_withRemoteStorageSystem
}

func (*WithRemoteStorageSystemContext) IsWithRemoteStorageSystemContext() {}

func NewWithRemoteStorageSystemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WithRemoteStorageSystemContext {
	var p = new(WithRemoteStorageSystemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_withRemoteStorageSystem

	return p
}

func (s *WithRemoteStorageSystemContext) GetParser() antlr.Parser { return s.parser }

func (s *WithRemoteStorageSystemContext) GetBrokerProperties() IPropertyItemListContext {
	return s.brokerProperties
}

func (s *WithRemoteStorageSystemContext) GetBrokerName() IIdentifierOrTextContext {
	return s.brokerName
}

func (s *WithRemoteStorageSystemContext) SetBrokerProperties(v IPropertyItemListContext) {
	s.brokerProperties = v
}

func (s *WithRemoteStorageSystemContext) SetBrokerName(v IIdentifierOrTextContext) { s.brokerName = v }

func (s *WithRemoteStorageSystemContext) ResourceDesc() IResourceDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResourceDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResourceDescContext)
}

func (s *WithRemoteStorageSystemContext) WITH() antlr.TerminalNode {
	return s.GetToken(DorisParserParserWITH, 0)
}

func (s *WithRemoteStorageSystemContext) S3() antlr.TerminalNode {
	return s.GetToken(DorisParserParserS3, 0)
}

func (s *WithRemoteStorageSystemContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLEFT_PAREN, 0)
}

func (s *WithRemoteStorageSystemContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRIGHT_PAREN, 0)
}

func (s *WithRemoteStorageSystemContext) PropertyItemList() IPropertyItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyItemListContext)
}

func (s *WithRemoteStorageSystemContext) HDFS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserHDFS, 0)
}

func (s *WithRemoteStorageSystemContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLOCAL, 0)
}

func (s *WithRemoteStorageSystemContext) BROKER() antlr.TerminalNode {
	return s.GetToken(DorisParserParserBROKER, 0)
}

func (s *WithRemoteStorageSystemContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *WithRemoteStorageSystemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WithRemoteStorageSystemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WithRemoteStorageSystemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitWithRemoteStorageSystem(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) WithRemoteStorageSystem() (localctx IWithRemoteStorageSystemContext) {
	localctx = NewWithRemoteStorageSystemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 220, DorisParserParserRULE_withRemoteStorageSystem)
	var _la int

	p.SetState(4712)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 663, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4684)
			p.ResourceDesc()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4685)
			p.Match(DorisParserParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4686)
			p.Match(DorisParserParserS3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4687)
			p.Match(DorisParserParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4688)

			var _x = p.PropertyItemList()

			localctx.(*WithRemoteStorageSystemContext).brokerProperties = _x
		}
		{
			p.SetState(4689)
			p.Match(DorisParserParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4691)
			p.Match(DorisParserParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4692)
			p.Match(DorisParserParserHDFS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4693)
			p.Match(DorisParserParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4694)

			var _x = p.PropertyItemList()

			localctx.(*WithRemoteStorageSystemContext).brokerProperties = _x
		}
		{
			p.SetState(4695)
			p.Match(DorisParserParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4697)
			p.Match(DorisParserParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4698)
			p.Match(DorisParserParserLOCAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4699)
			p.Match(DorisParserParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4700)

			var _x = p.PropertyItemList()

			localctx.(*WithRemoteStorageSystemContext).brokerProperties = _x
		}
		{
			p.SetState(4701)
			p.Match(DorisParserParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4703)
			p.Match(DorisParserParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4704)
			p.Match(DorisParserParserBROKER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4705)

			var _x = p.IdentifierOrText()

			localctx.(*WithRemoteStorageSystemContext).brokerName = _x
		}
		p.SetState(4710)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserLEFT_PAREN {
			{
				p.SetState(4706)
				p.Match(DorisParserParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4707)

				var _x = p.PropertyItemList()

				localctx.(*WithRemoteStorageSystemContext).brokerProperties = _x
			}
			{
				p.SetState(4708)
				p.Match(DorisParserParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IResourceDescContext is an interface to support dynamic dispatch.
type IResourceDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetResourceName returns the resourceName rule contexts.
	GetResourceName() IIdentifierOrTextContext

	// SetResourceName sets the resourceName rule contexts.
	SetResourceName(IIdentifierOrTextContext)

	// Getter signatures
	WITH() antlr.TerminalNode
	RESOURCE() antlr.TerminalNode
	IdentifierOrText() IIdentifierOrTextContext
	LEFT_PAREN() antlr.TerminalNode
	PropertyItemList() IPropertyItemListContext
	RIGHT_PAREN() antlr.TerminalNode

	// IsResourceDescContext differentiates from other interfaces.
	IsResourceDescContext()
}

type ResourceDescContext struct {
	antlr.BaseParserRuleContext
	parser       antlr.Parser
	resourceName IIdentifierOrTextContext
}

func NewEmptyResourceDescContext() *ResourceDescContext {
	var p = new(ResourceDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_resourceDesc
	return p
}

func InitEmptyResourceDescContext(p *ResourceDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_resourceDesc
}

func (*ResourceDescContext) IsResourceDescContext() {}

func NewResourceDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ResourceDescContext {
	var p = new(ResourceDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_resourceDesc

	return p
}

func (s *ResourceDescContext) GetParser() antlr.Parser { return s.parser }

func (s *ResourceDescContext) GetResourceName() IIdentifierOrTextContext { return s.resourceName }

func (s *ResourceDescContext) SetResourceName(v IIdentifierOrTextContext) { s.resourceName = v }

func (s *ResourceDescContext) WITH() antlr.TerminalNode {
	return s.GetToken(DorisParserParserWITH, 0)
}

func (s *ResourceDescContext) RESOURCE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRESOURCE, 0)
}

func (s *ResourceDescContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *ResourceDescContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLEFT_PAREN, 0)
}

func (s *ResourceDescContext) PropertyItemList() IPropertyItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyItemListContext)
}

func (s *ResourceDescContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRIGHT_PAREN, 0)
}

func (s *ResourceDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResourceDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ResourceDescContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitResourceDesc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) ResourceDesc() (localctx IResourceDescContext) {
	localctx = NewResourceDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 222, DorisParserParserRULE_resourceDesc)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4714)
		p.Match(DorisParserParserWITH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4715)
		p.Match(DorisParserParserRESOURCE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4716)

		var _x = p.IdentifierOrText()

		localctx.(*ResourceDescContext).resourceName = _x
	}
	p.SetState(4721)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserParserLEFT_PAREN {
		{
			p.SetState(4717)
			p.Match(DorisParserParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4718)
			p.PropertyItemList()
		}
		{
			p.SetState(4719)
			p.Match(DorisParserParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMysqlDataDescContext is an interface to support dynamic dispatch.
type IMysqlDataDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetFilePath returns the filePath token.
	GetFilePath() antlr.Token

	// GetComma returns the comma token.
	GetComma() antlr.Token

	// GetSeparator returns the separator token.
	GetSeparator() antlr.Token

	// SetFilePath sets the filePath token.
	SetFilePath(antlr.Token)

	// SetComma sets the comma token.
	SetComma(antlr.Token)

	// SetSeparator sets the separator token.
	SetSeparator(antlr.Token)

	// GetTableName returns the tableName rule contexts.
	GetTableName() IMultipartIdentifierContext

	// GetPartition returns the partition rule contexts.
	GetPartition() IIdentifierListContext

	// GetColumns returns the columns rule contexts.
	GetColumns() IIdentifierListContext

	// SetTableName sets the tableName rule contexts.
	SetTableName(IMultipartIdentifierContext)

	// SetPartition sets the partition rule contexts.
	SetPartition(IIdentifierListContext)

	// SetColumns sets the columns rule contexts.
	SetColumns(IIdentifierListContext)

	// Getter signatures
	DATA() antlr.TerminalNode
	INFILE() antlr.TerminalNode
	INTO() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	AllSTRING_LITERAL() []antlr.TerminalNode
	STRING_LITERAL(i int) antlr.TerminalNode
	MultipartIdentifier() IMultipartIdentifierContext
	LOCAL() antlr.TerminalNode
	PARTITION() antlr.TerminalNode
	COLUMNS() antlr.TerminalNode
	AllTERMINATED() []antlr.TerminalNode
	TERMINATED(i int) antlr.TerminalNode
	AllBY() []antlr.TerminalNode
	BY(i int) antlr.TerminalNode
	LINES() antlr.TerminalNode
	SkipLines() ISkipLinesContext
	ColMappingList() IColMappingListContext
	PropertyClause() IPropertyClauseContext
	AllIdentifierList() []IIdentifierListContext
	IdentifierList(i int) IIdentifierListContext

	// IsMysqlDataDescContext differentiates from other interfaces.
	IsMysqlDataDescContext()
}

type MysqlDataDescContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	filePath  antlr.Token
	tableName IMultipartIdentifierContext
	partition IIdentifierListContext
	comma     antlr.Token
	separator antlr.Token
	columns   IIdentifierListContext
}

func NewEmptyMysqlDataDescContext() *MysqlDataDescContext {
	var p = new(MysqlDataDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_mysqlDataDesc
	return p
}

func InitEmptyMysqlDataDescContext(p *MysqlDataDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_mysqlDataDesc
}

func (*MysqlDataDescContext) IsMysqlDataDescContext() {}

func NewMysqlDataDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MysqlDataDescContext {
	var p = new(MysqlDataDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_mysqlDataDesc

	return p
}

func (s *MysqlDataDescContext) GetParser() antlr.Parser { return s.parser }

func (s *MysqlDataDescContext) GetFilePath() antlr.Token { return s.filePath }

func (s *MysqlDataDescContext) GetComma() antlr.Token { return s.comma }

func (s *MysqlDataDescContext) GetSeparator() antlr.Token { return s.separator }

func (s *MysqlDataDescContext) SetFilePath(v antlr.Token) { s.filePath = v }

func (s *MysqlDataDescContext) SetComma(v antlr.Token) { s.comma = v }

func (s *MysqlDataDescContext) SetSeparator(v antlr.Token) { s.separator = v }

func (s *MysqlDataDescContext) GetTableName() IMultipartIdentifierContext { return s.tableName }

func (s *MysqlDataDescContext) GetPartition() IIdentifierListContext { return s.partition }

func (s *MysqlDataDescContext) GetColumns() IIdentifierListContext { return s.columns }

func (s *MysqlDataDescContext) SetTableName(v IMultipartIdentifierContext) { s.tableName = v }

func (s *MysqlDataDescContext) SetPartition(v IIdentifierListContext) { s.partition = v }

func (s *MysqlDataDescContext) SetColumns(v IIdentifierListContext) { s.columns = v }

func (s *MysqlDataDescContext) DATA() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDATA, 0)
}

func (s *MysqlDataDescContext) INFILE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserINFILE, 0)
}

func (s *MysqlDataDescContext) INTO() antlr.TerminalNode {
	return s.GetToken(DorisParserParserINTO, 0)
}

func (s *MysqlDataDescContext) TABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserTABLE, 0)
}

func (s *MysqlDataDescContext) AllSTRING_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserSTRING_LITERAL)
}

func (s *MysqlDataDescContext) STRING_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTRING_LITERAL, i)
}

func (s *MysqlDataDescContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *MysqlDataDescContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLOCAL, 0)
}

func (s *MysqlDataDescContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(DorisParserParserPARTITION, 0)
}

func (s *MysqlDataDescContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOLUMNS, 0)
}

func (s *MysqlDataDescContext) AllTERMINATED() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserTERMINATED)
}

func (s *MysqlDataDescContext) TERMINATED(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserTERMINATED, i)
}

func (s *MysqlDataDescContext) AllBY() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserBY)
}

func (s *MysqlDataDescContext) BY(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserBY, i)
}

func (s *MysqlDataDescContext) LINES() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLINES, 0)
}

func (s *MysqlDataDescContext) SkipLines() ISkipLinesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISkipLinesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISkipLinesContext)
}

func (s *MysqlDataDescContext) ColMappingList() IColMappingListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColMappingListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColMappingListContext)
}

func (s *MysqlDataDescContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *MysqlDataDescContext) AllIdentifierList() []IIdentifierListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierListContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierListContext); ok {
			tst[i] = t.(IIdentifierListContext)
			i++
		}
	}

	return tst
}

func (s *MysqlDataDescContext) IdentifierList(i int) IIdentifierListContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *MysqlDataDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MysqlDataDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MysqlDataDescContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitMysqlDataDesc(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) MysqlDataDesc() (localctx IMysqlDataDescContext) {
	localctx = NewMysqlDataDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 224, DorisParserParserRULE_mysqlDataDesc)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4723)
		p.Match(DorisParserParserDATA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4725)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserParserLOCAL {
		{
			p.SetState(4724)
			p.Match(DorisParserParserLOCAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(4727)
		p.Match(DorisParserParserINFILE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4728)

		var _m = p.Match(DorisParserParserSTRING_LITERAL)

		localctx.(*MysqlDataDescContext).filePath = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4729)
		p.Match(DorisParserParserINTO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4730)
		p.Match(DorisParserParserTABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4731)

		var _x = p.MultipartIdentifier()

		localctx.(*MysqlDataDescContext).tableName = _x
	}
	p.SetState(4734)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserParserPARTITION {
		{
			p.SetState(4732)
			p.Match(DorisParserParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4733)

			var _x = p.IdentifierList()

			localctx.(*MysqlDataDescContext).partition = _x
		}

	}
	p.SetState(4740)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserParserCOLUMNS {
		{
			p.SetState(4736)
			p.Match(DorisParserParserCOLUMNS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4737)
			p.Match(DorisParserParserTERMINATED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4738)
			p.Match(DorisParserParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4739)

			var _m = p.Match(DorisParserParserSTRING_LITERAL)

			localctx.(*MysqlDataDescContext).comma = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(4746)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserParserLINES {
		{
			p.SetState(4742)
			p.Match(DorisParserParserLINES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4743)
			p.Match(DorisParserParserTERMINATED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4744)
			p.Match(DorisParserParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4745)

			var _m = p.Match(DorisParserParserSTRING_LITERAL)

			localctx.(*MysqlDataDescContext).separator = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(4749)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserParserIGNORE {
		{
			p.SetState(4748)
			p.SkipLines()
		}

	}
	p.SetState(4752)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserParserLEFT_PAREN {
		{
			p.SetState(4751)

			var _x = p.IdentifierList()

			localctx.(*MysqlDataDescContext).columns = _x
		}

	}
	p.SetState(4755)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserParserSET {
		{
			p.SetState(4754)
			p.ColMappingList()
		}

	}
	p.SetState(4758)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 672, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4757)
			p.PropertyClause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISkipLinesContext is an interface to support dynamic dispatch.
type ISkipLinesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetLines returns the lines token.
	GetLines() antlr.Token

	// SetLines sets the lines token.
	SetLines(antlr.Token)

	// Getter signatures
	IGNORE() antlr.TerminalNode
	LINES() antlr.TerminalNode
	INTEGER_VALUE() antlr.TerminalNode
	ROWS() antlr.TerminalNode

	// IsSkipLinesContext differentiates from other interfaces.
	IsSkipLinesContext()
}

type SkipLinesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	lines  antlr.Token
}

func NewEmptySkipLinesContext() *SkipLinesContext {
	var p = new(SkipLinesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_skipLines
	return p
}

func InitEmptySkipLinesContext(p *SkipLinesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_skipLines
}

func (*SkipLinesContext) IsSkipLinesContext() {}

func NewSkipLinesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SkipLinesContext {
	var p = new(SkipLinesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_skipLines

	return p
}

func (s *SkipLinesContext) GetParser() antlr.Parser { return s.parser }

func (s *SkipLinesContext) GetLines() antlr.Token { return s.lines }

func (s *SkipLinesContext) SetLines(v antlr.Token) { s.lines = v }

func (s *SkipLinesContext) IGNORE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserIGNORE, 0)
}

func (s *SkipLinesContext) LINES() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLINES, 0)
}

func (s *SkipLinesContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserINTEGER_VALUE, 0)
}

func (s *SkipLinesContext) ROWS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserROWS, 0)
}

func (s *SkipLinesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SkipLinesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SkipLinesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitSkipLines(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) SkipLines() (localctx ISkipLinesContext) {
	localctx = NewSkipLinesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 226, DorisParserParserRULE_skipLines)
	p.SetState(4766)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 673, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4760)
			p.Match(DorisParserParserIGNORE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4761)

			var _m = p.Match(DorisParserParserINTEGER_VALUE)

			localctx.(*SkipLinesContext).lines = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4762)
			p.Match(DorisParserParserLINES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4763)
			p.Match(DorisParserParserIGNORE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4764)

			var _m = p.Match(DorisParserParserINTEGER_VALUE)

			localctx.(*SkipLinesContext).lines = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4765)
			p.Match(DorisParserParserROWS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOutFileClauseContext is an interface to support dynamic dispatch.
type IOutFileClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetFilePath returns the filePath rule contexts.
	GetFilePath() IConstantContext

	// GetFormat returns the format rule contexts.
	GetFormat() IIdentifierContext

	// SetFilePath sets the filePath rule contexts.
	SetFilePath(IConstantContext)

	// SetFormat sets the format rule contexts.
	SetFormat(IIdentifierContext)

	// Getter signatures
	INTO() antlr.TerminalNode
	OUTFILE() antlr.TerminalNode
	Constant() IConstantContext
	FORMAT() antlr.TerminalNode
	AS() antlr.TerminalNode
	PropertyClause() IPropertyClauseContext
	Identifier() IIdentifierContext

	// IsOutFileClauseContext differentiates from other interfaces.
	IsOutFileClauseContext()
}

type OutFileClauseContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	filePath IConstantContext
	format   IIdentifierContext
}

func NewEmptyOutFileClauseContext() *OutFileClauseContext {
	var p = new(OutFileClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_outFileClause
	return p
}

func InitEmptyOutFileClauseContext(p *OutFileClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_outFileClause
}

func (*OutFileClauseContext) IsOutFileClauseContext() {}

func NewOutFileClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OutFileClauseContext {
	var p = new(OutFileClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_outFileClause

	return p
}

func (s *OutFileClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *OutFileClauseContext) GetFilePath() IConstantContext { return s.filePath }

func (s *OutFileClauseContext) GetFormat() IIdentifierContext { return s.format }

func (s *OutFileClauseContext) SetFilePath(v IConstantContext) { s.filePath = v }

func (s *OutFileClauseContext) SetFormat(v IIdentifierContext) { s.format = v }

func (s *OutFileClauseContext) INTO() antlr.TerminalNode {
	return s.GetToken(DorisParserParserINTO, 0)
}

func (s *OutFileClauseContext) OUTFILE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserOUTFILE, 0)
}

func (s *OutFileClauseContext) Constant() IConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *OutFileClauseContext) FORMAT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFORMAT, 0)
}

func (s *OutFileClauseContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserAS, 0)
}

func (s *OutFileClauseContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *OutFileClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *OutFileClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OutFileClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OutFileClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitOutFileClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) OutFileClause() (localctx IOutFileClauseContext) {
	localctx = NewOutFileClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 228, DorisParserParserRULE_outFileClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4768)
		p.Match(DorisParserParserINTO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4769)
		p.Match(DorisParserParserOUTFILE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4770)

		var _x = p.Constant()

		localctx.(*OutFileClauseContext).filePath = _x
	}
	p.SetState(4774)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserParserFORMAT {
		{
			p.SetState(4771)
			p.Match(DorisParserParserFORMAT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4772)
			p.Match(DorisParserParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4773)

			var _x = p.Identifier()

			localctx.(*OutFileClauseContext).format = _x
		}

	}
	p.SetState(4777)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserParserPROPERTIES {
		{
			p.SetState(4776)
			p.PropertyClause()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQueryContext is an interface to support dynamic dispatch.
type IQueryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QueryTerm() IQueryTermContext
	QueryOrganization() IQueryOrganizationContext
	Cte() ICteContext

	// IsQueryContext differentiates from other interfaces.
	IsQueryContext()
}

type QueryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQueryContext() *QueryContext {
	var p = new(QueryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_query
	return p
}

func InitEmptyQueryContext(p *QueryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_query
}

func (*QueryContext) IsQueryContext() {}

func NewQueryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryContext {
	var p = new(QueryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_query

	return p
}

func (s *QueryContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryContext) QueryTerm() IQueryTermContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryTermContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryTermContext)
}

func (s *QueryContext) QueryOrganization() IQueryOrganizationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryOrganizationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryOrganizationContext)
}

func (s *QueryContext) Cte() ICteContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICteContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICteContext)
}

func (s *QueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QueryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitQuery(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) Query() (localctx IQueryContext) {
	localctx = NewQueryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 230, DorisParserParserRULE_query)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4780)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserParserWITH {
		{
			p.SetState(4779)
			p.Cte()
		}

	}
	{
		p.SetState(4782)
		p.queryTerm(0)
	}
	{
		p.SetState(4783)
		p.QueryOrganization()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQueryTermContext is an interface to support dynamic dispatch.
type IQueryTermContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsQueryTermContext differentiates from other interfaces.
	IsQueryTermContext()
}

type QueryTermContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQueryTermContext() *QueryTermContext {
	var p = new(QueryTermContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_queryTerm
	return p
}

func InitEmptyQueryTermContext(p *QueryTermContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_queryTerm
}

func (*QueryTermContext) IsQueryTermContext() {}

func NewQueryTermContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryTermContext {
	var p = new(QueryTermContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_queryTerm

	return p
}

func (s *QueryTermContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryTermContext) CopyAll(ctx *QueryTermContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *QueryTermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryTermContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type QueryTermDefaultContext struct {
	QueryTermContext
}

func NewQueryTermDefaultContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *QueryTermDefaultContext {
	var p = new(QueryTermDefaultContext)

	InitEmptyQueryTermContext(&p.QueryTermContext)
	p.parser = parser
	p.CopyAll(ctx.(*QueryTermContext))

	return p
}

func (s *QueryTermDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryTermDefaultContext) QueryPrimary() IQueryPrimaryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryPrimaryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryPrimaryContext)
}

func (s *QueryTermDefaultContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitQueryTermDefault(s)

	default:
		return t.VisitChildren(s)
	}
}

type SetOperationContext struct {
	QueryTermContext
	left     IQueryTermContext
	operator antlr.Token
	right    IQueryTermContext
}

func NewSetOperationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetOperationContext {
	var p = new(SetOperationContext)

	InitEmptyQueryTermContext(&p.QueryTermContext)
	p.parser = parser
	p.CopyAll(ctx.(*QueryTermContext))

	return p
}

func (s *SetOperationContext) GetOperator() antlr.Token { return s.operator }

func (s *SetOperationContext) SetOperator(v antlr.Token) { s.operator = v }

func (s *SetOperationContext) GetLeft() IQueryTermContext { return s.left }

func (s *SetOperationContext) GetRight() IQueryTermContext { return s.right }

func (s *SetOperationContext) SetLeft(v IQueryTermContext) { s.left = v }

func (s *SetOperationContext) SetRight(v IQueryTermContext) { s.right = v }

func (s *SetOperationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetOperationContext) AllQueryTerm() []IQueryTermContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQueryTermContext); ok {
			len++
		}
	}

	tst := make([]IQueryTermContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQueryTermContext); ok {
			tst[i] = t.(IQueryTermContext)
			i++
		}
	}

	return tst
}

func (s *SetOperationContext) QueryTerm(i int) IQueryTermContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryTermContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryTermContext)
}

func (s *SetOperationContext) INTERSECT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserINTERSECT, 0)
}

func (s *SetOperationContext) SetQuantifier() ISetQuantifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetQuantifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetQuantifierContext)
}

func (s *SetOperationContext) UNION() antlr.TerminalNode {
	return s.GetToken(DorisParserParserUNION, 0)
}

func (s *SetOperationContext) EXCEPT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserEXCEPT, 0)
}

func (s *SetOperationContext) MINUS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserMINUS, 0)
}

func (s *SetOperationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitSetOperation(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) QueryTerm() (localctx IQueryTermContext) {
	return p.queryTerm(0)
}

func (p *DorisParserParser) queryTerm(_p int) (localctx IQueryTermContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewQueryTermContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IQueryTermContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 232
	p.EnterRecursionRule(localctx, 232, DorisParserParserRULE_queryTerm, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	localctx = NewQueryTermDefaultContext(p, localctx)
	p.SetParserRuleContext(localctx)
	_prevctx = localctx

	{
		p.SetState(4786)
		p.QueryPrimary()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(4802)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 680, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(4800)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 679, p.GetParserRuleContext()) {
			case 1:
				localctx = NewSetOperationContext(p, NewQueryTermContext(p, _parentctx, _parentState))
				localctx.(*SetOperationContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, DorisParserParserRULE_queryTerm)
				p.SetState(4788)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
					goto errorExit
				}
				{
					p.SetState(4789)

					var _m = p.Match(DorisParserParserINTERSECT)

					localctx.(*SetOperationContext).operator = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(4791)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == DorisParserParserALL || _la == DorisParserParserDISTINCT {
					{
						p.SetState(4790)
						p.SetQuantifier()
					}

				}
				{
					p.SetState(4793)

					var _x = p.queryTerm(3)

					localctx.(*SetOperationContext).right = _x
				}

			case 2:
				localctx = NewSetOperationContext(p, NewQueryTermContext(p, _parentctx, _parentState))
				localctx.(*SetOperationContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, DorisParserParserRULE_queryTerm)
				p.SetState(4794)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
					goto errorExit
				}
				{
					p.SetState(4795)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*SetOperationContext).operator = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == DorisParserParserEXCEPT || _la == DorisParserParserMINUS || _la == DorisParserParserUNION) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*SetOperationContext).operator = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				p.SetState(4797)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == DorisParserParserALL || _la == DorisParserParserDISTINCT {
					{
						p.SetState(4796)
						p.SetQuantifier()
					}

				}
				{
					p.SetState(4799)

					var _x = p.queryTerm(2)

					localctx.(*SetOperationContext).right = _x
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(4804)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 680, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISetQuantifierContext is an interface to support dynamic dispatch.
type ISetQuantifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DISTINCT() antlr.TerminalNode
	ALL() antlr.TerminalNode

	// IsSetQuantifierContext differentiates from other interfaces.
	IsSetQuantifierContext()
}

type SetQuantifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetQuantifierContext() *SetQuantifierContext {
	var p = new(SetQuantifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_setQuantifier
	return p
}

func InitEmptySetQuantifierContext(p *SetQuantifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_setQuantifier
}

func (*SetQuantifierContext) IsSetQuantifierContext() {}

func NewSetQuantifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetQuantifierContext {
	var p = new(SetQuantifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_setQuantifier

	return p
}

func (s *SetQuantifierContext) GetParser() antlr.Parser { return s.parser }

func (s *SetQuantifierContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDISTINCT, 0)
}

func (s *SetQuantifierContext) ALL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserALL, 0)
}

func (s *SetQuantifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetQuantifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetQuantifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitSetQuantifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) SetQuantifier() (localctx ISetQuantifierContext) {
	localctx = NewSetQuantifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 234, DorisParserParserRULE_setQuantifier)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4805)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisParserParserALL || _la == DorisParserParserDISTINCT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQueryPrimaryContext is an interface to support dynamic dispatch.
type IQueryPrimaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsQueryPrimaryContext differentiates from other interfaces.
	IsQueryPrimaryContext()
}

type QueryPrimaryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQueryPrimaryContext() *QueryPrimaryContext {
	var p = new(QueryPrimaryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_queryPrimary
	return p
}

func InitEmptyQueryPrimaryContext(p *QueryPrimaryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_queryPrimary
}

func (*QueryPrimaryContext) IsQueryPrimaryContext() {}

func NewQueryPrimaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryPrimaryContext {
	var p = new(QueryPrimaryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_queryPrimary

	return p
}

func (s *QueryPrimaryContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryPrimaryContext) CopyAll(ctx *QueryPrimaryContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *QueryPrimaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryPrimaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SubqueryContext struct {
	QueryPrimaryContext
}

func NewSubqueryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SubqueryContext {
	var p = new(SubqueryContext)

	InitEmptyQueryPrimaryContext(&p.QueryPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*QueryPrimaryContext))

	return p
}

func (s *SubqueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubqueryContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLEFT_PAREN, 0)
}

func (s *SubqueryContext) Query() IQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *SubqueryContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRIGHT_PAREN, 0)
}

func (s *SubqueryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitSubquery(s)

	default:
		return t.VisitChildren(s)
	}
}

type ValuesTableContext struct {
	QueryPrimaryContext
}

func NewValuesTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ValuesTableContext {
	var p = new(ValuesTableContext)

	InitEmptyQueryPrimaryContext(&p.QueryPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*QueryPrimaryContext))

	return p
}

func (s *ValuesTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValuesTableContext) InlineTable() IInlineTableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInlineTableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInlineTableContext)
}

func (s *ValuesTableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitValuesTable(s)

	default:
		return t.VisitChildren(s)
	}
}

type QueryPrimaryDefaultContext struct {
	QueryPrimaryContext
}

func NewQueryPrimaryDefaultContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *QueryPrimaryDefaultContext {
	var p = new(QueryPrimaryDefaultContext)

	InitEmptyQueryPrimaryContext(&p.QueryPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*QueryPrimaryContext))

	return p
}

func (s *QueryPrimaryDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryPrimaryDefaultContext) QuerySpecification() IQuerySpecificationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuerySpecificationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuerySpecificationContext)
}

func (s *QueryPrimaryDefaultContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitQueryPrimaryDefault(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) QueryPrimary() (localctx IQueryPrimaryContext) {
	localctx = NewQueryPrimaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 236, DorisParserParserRULE_queryPrimary)
	p.SetState(4813)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserParserSELECT:
		localctx = NewQueryPrimaryDefaultContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4807)
			p.QuerySpecification()
		}

	case DorisParserParserLEFT_PAREN:
		localctx = NewSubqueryContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4808)
			p.Match(DorisParserParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4809)
			p.Query()
		}
		{
			p.SetState(4810)
			p.Match(DorisParserParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserParserVALUES:
		localctx = NewValuesTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4812)
			p.InlineTable()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQuerySpecificationContext is an interface to support dynamic dispatch.
type IQuerySpecificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsQuerySpecificationContext differentiates from other interfaces.
	IsQuerySpecificationContext()
}

type QuerySpecificationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQuerySpecificationContext() *QuerySpecificationContext {
	var p = new(QuerySpecificationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_querySpecification
	return p
}

func InitEmptyQuerySpecificationContext(p *QuerySpecificationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_querySpecification
}

func (*QuerySpecificationContext) IsQuerySpecificationContext() {}

func NewQuerySpecificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QuerySpecificationContext {
	var p = new(QuerySpecificationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_querySpecification

	return p
}

func (s *QuerySpecificationContext) GetParser() antlr.Parser { return s.parser }

func (s *QuerySpecificationContext) CopyAll(ctx *QuerySpecificationContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *QuerySpecificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QuerySpecificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type RegularQuerySpecificationContext struct {
	QuerySpecificationContext
}

func NewRegularQuerySpecificationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RegularQuerySpecificationContext {
	var p = new(RegularQuerySpecificationContext)

	InitEmptyQuerySpecificationContext(&p.QuerySpecificationContext)
	p.parser = parser
	p.CopyAll(ctx.(*QuerySpecificationContext))

	return p
}

func (s *RegularQuerySpecificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RegularQuerySpecificationContext) SelectClause() ISelectClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectClauseContext)
}

func (s *RegularQuerySpecificationContext) QueryOrganization() IQueryOrganizationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryOrganizationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryOrganizationContext)
}

func (s *RegularQuerySpecificationContext) IntoClause() IIntoClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntoClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntoClauseContext)
}

func (s *RegularQuerySpecificationContext) FromClause() IFromClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFromClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFromClauseContext)
}

func (s *RegularQuerySpecificationContext) WhereClause() IWhereClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhereClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhereClauseContext)
}

func (s *RegularQuerySpecificationContext) AggClause() IAggClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAggClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAggClauseContext)
}

func (s *RegularQuerySpecificationContext) HavingClause() IHavingClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHavingClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHavingClauseContext)
}

func (s *RegularQuerySpecificationContext) QualifyClause() IQualifyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifyClauseContext)
}

func (s *RegularQuerySpecificationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitRegularQuerySpecification(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) QuerySpecification() (localctx IQuerySpecificationContext) {
	localctx = NewQuerySpecificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 238, DorisParserParserRULE_querySpecification)
	localctx = NewRegularQuerySpecificationContext(p, localctx)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4815)
		p.SelectClause()
	}
	p.SetState(4817)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 682, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4816)
			p.IntoClause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(4820)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 683, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4819)
			p.FromClause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(4823)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 684, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4822)
			p.WhereClause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(4826)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 685, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4825)
			p.AggClause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(4829)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 686, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4828)
			p.HavingClause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(4832)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 687, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4831)
			p.QualifyClause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(4837)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 688, p.GetParserRuleContext()) {
	case 1:
		p.SetState(4834)

		if !(!ansiSQLSyntax) {
			p.SetError(antlr.NewFailedPredicateException(p, "!ansiSQLSyntax", ""))
			goto errorExit
		}
		{
			p.SetState(4835)
			p.QueryOrganization()
		}

	case 2:
		p.SetState(4836)

		if !(ansiSQLSyntax) {
			p.SetError(antlr.NewFailedPredicateException(p, "ansiSQLSyntax", ""))
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICteContext is an interface to support dynamic dispatch.
type ICteContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WITH() antlr.TerminalNode
	AllAliasQuery() []IAliasQueryContext
	AliasQuery(i int) IAliasQueryContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsCteContext differentiates from other interfaces.
	IsCteContext()
}

type CteContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCteContext() *CteContext {
	var p = new(CteContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_cte
	return p
}

func InitEmptyCteContext(p *CteContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_cte
}

func (*CteContext) IsCteContext() {}

func NewCteContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CteContext {
	var p = new(CteContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_cte

	return p
}

func (s *CteContext) GetParser() antlr.Parser { return s.parser }

func (s *CteContext) WITH() antlr.TerminalNode {
	return s.GetToken(DorisParserParserWITH, 0)
}

func (s *CteContext) AllAliasQuery() []IAliasQueryContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAliasQueryContext); ok {
			len++
		}
	}

	tst := make([]IAliasQueryContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAliasQueryContext); ok {
			tst[i] = t.(IAliasQueryContext)
			i++
		}
	}

	return tst
}

func (s *CteContext) AliasQuery(i int) IAliasQueryContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAliasQueryContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAliasQueryContext)
}

func (s *CteContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserCOMMA)
}

func (s *CteContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOMMA, i)
}

func (s *CteContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CteContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CteContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitCte(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) Cte() (localctx ICteContext) {
	localctx = NewCteContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 240, DorisParserParserRULE_cte)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4839)
		p.Match(DorisParserParserWITH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4840)
		p.AliasQuery()
	}
	p.SetState(4845)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisParserParserCOMMA {
		{
			p.SetState(4841)
			p.Match(DorisParserParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4842)
			p.AliasQuery()
		}

		p.SetState(4847)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAliasQueryContext is an interface to support dynamic dispatch.
type IAliasQueryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	AS() antlr.TerminalNode
	LEFT_PAREN() antlr.TerminalNode
	Query() IQueryContext
	RIGHT_PAREN() antlr.TerminalNode
	ColumnAliases() IColumnAliasesContext

	// IsAliasQueryContext differentiates from other interfaces.
	IsAliasQueryContext()
}

type AliasQueryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAliasQueryContext() *AliasQueryContext {
	var p = new(AliasQueryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_aliasQuery
	return p
}

func InitEmptyAliasQueryContext(p *AliasQueryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_aliasQuery
}

func (*AliasQueryContext) IsAliasQueryContext() {}

func NewAliasQueryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AliasQueryContext {
	var p = new(AliasQueryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_aliasQuery

	return p
}

func (s *AliasQueryContext) GetParser() antlr.Parser { return s.parser }

func (s *AliasQueryContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AliasQueryContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserAS, 0)
}

func (s *AliasQueryContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLEFT_PAREN, 0)
}

func (s *AliasQueryContext) Query() IQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *AliasQueryContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRIGHT_PAREN, 0)
}

func (s *AliasQueryContext) ColumnAliases() IColumnAliasesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnAliasesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnAliasesContext)
}

func (s *AliasQueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AliasQueryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AliasQueryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitAliasQuery(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) AliasQuery() (localctx IAliasQueryContext) {
	localctx = NewAliasQueryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 242, DorisParserParserRULE_aliasQuery)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4848)
		p.Identifier()
	}
	p.SetState(4850)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserParserLEFT_PAREN {
		{
			p.SetState(4849)
			p.ColumnAliases()
		}

	}
	{
		p.SetState(4852)
		p.Match(DorisParserParserAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4853)
		p.Match(DorisParserParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4854)
		p.Query()
	}
	{
		p.SetState(4855)
		p.Match(DorisParserParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnAliasesContext is an interface to support dynamic dispatch.
type IColumnAliasesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LEFT_PAREN() antlr.TerminalNode
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	RIGHT_PAREN() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsColumnAliasesContext differentiates from other interfaces.
	IsColumnAliasesContext()
}

type ColumnAliasesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnAliasesContext() *ColumnAliasesContext {
	var p = new(ColumnAliasesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_columnAliases
	return p
}

func InitEmptyColumnAliasesContext(p *ColumnAliasesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_columnAliases
}

func (*ColumnAliasesContext) IsColumnAliasesContext() {}

func NewColumnAliasesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnAliasesContext {
	var p = new(ColumnAliasesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_columnAliases

	return p
}

func (s *ColumnAliasesContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnAliasesContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLEFT_PAREN, 0)
}

func (s *ColumnAliasesContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *ColumnAliasesContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ColumnAliasesContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRIGHT_PAREN, 0)
}

func (s *ColumnAliasesContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserCOMMA)
}

func (s *ColumnAliasesContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOMMA, i)
}

func (s *ColumnAliasesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnAliasesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnAliasesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitColumnAliases(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) ColumnAliases() (localctx IColumnAliasesContext) {
	localctx = NewColumnAliasesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 244, DorisParserParserRULE_columnAliases)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4857)
		p.Match(DorisParserParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4858)
		p.Identifier()
	}
	p.SetState(4863)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisParserParserCOMMA {
		{
			p.SetState(4859)
			p.Match(DorisParserParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4860)
			p.Identifier()
		}

		p.SetState(4865)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(4866)
		p.Match(DorisParserParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelectClauseContext is an interface to support dynamic dispatch.
type ISelectClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SELECT() antlr.TerminalNode
	SelectColumnClause() ISelectColumnClauseContext
	DISTINCT() antlr.TerminalNode
	ALL() antlr.TerminalNode

	// IsSelectClauseContext differentiates from other interfaces.
	IsSelectClauseContext()
}

type SelectClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectClauseContext() *SelectClauseContext {
	var p = new(SelectClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_selectClause
	return p
}

func InitEmptySelectClauseContext(p *SelectClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_selectClause
}

func (*SelectClauseContext) IsSelectClauseContext() {}

func NewSelectClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectClauseContext {
	var p = new(SelectClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_selectClause

	return p
}

func (s *SelectClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectClauseContext) SELECT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSELECT, 0)
}

func (s *SelectClauseContext) SelectColumnClause() ISelectColumnClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectColumnClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectColumnClauseContext)
}

func (s *SelectClauseContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDISTINCT, 0)
}

func (s *SelectClauseContext) ALL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserALL, 0)
}

func (s *SelectClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelectClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitSelectClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) SelectClause() (localctx ISelectClauseContext) {
	localctx = NewSelectClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 246, DorisParserParserRULE_selectClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4868)
		p.Match(DorisParserParserSELECT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4870)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserParserALL || _la == DorisParserParserDISTINCT {
		{
			p.SetState(4869)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserParserALL || _la == DorisParserParserDISTINCT) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(4872)
		p.SelectColumnClause()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelectColumnClauseContext is an interface to support dynamic dispatch.
type ISelectColumnClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NamedExpressionSeq() INamedExpressionSeqContext

	// IsSelectColumnClauseContext differentiates from other interfaces.
	IsSelectColumnClauseContext()
}

type SelectColumnClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectColumnClauseContext() *SelectColumnClauseContext {
	var p = new(SelectColumnClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_selectColumnClause
	return p
}

func InitEmptySelectColumnClauseContext(p *SelectColumnClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_selectColumnClause
}

func (*SelectColumnClauseContext) IsSelectColumnClauseContext() {}

func NewSelectColumnClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectColumnClauseContext {
	var p = new(SelectColumnClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_selectColumnClause

	return p
}

func (s *SelectColumnClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectColumnClauseContext) NamedExpressionSeq() INamedExpressionSeqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamedExpressionSeqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamedExpressionSeqContext)
}

func (s *SelectColumnClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectColumnClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelectColumnClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitSelectColumnClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) SelectColumnClause() (localctx ISelectColumnClauseContext) {
	localctx = NewSelectColumnClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 248, DorisParserParserRULE_selectColumnClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4874)
		p.NamedExpressionSeq()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWhereClauseContext is an interface to support dynamic dispatch.
type IWhereClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WHERE() antlr.TerminalNode
	BooleanExpression() IBooleanExpressionContext

	// IsWhereClauseContext differentiates from other interfaces.
	IsWhereClauseContext()
}

type WhereClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhereClauseContext() *WhereClauseContext {
	var p = new(WhereClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_whereClause
	return p
}

func InitEmptyWhereClauseContext(p *WhereClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_whereClause
}

func (*WhereClauseContext) IsWhereClauseContext() {}

func NewWhereClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhereClauseContext {
	var p = new(WhereClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_whereClause

	return p
}

func (s *WhereClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *WhereClauseContext) WHERE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserWHERE, 0)
}

func (s *WhereClauseContext) BooleanExpression() IBooleanExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *WhereClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhereClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhereClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitWhereClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) WhereClause() (localctx IWhereClauseContext) {
	localctx = NewWhereClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 250, DorisParserParserRULE_whereClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4876)
		p.Match(DorisParserParserWHERE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4877)
		p.booleanExpression(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFromClauseContext is an interface to support dynamic dispatch.
type IFromClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FROM() antlr.TerminalNode
	Relations() IRelationsContext

	// IsFromClauseContext differentiates from other interfaces.
	IsFromClauseContext()
}

type FromClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFromClauseContext() *FromClauseContext {
	var p = new(FromClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_fromClause
	return p
}

func InitEmptyFromClauseContext(p *FromClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_fromClause
}

func (*FromClauseContext) IsFromClauseContext() {}

func NewFromClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FromClauseContext {
	var p = new(FromClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_fromClause

	return p
}

func (s *FromClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *FromClauseContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFROM, 0)
}

func (s *FromClauseContext) Relations() IRelationsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationsContext)
}

func (s *FromClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FromClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FromClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitFromClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) FromClause() (localctx IFromClauseContext) {
	localctx = NewFromClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 252, DorisParserParserRULE_fromClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4879)
		p.Match(DorisParserParserFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4880)
		p.Relations()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIntoClauseContext is an interface to support dynamic dispatch.
type IIntoClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INTO() antlr.TerminalNode
	AllTableRow() []ITableRowContext
	TableRow(i int) ITableRowContext
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	BulkCollectClause() IBulkCollectClauseContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsIntoClauseContext differentiates from other interfaces.
	IsIntoClauseContext()
}

type IntoClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIntoClauseContext() *IntoClauseContext {
	var p = new(IntoClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_intoClause
	return p
}

func InitEmptyIntoClauseContext(p *IntoClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_intoClause
}

func (*IntoClauseContext) IsIntoClauseContext() {}

func NewIntoClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntoClauseContext {
	var p = new(IntoClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_intoClause

	return p
}

func (s *IntoClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *IntoClauseContext) INTO() antlr.TerminalNode {
	return s.GetToken(DorisParserParserINTO, 0)
}

func (s *IntoClauseContext) AllTableRow() []ITableRowContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITableRowContext); ok {
			len++
		}
	}

	tst := make([]ITableRowContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITableRowContext); ok {
			tst[i] = t.(ITableRowContext)
			i++
		}
	}

	return tst
}

func (s *IntoClauseContext) TableRow(i int) ITableRowContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableRowContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableRowContext)
}

func (s *IntoClauseContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *IntoClauseContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *IntoClauseContext) BulkCollectClause() IBulkCollectClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBulkCollectClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBulkCollectClauseContext)
}

func (s *IntoClauseContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserCOMMA)
}

func (s *IntoClauseContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOMMA, i)
}

func (s *IntoClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntoClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IntoClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitIntoClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) IntoClause() (localctx IIntoClauseContext) {
	localctx = NewIntoClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 254, DorisParserParserRULE_intoClause)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4883)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserParserBULK {
		{
			p.SetState(4882)
			p.BulkCollectClause()
		}

	}
	{
		p.SetState(4885)
		p.Match(DorisParserParserINTO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4888)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 694, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4886)
			p.TableRow()
		}

	case 2:
		{
			p.SetState(4887)
			p.Identifier()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.SetState(4897)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 696, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(4890)
				p.Match(DorisParserParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(4893)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 695, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(4891)
					p.TableRow()
				}

			case 2:
				{
					p.SetState(4892)
					p.Identifier()
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(4899)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 696, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBulkCollectClauseContext is an interface to support dynamic dispatch.
type IBulkCollectClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BULK() antlr.TerminalNode
	COLLECT() antlr.TerminalNode

	// IsBulkCollectClauseContext differentiates from other interfaces.
	IsBulkCollectClauseContext()
}

type BulkCollectClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBulkCollectClauseContext() *BulkCollectClauseContext {
	var p = new(BulkCollectClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_bulkCollectClause
	return p
}

func InitEmptyBulkCollectClauseContext(p *BulkCollectClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_bulkCollectClause
}

func (*BulkCollectClauseContext) IsBulkCollectClauseContext() {}

func NewBulkCollectClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BulkCollectClauseContext {
	var p = new(BulkCollectClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_bulkCollectClause

	return p
}

func (s *BulkCollectClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *BulkCollectClauseContext) BULK() antlr.TerminalNode {
	return s.GetToken(DorisParserParserBULK, 0)
}

func (s *BulkCollectClauseContext) COLLECT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOLLECT, 0)
}

func (s *BulkCollectClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BulkCollectClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BulkCollectClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitBulkCollectClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) BulkCollectClause() (localctx IBulkCollectClauseContext) {
	localctx = NewBulkCollectClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 256, DorisParserParserRULE_bulkCollectClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4900)
		p.Match(DorisParserParserBULK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4901)
		p.Match(DorisParserParserCOLLECT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableRowContext is an interface to support dynamic dispatch.
type ITableRowContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	LEFT_PAREN() antlr.TerminalNode
	INTEGER_VALUE() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode

	// IsTableRowContext differentiates from other interfaces.
	IsTableRowContext()
}

type TableRowContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableRowContext() *TableRowContext {
	var p = new(TableRowContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_tableRow
	return p
}

func InitEmptyTableRowContext(p *TableRowContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_tableRow
}

func (*TableRowContext) IsTableRowContext() {}

func NewTableRowContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableRowContext {
	var p = new(TableRowContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_tableRow

	return p
}

func (s *TableRowContext) GetParser() antlr.Parser { return s.parser }

func (s *TableRowContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TableRowContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLEFT_PAREN, 0)
}

func (s *TableRowContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserINTEGER_VALUE, 0)
}

func (s *TableRowContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRIGHT_PAREN, 0)
}

func (s *TableRowContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableRowContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableRowContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitTableRow(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) TableRow() (localctx ITableRowContext) {
	localctx = NewTableRowContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 258, DorisParserParserRULE_tableRow)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4903)
		p.Identifier()
	}
	{
		p.SetState(4904)
		p.Match(DorisParserParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4905)
		p.Match(DorisParserParserINTEGER_VALUE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4906)
		p.Match(DorisParserParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRelationsContext is an interface to support dynamic dispatch.
type IRelationsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllRelation() []IRelationContext
	Relation(i int) IRelationContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsRelationsContext differentiates from other interfaces.
	IsRelationsContext()
}

type RelationsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationsContext() *RelationsContext {
	var p = new(RelationsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_relations
	return p
}

func InitEmptyRelationsContext(p *RelationsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_relations
}

func (*RelationsContext) IsRelationsContext() {}

func NewRelationsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationsContext {
	var p = new(RelationsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_relations

	return p
}

func (s *RelationsContext) GetParser() antlr.Parser { return s.parser }

func (s *RelationsContext) AllRelation() []IRelationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRelationContext); ok {
			len++
		}
	}

	tst := make([]IRelationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRelationContext); ok {
			tst[i] = t.(IRelationContext)
			i++
		}
	}

	return tst
}

func (s *RelationsContext) Relation(i int) IRelationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationContext)
}

func (s *RelationsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserCOMMA)
}

func (s *RelationsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOMMA, i)
}

func (s *RelationsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RelationsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitRelations(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) Relations() (localctx IRelationsContext) {
	localctx = NewRelationsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 260, DorisParserParserRULE_relations)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4908)
		p.Relation()
	}
	p.SetState(4913)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 697, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(4909)
				p.Match(DorisParserParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4910)
				p.Relation()
			}

		}
		p.SetState(4915)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 697, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRelationContext is an interface to support dynamic dispatch.
type IRelationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RelationPrimary() IRelationPrimaryContext
	AllJoinRelation() []IJoinRelationContext
	JoinRelation(i int) IJoinRelationContext

	// IsRelationContext differentiates from other interfaces.
	IsRelationContext()
}

type RelationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationContext() *RelationContext {
	var p = new(RelationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_relation
	return p
}

func InitEmptyRelationContext(p *RelationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_relation
}

func (*RelationContext) IsRelationContext() {}

func NewRelationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationContext {
	var p = new(RelationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_relation

	return p
}

func (s *RelationContext) GetParser() antlr.Parser { return s.parser }

func (s *RelationContext) RelationPrimary() IRelationPrimaryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationPrimaryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationPrimaryContext)
}

func (s *RelationContext) AllJoinRelation() []IJoinRelationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IJoinRelationContext); ok {
			len++
		}
	}

	tst := make([]IJoinRelationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IJoinRelationContext); ok {
			tst[i] = t.(IJoinRelationContext)
			i++
		}
	}

	return tst
}

func (s *RelationContext) JoinRelation(i int) IJoinRelationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJoinRelationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJoinRelationContext)
}

func (s *RelationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RelationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitRelation(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) Relation() (localctx IRelationContext) {
	localctx = NewRelationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 262, DorisParserParserRULE_relation)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4916)
		p.RelationPrimary()
	}
	p.SetState(4920)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 698, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(4917)
				p.JoinRelation()
			}

		}
		p.SetState(4922)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 698, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJoinRelationContext is an interface to support dynamic dispatch.
type IJoinRelationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetRight returns the right rule contexts.
	GetRight() IRelationPrimaryContext

	// SetRight sets the right rule contexts.
	SetRight(IRelationPrimaryContext)

	// Getter signatures
	JOIN() antlr.TerminalNode
	RelationPrimary() IRelationPrimaryContext
	JoinType() IJoinTypeContext
	DistributeType() IDistributeTypeContext
	JoinCriteria() IJoinCriteriaContext

	// IsJoinRelationContext differentiates from other interfaces.
	IsJoinRelationContext()
}

type JoinRelationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	right  IRelationPrimaryContext
}

func NewEmptyJoinRelationContext() *JoinRelationContext {
	var p = new(JoinRelationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_joinRelation
	return p
}

func InitEmptyJoinRelationContext(p *JoinRelationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_joinRelation
}

func (*JoinRelationContext) IsJoinRelationContext() {}

func NewJoinRelationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JoinRelationContext {
	var p = new(JoinRelationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_joinRelation

	return p
}

func (s *JoinRelationContext) GetParser() antlr.Parser { return s.parser }

func (s *JoinRelationContext) GetRight() IRelationPrimaryContext { return s.right }

func (s *JoinRelationContext) SetRight(v IRelationPrimaryContext) { s.right = v }

func (s *JoinRelationContext) JOIN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserJOIN, 0)
}

func (s *JoinRelationContext) RelationPrimary() IRelationPrimaryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationPrimaryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationPrimaryContext)
}

func (s *JoinRelationContext) JoinType() IJoinTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJoinTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJoinTypeContext)
}

func (s *JoinRelationContext) DistributeType() IDistributeTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDistributeTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDistributeTypeContext)
}

func (s *JoinRelationContext) JoinCriteria() IJoinCriteriaContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJoinCriteriaContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJoinCriteriaContext)
}

func (s *JoinRelationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinRelationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JoinRelationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitJoinRelation(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) JoinRelation() (localctx IJoinRelationContext) {
	localctx = NewJoinRelationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 264, DorisParserParserRULE_joinRelation)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4923)
		p.JoinType()
	}

	{
		p.SetState(4924)
		p.Match(DorisParserParserJOIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4926)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 699, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4925)
			p.DistributeType()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(4928)

		var _x = p.RelationPrimary()

		localctx.(*JoinRelationContext).right = _x
	}
	p.SetState(4930)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 700, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4929)
			p.JoinCriteria()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDistributeTypeContext is an interface to support dynamic dispatch.
type IDistributeTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsDistributeTypeContext differentiates from other interfaces.
	IsDistributeTypeContext()
}

type DistributeTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDistributeTypeContext() *DistributeTypeContext {
	var p = new(DistributeTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_distributeType
	return p
}

func InitEmptyDistributeTypeContext(p *DistributeTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_distributeType
}

func (*DistributeTypeContext) IsDistributeTypeContext() {}

func NewDistributeTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DistributeTypeContext {
	var p = new(DistributeTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_distributeType

	return p
}

func (s *DistributeTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *DistributeTypeContext) CopyAll(ctx *DistributeTypeContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *DistributeTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DistributeTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type CommentDistributeTypeContext struct {
	DistributeTypeContext
}

func NewCommentDistributeTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CommentDistributeTypeContext {
	var p = new(CommentDistributeTypeContext)

	InitEmptyDistributeTypeContext(&p.DistributeTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*DistributeTypeContext))

	return p
}

func (s *CommentDistributeTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommentDistributeTypeContext) HINT_START() antlr.TerminalNode {
	return s.GetToken(DorisParserParserHINT_START, 0)
}

func (s *CommentDistributeTypeContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CommentDistributeTypeContext) HINT_END() antlr.TerminalNode {
	return s.GetToken(DorisParserParserHINT_END, 0)
}

func (s *CommentDistributeTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitCommentDistributeType(s)

	default:
		return t.VisitChildren(s)
	}
}

type BracketDistributeTypeContext struct {
	DistributeTypeContext
}

func NewBracketDistributeTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BracketDistributeTypeContext {
	var p = new(BracketDistributeTypeContext)

	InitEmptyDistributeTypeContext(&p.DistributeTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*DistributeTypeContext))

	return p
}

func (s *BracketDistributeTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BracketDistributeTypeContext) LEFT_BRACKET() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLEFT_BRACKET, 0)
}

func (s *BracketDistributeTypeContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *BracketDistributeTypeContext) RIGHT_BRACKET() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRIGHT_BRACKET, 0)
}

func (s *BracketDistributeTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitBracketDistributeType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) DistributeType() (localctx IDistributeTypeContext) {
	localctx = NewDistributeTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 266, DorisParserParserRULE_distributeType)
	p.SetState(4940)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserParserLEFT_BRACKET:
		localctx = NewBracketDistributeTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4932)
			p.Match(DorisParserParserLEFT_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4933)
			p.Identifier()
		}
		{
			p.SetState(4934)
			p.Match(DorisParserParserRIGHT_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserParserHINT_START:
		localctx = NewCommentDistributeTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4936)
			p.Match(DorisParserParserHINT_START)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4937)
			p.Identifier()
		}
		{
			p.SetState(4938)
			p.Match(DorisParserParserHINT_END)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRelationHintContext is an interface to support dynamic dispatch.
type IRelationHintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsRelationHintContext differentiates from other interfaces.
	IsRelationHintContext()
}

type RelationHintContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationHintContext() *RelationHintContext {
	var p = new(RelationHintContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_relationHint
	return p
}

func InitEmptyRelationHintContext(p *RelationHintContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_relationHint
}

func (*RelationHintContext) IsRelationHintContext() {}

func NewRelationHintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationHintContext {
	var p = new(RelationHintContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_relationHint

	return p
}

func (s *RelationHintContext) GetParser() antlr.Parser { return s.parser }

func (s *RelationHintContext) CopyAll(ctx *RelationHintContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *RelationHintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationHintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type BracketRelationHintContext struct {
	RelationHintContext
}

func NewBracketRelationHintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BracketRelationHintContext {
	var p = new(BracketRelationHintContext)

	InitEmptyRelationHintContext(&p.RelationHintContext)
	p.parser = parser
	p.CopyAll(ctx.(*RelationHintContext))

	return p
}

func (s *BracketRelationHintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BracketRelationHintContext) LEFT_BRACKET() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLEFT_BRACKET, 0)
}

func (s *BracketRelationHintContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *BracketRelationHintContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *BracketRelationHintContext) RIGHT_BRACKET() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRIGHT_BRACKET, 0)
}

func (s *BracketRelationHintContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserCOMMA)
}

func (s *BracketRelationHintContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOMMA, i)
}

func (s *BracketRelationHintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitBracketRelationHint(s)

	default:
		return t.VisitChildren(s)
	}
}

type CommentRelationHintContext struct {
	RelationHintContext
}

func NewCommentRelationHintContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CommentRelationHintContext {
	var p = new(CommentRelationHintContext)

	InitEmptyRelationHintContext(&p.RelationHintContext)
	p.parser = parser
	p.CopyAll(ctx.(*RelationHintContext))

	return p
}

func (s *CommentRelationHintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommentRelationHintContext) HINT_START() antlr.TerminalNode {
	return s.GetToken(DorisParserParserHINT_START, 0)
}

func (s *CommentRelationHintContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *CommentRelationHintContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CommentRelationHintContext) HINT_END() antlr.TerminalNode {
	return s.GetToken(DorisParserParserHINT_END, 0)
}

func (s *CommentRelationHintContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserCOMMA)
}

func (s *CommentRelationHintContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOMMA, i)
}

func (s *CommentRelationHintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitCommentRelationHint(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) RelationHint() (localctx IRelationHintContext) {
	localctx = NewRelationHintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 268, DorisParserParserRULE_relationHint)
	var _la int

	p.SetState(4964)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserParserLEFT_BRACKET:
		localctx = NewBracketRelationHintContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4942)
			p.Match(DorisParserParserLEFT_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4943)
			p.Identifier()
		}
		p.SetState(4948)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserParserCOMMA {
			{
				p.SetState(4944)
				p.Match(DorisParserParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4945)
				p.Identifier()
			}

			p.SetState(4950)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(4951)
			p.Match(DorisParserParserRIGHT_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserParserHINT_START:
		localctx = NewCommentRelationHintContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4953)
			p.Match(DorisParserParserHINT_START)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4954)
			p.Identifier()
		}
		p.SetState(4959)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserParserCOMMA {
			{
				p.SetState(4955)
				p.Match(DorisParserParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4956)
				p.Identifier()
			}

			p.SetState(4961)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(4962)
			p.Match(DorisParserParserHINT_END)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAggClauseContext is an interface to support dynamic dispatch.
type IAggClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GROUP() antlr.TerminalNode
	BY() antlr.TerminalNode
	GroupingElement() IGroupingElementContext

	// IsAggClauseContext differentiates from other interfaces.
	IsAggClauseContext()
}

type AggClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAggClauseContext() *AggClauseContext {
	var p = new(AggClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_aggClause
	return p
}

func InitEmptyAggClauseContext(p *AggClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_aggClause
}

func (*AggClauseContext) IsAggClauseContext() {}

func NewAggClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AggClauseContext {
	var p = new(AggClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_aggClause

	return p
}

func (s *AggClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *AggClauseContext) GROUP() antlr.TerminalNode {
	return s.GetToken(DorisParserParserGROUP, 0)
}

func (s *AggClauseContext) BY() antlr.TerminalNode {
	return s.GetToken(DorisParserParserBY, 0)
}

func (s *AggClauseContext) GroupingElement() IGroupingElementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGroupingElementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGroupingElementContext)
}

func (s *AggClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AggClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AggClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitAggClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) AggClause() (localctx IAggClauseContext) {
	localctx = NewAggClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 270, DorisParserParserRULE_aggClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4966)
		p.Match(DorisParserParserGROUP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4967)
		p.Match(DorisParserParserBY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4968)
		p.GroupingElement()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGroupingElementContext is an interface to support dynamic dispatch.
type IGroupingElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ROLLUP() antlr.TerminalNode
	LEFT_PAREN() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	CUBE() antlr.TerminalNode
	GROUPING() antlr.TerminalNode
	SETS() antlr.TerminalNode
	AllGroupingSet() []IGroupingSetContext
	GroupingSet(i int) IGroupingSetContext
	WITH() antlr.TerminalNode

	// IsGroupingElementContext differentiates from other interfaces.
	IsGroupingElementContext()
}

type GroupingElementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroupingElementContext() *GroupingElementContext {
	var p = new(GroupingElementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_groupingElement
	return p
}

func InitEmptyGroupingElementContext(p *GroupingElementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_groupingElement
}

func (*GroupingElementContext) IsGroupingElementContext() {}

func NewGroupingElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GroupingElementContext {
	var p = new(GroupingElementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_groupingElement

	return p
}

func (s *GroupingElementContext) GetParser() antlr.Parser { return s.parser }

func (s *GroupingElementContext) ROLLUP() antlr.TerminalNode {
	return s.GetToken(DorisParserParserROLLUP, 0)
}

func (s *GroupingElementContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLEFT_PAREN, 0)
}

func (s *GroupingElementContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRIGHT_PAREN, 0)
}

func (s *GroupingElementContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *GroupingElementContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *GroupingElementContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserCOMMA)
}

func (s *GroupingElementContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOMMA, i)
}

func (s *GroupingElementContext) CUBE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCUBE, 0)
}

func (s *GroupingElementContext) GROUPING() antlr.TerminalNode {
	return s.GetToken(DorisParserParserGROUPING, 0)
}

func (s *GroupingElementContext) SETS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSETS, 0)
}

func (s *GroupingElementContext) AllGroupingSet() []IGroupingSetContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IGroupingSetContext); ok {
			len++
		}
	}

	tst := make([]IGroupingSetContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IGroupingSetContext); ok {
			tst[i] = t.(IGroupingSetContext)
			i++
		}
	}

	return tst
}

func (s *GroupingElementContext) GroupingSet(i int) IGroupingSetContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGroupingSetContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGroupingSetContext)
}

func (s *GroupingElementContext) WITH() antlr.TerminalNode {
	return s.GetToken(DorisParserParserWITH, 0)
}

func (s *GroupingElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupingElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GroupingElementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitGroupingElement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) GroupingElement() (localctx IGroupingElementContext) {
	localctx = NewGroupingElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 272, DorisParserParserRULE_groupingElement)
	var _la int

	var _alt int

	p.SetState(5021)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 712, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4970)
			p.Match(DorisParserParserROLLUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4971)
			p.Match(DorisParserParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4980)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-2305884869834611068) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&4610552282352573437) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-9079382760121755163) != 0) || ((int64((_la-192)) & ^0x3f) == 0 && ((int64(1)<<(_la-192))&4321098383830537129) != 0) || ((int64((_la-256)) & ^0x3f) == 0 && ((int64(1)<<(_la-256))&-5206443760946300951) != 0) || ((int64((_la-320)) & ^0x3f) == 0 && ((int64(1)<<(_la-320))&-4187784802352497917) != 0) || ((int64((_la-384)) & ^0x3f) == 0 && ((int64(1)<<(_la-384))&9222796779122712571) != 0) || ((int64((_la-452)) & ^0x3f) == 0 && ((int64(1)<<(_la-452))&2449945648132536049) != 0) || ((int64((_la-517)) & ^0x3f) == 0 && ((int64(1)<<(_la-517))&236487517953) != 0) {
			{
				p.SetState(4972)
				p.Expression()
			}
			p.SetState(4977)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == DorisParserParserCOMMA {
				{
					p.SetState(4973)
					p.Match(DorisParserParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(4974)
					p.Expression()
				}

				p.SetState(4979)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(4982)
			p.Match(DorisParserParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4983)
			p.Match(DorisParserParserCUBE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4984)
			p.Match(DorisParserParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4993)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-2305884869834611068) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&4610552282352573437) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-9079382760121755163) != 0) || ((int64((_la-192)) & ^0x3f) == 0 && ((int64(1)<<(_la-192))&4321098383830537129) != 0) || ((int64((_la-256)) & ^0x3f) == 0 && ((int64(1)<<(_la-256))&-5206443760946300951) != 0) || ((int64((_la-320)) & ^0x3f) == 0 && ((int64(1)<<(_la-320))&-4187784802352497917) != 0) || ((int64((_la-384)) & ^0x3f) == 0 && ((int64(1)<<(_la-384))&9222796779122712571) != 0) || ((int64((_la-452)) & ^0x3f) == 0 && ((int64(1)<<(_la-452))&2449945648132536049) != 0) || ((int64((_la-517)) & ^0x3f) == 0 && ((int64(1)<<(_la-517))&236487517953) != 0) {
			{
				p.SetState(4985)
				p.Expression()
			}
			p.SetState(4990)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == DorisParserParserCOMMA {
				{
					p.SetState(4986)
					p.Match(DorisParserParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(4987)
					p.Expression()
				}

				p.SetState(4992)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(4995)
			p.Match(DorisParserParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4996)
			p.Match(DorisParserParserGROUPING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4997)
			p.Match(DorisParserParserSETS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4998)
			p.Match(DorisParserParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4999)
			p.GroupingSet()
		}
		p.SetState(5004)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserParserCOMMA {
			{
				p.SetState(5000)
				p.Match(DorisParserParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5001)
				p.GroupingSet()
			}

			p.SetState(5006)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(5007)
			p.Match(DorisParserParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5009)
			p.Expression()
		}
		p.SetState(5014)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 710, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(5010)
					p.Match(DorisParserParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(5011)
					p.Expression()
				}

			}
			p.SetState(5016)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 710, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(5019)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 711, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5017)
				p.Match(DorisParserParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5018)
				p.Match(DorisParserParserROLLUP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGroupingSetContext is an interface to support dynamic dispatch.
type IGroupingSetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LEFT_PAREN() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsGroupingSetContext differentiates from other interfaces.
	IsGroupingSetContext()
}

type GroupingSetContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroupingSetContext() *GroupingSetContext {
	var p = new(GroupingSetContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_groupingSet
	return p
}

func InitEmptyGroupingSetContext(p *GroupingSetContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_groupingSet
}

func (*GroupingSetContext) IsGroupingSetContext() {}

func NewGroupingSetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GroupingSetContext {
	var p = new(GroupingSetContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_groupingSet

	return p
}

func (s *GroupingSetContext) GetParser() antlr.Parser { return s.parser }

func (s *GroupingSetContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLEFT_PAREN, 0)
}

func (s *GroupingSetContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRIGHT_PAREN, 0)
}

func (s *GroupingSetContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *GroupingSetContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *GroupingSetContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserCOMMA)
}

func (s *GroupingSetContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOMMA, i)
}

func (s *GroupingSetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupingSetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GroupingSetContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitGroupingSet(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) GroupingSet() (localctx IGroupingSetContext) {
	localctx = NewGroupingSetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 274, DorisParserParserRULE_groupingSet)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5023)
		p.Match(DorisParserParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5032)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-2305884869834611068) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&4610552282352573437) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-9079382760121755163) != 0) || ((int64((_la-192)) & ^0x3f) == 0 && ((int64(1)<<(_la-192))&4321098383830537129) != 0) || ((int64((_la-256)) & ^0x3f) == 0 && ((int64(1)<<(_la-256))&-5206443760946300951) != 0) || ((int64((_la-320)) & ^0x3f) == 0 && ((int64(1)<<(_la-320))&-4187784802352497917) != 0) || ((int64((_la-384)) & ^0x3f) == 0 && ((int64(1)<<(_la-384))&9222796779122712571) != 0) || ((int64((_la-452)) & ^0x3f) == 0 && ((int64(1)<<(_la-452))&2449945648132536049) != 0) || ((int64((_la-517)) & ^0x3f) == 0 && ((int64(1)<<(_la-517))&236487517953) != 0) {
		{
			p.SetState(5024)
			p.Expression()
		}
		p.SetState(5029)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserParserCOMMA {
			{
				p.SetState(5025)
				p.Match(DorisParserParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5026)
				p.Expression()
			}

			p.SetState(5031)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(5034)
		p.Match(DorisParserParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHavingClauseContext is an interface to support dynamic dispatch.
type IHavingClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	HAVING() antlr.TerminalNode
	BooleanExpression() IBooleanExpressionContext

	// IsHavingClauseContext differentiates from other interfaces.
	IsHavingClauseContext()
}

type HavingClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHavingClauseContext() *HavingClauseContext {
	var p = new(HavingClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_havingClause
	return p
}

func InitEmptyHavingClauseContext(p *HavingClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_havingClause
}

func (*HavingClauseContext) IsHavingClauseContext() {}

func NewHavingClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HavingClauseContext {
	var p = new(HavingClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_havingClause

	return p
}

func (s *HavingClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *HavingClauseContext) HAVING() antlr.TerminalNode {
	return s.GetToken(DorisParserParserHAVING, 0)
}

func (s *HavingClauseContext) BooleanExpression() IBooleanExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *HavingClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HavingClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HavingClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitHavingClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) HavingClause() (localctx IHavingClauseContext) {
	localctx = NewHavingClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 276, DorisParserParserRULE_havingClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5036)
		p.Match(DorisParserParserHAVING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5037)
		p.booleanExpression(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQualifyClauseContext is an interface to support dynamic dispatch.
type IQualifyClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QUALIFY() antlr.TerminalNode
	BooleanExpression() IBooleanExpressionContext

	// IsQualifyClauseContext differentiates from other interfaces.
	IsQualifyClauseContext()
}

type QualifyClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQualifyClauseContext() *QualifyClauseContext {
	var p = new(QualifyClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_qualifyClause
	return p
}

func InitEmptyQualifyClauseContext(p *QualifyClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_qualifyClause
}

func (*QualifyClauseContext) IsQualifyClauseContext() {}

func NewQualifyClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QualifyClauseContext {
	var p = new(QualifyClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_qualifyClause

	return p
}

func (s *QualifyClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *QualifyClauseContext) QUALIFY() antlr.TerminalNode {
	return s.GetToken(DorisParserParserQUALIFY, 0)
}

func (s *QualifyClauseContext) BooleanExpression() IBooleanExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *QualifyClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QualifyClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QualifyClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitQualifyClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) QualifyClause() (localctx IQualifyClauseContext) {
	localctx = NewQualifyClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 278, DorisParserParserRULE_qualifyClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5039)
		p.Match(DorisParserParserQUALIFY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5040)
		p.booleanExpression(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelectHintContext is an interface to support dynamic dispatch.
type ISelectHintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_hintStatement returns the _hintStatement rule contexts.
	Get_hintStatement() IHintStatementContext

	// Set_hintStatement sets the _hintStatement rule contexts.
	Set_hintStatement(IHintStatementContext)

	// GetHintStatements returns the hintStatements rule context list.
	GetHintStatements() []IHintStatementContext

	// SetHintStatements sets the hintStatements rule context list.
	SetHintStatements([]IHintStatementContext)

	// Getter signatures
	HINT_END() antlr.TerminalNode
	AllHintStatement() []IHintStatementContext
	HintStatement(i int) IHintStatementContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsSelectHintContext differentiates from other interfaces.
	IsSelectHintContext()
}

type SelectHintContext struct {
	antlr.BaseParserRuleContext
	parser         antlr.Parser
	_hintStatement IHintStatementContext
	hintStatements []IHintStatementContext
}

func NewEmptySelectHintContext() *SelectHintContext {
	var p = new(SelectHintContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_selectHint
	return p
}

func InitEmptySelectHintContext(p *SelectHintContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_selectHint
}

func (*SelectHintContext) IsSelectHintContext() {}

func NewSelectHintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectHintContext {
	var p = new(SelectHintContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_selectHint

	return p
}

func (s *SelectHintContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectHintContext) Get_hintStatement() IHintStatementContext { return s._hintStatement }

func (s *SelectHintContext) Set_hintStatement(v IHintStatementContext) { s._hintStatement = v }

func (s *SelectHintContext) GetHintStatements() []IHintStatementContext { return s.hintStatements }

func (s *SelectHintContext) SetHintStatements(v []IHintStatementContext) { s.hintStatements = v }

func (s *SelectHintContext) HINT_END() antlr.TerminalNode {
	return s.GetToken(DorisParserParserHINT_END, 0)
}

func (s *SelectHintContext) AllHintStatement() []IHintStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IHintStatementContext); ok {
			len++
		}
	}

	tst := make([]IHintStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IHintStatementContext); ok {
			tst[i] = t.(IHintStatementContext)
			i++
		}
	}

	return tst
}

func (s *SelectHintContext) HintStatement(i int) IHintStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHintStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHintStatementContext)
}

func (s *SelectHintContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserCOMMA)
}

func (s *SelectHintContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOMMA, i)
}

func (s *SelectHintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectHintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelectHintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitSelectHint(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) SelectHint() (localctx ISelectHintContext) {
	localctx = NewSelectHintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 280, DorisParserParserRULE_selectHint)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5042)

		var _x = p.HintStatement()

		localctx.(*SelectHintContext)._hintStatement = _x
	}
	localctx.(*SelectHintContext).hintStatements = append(localctx.(*SelectHintContext).hintStatements, localctx.(*SelectHintContext)._hintStatement)
	p.SetState(5049)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 716, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(5044)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserParserCOMMA {
				{
					p.SetState(5043)
					p.Match(DorisParserParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(5046)

				var _x = p.HintStatement()

				localctx.(*SelectHintContext)._hintStatement = _x
			}
			localctx.(*SelectHintContext).hintStatements = append(localctx.(*SelectHintContext).hintStatements, localctx.(*SelectHintContext)._hintStatement)

		}
		p.SetState(5051)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 716, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(5052)
		p.Match(DorisParserParserHINT_END)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHintStatementContext is an interface to support dynamic dispatch.
type IHintStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetHintName returns the hintName rule contexts.
	GetHintName() IIdentifierContext

	// Get_hintAssignment returns the _hintAssignment rule contexts.
	Get_hintAssignment() IHintAssignmentContext

	// Get_multipartIdentifier returns the _multipartIdentifier rule contexts.
	Get_multipartIdentifier() IMultipartIdentifierContext

	// SetHintName sets the hintName rule contexts.
	SetHintName(IIdentifierContext)

	// Set_hintAssignment sets the _hintAssignment rule contexts.
	Set_hintAssignment(IHintAssignmentContext)

	// Set_multipartIdentifier sets the _multipartIdentifier rule contexts.
	Set_multipartIdentifier(IMultipartIdentifierContext)

	// GetParameters returns the parameters rule context list.
	GetParameters() []IHintAssignmentContext

	// GetTableList returns the tableList rule context list.
	GetTableList() []IMultipartIdentifierContext

	// SetParameters sets the parameters rule context list.
	SetParameters([]IHintAssignmentContext)

	// SetTableList sets the tableList rule context list.
	SetTableList([]IMultipartIdentifierContext)

	// Getter signatures
	Identifier() IIdentifierContext
	LEFT_PAREN() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode
	AllHintAssignment() []IHintAssignmentContext
	HintAssignment(i int) IHintAssignmentContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	USE_MV() antlr.TerminalNode
	NO_USE_MV() antlr.TerminalNode
	AllMultipartIdentifier() []IMultipartIdentifierContext
	MultipartIdentifier(i int) IMultipartIdentifierContext

	// IsHintStatementContext differentiates from other interfaces.
	IsHintStatementContext()
}

type HintStatementContext struct {
	antlr.BaseParserRuleContext
	parser               antlr.Parser
	hintName             IIdentifierContext
	_hintAssignment      IHintAssignmentContext
	parameters           []IHintAssignmentContext
	_multipartIdentifier IMultipartIdentifierContext
	tableList            []IMultipartIdentifierContext
}

func NewEmptyHintStatementContext() *HintStatementContext {
	var p = new(HintStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_hintStatement
	return p
}

func InitEmptyHintStatementContext(p *HintStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_hintStatement
}

func (*HintStatementContext) IsHintStatementContext() {}

func NewHintStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HintStatementContext {
	var p = new(HintStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_hintStatement

	return p
}

func (s *HintStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *HintStatementContext) GetHintName() IIdentifierContext { return s.hintName }

func (s *HintStatementContext) Get_hintAssignment() IHintAssignmentContext { return s._hintAssignment }

func (s *HintStatementContext) Get_multipartIdentifier() IMultipartIdentifierContext {
	return s._multipartIdentifier
}

func (s *HintStatementContext) SetHintName(v IIdentifierContext) { s.hintName = v }

func (s *HintStatementContext) Set_hintAssignment(v IHintAssignmentContext) { s._hintAssignment = v }

func (s *HintStatementContext) Set_multipartIdentifier(v IMultipartIdentifierContext) {
	s._multipartIdentifier = v
}

func (s *HintStatementContext) GetParameters() []IHintAssignmentContext { return s.parameters }

func (s *HintStatementContext) GetTableList() []IMultipartIdentifierContext { return s.tableList }

func (s *HintStatementContext) SetParameters(v []IHintAssignmentContext) { s.parameters = v }

func (s *HintStatementContext) SetTableList(v []IMultipartIdentifierContext) { s.tableList = v }

func (s *HintStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *HintStatementContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLEFT_PAREN, 0)
}

func (s *HintStatementContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRIGHT_PAREN, 0)
}

func (s *HintStatementContext) AllHintAssignment() []IHintAssignmentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IHintAssignmentContext); ok {
			len++
		}
	}

	tst := make([]IHintAssignmentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IHintAssignmentContext); ok {
			tst[i] = t.(IHintAssignmentContext)
			i++
		}
	}

	return tst
}

func (s *HintStatementContext) HintAssignment(i int) IHintAssignmentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHintAssignmentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHintAssignmentContext)
}

func (s *HintStatementContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserCOMMA)
}

func (s *HintStatementContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOMMA, i)
}

func (s *HintStatementContext) USE_MV() antlr.TerminalNode {
	return s.GetToken(DorisParserParserUSE_MV, 0)
}

func (s *HintStatementContext) NO_USE_MV() antlr.TerminalNode {
	return s.GetToken(DorisParserParserNO_USE_MV, 0)
}

func (s *HintStatementContext) AllMultipartIdentifier() []IMultipartIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IMultipartIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMultipartIdentifierContext); ok {
			tst[i] = t.(IMultipartIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *HintStatementContext) MultipartIdentifier(i int) IMultipartIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *HintStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HintStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HintStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitHintStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) HintStatement() (localctx IHintStatementContext) {
	localctx = NewHintStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 282, DorisParserParserRULE_hintStatement)
	var _la int

	p.SetState(5084)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserParserLEFT_BRACE, DorisParserParserRIGHT_BRACE, DorisParserParserACTIONS, DorisParserParserAFTER, DorisParserParserAGG_STATE, DorisParserParserAGGREGATE, DorisParserParserALIAS, DorisParserParserANALYZED, DorisParserParserARRAY, DorisParserParserAT, DorisParserParserAUTHORS, DorisParserParserAUTO_INCREMENT, DorisParserParserALWAYS, DorisParserParserBACKENDS, DorisParserParserBACKUP, DorisParserParserBEGIN, DorisParserParserBELONG, DorisParserParserBIN, DorisParserParserBITAND, DorisParserParserBITMAP, DorisParserParserBITMAP_EMPTY, DorisParserParserBITMAP_UNION, DorisParserParserBITOR, DorisParserParserBITXOR, DorisParserParserBLOB, DorisParserParserBOOLEAN, DorisParserParserBRANCH, DorisParserParserBRIEF, DorisParserParserBROKER, DorisParserParserBUCKETS, DorisParserParserBUILD, DorisParserParserBUILTIN, DorisParserParserBULK, DorisParserParserCACHE, DorisParserParserCACHED, DorisParserParserCALL, DorisParserParserCATALOG, DorisParserParserCATALOGS, DorisParserParserCHAIN, DorisParserParserCHAR, DorisParserParserCHARSET, DorisParserParserCHECK, DorisParserParserCLUSTER, DorisParserParserCLUSTERS, DorisParserParserCOLLATION, DorisParserParserCOLLECT, DorisParserParserCOLOCATE, DorisParserParserCOLUMNS, DorisParserParserCOMMENT, DorisParserParserCOMMIT, DorisParserParserCOMMITTED, DorisParserParserCOMPACT, DorisParserParserCOMPLETE, DorisParserParserCOMPRESS_TYPE, DorisParserParserCOMPUTE, DorisParserParserCONDITIONS, DorisParserParserCONFIG, DorisParserParserCONNECTION, DorisParserParserCONNECTION_ID, DorisParserParserCONSISTENT, DorisParserParserCONSTRAINTS, DorisParserParserCONVERT, DorisParserParserCONVERT_LSC, DorisParserParserCOPY, DorisParserParserCOUNT, DorisParserParserCREATION, DorisParserParserCRON, DorisParserParserCURRENT_CATALOG, DorisParserParserCURRENT_DATE, DorisParserParserCURRENT_TIME, DorisParserParserCURRENT_TIMESTAMP, DorisParserParserCURRENT_USER, DorisParserParserDATA, DorisParserParserDATE, DorisParserParserDATETIME, DorisParserParserDATETIMEV2, DorisParserParserDATEV2, DorisParserParserDATETIMEV1, DorisParserParserDATEV1, DorisParserParserDAY, DorisParserParserDAYS, DorisParserParserDECIMAL, DorisParserParserDECIMALV2, DorisParserParserDECIMALV3, DorisParserParserDEFERRED, DorisParserParserDEMAND, DorisParserParserDIAGNOSE, DorisParserParserDIAGNOSIS, DorisParserParserDICTIONARIES, DorisParserParserDICTIONARY, DorisParserParserDISTINCTPC, DorisParserParserDISTINCTPCSA, DorisParserParserDO, DorisParserParserDORIS_INTERNAL_TABLE_ID, DorisParserParserDUAL, DorisParserParserDYNAMIC, DorisParserParserE, DorisParserParserENABLE, DorisParserParserENCRYPTKEY, DorisParserParserENCRYPTKEYS, DorisParserParserEND, DorisParserParserENDS, DorisParserParserENGINE, DorisParserParserENGINES, DorisParserParserERRORS, DorisParserParserESCAPE, DorisParserParserEVENTS, DorisParserParserEVERY, DorisParserParserEXCLUDE, DorisParserParserEXPIRED, DorisParserParserEXTERNAL, DorisParserParserFAILED_LOGIN_ATTEMPTS, DorisParserParserFAST, DorisParserParserFEATURE, DorisParserParserFIELDS, DorisParserParserFILE, DorisParserParserFILTER, DorisParserParserFIRST, DorisParserParserFORMAT, DorisParserParserFREE, DorisParserParserFRONTENDS, DorisParserParserFUNCTION, DorisParserParserGENERATED, DorisParserParserGENERIC, DorisParserParserGLOBAL, DorisParserParserGRAPH, DorisParserParserGROUPING, DorisParserParserGROUPS, DorisParserParserHASH, DorisParserParserHASH_MAP, DorisParserParserHDFS, DorisParserParserHELP, DorisParserParserHISTOGRAM, DorisParserParserHLL_UNION, DorisParserParserHOSTNAME, DorisParserParserHOTSPOT, DorisParserParserHOUR, DorisParserParserHOURS, DorisParserParserHUB, DorisParserParserIDENTIFIED, DorisParserParserIGNORE, DorisParserParserIMMEDIATE, DorisParserParserINCREMENTAL, DorisParserParserINDEXES, DorisParserParserINVERTED, DorisParserParserIP_TRIE, DorisParserParserIPV4, DorisParserParserIPV6, DorisParserParserIS_NOT_NULL_PRED, DorisParserParserIS_NULL_PRED, DorisParserParserISNULL, DorisParserParserISOLATION, DorisParserParserJOB, DorisParserParserJOBS, DorisParserParserJSON, DorisParserParserJSONB, DorisParserParserLABEL, DorisParserParserLAST, DorisParserParserLDAP, DorisParserParserLDAP_ADMIN_PASSWORD, DorisParserParserLESS, DorisParserParserLEVEL, DorisParserParserLINES, DorisParserParserLINK, DorisParserParserLOCAL, DorisParserParserLOCALTIME, DorisParserParserLOCALTIMESTAMP, DorisParserParserLOCATION, DorisParserParserLOCK, DorisParserParserLOGICAL, DorisParserParserMANUAL, DorisParserParserMAP, DorisParserParserMATCH_ALL, DorisParserParserMATCH_ANY, DorisParserParserMATCH_PHRASE, DorisParserParserMATCH_PHRASE_EDGE, DorisParserParserMATCH_PHRASE_PREFIX, DorisParserParserMATCH_REGEXP, DorisParserParserMATERIALIZED, DorisParserParserMAX, DorisParserParserMEMO, DorisParserParserMERGE, DorisParserParserMIGRATE, DorisParserParserMIGRATIONS, DorisParserParserMIN, DorisParserParserMINUTE, DorisParserParserMINUTES, DorisParserParserMODIFY, DorisParserParserMONTH, DorisParserParserMTMV, DorisParserParserNAME, DorisParserParserNAMES, DorisParserParserNEGATIVE, DorisParserParserNEVER, DorisParserParserNEXT, DorisParserParserNGRAM_BF, DorisParserParserNO, DorisParserParserNON_NULLABLE, DorisParserParserNULLS, DorisParserParserOF, DorisParserParserOFFSET, DorisParserParserONLY, DorisParserParserOPEN, DorisParserParserOPTIMIZED, DorisParserParserPARAMETER, DorisParserParserPARSED, DorisParserParserPARTITIONS, DorisParserParserPASSWORD, DorisParserParserPASSWORD_EXPIRE, DorisParserParserPASSWORD_HISTORY, DorisParserParserPASSWORD_LOCK_TIME, DorisParserParserPASSWORD_REUSE, DorisParserParserPATH, DorisParserParserPAUSE, DorisParserParserPERCENT, DorisParserParserPERIOD, DorisParserParserPERMISSIVE, DorisParserParserPHYSICAL, DorisParserParserPI, DorisParserParserPLAN, DorisParserParserPRIVILEGES, DorisParserParserPROCESS, DorisParserParserPLUGIN, DorisParserParserPLUGINS, DorisParserParserPOLICY, DorisParserParserPROC, DorisParserParserPROCESSLIST, DorisParserParserPROFILE, DorisParserParserPROPERTIES, DorisParserParserPROPERTY, DorisParserParserQUANTILE_STATE, DorisParserParserQUANTILE_UNION, DorisParserParserQUERY, DorisParserParserQUEUED, DorisParserParserQUOTA, DorisParserParserQUALIFY, DorisParserParserQUARTER, DorisParserParserRANDOM, DorisParserParserRECENT, DorisParserParserRECOVER, DorisParserParserRECYCLE, DorisParserParserREFRESH, DorisParserParserREPEATABLE, DorisParserParserREPLACE, DorisParserParserREPLACE_IF_NOT_NULL, DorisParserParserREPLAYER, DorisParserParserREPOSITORIES, DorisParserParserREPOSITORY, DorisParserParserRESOURCE, DorisParserParserRESOURCES, DorisParserParserRESTORE, DorisParserParserRESTRICTIVE, DorisParserParserRESUME, DorisParserParserRETAIN, DorisParserParserRETENTION, DorisParserParserRETURNS, DorisParserParserREWRITTEN, DorisParserParserRLIKE, DorisParserParserROLLBACK, DorisParserParserROLLUP, DorisParserParserROUTINE, DorisParserParserS3, DorisParserParserSAMPLE, DorisParserParserSCHEDULE, DorisParserParserSCHEDULER, DorisParserParserSCHEMA, DorisParserParserSECOND, DorisParserParserSERIALIZABLE, DorisParserParserSESSION, DorisParserParserSESSION_USER, DorisParserParserSET_SESSION_VARIABLE, DorisParserParserSHAPE, DorisParserParserSKEW, DorisParserParserSNAPSHOT, DorisParserParserSNAPSHOTS, DorisParserParserSONAME, DorisParserParserSPLIT, DorisParserParserSQL, DorisParserParserSTAGE, DorisParserParserSTAGES, DorisParserParserSTART, DorisParserParserSTARTS, DorisParserParserSTATS, DorisParserParserSTATUS, DorisParserParserSTOP, DorisParserParserSTORAGE, DorisParserParserSTREAM, DorisParserParserSTREAMING, DorisParserParserSTRING, DorisParserParserSTRUCT, DorisParserParserSUM, DorisParserParserTABLES, DorisParserParserTAG, DorisParserParserTASK, DorisParserParserTASKS, DorisParserParserTEMPORARY, DorisParserParserTEXT, DorisParserParserTHAN, DorisParserParserTIME, DorisParserParserTIMESTAMP, DorisParserParserTRANSACTION, DorisParserParserTREE, DorisParserParserTRIGGERS, DorisParserParserTRUNCATE, DorisParserParserTYPE, DorisParserParserTYPES, DorisParserParserUNCOMMITTED, DorisParserParserUNLOCK, DorisParserParserUNSET, DorisParserParserUP, DorisParserParserUSER, DorisParserParserVALUE, DorisParserParserVARCHAR, DorisParserParserVARIABLE, DorisParserParserVARIABLES, DorisParserParserVARIANT, DorisParserParserVAULT, DorisParserParserVAULTS, DorisParserParserVERBOSE, DorisParserParserVERSION, DorisParserParserVIEW, DorisParserParserVIEWS, DorisParserParserWARM, DorisParserParserWARNINGS, DorisParserParserWEEK, DorisParserParserWORK, DorisParserParserYEAR, DorisParserParserHINT_START, DorisParserParserHINT_END, DorisParserParserCOMMENT_START, DorisParserParserIDENTIFIER, DorisParserParserBACKQUOTED_IDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5054)

			var _x = p.Identifier()

			localctx.(*HintStatementContext).hintName = _x
		}
		p.SetState(5068)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserLEFT_PAREN {
			{
				p.SetState(5055)
				p.Match(DorisParserParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5056)

				var _x = p.HintAssignment()

				localctx.(*HintStatementContext)._hintAssignment = _x
			}
			localctx.(*HintStatementContext).parameters = append(localctx.(*HintStatementContext).parameters, localctx.(*HintStatementContext)._hintAssignment)
			p.SetState(5063)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-2305884869834627440) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&4609989332399152113) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-9079668633144976923) != 0) || ((int64((_la-192)) & ^0x3f) == 0 && ((int64(1)<<(_la-192))&2015220189171012521) != 0) || ((int64((_la-256)) & ^0x3f) == 0 && ((int64(1)<<(_la-256))&-5278501354984230039) != 0) || ((int64((_la-320)) & ^0x3f) == 0 && ((int64(1)<<(_la-320))&-4476015178504209661) != 0) || ((int64((_la-384)) & ^0x3f) == 0 && ((int64(1)<<(_la-384))&9222796779122679803) != 0) || ((int64((_la-452)) & ^0x3f) == 0 && ((int64(1)<<(_la-452))&2449945648128341745) != 0) || ((int64((_la-517)) & ^0x3f) == 0 && ((int64(1)<<(_la-517))&236386779649) != 0) {
				p.SetState(5058)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == DorisParserParserCOMMA {
					{
						p.SetState(5057)
						p.Match(DorisParserParserCOMMA)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}
				{
					p.SetState(5060)

					var _x = p.HintAssignment()

					localctx.(*HintStatementContext)._hintAssignment = _x
				}
				localctx.(*HintStatementContext).parameters = append(localctx.(*HintStatementContext).parameters, localctx.(*HintStatementContext)._hintAssignment)

				p.SetState(5065)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(5066)
				p.Match(DorisParserParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case DorisParserParserNO_USE_MV, DorisParserParserUSE_MV:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5070)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserParserNO_USE_MV || _la == DorisParserParserUSE_MV) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(5082)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserLEFT_PAREN {
			{
				p.SetState(5071)
				p.Match(DorisParserParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5072)

				var _x = p.MultipartIdentifier()

				localctx.(*HintStatementContext)._multipartIdentifier = _x
			}
			localctx.(*HintStatementContext).tableList = append(localctx.(*HintStatementContext).tableList, localctx.(*HintStatementContext)._multipartIdentifier)
			p.SetState(5077)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == DorisParserParserCOMMA {
				{
					p.SetState(5073)
					p.Match(DorisParserParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(5074)

					var _x = p.MultipartIdentifier()

					localctx.(*HintStatementContext)._multipartIdentifier = _x
				}
				localctx.(*HintStatementContext).tableList = append(localctx.(*HintStatementContext).tableList, localctx.(*HintStatementContext)._multipartIdentifier)

				p.SetState(5079)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(5080)
				p.Match(DorisParserParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHintAssignmentContext is an interface to support dynamic dispatch.
type IHintAssignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetKey returns the key rule contexts.
	GetKey() IIdentifierOrTextContext

	// GetConstantValue returns the constantValue rule contexts.
	GetConstantValue() IConstantContext

	// GetIdentifierValue returns the identifierValue rule contexts.
	GetIdentifierValue() IIdentifierContext

	// SetKey sets the key rule contexts.
	SetKey(IIdentifierOrTextContext)

	// SetConstantValue sets the constantValue rule contexts.
	SetConstantValue(IConstantContext)

	// SetIdentifierValue sets the identifierValue rule contexts.
	SetIdentifierValue(IIdentifierContext)

	// Getter signatures
	IdentifierOrText() IIdentifierOrTextContext
	EQ() antlr.TerminalNode
	Constant() IConstantContext
	Identifier() IIdentifierContext

	// IsHintAssignmentContext differentiates from other interfaces.
	IsHintAssignmentContext()
}

type HintAssignmentContext struct {
	antlr.BaseParserRuleContext
	parser          antlr.Parser
	key             IIdentifierOrTextContext
	constantValue   IConstantContext
	identifierValue IIdentifierContext
}

func NewEmptyHintAssignmentContext() *HintAssignmentContext {
	var p = new(HintAssignmentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_hintAssignment
	return p
}

func InitEmptyHintAssignmentContext(p *HintAssignmentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_hintAssignment
}

func (*HintAssignmentContext) IsHintAssignmentContext() {}

func NewHintAssignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HintAssignmentContext {
	var p = new(HintAssignmentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_hintAssignment

	return p
}

func (s *HintAssignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *HintAssignmentContext) GetKey() IIdentifierOrTextContext { return s.key }

func (s *HintAssignmentContext) GetConstantValue() IConstantContext { return s.constantValue }

func (s *HintAssignmentContext) GetIdentifierValue() IIdentifierContext { return s.identifierValue }

func (s *HintAssignmentContext) SetKey(v IIdentifierOrTextContext) { s.key = v }

func (s *HintAssignmentContext) SetConstantValue(v IConstantContext) { s.constantValue = v }

func (s *HintAssignmentContext) SetIdentifierValue(v IIdentifierContext) { s.identifierValue = v }

func (s *HintAssignmentContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *HintAssignmentContext) EQ() antlr.TerminalNode {
	return s.GetToken(DorisParserParserEQ, 0)
}

func (s *HintAssignmentContext) Constant() IConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *HintAssignmentContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *HintAssignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HintAssignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HintAssignmentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitHintAssignment(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) HintAssignment() (localctx IHintAssignmentContext) {
	localctx = NewHintAssignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 284, DorisParserParserRULE_hintAssignment)
	var _la int

	p.SetState(5095)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 725, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5086)

			var _x = p.IdentifierOrText()

			localctx.(*HintAssignmentContext).key = _x
		}
		p.SetState(5092)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserEQ {
			{
				p.SetState(5087)
				p.Match(DorisParserParserEQ)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(5090)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 723, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(5088)

					var _x = p.Constant()

					localctx.(*HintAssignmentContext).constantValue = _x
				}

			case 2:
				{
					p.SetState(5089)

					var _x = p.Identifier()

					localctx.(*HintAssignmentContext).identifierValue = _x
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5094)
			p.Constant()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUpdateAssignmentContext is an interface to support dynamic dispatch.
type IUpdateAssignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCol returns the col rule contexts.
	GetCol() IMultipartIdentifierContext

	// SetCol sets the col rule contexts.
	SetCol(IMultipartIdentifierContext)

	// Getter signatures
	EQ() antlr.TerminalNode
	MultipartIdentifier() IMultipartIdentifierContext
	Expression() IExpressionContext
	DEFAULT() antlr.TerminalNode

	// IsUpdateAssignmentContext differentiates from other interfaces.
	IsUpdateAssignmentContext()
}

type UpdateAssignmentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	col    IMultipartIdentifierContext
}

func NewEmptyUpdateAssignmentContext() *UpdateAssignmentContext {
	var p = new(UpdateAssignmentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_updateAssignment
	return p
}

func InitEmptyUpdateAssignmentContext(p *UpdateAssignmentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_updateAssignment
}

func (*UpdateAssignmentContext) IsUpdateAssignmentContext() {}

func NewUpdateAssignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UpdateAssignmentContext {
	var p = new(UpdateAssignmentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_updateAssignment

	return p
}

func (s *UpdateAssignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *UpdateAssignmentContext) GetCol() IMultipartIdentifierContext { return s.col }

func (s *UpdateAssignmentContext) SetCol(v IMultipartIdentifierContext) { s.col = v }

func (s *UpdateAssignmentContext) EQ() antlr.TerminalNode {
	return s.GetToken(DorisParserParserEQ, 0)
}

func (s *UpdateAssignmentContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *UpdateAssignmentContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *UpdateAssignmentContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDEFAULT, 0)
}

func (s *UpdateAssignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UpdateAssignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UpdateAssignmentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitUpdateAssignment(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) UpdateAssignment() (localctx IUpdateAssignmentContext) {
	localctx = NewUpdateAssignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 286, DorisParserParserRULE_updateAssignment)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5097)

		var _x = p.MultipartIdentifier()

		localctx.(*UpdateAssignmentContext).col = _x
	}
	{
		p.SetState(5098)
		p.Match(DorisParserParserEQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5101)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserParserLEFT_PAREN, DorisParserParserLEFT_BRACKET, DorisParserParserLEFT_BRACE, DorisParserParserRIGHT_BRACE, DorisParserParserACTIONS, DorisParserParserADD, DorisParserParserAFTER, DorisParserParserAGG_STATE, DorisParserParserAGGREGATE, DorisParserParserALIAS, DorisParserParserANALYZED, DorisParserParserARRAY, DorisParserParserAT, DorisParserParserAUTHORS, DorisParserParserAUTO_INCREMENT, DorisParserParserALWAYS, DorisParserParserBACKENDS, DorisParserParserBACKUP, DorisParserParserBEGIN, DorisParserParserBELONG, DorisParserParserBIN, DorisParserParserBINARY, DorisParserParserBITAND, DorisParserParserBITMAP, DorisParserParserBITMAP_EMPTY, DorisParserParserBITMAP_UNION, DorisParserParserBITOR, DorisParserParserBITXOR, DorisParserParserBLOB, DorisParserParserBOOLEAN, DorisParserParserBRANCH, DorisParserParserBRIEF, DorisParserParserBROKER, DorisParserParserBUCKETS, DorisParserParserBUILD, DorisParserParserBUILTIN, DorisParserParserBULK, DorisParserParserCACHE, DorisParserParserCACHED, DorisParserParserCALL, DorisParserParserCASE, DorisParserParserCAST, DorisParserParserCATALOG, DorisParserParserCATALOGS, DorisParserParserCHAIN, DorisParserParserCHAR, DorisParserParserCHARSET, DorisParserParserCHECK, DorisParserParserCLUSTER, DorisParserParserCLUSTERS, DorisParserParserCOLLATION, DorisParserParserCOLLECT, DorisParserParserCOLOCATE, DorisParserParserCOLUMNS, DorisParserParserCOMMENT, DorisParserParserCOMMIT, DorisParserParserCOMMITTED, DorisParserParserCOMPACT, DorisParserParserCOMPLETE, DorisParserParserCOMPRESS_TYPE, DorisParserParserCOMPUTE, DorisParserParserCONDITIONS, DorisParserParserCONFIG, DorisParserParserCONNECTION, DorisParserParserCONNECTION_ID, DorisParserParserCONSISTENT, DorisParserParserCONSTRAINTS, DorisParserParserCONVERT, DorisParserParserCONVERT_LSC, DorisParserParserCOPY, DorisParserParserCOUNT, DorisParserParserCREATION, DorisParserParserCRON, DorisParserParserCURRENT_CATALOG, DorisParserParserCURRENT_DATE, DorisParserParserCURRENT_TIME, DorisParserParserCURRENT_TIMESTAMP, DorisParserParserCURRENT_USER, DorisParserParserDATA, DorisParserParserDATABASE, DorisParserParserDATE, DorisParserParserDATETIME, DorisParserParserDATETIMEV2, DorisParserParserDATEV2, DorisParserParserDATETIMEV1, DorisParserParserDATEV1, DorisParserParserDAY, DorisParserParserDAYS, DorisParserParserDECIMAL, DorisParserParserDECIMALV2, DorisParserParserDECIMALV3, DorisParserParserDEFERRED, DorisParserParserDEMAND, DorisParserParserDIAGNOSE, DorisParserParserDIAGNOSIS, DorisParserParserDICTIONARIES, DorisParserParserDICTIONARY, DorisParserParserDISTINCTPC, DorisParserParserDISTINCTPCSA, DorisParserParserDO, DorisParserParserDORIS_INTERNAL_TABLE_ID, DorisParserParserDUAL, DorisParserParserDYNAMIC, DorisParserParserE, DorisParserParserENABLE, DorisParserParserENCRYPTKEY, DorisParserParserENCRYPTKEYS, DorisParserParserEND, DorisParserParserENDS, DorisParserParserENGINE, DorisParserParserENGINES, DorisParserParserERRORS, DorisParserParserESCAPE, DorisParserParserEVENTS, DorisParserParserEVERY, DorisParserParserEXCLUDE, DorisParserParserEXISTS, DorisParserParserEXPIRED, DorisParserParserEXTERNAL, DorisParserParserEXTRACT, DorisParserParserFAILED_LOGIN_ATTEMPTS, DorisParserParserFALSE, DorisParserParserFAST, DorisParserParserFEATURE, DorisParserParserFIELDS, DorisParserParserFILE, DorisParserParserFILTER, DorisParserParserFIRST, DorisParserParserFORMAT, DorisParserParserFREE, DorisParserParserFRONTENDS, DorisParserParserFUNCTION, DorisParserParserGENERATED, DorisParserParserGENERIC, DorisParserParserGLOBAL, DorisParserParserGRAPH, DorisParserParserGROUPING, DorisParserParserGROUPS, DorisParserParserHASH, DorisParserParserHASH_MAP, DorisParserParserHDFS, DorisParserParserHELP, DorisParserParserHISTOGRAM, DorisParserParserHLL_UNION, DorisParserParserHOSTNAME, DorisParserParserHOTSPOT, DorisParserParserHOUR, DorisParserParserHOURS, DorisParserParserHUB, DorisParserParserIDENTIFIED, DorisParserParserIF, DorisParserParserIGNORE, DorisParserParserIMMEDIATE, DorisParserParserINCREMENTAL, DorisParserParserINDEXES, DorisParserParserINTERVAL, DorisParserParserINVERTED, DorisParserParserIP_TRIE, DorisParserParserIPV4, DorisParserParserIPV6, DorisParserParserIS_NOT_NULL_PRED, DorisParserParserIS_NULL_PRED, DorisParserParserISNULL, DorisParserParserISOLATION, DorisParserParserJOB, DorisParserParserJOBS, DorisParserParserJSON, DorisParserParserJSONB, DorisParserParserKEY, DorisParserParserLABEL, DorisParserParserLAST, DorisParserParserLDAP, DorisParserParserLDAP_ADMIN_PASSWORD, DorisParserParserLEFT, DorisParserParserLESS, DorisParserParserLEVEL, DorisParserParserLIKE, DorisParserParserLINES, DorisParserParserLINK, DorisParserParserLOCAL, DorisParserParserLOCALTIME, DorisParserParserLOCALTIMESTAMP, DorisParserParserLOCATION, DorisParserParserLOCK, DorisParserParserLOGICAL, DorisParserParserMANUAL, DorisParserParserMAP, DorisParserParserMATCH_ALL, DorisParserParserMATCH_ANY, DorisParserParserMATCH_PHRASE, DorisParserParserMATCH_PHRASE_EDGE, DorisParserParserMATCH_PHRASE_PREFIX, DorisParserParserMATCH_REGEXP, DorisParserParserMATERIALIZED, DorisParserParserMAX, DorisParserParserMEMO, DorisParserParserMERGE, DorisParserParserMIGRATE, DorisParserParserMIGRATIONS, DorisParserParserMIN, DorisParserParserMINUTE, DorisParserParserMINUTES, DorisParserParserMODIFY, DorisParserParserMONTH, DorisParserParserMTMV, DorisParserParserNAME, DorisParserParserNAMES, DorisParserParserNEGATIVE, DorisParserParserNEVER, DorisParserParserNEXT, DorisParserParserNGRAM_BF, DorisParserParserNO, DorisParserParserNON_NULLABLE, DorisParserParserNOT, DorisParserParserNULL, DorisParserParserNULLS, DorisParserParserOF, DorisParserParserOFFSET, DorisParserParserONLY, DorisParserParserOPEN, DorisParserParserOPTIMIZED, DorisParserParserPARAMETER, DorisParserParserPARSED, DorisParserParserPARTITIONS, DorisParserParserPASSWORD, DorisParserParserPASSWORD_EXPIRE, DorisParserParserPASSWORD_HISTORY, DorisParserParserPASSWORD_LOCK_TIME, DorisParserParserPASSWORD_REUSE, DorisParserParserPATH, DorisParserParserPAUSE, DorisParserParserPERCENT, DorisParserParserPERIOD, DorisParserParserPERMISSIVE, DorisParserParserPHYSICAL, DorisParserParserPI, DorisParserParserPLACEHOLDER, DorisParserParserPLAN, DorisParserParserPRIVILEGES, DorisParserParserPROCESS, DorisParserParserPLUGIN, DorisParserParserPLUGINS, DorisParserParserPOLICY, DorisParserParserPROC, DorisParserParserPROCESSLIST, DorisParserParserPROFILE, DorisParserParserPROPERTIES, DorisParserParserPROPERTY, DorisParserParserQUANTILE_STATE, DorisParserParserQUANTILE_UNION, DorisParserParserQUERY, DorisParserParserQUEUED, DorisParserParserQUOTA, DorisParserParserQUALIFY, DorisParserParserQUARTER, DorisParserParserRANDOM, DorisParserParserRECENT, DorisParserParserRECOVER, DorisParserParserRECYCLE, DorisParserParserREFRESH, DorisParserParserREGEXP, DorisParserParserREPEATABLE, DorisParserParserREPLACE, DorisParserParserREPLACE_IF_NOT_NULL, DorisParserParserREPLAYER, DorisParserParserREPOSITORIES, DorisParserParserREPOSITORY, DorisParserParserRESOURCE, DorisParserParserRESOURCES, DorisParserParserRESTORE, DorisParserParserRESTRICTIVE, DorisParserParserRESUME, DorisParserParserRETAIN, DorisParserParserRETENTION, DorisParserParserRETURNS, DorisParserParserREWRITTEN, DorisParserParserRIGHT, DorisParserParserRLIKE, DorisParserParserROLLBACK, DorisParserParserROLLUP, DorisParserParserROUTINE, DorisParserParserS3, DorisParserParserSAMPLE, DorisParserParserSCHEDULE, DorisParserParserSCHEDULER, DorisParserParserSCHEMA, DorisParserParserSECOND, DorisParserParserSERIALIZABLE, DorisParserParserSESSION, DorisParserParserSESSION_USER, DorisParserParserSET_SESSION_VARIABLE, DorisParserParserSHAPE, DorisParserParserSKEW, DorisParserParserSNAPSHOT, DorisParserParserSNAPSHOTS, DorisParserParserSONAME, DorisParserParserSPLIT, DorisParserParserSQL, DorisParserParserSTAGE, DorisParserParserSTAGES, DorisParserParserSTART, DorisParserParserSTARTS, DorisParserParserSTATS, DorisParserParserSTATUS, DorisParserParserSTOP, DorisParserParserSTORAGE, DorisParserParserSTREAM, DorisParserParserSTREAMING, DorisParserParserSTRING, DorisParserParserSTRUCT, DorisParserParserSUM, DorisParserParserTABLES, DorisParserParserTAG, DorisParserParserTASK, DorisParserParserTASKS, DorisParserParserTEMPORARY, DorisParserParserTEXT, DorisParserParserTHAN, DorisParserParserTIME, DorisParserParserTIMESTAMP, DorisParserParserTRANSACTION, DorisParserParserTREE, DorisParserParserTRIGGERS, DorisParserParserTRIM, DorisParserParserTRUE, DorisParserParserTRUNCATE, DorisParserParserTYPE, DorisParserParserTYPES, DorisParserParserUNCOMMITTED, DorisParserParserUNLOCK, DorisParserParserUNSET, DorisParserParserUP, DorisParserParserUSER, DorisParserParserVALUE, DorisParserParserVARCHAR, DorisParserParserVARIABLE, DorisParserParserVARIABLES, DorisParserParserVARIANT, DorisParserParserVAULT, DorisParserParserVAULTS, DorisParserParserVERBOSE, DorisParserParserVERSION, DorisParserParserVIEW, DorisParserParserVIEWS, DorisParserParserWARM, DorisParserParserWARNINGS, DorisParserParserWEEK, DorisParserParserWORK, DorisParserParserYEAR, DorisParserParserPLUS, DorisParserParserSUBTRACT, DorisParserParserASTERISK, DorisParserParserTILDE, DorisParserParserLOGICALNOT, DorisParserParserHINT_START, DorisParserParserHINT_END, DorisParserParserCOMMENT_START, DorisParserParserATSIGN, DorisParserParserDOUBLEATSIGN, DorisParserParserSTRING_LITERAL, DorisParserParserINTEGER_VALUE, DorisParserParserEXPONENT_VALUE, DorisParserParserDECIMAL_VALUE, DorisParserParserIDENTIFIER, DorisParserParserBACKQUOTED_IDENTIFIER:
		{
			p.SetState(5099)
			p.Expression()
		}

	case DorisParserParserDEFAULT:
		{
			p.SetState(5100)
			p.Match(DorisParserParserDEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUpdateAssignmentSeqContext is an interface to support dynamic dispatch.
type IUpdateAssignmentSeqContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_updateAssignment returns the _updateAssignment rule contexts.
	Get_updateAssignment() IUpdateAssignmentContext

	// Set_updateAssignment sets the _updateAssignment rule contexts.
	Set_updateAssignment(IUpdateAssignmentContext)

	// GetAssignments returns the assignments rule context list.
	GetAssignments() []IUpdateAssignmentContext

	// SetAssignments sets the assignments rule context list.
	SetAssignments([]IUpdateAssignmentContext)

	// Getter signatures
	AllUpdateAssignment() []IUpdateAssignmentContext
	UpdateAssignment(i int) IUpdateAssignmentContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsUpdateAssignmentSeqContext differentiates from other interfaces.
	IsUpdateAssignmentSeqContext()
}

type UpdateAssignmentSeqContext struct {
	antlr.BaseParserRuleContext
	parser            antlr.Parser
	_updateAssignment IUpdateAssignmentContext
	assignments       []IUpdateAssignmentContext
}

func NewEmptyUpdateAssignmentSeqContext() *UpdateAssignmentSeqContext {
	var p = new(UpdateAssignmentSeqContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_updateAssignmentSeq
	return p
}

func InitEmptyUpdateAssignmentSeqContext(p *UpdateAssignmentSeqContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_updateAssignmentSeq
}

func (*UpdateAssignmentSeqContext) IsUpdateAssignmentSeqContext() {}

func NewUpdateAssignmentSeqContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UpdateAssignmentSeqContext {
	var p = new(UpdateAssignmentSeqContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_updateAssignmentSeq

	return p
}

func (s *UpdateAssignmentSeqContext) GetParser() antlr.Parser { return s.parser }

func (s *UpdateAssignmentSeqContext) Get_updateAssignment() IUpdateAssignmentContext {
	return s._updateAssignment
}

func (s *UpdateAssignmentSeqContext) Set_updateAssignment(v IUpdateAssignmentContext) {
	s._updateAssignment = v
}

func (s *UpdateAssignmentSeqContext) GetAssignments() []IUpdateAssignmentContext {
	return s.assignments
}

func (s *UpdateAssignmentSeqContext) SetAssignments(v []IUpdateAssignmentContext) { s.assignments = v }

func (s *UpdateAssignmentSeqContext) AllUpdateAssignment() []IUpdateAssignmentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUpdateAssignmentContext); ok {
			len++
		}
	}

	tst := make([]IUpdateAssignmentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUpdateAssignmentContext); ok {
			tst[i] = t.(IUpdateAssignmentContext)
			i++
		}
	}

	return tst
}

func (s *UpdateAssignmentSeqContext) UpdateAssignment(i int) IUpdateAssignmentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpdateAssignmentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpdateAssignmentContext)
}

func (s *UpdateAssignmentSeqContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserCOMMA)
}

func (s *UpdateAssignmentSeqContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOMMA, i)
}

func (s *UpdateAssignmentSeqContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UpdateAssignmentSeqContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UpdateAssignmentSeqContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitUpdateAssignmentSeq(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) UpdateAssignmentSeq() (localctx IUpdateAssignmentSeqContext) {
	localctx = NewUpdateAssignmentSeqContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 288, DorisParserParserRULE_updateAssignmentSeq)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5103)

		var _x = p.UpdateAssignment()

		localctx.(*UpdateAssignmentSeqContext)._updateAssignment = _x
	}
	localctx.(*UpdateAssignmentSeqContext).assignments = append(localctx.(*UpdateAssignmentSeqContext).assignments, localctx.(*UpdateAssignmentSeqContext)._updateAssignment)
	p.SetState(5108)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisParserParserCOMMA {
		{
			p.SetState(5104)
			p.Match(DorisParserParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5105)

			var _x = p.UpdateAssignment()

			localctx.(*UpdateAssignmentSeqContext)._updateAssignment = _x
		}
		localctx.(*UpdateAssignmentSeqContext).assignments = append(localctx.(*UpdateAssignmentSeqContext).assignments, localctx.(*UpdateAssignmentSeqContext)._updateAssignment)

		p.SetState(5110)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILateralViewContext is an interface to support dynamic dispatch.
type ILateralViewContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetFunctionName returns the functionName rule contexts.
	GetFunctionName() IIdentifierContext

	// GetTableName returns the tableName rule contexts.
	GetTableName() IIdentifierContext

	// Get_identifier returns the _identifier rule contexts.
	Get_identifier() IIdentifierContext

	// SetFunctionName sets the functionName rule contexts.
	SetFunctionName(IIdentifierContext)

	// SetTableName sets the tableName rule contexts.
	SetTableName(IIdentifierContext)

	// Set_identifier sets the _identifier rule contexts.
	Set_identifier(IIdentifierContext)

	// GetColumnNames returns the columnNames rule context list.
	GetColumnNames() []IIdentifierContext

	// SetColumnNames sets the columnNames rule context list.
	SetColumnNames([]IIdentifierContext)

	// Getter signatures
	LATERAL() antlr.TerminalNode
	VIEW() antlr.TerminalNode
	LEFT_PAREN() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode
	AS() antlr.TerminalNode
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsLateralViewContext differentiates from other interfaces.
	IsLateralViewContext()
}

type LateralViewContext struct {
	antlr.BaseParserRuleContext
	parser       antlr.Parser
	functionName IIdentifierContext
	tableName    IIdentifierContext
	_identifier  IIdentifierContext
	columnNames  []IIdentifierContext
}

func NewEmptyLateralViewContext() *LateralViewContext {
	var p = new(LateralViewContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_lateralView
	return p
}

func InitEmptyLateralViewContext(p *LateralViewContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_lateralView
}

func (*LateralViewContext) IsLateralViewContext() {}

func NewLateralViewContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LateralViewContext {
	var p = new(LateralViewContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_lateralView

	return p
}

func (s *LateralViewContext) GetParser() antlr.Parser { return s.parser }

func (s *LateralViewContext) GetFunctionName() IIdentifierContext { return s.functionName }

func (s *LateralViewContext) GetTableName() IIdentifierContext { return s.tableName }

func (s *LateralViewContext) Get_identifier() IIdentifierContext { return s._identifier }

func (s *LateralViewContext) SetFunctionName(v IIdentifierContext) { s.functionName = v }

func (s *LateralViewContext) SetTableName(v IIdentifierContext) { s.tableName = v }

func (s *LateralViewContext) Set_identifier(v IIdentifierContext) { s._identifier = v }

func (s *LateralViewContext) GetColumnNames() []IIdentifierContext { return s.columnNames }

func (s *LateralViewContext) SetColumnNames(v []IIdentifierContext) { s.columnNames = v }

func (s *LateralViewContext) LATERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLATERAL, 0)
}

func (s *LateralViewContext) VIEW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserVIEW, 0)
}

func (s *LateralViewContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLEFT_PAREN, 0)
}

func (s *LateralViewContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRIGHT_PAREN, 0)
}

func (s *LateralViewContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserAS, 0)
}

func (s *LateralViewContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *LateralViewContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *LateralViewContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *LateralViewContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *LateralViewContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserCOMMA)
}

func (s *LateralViewContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOMMA, i)
}

func (s *LateralViewContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LateralViewContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LateralViewContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitLateralView(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) LateralView() (localctx ILateralViewContext) {
	localctx = NewLateralViewContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 290, DorisParserParserRULE_lateralView)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5111)
		p.Match(DorisParserParserLATERAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5112)
		p.Match(DorisParserParserVIEW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5113)

		var _x = p.Identifier()

		localctx.(*LateralViewContext).functionName = _x
	}
	{
		p.SetState(5114)
		p.Match(DorisParserParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5123)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-2305884869834611068) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&4610552282352573437) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-9079382760121755163) != 0) || ((int64((_la-192)) & ^0x3f) == 0 && ((int64(1)<<(_la-192))&4321098383830537129) != 0) || ((int64((_la-256)) & ^0x3f) == 0 && ((int64(1)<<(_la-256))&-5206443760946300951) != 0) || ((int64((_la-320)) & ^0x3f) == 0 && ((int64(1)<<(_la-320))&-4187784802352497917) != 0) || ((int64((_la-384)) & ^0x3f) == 0 && ((int64(1)<<(_la-384))&9222796779122712571) != 0) || ((int64((_la-452)) & ^0x3f) == 0 && ((int64(1)<<(_la-452))&2449945648132536049) != 0) || ((int64((_la-517)) & ^0x3f) == 0 && ((int64(1)<<(_la-517))&236487517953) != 0) {
		{
			p.SetState(5115)
			p.Expression()
		}
		p.SetState(5120)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserParserCOMMA {
			{
				p.SetState(5116)
				p.Match(DorisParserParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5117)
				p.Expression()
			}

			p.SetState(5122)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(5125)
		p.Match(DorisParserParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5126)

		var _x = p.Identifier()

		localctx.(*LateralViewContext).tableName = _x
	}
	{
		p.SetState(5127)
		p.Match(DorisParserParserAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5128)

		var _x = p.Identifier()

		localctx.(*LateralViewContext)._identifier = _x
	}
	localctx.(*LateralViewContext).columnNames = append(localctx.(*LateralViewContext).columnNames, localctx.(*LateralViewContext)._identifier)
	p.SetState(5133)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 730, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(5129)
				p.Match(DorisParserParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5130)

				var _x = p.Identifier()

				localctx.(*LateralViewContext)._identifier = _x
			}
			localctx.(*LateralViewContext).columnNames = append(localctx.(*LateralViewContext).columnNames, localctx.(*LateralViewContext)._identifier)

		}
		p.SetState(5135)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 730, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQueryOrganizationContext is an interface to support dynamic dispatch.
type IQueryOrganizationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SortClause() ISortClauseContext
	LimitClause() ILimitClauseContext

	// IsQueryOrganizationContext differentiates from other interfaces.
	IsQueryOrganizationContext()
}

type QueryOrganizationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQueryOrganizationContext() *QueryOrganizationContext {
	var p = new(QueryOrganizationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_queryOrganization
	return p
}

func InitEmptyQueryOrganizationContext(p *QueryOrganizationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_queryOrganization
}

func (*QueryOrganizationContext) IsQueryOrganizationContext() {}

func NewQueryOrganizationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryOrganizationContext {
	var p = new(QueryOrganizationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_queryOrganization

	return p
}

func (s *QueryOrganizationContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryOrganizationContext) SortClause() ISortClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortClauseContext)
}

func (s *QueryOrganizationContext) LimitClause() ILimitClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitClauseContext)
}

func (s *QueryOrganizationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryOrganizationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QueryOrganizationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitQueryOrganization(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) QueryOrganization() (localctx IQueryOrganizationContext) {
	localctx = NewQueryOrganizationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 292, DorisParserParserRULE_queryOrganization)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(5137)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 731, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5136)
			p.SortClause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(5140)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 732, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5139)
			p.LimitClause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISortClauseContext is an interface to support dynamic dispatch.
type ISortClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ORDER() antlr.TerminalNode
	BY() antlr.TerminalNode
	AllSortItem() []ISortItemContext
	SortItem(i int) ISortItemContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsSortClauseContext differentiates from other interfaces.
	IsSortClauseContext()
}

type SortClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySortClauseContext() *SortClauseContext {
	var p = new(SortClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_sortClause
	return p
}

func InitEmptySortClauseContext(p *SortClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_sortClause
}

func (*SortClauseContext) IsSortClauseContext() {}

func NewSortClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SortClauseContext {
	var p = new(SortClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_sortClause

	return p
}

func (s *SortClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *SortClauseContext) ORDER() antlr.TerminalNode {
	return s.GetToken(DorisParserParserORDER, 0)
}

func (s *SortClauseContext) BY() antlr.TerminalNode {
	return s.GetToken(DorisParserParserBY, 0)
}

func (s *SortClauseContext) AllSortItem() []ISortItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISortItemContext); ok {
			len++
		}
	}

	tst := make([]ISortItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISortItemContext); ok {
			tst[i] = t.(ISortItemContext)
			i++
		}
	}

	return tst
}

func (s *SortClauseContext) SortItem(i int) ISortItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortItemContext)
}

func (s *SortClauseContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserCOMMA)
}

func (s *SortClauseContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOMMA, i)
}

func (s *SortClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SortClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SortClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitSortClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) SortClause() (localctx ISortClauseContext) {
	localctx = NewSortClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 294, DorisParserParserRULE_sortClause)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5142)
		p.Match(DorisParserParserORDER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5143)
		p.Match(DorisParserParserBY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5144)
		p.SortItem()
	}
	p.SetState(5149)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 733, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(5145)
				p.Match(DorisParserParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5146)
				p.SortItem()
			}

		}
		p.SetState(5151)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 733, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISortItemContext is an interface to support dynamic dispatch.
type ISortItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOrdering returns the ordering token.
	GetOrdering() antlr.Token

	// SetOrdering sets the ordering token.
	SetOrdering(antlr.Token)

	// Getter signatures
	Expression() IExpressionContext
	NULLS() antlr.TerminalNode
	FIRST() antlr.TerminalNode
	LAST() antlr.TerminalNode
	ASC() antlr.TerminalNode
	DESC() antlr.TerminalNode

	// IsSortItemContext differentiates from other interfaces.
	IsSortItemContext()
}

type SortItemContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	ordering antlr.Token
}

func NewEmptySortItemContext() *SortItemContext {
	var p = new(SortItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_sortItem
	return p
}

func InitEmptySortItemContext(p *SortItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_sortItem
}

func (*SortItemContext) IsSortItemContext() {}

func NewSortItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SortItemContext {
	var p = new(SortItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_sortItem

	return p
}

func (s *SortItemContext) GetParser() antlr.Parser { return s.parser }

func (s *SortItemContext) GetOrdering() antlr.Token { return s.ordering }

func (s *SortItemContext) SetOrdering(v antlr.Token) { s.ordering = v }

func (s *SortItemContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SortItemContext) NULLS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserNULLS, 0)
}

func (s *SortItemContext) FIRST() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFIRST, 0)
}

func (s *SortItemContext) LAST() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLAST, 0)
}

func (s *SortItemContext) ASC() antlr.TerminalNode {
	return s.GetToken(DorisParserParserASC, 0)
}

func (s *SortItemContext) DESC() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDESC, 0)
}

func (s *SortItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SortItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SortItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitSortItem(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) SortItem() (localctx ISortItemContext) {
	localctx = NewSortItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 296, DorisParserParserRULE_sortItem)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5152)
		p.Expression()
	}
	p.SetState(5154)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 734, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5153)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*SortItemContext).ordering = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserParserASC || _la == DorisParserParserDESC) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*SortItemContext).ordering = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(5158)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 735, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5156)
			p.Match(DorisParserParserNULLS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5157)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserParserFIRST || _la == DorisParserParserLAST) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILimitClauseContext is an interface to support dynamic dispatch.
type ILimitClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetLimit returns the limit token.
	GetLimit() antlr.Token

	// GetOffset returns the offset token.
	GetOffset() antlr.Token

	// SetLimit sets the limit token.
	SetLimit(antlr.Token)

	// SetOffset sets the offset token.
	SetOffset(antlr.Token)

	// Getter signatures
	LIMIT() antlr.TerminalNode
	AllINTEGER_VALUE() []antlr.TerminalNode
	INTEGER_VALUE(i int) antlr.TerminalNode
	OFFSET() antlr.TerminalNode
	COMMA() antlr.TerminalNode

	// IsLimitClauseContext differentiates from other interfaces.
	IsLimitClauseContext()
}

type LimitClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	limit  antlr.Token
	offset antlr.Token
}

func NewEmptyLimitClauseContext() *LimitClauseContext {
	var p = new(LimitClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_limitClause
	return p
}

func InitEmptyLimitClauseContext(p *LimitClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_limitClause
}

func (*LimitClauseContext) IsLimitClauseContext() {}

func NewLimitClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LimitClauseContext {
	var p = new(LimitClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_limitClause

	return p
}

func (s *LimitClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *LimitClauseContext) GetLimit() antlr.Token { return s.limit }

func (s *LimitClauseContext) GetOffset() antlr.Token { return s.offset }

func (s *LimitClauseContext) SetLimit(v antlr.Token) { s.limit = v }

func (s *LimitClauseContext) SetOffset(v antlr.Token) { s.offset = v }

func (s *LimitClauseContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLIMIT, 0)
}

func (s *LimitClauseContext) AllINTEGER_VALUE() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserINTEGER_VALUE)
}

func (s *LimitClauseContext) INTEGER_VALUE(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserINTEGER_VALUE, i)
}

func (s *LimitClauseContext) OFFSET() antlr.TerminalNode {
	return s.GetToken(DorisParserParserOFFSET, 0)
}

func (s *LimitClauseContext) COMMA() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOMMA, 0)
}

func (s *LimitClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LimitClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LimitClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitLimitClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) LimitClause() (localctx ILimitClauseContext) {
	localctx = NewLimitClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 298, DorisParserParserRULE_limitClause)
	p.SetState(5170)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 736, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5160)
			p.Match(DorisParserParserLIMIT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5161)

			var _m = p.Match(DorisParserParserINTEGER_VALUE)

			localctx.(*LimitClauseContext).limit = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5162)
			p.Match(DorisParserParserLIMIT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5163)

			var _m = p.Match(DorisParserParserINTEGER_VALUE)

			localctx.(*LimitClauseContext).limit = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5164)
			p.Match(DorisParserParserOFFSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5165)

			var _m = p.Match(DorisParserParserINTEGER_VALUE)

			localctx.(*LimitClauseContext).offset = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5166)
			p.Match(DorisParserParserLIMIT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5167)

			var _m = p.Match(DorisParserParserINTEGER_VALUE)

			localctx.(*LimitClauseContext).offset = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5168)
			p.Match(DorisParserParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5169)

			var _m = p.Match(DorisParserParserINTEGER_VALUE)

			localctx.(*LimitClauseContext).limit = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionClauseContext is an interface to support dynamic dispatch.
type IPartitionClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PARTITION() antlr.TerminalNode
	BY() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsPartitionClauseContext differentiates from other interfaces.
	IsPartitionClauseContext()
}

type PartitionClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionClauseContext() *PartitionClauseContext {
	var p = new(PartitionClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_partitionClause
	return p
}

func InitEmptyPartitionClauseContext(p *PartitionClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_partitionClause
}

func (*PartitionClauseContext) IsPartitionClauseContext() {}

func NewPartitionClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionClauseContext {
	var p = new(PartitionClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_partitionClause

	return p
}

func (s *PartitionClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionClauseContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(DorisParserParserPARTITION, 0)
}

func (s *PartitionClauseContext) BY() antlr.TerminalNode {
	return s.GetToken(DorisParserParserBY, 0)
}

func (s *PartitionClauseContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *PartitionClauseContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PartitionClauseContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserCOMMA)
}

func (s *PartitionClauseContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOMMA, i)
}

func (s *PartitionClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitPartitionClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) PartitionClause() (localctx IPartitionClauseContext) {
	localctx = NewPartitionClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 300, DorisParserParserRULE_partitionClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5172)
		p.Match(DorisParserParserPARTITION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5173)
		p.Match(DorisParserParserBY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5174)
		p.Expression()
	}
	p.SetState(5179)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisParserParserCOMMA {
		{
			p.SetState(5175)
			p.Match(DorisParserParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5176)
			p.Expression()
		}

		p.SetState(5181)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJoinTypeContext is an interface to support dynamic dispatch.
type IJoinTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INNER() antlr.TerminalNode
	CROSS() antlr.TerminalNode
	LEFT() antlr.TerminalNode
	OUTER() antlr.TerminalNode
	RIGHT() antlr.TerminalNode
	FULL() antlr.TerminalNode
	SEMI() antlr.TerminalNode
	ANTI() antlr.TerminalNode

	// IsJoinTypeContext differentiates from other interfaces.
	IsJoinTypeContext()
}

type JoinTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJoinTypeContext() *JoinTypeContext {
	var p = new(JoinTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_joinType
	return p
}

func InitEmptyJoinTypeContext(p *JoinTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_joinType
}

func (*JoinTypeContext) IsJoinTypeContext() {}

func NewJoinTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JoinTypeContext {
	var p = new(JoinTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_joinType

	return p
}

func (s *JoinTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *JoinTypeContext) INNER() antlr.TerminalNode {
	return s.GetToken(DorisParserParserINNER, 0)
}

func (s *JoinTypeContext) CROSS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCROSS, 0)
}

func (s *JoinTypeContext) LEFT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLEFT, 0)
}

func (s *JoinTypeContext) OUTER() antlr.TerminalNode {
	return s.GetToken(DorisParserParserOUTER, 0)
}

func (s *JoinTypeContext) RIGHT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRIGHT, 0)
}

func (s *JoinTypeContext) FULL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFULL, 0)
}

func (s *JoinTypeContext) SEMI() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSEMI, 0)
}

func (s *JoinTypeContext) ANTI() antlr.TerminalNode {
	return s.GetToken(DorisParserParserANTI, 0)
}

func (s *JoinTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JoinTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitJoinType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) JoinType() (localctx IJoinTypeContext) {
	localctx = NewJoinTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 302, DorisParserParserRULE_joinType)
	var _la int

	p.SetState(5206)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 742, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(5183)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserINNER {
			{
				p.SetState(5182)
				p.Match(DorisParserParserINNER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5185)
			p.Match(DorisParserParserCROSS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5186)
			p.Match(DorisParserParserLEFT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5188)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserOUTER {
			{
				p.SetState(5187)
				p.Match(DorisParserParserOUTER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5190)
			p.Match(DorisParserParserRIGHT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5192)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserOUTER {
			{
				p.SetState(5191)
				p.Match(DorisParserParserOUTER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(5194)
			p.Match(DorisParserParserFULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5196)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserOUTER {
			{
				p.SetState(5195)
				p.Match(DorisParserParserOUTER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(5198)
			p.Match(DorisParserParserLEFT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5199)
			p.Match(DorisParserParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(5200)
			p.Match(DorisParserParserRIGHT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5201)
			p.Match(DorisParserParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(5202)
			p.Match(DorisParserParserLEFT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5203)
			p.Match(DorisParserParserANTI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(5204)
			p.Match(DorisParserParserRIGHT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5205)
			p.Match(DorisParserParserANTI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJoinCriteriaContext is an interface to support dynamic dispatch.
type IJoinCriteriaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ON() antlr.TerminalNode
	BooleanExpression() IBooleanExpressionContext
	USING() antlr.TerminalNode
	IdentifierList() IIdentifierListContext

	// IsJoinCriteriaContext differentiates from other interfaces.
	IsJoinCriteriaContext()
}

type JoinCriteriaContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJoinCriteriaContext() *JoinCriteriaContext {
	var p = new(JoinCriteriaContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_joinCriteria
	return p
}

func InitEmptyJoinCriteriaContext(p *JoinCriteriaContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_joinCriteria
}

func (*JoinCriteriaContext) IsJoinCriteriaContext() {}

func NewJoinCriteriaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JoinCriteriaContext {
	var p = new(JoinCriteriaContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_joinCriteria

	return p
}

func (s *JoinCriteriaContext) GetParser() antlr.Parser { return s.parser }

func (s *JoinCriteriaContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisParserParserON, 0)
}

func (s *JoinCriteriaContext) BooleanExpression() IBooleanExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *JoinCriteriaContext) USING() antlr.TerminalNode {
	return s.GetToken(DorisParserParserUSING, 0)
}

func (s *JoinCriteriaContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *JoinCriteriaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinCriteriaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JoinCriteriaContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitJoinCriteria(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) JoinCriteria() (localctx IJoinCriteriaContext) {
	localctx = NewJoinCriteriaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 304, DorisParserParserRULE_joinCriteria)
	p.SetState(5212)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserParserON:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5208)
			p.Match(DorisParserParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5209)
			p.booleanExpression(0)
		}

	case DorisParserParserUSING:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5210)
			p.Match(DorisParserParserUSING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5211)
			p.IdentifierList()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierListContext is an interface to support dynamic dispatch.
type IIdentifierListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LEFT_PAREN() antlr.TerminalNode
	IdentifierSeq() IIdentifierSeqContext
	RIGHT_PAREN() antlr.TerminalNode

	// IsIdentifierListContext differentiates from other interfaces.
	IsIdentifierListContext()
}

type IdentifierListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierListContext() *IdentifierListContext {
	var p = new(IdentifierListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_identifierList
	return p
}

func InitEmptyIdentifierListContext(p *IdentifierListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_identifierList
}

func (*IdentifierListContext) IsIdentifierListContext() {}

func NewIdentifierListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierListContext {
	var p = new(IdentifierListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_identifierList

	return p
}

func (s *IdentifierListContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierListContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLEFT_PAREN, 0)
}

func (s *IdentifierListContext) IdentifierSeq() IIdentifierSeqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierSeqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierSeqContext)
}

func (s *IdentifierListContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRIGHT_PAREN, 0)
}

func (s *IdentifierListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitIdentifierList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) IdentifierList() (localctx IIdentifierListContext) {
	localctx = NewIdentifierListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 306, DorisParserParserRULE_identifierList)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5214)
		p.Match(DorisParserParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5215)
		p.IdentifierSeq()
	}
	{
		p.SetState(5216)
		p.Match(DorisParserParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierSeqContext is an interface to support dynamic dispatch.
type IIdentifierSeqContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_errorCapturingIdentifier returns the _errorCapturingIdentifier rule contexts.
	Get_errorCapturingIdentifier() IErrorCapturingIdentifierContext

	// Set_errorCapturingIdentifier sets the _errorCapturingIdentifier rule contexts.
	Set_errorCapturingIdentifier(IErrorCapturingIdentifierContext)

	// GetIdent returns the ident rule context list.
	GetIdent() []IErrorCapturingIdentifierContext

	// SetIdent sets the ident rule context list.
	SetIdent([]IErrorCapturingIdentifierContext)

	// Getter signatures
	AllErrorCapturingIdentifier() []IErrorCapturingIdentifierContext
	ErrorCapturingIdentifier(i int) IErrorCapturingIdentifierContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsIdentifierSeqContext differentiates from other interfaces.
	IsIdentifierSeqContext()
}

type IdentifierSeqContext struct {
	antlr.BaseParserRuleContext
	parser                    antlr.Parser
	_errorCapturingIdentifier IErrorCapturingIdentifierContext
	ident                     []IErrorCapturingIdentifierContext
}

func NewEmptyIdentifierSeqContext() *IdentifierSeqContext {
	var p = new(IdentifierSeqContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_identifierSeq
	return p
}

func InitEmptyIdentifierSeqContext(p *IdentifierSeqContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_identifierSeq
}

func (*IdentifierSeqContext) IsIdentifierSeqContext() {}

func NewIdentifierSeqContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierSeqContext {
	var p = new(IdentifierSeqContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_identifierSeq

	return p
}

func (s *IdentifierSeqContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierSeqContext) Get_errorCapturingIdentifier() IErrorCapturingIdentifierContext {
	return s._errorCapturingIdentifier
}

func (s *IdentifierSeqContext) Set_errorCapturingIdentifier(v IErrorCapturingIdentifierContext) {
	s._errorCapturingIdentifier = v
}

func (s *IdentifierSeqContext) GetIdent() []IErrorCapturingIdentifierContext { return s.ident }

func (s *IdentifierSeqContext) SetIdent(v []IErrorCapturingIdentifierContext) { s.ident = v }

func (s *IdentifierSeqContext) AllErrorCapturingIdentifier() []IErrorCapturingIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IErrorCapturingIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IErrorCapturingIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IErrorCapturingIdentifierContext); ok {
			tst[i] = t.(IErrorCapturingIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *IdentifierSeqContext) ErrorCapturingIdentifier(i int) IErrorCapturingIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IErrorCapturingIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IErrorCapturingIdentifierContext)
}

func (s *IdentifierSeqContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserCOMMA)
}

func (s *IdentifierSeqContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOMMA, i)
}

func (s *IdentifierSeqContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierSeqContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierSeqContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitIdentifierSeq(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) IdentifierSeq() (localctx IIdentifierSeqContext) {
	localctx = NewIdentifierSeqContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 308, DorisParserParserRULE_identifierSeq)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5218)

		var _x = p.ErrorCapturingIdentifier()

		localctx.(*IdentifierSeqContext)._errorCapturingIdentifier = _x
	}
	localctx.(*IdentifierSeqContext).ident = append(localctx.(*IdentifierSeqContext).ident, localctx.(*IdentifierSeqContext)._errorCapturingIdentifier)
	p.SetState(5223)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisParserParserCOMMA {
		{
			p.SetState(5219)
			p.Match(DorisParserParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5220)

			var _x = p.ErrorCapturingIdentifier()

			localctx.(*IdentifierSeqContext)._errorCapturingIdentifier = _x
		}
		localctx.(*IdentifierSeqContext).ident = append(localctx.(*IdentifierSeqContext).ident, localctx.(*IdentifierSeqContext)._errorCapturingIdentifier)

		p.SetState(5225)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOptScanParamsContext is an interface to support dynamic dispatch.
type IOptScanParamsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetFuncName returns the funcName rule contexts.
	GetFuncName() IIdentifierContext

	// GetMapParams returns the mapParams rule contexts.
	GetMapParams() IPropertyItemListContext

	// GetListParams returns the listParams rule contexts.
	GetListParams() IIdentifierSeqContext

	// SetFuncName sets the funcName rule contexts.
	SetFuncName(IIdentifierContext)

	// SetMapParams sets the mapParams rule contexts.
	SetMapParams(IPropertyItemListContext)

	// SetListParams sets the listParams rule contexts.
	SetListParams(IIdentifierSeqContext)

	// Getter signatures
	ATSIGN() antlr.TerminalNode
	LEFT_PAREN() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode
	Identifier() IIdentifierContext
	PropertyItemList() IPropertyItemListContext
	IdentifierSeq() IIdentifierSeqContext

	// IsOptScanParamsContext differentiates from other interfaces.
	IsOptScanParamsContext()
}

type OptScanParamsContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	funcName   IIdentifierContext
	mapParams  IPropertyItemListContext
	listParams IIdentifierSeqContext
}

func NewEmptyOptScanParamsContext() *OptScanParamsContext {
	var p = new(OptScanParamsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_optScanParams
	return p
}

func InitEmptyOptScanParamsContext(p *OptScanParamsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_optScanParams
}

func (*OptScanParamsContext) IsOptScanParamsContext() {}

func NewOptScanParamsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OptScanParamsContext {
	var p = new(OptScanParamsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_optScanParams

	return p
}

func (s *OptScanParamsContext) GetParser() antlr.Parser { return s.parser }

func (s *OptScanParamsContext) GetFuncName() IIdentifierContext { return s.funcName }

func (s *OptScanParamsContext) GetMapParams() IPropertyItemListContext { return s.mapParams }

func (s *OptScanParamsContext) GetListParams() IIdentifierSeqContext { return s.listParams }

func (s *OptScanParamsContext) SetFuncName(v IIdentifierContext) { s.funcName = v }

func (s *OptScanParamsContext) SetMapParams(v IPropertyItemListContext) { s.mapParams = v }

func (s *OptScanParamsContext) SetListParams(v IIdentifierSeqContext) { s.listParams = v }

func (s *OptScanParamsContext) ATSIGN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserATSIGN, 0)
}

func (s *OptScanParamsContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLEFT_PAREN, 0)
}

func (s *OptScanParamsContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRIGHT_PAREN, 0)
}

func (s *OptScanParamsContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *OptScanParamsContext) PropertyItemList() IPropertyItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyItemListContext)
}

func (s *OptScanParamsContext) IdentifierSeq() IIdentifierSeqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierSeqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierSeqContext)
}

func (s *OptScanParamsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OptScanParamsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OptScanParamsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitOptScanParams(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) OptScanParams() (localctx IOptScanParamsContext) {
	localctx = NewOptScanParamsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 310, DorisParserParserRULE_optScanParams)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5226)
		p.Match(DorisParserParserATSIGN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5227)

		var _x = p.Identifier()

		localctx.(*OptScanParamsContext).funcName = _x
	}
	{
		p.SetState(5228)
		p.Match(DorisParserParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5231)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 745, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5229)

			var _x = p.PropertyItemList()

			localctx.(*OptScanParamsContext).mapParams = _x
		}

	} else if p.HasError() { // JIM
		goto errorExit
	} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 745, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(5230)

			var _x = p.IdentifierSeq()

			localctx.(*OptScanParamsContext).listParams = _x
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(5233)
		p.Match(DorisParserParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRelationPrimaryContext is an interface to support dynamic dispatch.
type IRelationPrimaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsRelationPrimaryContext differentiates from other interfaces.
	IsRelationPrimaryContext()
}

type RelationPrimaryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationPrimaryContext() *RelationPrimaryContext {
	var p = new(RelationPrimaryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_relationPrimary
	return p
}

func InitEmptyRelationPrimaryContext(p *RelationPrimaryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_relationPrimary
}

func (*RelationPrimaryContext) IsRelationPrimaryContext() {}

func NewRelationPrimaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationPrimaryContext {
	var p = new(RelationPrimaryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_relationPrimary

	return p
}

func (s *RelationPrimaryContext) GetParser() antlr.Parser { return s.parser }

func (s *RelationPrimaryContext) CopyAll(ctx *RelationPrimaryContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *RelationPrimaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationPrimaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type TableValuedFunctionContext struct {
	RelationPrimaryContext
	tvfName    IIdentifierContext
	properties IPropertyItemListContext
}

func NewTableValuedFunctionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableValuedFunctionContext {
	var p = new(TableValuedFunctionContext)

	InitEmptyRelationPrimaryContext(&p.RelationPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*RelationPrimaryContext))

	return p
}

func (s *TableValuedFunctionContext) GetTvfName() IIdentifierContext { return s.tvfName }

func (s *TableValuedFunctionContext) GetProperties() IPropertyItemListContext { return s.properties }

func (s *TableValuedFunctionContext) SetTvfName(v IIdentifierContext) { s.tvfName = v }

func (s *TableValuedFunctionContext) SetProperties(v IPropertyItemListContext) { s.properties = v }

func (s *TableValuedFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableValuedFunctionContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLEFT_PAREN, 0)
}

func (s *TableValuedFunctionContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRIGHT_PAREN, 0)
}

func (s *TableValuedFunctionContext) TableAlias() ITableAliasContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableAliasContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableAliasContext)
}

func (s *TableValuedFunctionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TableValuedFunctionContext) PropertyItemList() IPropertyItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyItemListContext)
}

func (s *TableValuedFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitTableValuedFunction(s)

	default:
		return t.VisitChildren(s)
	}
}

type RelationListContext struct {
	RelationPrimaryContext
}

func NewRelationListContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RelationListContext {
	var p = new(RelationListContext)

	InitEmptyRelationPrimaryContext(&p.RelationPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*RelationPrimaryContext))

	return p
}

func (s *RelationListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationListContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLEFT_PAREN, 0)
}

func (s *RelationListContext) Relations() IRelationsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationsContext)
}

func (s *RelationListContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRIGHT_PAREN, 0)
}

func (s *RelationListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitRelationList(s)

	default:
		return t.VisitChildren(s)
	}
}

type AliasedQueryContext struct {
	RelationPrimaryContext
}

func NewAliasedQueryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AliasedQueryContext {
	var p = new(AliasedQueryContext)

	InitEmptyRelationPrimaryContext(&p.RelationPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*RelationPrimaryContext))

	return p
}

func (s *AliasedQueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AliasedQueryContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLEFT_PAREN, 0)
}

func (s *AliasedQueryContext) Query() IQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *AliasedQueryContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRIGHT_PAREN, 0)
}

func (s *AliasedQueryContext) TableAlias() ITableAliasContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableAliasContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableAliasContext)
}

func (s *AliasedQueryContext) AllLateralView() []ILateralViewContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILateralViewContext); ok {
			len++
		}
	}

	tst := make([]ILateralViewContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILateralViewContext); ok {
			tst[i] = t.(ILateralViewContext)
			i++
		}
	}

	return tst
}

func (s *AliasedQueryContext) LateralView(i int) ILateralViewContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILateralViewContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILateralViewContext)
}

func (s *AliasedQueryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitAliasedQuery(s)

	default:
		return t.VisitChildren(s)
	}
}

type TableNameContext struct {
	RelationPrimaryContext
}

func NewTableNameContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableNameContext {
	var p = new(TableNameContext)

	InitEmptyRelationPrimaryContext(&p.RelationPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*RelationPrimaryContext))

	return p
}

func (s *TableNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableNameContext) MultipartIdentifier() IMultipartIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipartIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipartIdentifierContext)
}

func (s *TableNameContext) TableAlias() ITableAliasContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableAliasContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableAliasContext)
}

func (s *TableNameContext) OptScanParams() IOptScanParamsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOptScanParamsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOptScanParamsContext)
}

func (s *TableNameContext) MaterializedViewName() IMaterializedViewNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMaterializedViewNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMaterializedViewNameContext)
}

func (s *TableNameContext) TableSnapshot() ITableSnapshotContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableSnapshotContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableSnapshotContext)
}

func (s *TableNameContext) SpecifiedPartition() ISpecifiedPartitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISpecifiedPartitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISpecifiedPartitionContext)
}

func (s *TableNameContext) TabletList() ITabletListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITabletListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITabletListContext)
}

func (s *TableNameContext) Sample() ISampleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISampleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISampleContext)
}

func (s *TableNameContext) RelationHint() IRelationHintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationHintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationHintContext)
}

func (s *TableNameContext) AllLateralView() []ILateralViewContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILateralViewContext); ok {
			len++
		}
	}

	tst := make([]ILateralViewContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILateralViewContext); ok {
			tst[i] = t.(ILateralViewContext)
			i++
		}
	}

	return tst
}

func (s *TableNameContext) LateralView(i int) ILateralViewContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILateralViewContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILateralViewContext)
}

func (s *TableNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitTableName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) RelationPrimary() (localctx IRelationPrimaryContext) {
	localctx = NewRelationPrimaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 312, DorisParserParserRULE_relationPrimary)
	var _la int

	var _alt int

	p.SetState(5286)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 756, p.GetParserRuleContext()) {
	case 1:
		localctx = NewTableNameContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5235)
			p.MultipartIdentifier()
		}
		p.SetState(5237)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 746, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5236)
				p.OptScanParams()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(5240)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 747, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5239)
				p.MaterializedViewName()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(5243)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 748, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5242)
				p.TableSnapshot()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(5246)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 749, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5245)
				p.SpecifiedPartition()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(5249)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 750, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5248)
				p.TabletList()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(5251)
			p.TableAlias()
		}
		p.SetState(5253)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 751, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5252)
				p.Sample()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(5256)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 752, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5255)
				p.RelationHint()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(5261)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 753, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(5258)
					p.LateralView()
				}

			}
			p.SetState(5263)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 753, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case 2:
		localctx = NewAliasedQueryContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5264)
			p.Match(DorisParserParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5265)
			p.Query()
		}
		{
			p.SetState(5266)
			p.Match(DorisParserParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5267)
			p.TableAlias()
		}
		p.SetState(5271)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 754, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(5268)
					p.LateralView()
				}

			}
			p.SetState(5273)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 754, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case 3:
		localctx = NewTableValuedFunctionContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5274)

			var _x = p.Identifier()

			localctx.(*TableValuedFunctionContext).tvfName = _x
		}
		{
			p.SetState(5275)
			p.Match(DorisParserParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5277)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-2305884869834627456) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&4609989332399152113) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-9079668633144976923) != 0) || ((int64((_la-192)) & ^0x3f) == 0 && ((int64(1)<<(_la-192))&2015220189171012521) != 0) || ((int64((_la-256)) & ^0x3f) == 0 && ((int64(1)<<(_la-256))&-5278501354984230039) != 0) || ((int64((_la-320)) & ^0x3f) == 0 && ((int64(1)<<(_la-320))&-4476015178504209661) != 0) || ((int64((_la-384)) & ^0x3f) == 0 && ((int64(1)<<(_la-384))&9222796779122679803) != 0) || ((int64((_la-452)) & ^0x3f) == 0 && ((int64(1)<<(_la-452))&2449945648128341745) != 0) || ((int64((_la-517)) & ^0x3f) == 0 && ((int64(1)<<(_la-517))&236386779649) != 0) {
			{
				p.SetState(5276)

				var _x = p.PropertyItemList()

				localctx.(*TableValuedFunctionContext).properties = _x
			}

		}
		{
			p.SetState(5279)
			p.Match(DorisParserParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5280)
			p.TableAlias()
		}

	case 4:
		localctx = NewRelationListContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5282)
			p.Match(DorisParserParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5283)
			p.Relations()
		}
		{
			p.SetState(5284)
			p.Match(DorisParserParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMaterializedViewNameContext is an interface to support dynamic dispatch.
type IMaterializedViewNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetIndexName returns the indexName rule contexts.
	GetIndexName() IIdentifierContext

	// SetIndexName sets the indexName rule contexts.
	SetIndexName(IIdentifierContext)

	// Getter signatures
	INDEX() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsMaterializedViewNameContext differentiates from other interfaces.
	IsMaterializedViewNameContext()
}

type MaterializedViewNameContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	indexName IIdentifierContext
}

func NewEmptyMaterializedViewNameContext() *MaterializedViewNameContext {
	var p = new(MaterializedViewNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_materializedViewName
	return p
}

func InitEmptyMaterializedViewNameContext(p *MaterializedViewNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_materializedViewName
}

func (*MaterializedViewNameContext) IsMaterializedViewNameContext() {}

func NewMaterializedViewNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MaterializedViewNameContext {
	var p = new(MaterializedViewNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_materializedViewName

	return p
}

func (s *MaterializedViewNameContext) GetParser() antlr.Parser { return s.parser }

func (s *MaterializedViewNameContext) GetIndexName() IIdentifierContext { return s.indexName }

func (s *MaterializedViewNameContext) SetIndexName(v IIdentifierContext) { s.indexName = v }

func (s *MaterializedViewNameContext) INDEX() antlr.TerminalNode {
	return s.GetToken(DorisParserParserINDEX, 0)
}

func (s *MaterializedViewNameContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *MaterializedViewNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MaterializedViewNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MaterializedViewNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitMaterializedViewName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) MaterializedViewName() (localctx IMaterializedViewNameContext) {
	localctx = NewMaterializedViewNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 314, DorisParserParserRULE_materializedViewName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5288)
		p.Match(DorisParserParserINDEX)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5289)

		var _x = p.Identifier()

		localctx.(*MaterializedViewNameContext).indexName = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertyClauseContext is an interface to support dynamic dispatch.
type IPropertyClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetFileProperties returns the fileProperties rule contexts.
	GetFileProperties() IPropertyItemListContext

	// SetFileProperties sets the fileProperties rule contexts.
	SetFileProperties(IPropertyItemListContext)

	// Getter signatures
	PROPERTIES() antlr.TerminalNode
	LEFT_PAREN() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode
	PropertyItemList() IPropertyItemListContext

	// IsPropertyClauseContext differentiates from other interfaces.
	IsPropertyClauseContext()
}

type PropertyClauseContext struct {
	antlr.BaseParserRuleContext
	parser         antlr.Parser
	fileProperties IPropertyItemListContext
}

func NewEmptyPropertyClauseContext() *PropertyClauseContext {
	var p = new(PropertyClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_propertyClause
	return p
}

func InitEmptyPropertyClauseContext(p *PropertyClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_propertyClause
}

func (*PropertyClauseContext) IsPropertyClauseContext() {}

func NewPropertyClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyClauseContext {
	var p = new(PropertyClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_propertyClause

	return p
}

func (s *PropertyClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyClauseContext) GetFileProperties() IPropertyItemListContext { return s.fileProperties }

func (s *PropertyClauseContext) SetFileProperties(v IPropertyItemListContext) { s.fileProperties = v }

func (s *PropertyClauseContext) PROPERTIES() antlr.TerminalNode {
	return s.GetToken(DorisParserParserPROPERTIES, 0)
}

func (s *PropertyClauseContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLEFT_PAREN, 0)
}

func (s *PropertyClauseContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRIGHT_PAREN, 0)
}

func (s *PropertyClauseContext) PropertyItemList() IPropertyItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyItemListContext)
}

func (s *PropertyClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitPropertyClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) PropertyClause() (localctx IPropertyClauseContext) {
	localctx = NewPropertyClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 316, DorisParserParserRULE_propertyClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5291)
		p.Match(DorisParserParserPROPERTIES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5292)
		p.Match(DorisParserParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5293)

		var _x = p.PropertyItemList()

		localctx.(*PropertyClauseContext).fileProperties = _x
	}
	{
		p.SetState(5294)
		p.Match(DorisParserParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertyItemListContext is an interface to support dynamic dispatch.
type IPropertyItemListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_propertyItem returns the _propertyItem rule contexts.
	Get_propertyItem() IPropertyItemContext

	// Set_propertyItem sets the _propertyItem rule contexts.
	Set_propertyItem(IPropertyItemContext)

	// GetProperties returns the properties rule context list.
	GetProperties() []IPropertyItemContext

	// SetProperties sets the properties rule context list.
	SetProperties([]IPropertyItemContext)

	// Getter signatures
	AllPropertyItem() []IPropertyItemContext
	PropertyItem(i int) IPropertyItemContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsPropertyItemListContext differentiates from other interfaces.
	IsPropertyItemListContext()
}

type PropertyItemListContext struct {
	antlr.BaseParserRuleContext
	parser        antlr.Parser
	_propertyItem IPropertyItemContext
	properties    []IPropertyItemContext
}

func NewEmptyPropertyItemListContext() *PropertyItemListContext {
	var p = new(PropertyItemListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_propertyItemList
	return p
}

func InitEmptyPropertyItemListContext(p *PropertyItemListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_propertyItemList
}

func (*PropertyItemListContext) IsPropertyItemListContext() {}

func NewPropertyItemListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyItemListContext {
	var p = new(PropertyItemListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_propertyItemList

	return p
}

func (s *PropertyItemListContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyItemListContext) Get_propertyItem() IPropertyItemContext { return s._propertyItem }

func (s *PropertyItemListContext) Set_propertyItem(v IPropertyItemContext) { s._propertyItem = v }

func (s *PropertyItemListContext) GetProperties() []IPropertyItemContext { return s.properties }

func (s *PropertyItemListContext) SetProperties(v []IPropertyItemContext) { s.properties = v }

func (s *PropertyItemListContext) AllPropertyItem() []IPropertyItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPropertyItemContext); ok {
			len++
		}
	}

	tst := make([]IPropertyItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPropertyItemContext); ok {
			tst[i] = t.(IPropertyItemContext)
			i++
		}
	}

	return tst
}

func (s *PropertyItemListContext) PropertyItem(i int) IPropertyItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyItemContext)
}

func (s *PropertyItemListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserCOMMA)
}

func (s *PropertyItemListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOMMA, i)
}

func (s *PropertyItemListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyItemListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyItemListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitPropertyItemList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) PropertyItemList() (localctx IPropertyItemListContext) {
	localctx = NewPropertyItemListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 318, DorisParserParserRULE_propertyItemList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5296)

		var _x = p.PropertyItem()

		localctx.(*PropertyItemListContext)._propertyItem = _x
	}
	localctx.(*PropertyItemListContext).properties = append(localctx.(*PropertyItemListContext).properties, localctx.(*PropertyItemListContext)._propertyItem)
	p.SetState(5301)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisParserParserCOMMA {
		{
			p.SetState(5297)
			p.Match(DorisParserParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5298)

			var _x = p.PropertyItem()

			localctx.(*PropertyItemListContext)._propertyItem = _x
		}
		localctx.(*PropertyItemListContext).properties = append(localctx.(*PropertyItemListContext).properties, localctx.(*PropertyItemListContext)._propertyItem)

		p.SetState(5303)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertyItemContext is an interface to support dynamic dispatch.
type IPropertyItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetKey returns the key rule contexts.
	GetKey() IPropertyKeyContext

	// GetValue returns the value rule contexts.
	GetValue() IPropertyValueContext

	// SetKey sets the key rule contexts.
	SetKey(IPropertyKeyContext)

	// SetValue sets the value rule contexts.
	SetValue(IPropertyValueContext)

	// Getter signatures
	EQ() antlr.TerminalNode
	PropertyKey() IPropertyKeyContext
	PropertyValue() IPropertyValueContext

	// IsPropertyItemContext differentiates from other interfaces.
	IsPropertyItemContext()
}

type PropertyItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	key    IPropertyKeyContext
	value  IPropertyValueContext
}

func NewEmptyPropertyItemContext() *PropertyItemContext {
	var p = new(PropertyItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_propertyItem
	return p
}

func InitEmptyPropertyItemContext(p *PropertyItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_propertyItem
}

func (*PropertyItemContext) IsPropertyItemContext() {}

func NewPropertyItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyItemContext {
	var p = new(PropertyItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_propertyItem

	return p
}

func (s *PropertyItemContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyItemContext) GetKey() IPropertyKeyContext { return s.key }

func (s *PropertyItemContext) GetValue() IPropertyValueContext { return s.value }

func (s *PropertyItemContext) SetKey(v IPropertyKeyContext) { s.key = v }

func (s *PropertyItemContext) SetValue(v IPropertyValueContext) { s.value = v }

func (s *PropertyItemContext) EQ() antlr.TerminalNode {
	return s.GetToken(DorisParserParserEQ, 0)
}

func (s *PropertyItemContext) PropertyKey() IPropertyKeyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyKeyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyKeyContext)
}

func (s *PropertyItemContext) PropertyValue() IPropertyValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyValueContext)
}

func (s *PropertyItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitPropertyItem(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) PropertyItem() (localctx IPropertyItemContext) {
	localctx = NewPropertyItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 320, DorisParserParserRULE_propertyItem)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5304)

		var _x = p.PropertyKey()

		localctx.(*PropertyItemContext).key = _x
	}
	{
		p.SetState(5305)
		p.Match(DorisParserParserEQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5306)

		var _x = p.PropertyValue()

		localctx.(*PropertyItemContext).value = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertyKeyContext is an interface to support dynamic dispatch.
type IPropertyKeyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	Constant() IConstantContext

	// IsPropertyKeyContext differentiates from other interfaces.
	IsPropertyKeyContext()
}

type PropertyKeyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyKeyContext() *PropertyKeyContext {
	var p = new(PropertyKeyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_propertyKey
	return p
}

func InitEmptyPropertyKeyContext(p *PropertyKeyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_propertyKey
}

func (*PropertyKeyContext) IsPropertyKeyContext() {}

func NewPropertyKeyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyKeyContext {
	var p = new(PropertyKeyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_propertyKey

	return p
}

func (s *PropertyKeyContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyKeyContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PropertyKeyContext) Constant() IConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *PropertyKeyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyKeyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyKeyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitPropertyKey(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) PropertyKey() (localctx IPropertyKeyContext) {
	localctx = NewPropertyKeyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 322, DorisParserParserRULE_propertyKey)
	p.SetState(5310)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 758, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5308)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5309)
			p.Constant()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertyValueContext is an interface to support dynamic dispatch.
type IPropertyValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	Constant() IConstantContext

	// IsPropertyValueContext differentiates from other interfaces.
	IsPropertyValueContext()
}

type PropertyValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyValueContext() *PropertyValueContext {
	var p = new(PropertyValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_propertyValue
	return p
}

func InitEmptyPropertyValueContext(p *PropertyValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_propertyValue
}

func (*PropertyValueContext) IsPropertyValueContext() {}

func NewPropertyValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyValueContext {
	var p = new(PropertyValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_propertyValue

	return p
}

func (s *PropertyValueContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyValueContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PropertyValueContext) Constant() IConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *PropertyValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitPropertyValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) PropertyValue() (localctx IPropertyValueContext) {
	localctx = NewPropertyValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 324, DorisParserParserRULE_propertyValue)
	p.SetState(5314)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 759, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5312)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5313)
			p.Constant()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableAliasContext is an interface to support dynamic dispatch.
type ITableAliasContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	StrictIdentifier() IStrictIdentifierContext
	AS() antlr.TerminalNode
	IdentifierList() IIdentifierListContext

	// IsTableAliasContext differentiates from other interfaces.
	IsTableAliasContext()
}

type TableAliasContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableAliasContext() *TableAliasContext {
	var p = new(TableAliasContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_tableAlias
	return p
}

func InitEmptyTableAliasContext(p *TableAliasContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_tableAlias
}

func (*TableAliasContext) IsTableAliasContext() {}

func NewTableAliasContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableAliasContext {
	var p = new(TableAliasContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_tableAlias

	return p
}

func (s *TableAliasContext) GetParser() antlr.Parser { return s.parser }

func (s *TableAliasContext) StrictIdentifier() IStrictIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStrictIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStrictIdentifierContext)
}

func (s *TableAliasContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserAS, 0)
}

func (s *TableAliasContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *TableAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableAliasContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableAliasContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitTableAlias(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) TableAlias() (localctx ITableAliasContext) {
	localctx = NewTableAliasContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 326, DorisParserParserRULE_tableAlias)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5323)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 762, p.GetParserRuleContext()) == 1 {
		p.SetState(5317)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserAS {
			{
				p.SetState(5316)
				p.Match(DorisParserParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(5319)
			p.StrictIdentifier()
		}
		p.SetState(5321)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 761, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5320)
				p.IdentifierList()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMultipartIdentifierContext is an interface to support dynamic dispatch.
type IMultipartIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_errorCapturingIdentifier returns the _errorCapturingIdentifier rule contexts.
	Get_errorCapturingIdentifier() IErrorCapturingIdentifierContext

	// Set_errorCapturingIdentifier sets the _errorCapturingIdentifier rule contexts.
	Set_errorCapturingIdentifier(IErrorCapturingIdentifierContext)

	// GetParts returns the parts rule context list.
	GetParts() []IErrorCapturingIdentifierContext

	// SetParts sets the parts rule context list.
	SetParts([]IErrorCapturingIdentifierContext)

	// Getter signatures
	AllErrorCapturingIdentifier() []IErrorCapturingIdentifierContext
	ErrorCapturingIdentifier(i int) IErrorCapturingIdentifierContext
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode

	// IsMultipartIdentifierContext differentiates from other interfaces.
	IsMultipartIdentifierContext()
}

type MultipartIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser                    antlr.Parser
	_errorCapturingIdentifier IErrorCapturingIdentifierContext
	parts                     []IErrorCapturingIdentifierContext
}

func NewEmptyMultipartIdentifierContext() *MultipartIdentifierContext {
	var p = new(MultipartIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_multipartIdentifier
	return p
}

func InitEmptyMultipartIdentifierContext(p *MultipartIdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_multipartIdentifier
}

func (*MultipartIdentifierContext) IsMultipartIdentifierContext() {}

func NewMultipartIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultipartIdentifierContext {
	var p = new(MultipartIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_multipartIdentifier

	return p
}

func (s *MultipartIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *MultipartIdentifierContext) Get_errorCapturingIdentifier() IErrorCapturingIdentifierContext {
	return s._errorCapturingIdentifier
}

func (s *MultipartIdentifierContext) Set_errorCapturingIdentifier(v IErrorCapturingIdentifierContext) {
	s._errorCapturingIdentifier = v
}

func (s *MultipartIdentifierContext) GetParts() []IErrorCapturingIdentifierContext { return s.parts }

func (s *MultipartIdentifierContext) SetParts(v []IErrorCapturingIdentifierContext) { s.parts = v }

func (s *MultipartIdentifierContext) AllErrorCapturingIdentifier() []IErrorCapturingIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IErrorCapturingIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IErrorCapturingIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IErrorCapturingIdentifierContext); ok {
			tst[i] = t.(IErrorCapturingIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *MultipartIdentifierContext) ErrorCapturingIdentifier(i int) IErrorCapturingIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IErrorCapturingIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IErrorCapturingIdentifierContext)
}

func (s *MultipartIdentifierContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserDOT)
}

func (s *MultipartIdentifierContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserDOT, i)
}

func (s *MultipartIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultipartIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultipartIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitMultipartIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) MultipartIdentifier() (localctx IMultipartIdentifierContext) {
	localctx = NewMultipartIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 328, DorisParserParserRULE_multipartIdentifier)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5325)

		var _x = p.ErrorCapturingIdentifier()

		localctx.(*MultipartIdentifierContext)._errorCapturingIdentifier = _x
	}
	localctx.(*MultipartIdentifierContext).parts = append(localctx.(*MultipartIdentifierContext).parts, localctx.(*MultipartIdentifierContext)._errorCapturingIdentifier)
	p.SetState(5330)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 763, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(5326)
				p.Match(DorisParserParserDOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5327)

				var _x = p.ErrorCapturingIdentifier()

				localctx.(*MultipartIdentifierContext)._errorCapturingIdentifier = _x
			}
			localctx.(*MultipartIdentifierContext).parts = append(localctx.(*MultipartIdentifierContext).parts, localctx.(*MultipartIdentifierContext)._errorCapturingIdentifier)

		}
		p.SetState(5332)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 763, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimpleColumnDefsContext is an interface to support dynamic dispatch.
type ISimpleColumnDefsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_simpleColumnDef returns the _simpleColumnDef rule contexts.
	Get_simpleColumnDef() ISimpleColumnDefContext

	// Set_simpleColumnDef sets the _simpleColumnDef rule contexts.
	Set_simpleColumnDef(ISimpleColumnDefContext)

	// GetCols returns the cols rule context list.
	GetCols() []ISimpleColumnDefContext

	// SetCols sets the cols rule context list.
	SetCols([]ISimpleColumnDefContext)

	// Getter signatures
	AllSimpleColumnDef() []ISimpleColumnDefContext
	SimpleColumnDef(i int) ISimpleColumnDefContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsSimpleColumnDefsContext differentiates from other interfaces.
	IsSimpleColumnDefsContext()
}

type SimpleColumnDefsContext struct {
	antlr.BaseParserRuleContext
	parser           antlr.Parser
	_simpleColumnDef ISimpleColumnDefContext
	cols             []ISimpleColumnDefContext
}

func NewEmptySimpleColumnDefsContext() *SimpleColumnDefsContext {
	var p = new(SimpleColumnDefsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_simpleColumnDefs
	return p
}

func InitEmptySimpleColumnDefsContext(p *SimpleColumnDefsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_simpleColumnDefs
}

func (*SimpleColumnDefsContext) IsSimpleColumnDefsContext() {}

func NewSimpleColumnDefsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleColumnDefsContext {
	var p = new(SimpleColumnDefsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_simpleColumnDefs

	return p
}

func (s *SimpleColumnDefsContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleColumnDefsContext) Get_simpleColumnDef() ISimpleColumnDefContext {
	return s._simpleColumnDef
}

func (s *SimpleColumnDefsContext) Set_simpleColumnDef(v ISimpleColumnDefContext) {
	s._simpleColumnDef = v
}

func (s *SimpleColumnDefsContext) GetCols() []ISimpleColumnDefContext { return s.cols }

func (s *SimpleColumnDefsContext) SetCols(v []ISimpleColumnDefContext) { s.cols = v }

func (s *SimpleColumnDefsContext) AllSimpleColumnDef() []ISimpleColumnDefContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISimpleColumnDefContext); ok {
			len++
		}
	}

	tst := make([]ISimpleColumnDefContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISimpleColumnDefContext); ok {
			tst[i] = t.(ISimpleColumnDefContext)
			i++
		}
	}

	return tst
}

func (s *SimpleColumnDefsContext) SimpleColumnDef(i int) ISimpleColumnDefContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleColumnDefContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleColumnDefContext)
}

func (s *SimpleColumnDefsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserCOMMA)
}

func (s *SimpleColumnDefsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOMMA, i)
}

func (s *SimpleColumnDefsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleColumnDefsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleColumnDefsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitSimpleColumnDefs(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) SimpleColumnDefs() (localctx ISimpleColumnDefsContext) {
	localctx = NewSimpleColumnDefsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 330, DorisParserParserRULE_simpleColumnDefs)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5333)

		var _x = p.SimpleColumnDef()

		localctx.(*SimpleColumnDefsContext)._simpleColumnDef = _x
	}
	localctx.(*SimpleColumnDefsContext).cols = append(localctx.(*SimpleColumnDefsContext).cols, localctx.(*SimpleColumnDefsContext)._simpleColumnDef)
	p.SetState(5338)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisParserParserCOMMA {
		{
			p.SetState(5334)
			p.Match(DorisParserParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5335)

			var _x = p.SimpleColumnDef()

			localctx.(*SimpleColumnDefsContext)._simpleColumnDef = _x
		}
		localctx.(*SimpleColumnDefsContext).cols = append(localctx.(*SimpleColumnDefsContext).cols, localctx.(*SimpleColumnDefsContext)._simpleColumnDef)

		p.SetState(5340)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimpleColumnDefContext is an interface to support dynamic dispatch.
type ISimpleColumnDefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetComment returns the comment token.
	GetComment() antlr.Token

	// SetComment sets the comment token.
	SetComment(antlr.Token)

	// GetColName returns the colName rule contexts.
	GetColName() IIdentifierContext

	// SetColName sets the colName rule contexts.
	SetColName(IIdentifierContext)

	// Getter signatures
	Identifier() IIdentifierContext
	COMMENT() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode

	// IsSimpleColumnDefContext differentiates from other interfaces.
	IsSimpleColumnDefContext()
}

type SimpleColumnDefContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	colName IIdentifierContext
	comment antlr.Token
}

func NewEmptySimpleColumnDefContext() *SimpleColumnDefContext {
	var p = new(SimpleColumnDefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_simpleColumnDef
	return p
}

func InitEmptySimpleColumnDefContext(p *SimpleColumnDefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_simpleColumnDef
}

func (*SimpleColumnDefContext) IsSimpleColumnDefContext() {}

func NewSimpleColumnDefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleColumnDefContext {
	var p = new(SimpleColumnDefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_simpleColumnDef

	return p
}

func (s *SimpleColumnDefContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleColumnDefContext) GetComment() antlr.Token { return s.comment }

func (s *SimpleColumnDefContext) SetComment(v antlr.Token) { s.comment = v }

func (s *SimpleColumnDefContext) GetColName() IIdentifierContext { return s.colName }

func (s *SimpleColumnDefContext) SetColName(v IIdentifierContext) { s.colName = v }

func (s *SimpleColumnDefContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SimpleColumnDefContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOMMENT, 0)
}

func (s *SimpleColumnDefContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTRING_LITERAL, 0)
}

func (s *SimpleColumnDefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleColumnDefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleColumnDefContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitSimpleColumnDef(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) SimpleColumnDef() (localctx ISimpleColumnDefContext) {
	localctx = NewSimpleColumnDefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 332, DorisParserParserRULE_simpleColumnDef)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5341)

		var _x = p.Identifier()

		localctx.(*SimpleColumnDefContext).colName = _x
	}
	p.SetState(5344)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserParserCOMMENT {
		{
			p.SetState(5342)
			p.Match(DorisParserParserCOMMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5343)

			var _m = p.Match(DorisParserParserSTRING_LITERAL)

			localctx.(*SimpleColumnDefContext).comment = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnDefsContext is an interface to support dynamic dispatch.
type IColumnDefsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_columnDef returns the _columnDef rule contexts.
	Get_columnDef() IColumnDefContext

	// Set_columnDef sets the _columnDef rule contexts.
	Set_columnDef(IColumnDefContext)

	// GetCols returns the cols rule context list.
	GetCols() []IColumnDefContext

	// SetCols sets the cols rule context list.
	SetCols([]IColumnDefContext)

	// Getter signatures
	AllColumnDef() []IColumnDefContext
	ColumnDef(i int) IColumnDefContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsColumnDefsContext differentiates from other interfaces.
	IsColumnDefsContext()
}

type ColumnDefsContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	_columnDef IColumnDefContext
	cols       []IColumnDefContext
}

func NewEmptyColumnDefsContext() *ColumnDefsContext {
	var p = new(ColumnDefsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_columnDefs
	return p
}

func InitEmptyColumnDefsContext(p *ColumnDefsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_columnDefs
}

func (*ColumnDefsContext) IsColumnDefsContext() {}

func NewColumnDefsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnDefsContext {
	var p = new(ColumnDefsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_columnDefs

	return p
}

func (s *ColumnDefsContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnDefsContext) Get_columnDef() IColumnDefContext { return s._columnDef }

func (s *ColumnDefsContext) Set_columnDef(v IColumnDefContext) { s._columnDef = v }

func (s *ColumnDefsContext) GetCols() []IColumnDefContext { return s.cols }

func (s *ColumnDefsContext) SetCols(v []IColumnDefContext) { s.cols = v }

func (s *ColumnDefsContext) AllColumnDef() []IColumnDefContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnDefContext); ok {
			len++
		}
	}

	tst := make([]IColumnDefContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnDefContext); ok {
			tst[i] = t.(IColumnDefContext)
			i++
		}
	}

	return tst
}

func (s *ColumnDefsContext) ColumnDef(i int) IColumnDefContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnDefContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnDefContext)
}

func (s *ColumnDefsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserCOMMA)
}

func (s *ColumnDefsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOMMA, i)
}

func (s *ColumnDefsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnDefsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnDefsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitColumnDefs(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) ColumnDefs() (localctx IColumnDefsContext) {
	localctx = NewColumnDefsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 334, DorisParserParserRULE_columnDefs)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5346)

		var _x = p.ColumnDef()

		localctx.(*ColumnDefsContext)._columnDef = _x
	}
	localctx.(*ColumnDefsContext).cols = append(localctx.(*ColumnDefsContext).cols, localctx.(*ColumnDefsContext)._columnDef)
	p.SetState(5351)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 766, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(5347)
				p.Match(DorisParserParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5348)

				var _x = p.ColumnDef()

				localctx.(*ColumnDefsContext)._columnDef = _x
			}
			localctx.(*ColumnDefsContext).cols = append(localctx.(*ColumnDefsContext).cols, localctx.(*ColumnDefsContext)._columnDef)

		}
		p.SetState(5353)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 766, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnDefContext is an interface to support dynamic dispatch.
type IColumnDefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetNullable returns the nullable token.
	GetNullable() antlr.Token

	// GetNullValue returns the nullValue token.
	GetNullValue() antlr.Token

	// GetStringValue returns the stringValue token.
	GetStringValue() antlr.Token

	// GetDefaultTimestamp returns the defaultTimestamp token.
	GetDefaultTimestamp() antlr.Token

	// GetComment returns the comment token.
	GetComment() antlr.Token

	// SetNullable sets the nullable token.
	SetNullable(antlr.Token)

	// SetNullValue sets the nullValue token.
	SetNullValue(antlr.Token)

	// SetStringValue sets the stringValue token.
	SetStringValue(antlr.Token)

	// SetDefaultTimestamp sets the defaultTimestamp token.
	SetDefaultTimestamp(antlr.Token)

	// SetComment sets the comment token.
	SetComment(antlr.Token)

	// GetColName returns the colName rule contexts.
	GetColName() IIdentifierContext

	// GetType_ returns the type_ rule contexts.
	GetType_() IDataTypeContext

	// GetAggType returns the aggType rule contexts.
	GetAggType() IAggTypeDefContext

	// GetGeneratedExpr returns the generatedExpr rule contexts.
	GetGeneratedExpr() IExpressionContext

	// GetAutoIncInitValue returns the autoIncInitValue rule contexts.
	GetAutoIncInitValue() INumberContext

	// GetDefaultValuePrecision returns the defaultValuePrecision rule contexts.
	GetDefaultValuePrecision() INumberContext

	// GetOnUpdateValuePrecision returns the onUpdateValuePrecision rule contexts.
	GetOnUpdateValuePrecision() INumberContext

	// SetColName sets the colName rule contexts.
	SetColName(IIdentifierContext)

	// SetType_ sets the type_ rule contexts.
	SetType_(IDataTypeContext)

	// SetAggType sets the aggType rule contexts.
	SetAggType(IAggTypeDefContext)

	// SetGeneratedExpr sets the generatedExpr rule contexts.
	SetGeneratedExpr(IExpressionContext)

	// SetAutoIncInitValue sets the autoIncInitValue rule contexts.
	SetAutoIncInitValue(INumberContext)

	// SetDefaultValuePrecision sets the defaultValuePrecision rule contexts.
	SetDefaultValuePrecision(INumberContext)

	// SetOnUpdateValuePrecision sets the onUpdateValuePrecision rule contexts.
	SetOnUpdateValuePrecision(INumberContext)

	// Getter signatures
	Identifier() IIdentifierContext
	DataType() IDataTypeContext
	KEY() antlr.TerminalNode
	AS() antlr.TerminalNode
	AllLEFT_PAREN() []antlr.TerminalNode
	LEFT_PAREN(i int) antlr.TerminalNode
	AllRIGHT_PAREN() []antlr.TerminalNode
	RIGHT_PAREN(i int) antlr.TerminalNode
	AUTO_INCREMENT() antlr.TerminalNode
	DEFAULT() antlr.TerminalNode
	ON() antlr.TerminalNode
	UPDATE() antlr.TerminalNode
	AllCURRENT_TIMESTAMP() []antlr.TerminalNode
	CURRENT_TIMESTAMP(i int) antlr.TerminalNode
	COMMENT() antlr.TerminalNode
	AggTypeDef() IAggTypeDefContext
	Expression() IExpressionContext
	AllNULL() []antlr.TerminalNode
	NULL(i int) antlr.TerminalNode
	AllSTRING_LITERAL() []antlr.TerminalNode
	STRING_LITERAL(i int) antlr.TerminalNode
	INTEGER_VALUE() antlr.TerminalNode
	DECIMAL_VALUE() antlr.TerminalNode
	PI() antlr.TerminalNode
	E() antlr.TerminalNode
	BITMAP_EMPTY() antlr.TerminalNode
	CURRENT_DATE() antlr.TerminalNode
	GENERATED() antlr.TerminalNode
	ALWAYS() antlr.TerminalNode
	NOT() antlr.TerminalNode
	AllNumber() []INumberContext
	Number(i int) INumberContext
	SUBTRACT() antlr.TerminalNode

	// IsColumnDefContext differentiates from other interfaces.
	IsColumnDefContext()
}

type ColumnDefContext struct {
	antlr.BaseParserRuleContext
	parser                 antlr.Parser
	colName                IIdentifierContext
	type_                  IDataTypeContext
	aggType                IAggTypeDefContext
	generatedExpr          IExpressionContext
	nullable               antlr.Token
	autoIncInitValue       INumberContext
	nullValue              antlr.Token
	stringValue            antlr.Token
	defaultTimestamp       antlr.Token
	defaultValuePrecision  INumberContext
	onUpdateValuePrecision INumberContext
	comment                antlr.Token
}

func NewEmptyColumnDefContext() *ColumnDefContext {
	var p = new(ColumnDefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_columnDef
	return p
}

func InitEmptyColumnDefContext(p *ColumnDefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_columnDef
}

func (*ColumnDefContext) IsColumnDefContext() {}

func NewColumnDefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnDefContext {
	var p = new(ColumnDefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_columnDef

	return p
}

func (s *ColumnDefContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnDefContext) GetNullable() antlr.Token { return s.nullable }

func (s *ColumnDefContext) GetNullValue() antlr.Token { return s.nullValue }

func (s *ColumnDefContext) GetStringValue() antlr.Token { return s.stringValue }

func (s *ColumnDefContext) GetDefaultTimestamp() antlr.Token { return s.defaultTimestamp }

func (s *ColumnDefContext) GetComment() antlr.Token { return s.comment }

func (s *ColumnDefContext) SetNullable(v antlr.Token) { s.nullable = v }

func (s *ColumnDefContext) SetNullValue(v antlr.Token) { s.nullValue = v }

func (s *ColumnDefContext) SetStringValue(v antlr.Token) { s.stringValue = v }

func (s *ColumnDefContext) SetDefaultTimestamp(v antlr.Token) { s.defaultTimestamp = v }

func (s *ColumnDefContext) SetComment(v antlr.Token) { s.comment = v }

func (s *ColumnDefContext) GetColName() IIdentifierContext { return s.colName }

func (s *ColumnDefContext) GetType_() IDataTypeContext { return s.type_ }

func (s *ColumnDefContext) GetAggType() IAggTypeDefContext { return s.aggType }

func (s *ColumnDefContext) GetGeneratedExpr() IExpressionContext { return s.generatedExpr }

func (s *ColumnDefContext) GetAutoIncInitValue() INumberContext { return s.autoIncInitValue }

func (s *ColumnDefContext) GetDefaultValuePrecision() INumberContext { return s.defaultValuePrecision }

func (s *ColumnDefContext) GetOnUpdateValuePrecision() INumberContext {
	return s.onUpdateValuePrecision
}

func (s *ColumnDefContext) SetColName(v IIdentifierContext) { s.colName = v }

func (s *ColumnDefContext) SetType_(v IDataTypeContext) { s.type_ = v }

func (s *ColumnDefContext) SetAggType(v IAggTypeDefContext) { s.aggType = v }

func (s *ColumnDefContext) SetGeneratedExpr(v IExpressionContext) { s.generatedExpr = v }

func (s *ColumnDefContext) SetAutoIncInitValue(v INumberContext) { s.autoIncInitValue = v }

func (s *ColumnDefContext) SetDefaultValuePrecision(v INumberContext) { s.defaultValuePrecision = v }

func (s *ColumnDefContext) SetOnUpdateValuePrecision(v INumberContext) { s.onUpdateValuePrecision = v }

func (s *ColumnDefContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ColumnDefContext) DataType() IDataTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *ColumnDefContext) KEY() antlr.TerminalNode {
	return s.GetToken(DorisParserParserKEY, 0)
}

func (s *ColumnDefContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserAS, 0)
}

func (s *ColumnDefContext) AllLEFT_PAREN() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserLEFT_PAREN)
}

func (s *ColumnDefContext) LEFT_PAREN(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserLEFT_PAREN, i)
}

func (s *ColumnDefContext) AllRIGHT_PAREN() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserRIGHT_PAREN)
}

func (s *ColumnDefContext) RIGHT_PAREN(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserRIGHT_PAREN, i)
}

func (s *ColumnDefContext) AUTO_INCREMENT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserAUTO_INCREMENT, 0)
}

func (s *ColumnDefContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDEFAULT, 0)
}

func (s *ColumnDefContext) ON() antlr.TerminalNode {
	return s.GetToken(DorisParserParserON, 0)
}

func (s *ColumnDefContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserUPDATE, 0)
}

func (s *ColumnDefContext) AllCURRENT_TIMESTAMP() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserCURRENT_TIMESTAMP)
}

func (s *ColumnDefContext) CURRENT_TIMESTAMP(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserCURRENT_TIMESTAMP, i)
}

func (s *ColumnDefContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOMMENT, 0)
}

func (s *ColumnDefContext) AggTypeDef() IAggTypeDefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAggTypeDefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAggTypeDefContext)
}

func (s *ColumnDefContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ColumnDefContext) AllNULL() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserNULL)
}

func (s *ColumnDefContext) NULL(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserNULL, i)
}

func (s *ColumnDefContext) AllSTRING_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserSTRING_LITERAL)
}

func (s *ColumnDefContext) STRING_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTRING_LITERAL, i)
}

func (s *ColumnDefContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserINTEGER_VALUE, 0)
}

func (s *ColumnDefContext) DECIMAL_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDECIMAL_VALUE, 0)
}

func (s *ColumnDefContext) PI() antlr.TerminalNode {
	return s.GetToken(DorisParserParserPI, 0)
}

func (s *ColumnDefContext) E() antlr.TerminalNode {
	return s.GetToken(DorisParserParserE, 0)
}

func (s *ColumnDefContext) BITMAP_EMPTY() antlr.TerminalNode {
	return s.GetToken(DorisParserParserBITMAP_EMPTY, 0)
}

func (s *ColumnDefContext) CURRENT_DATE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCURRENT_DATE, 0)
}

func (s *ColumnDefContext) GENERATED() antlr.TerminalNode {
	return s.GetToken(DorisParserParserGENERATED, 0)
}

func (s *ColumnDefContext) ALWAYS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserALWAYS, 0)
}

func (s *ColumnDefContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserNOT, 0)
}

func (s *ColumnDefContext) AllNumber() []INumberContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INumberContext); ok {
			len++
		}
	}

	tst := make([]INumberContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INumberContext); ok {
			tst[i] = t.(INumberContext)
			i++
		}
	}

	return tst
}

func (s *ColumnDefContext) Number(i int) INumberContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumberContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *ColumnDefContext) SUBTRACT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSUBTRACT, 0)
}

func (s *ColumnDefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnDefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnDefContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitColumnDef(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) ColumnDef() (localctx IColumnDefContext) {
	localctx = NewColumnDefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 336, DorisParserParserRULE_columnDef)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5354)

		var _x = p.Identifier()

		localctx.(*ColumnDefContext).colName = _x
	}
	{
		p.SetState(5355)

		var _x = p.DataType()

		localctx.(*ColumnDefContext).type_ = _x
	}
	p.SetState(5357)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserParserKEY {
		{
			p.SetState(5356)
			p.Match(DorisParserParserKEY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(5360)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserParserBITMAP_UNION || _la == DorisParserParserGENERIC || _la == DorisParserParserHLL_UNION || _la == DorisParserParserMAX || _la == DorisParserParserMIN || ((int64((_la-362)) & ^0x3f) == 0 && ((int64(1)<<(_la-362))&6291457) != 0) || _la == DorisParserParserSUM {
		{
			p.SetState(5359)

			var _x = p.AggTypeDef()

			localctx.(*ColumnDefContext).aggType = _x
		}

	}
	p.SetState(5371)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserParserAS || _la == DorisParserParserGENERATED {
		p.SetState(5364)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserGENERATED {
			{
				p.SetState(5362)
				p.Match(DorisParserParserGENERATED)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5363)
				p.Match(DorisParserParserALWAYS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(5366)
			p.Match(DorisParserParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5367)
			p.Match(DorisParserParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5368)

			var _x = p.Expression()

			localctx.(*ColumnDefContext).generatedExpr = _x
		}
		{
			p.SetState(5369)
			p.Match(DorisParserParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(5377)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserParserNOT || _la == DorisParserParserNULL {
		p.SetState(5374)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserNOT {
			{
				p.SetState(5373)
				p.Match(DorisParserParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(5376)

			var _m = p.Match(DorisParserParserNULL)

			localctx.(*ColumnDefContext).nullable = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(5386)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserParserAUTO_INCREMENT {
		{
			p.SetState(5379)
			p.Match(DorisParserParserAUTO_INCREMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5384)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserLEFT_PAREN {
			{
				p.SetState(5380)
				p.Match(DorisParserParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5381)

				var _x = p.Number()

				localctx.(*ColumnDefContext).autoIncInitValue = _x
			}
			{
				p.SetState(5382)
				p.Match(DorisParserParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	}
	p.SetState(5412)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserParserDEFAULT {
		{
			p.SetState(5388)
			p.Match(DorisParserParserDEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5410)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 778, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(5389)

				var _m = p.Match(DorisParserParserNULL)

				localctx.(*ColumnDefContext).nullValue = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 2:
			p.SetState(5391)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserParserSUBTRACT {
				{
					p.SetState(5390)
					p.Match(DorisParserParserSUBTRACT)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(5393)
				p.Match(DorisParserParserINTEGER_VALUE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 3:
			p.SetState(5395)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserParserSUBTRACT {
				{
					p.SetState(5394)
					p.Match(DorisParserParserSUBTRACT)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(5397)
				p.Match(DorisParserParserDECIMAL_VALUE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 4:
			{
				p.SetState(5398)
				p.Match(DorisParserParserPI)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 5:
			{
				p.SetState(5399)
				p.Match(DorisParserParserE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 6:
			{
				p.SetState(5400)
				p.Match(DorisParserParserBITMAP_EMPTY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 7:
			{
				p.SetState(5401)

				var _m = p.Match(DorisParserParserSTRING_LITERAL)

				localctx.(*ColumnDefContext).stringValue = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 8:
			{
				p.SetState(5402)
				p.Match(DorisParserParserCURRENT_DATE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 9:
			{
				p.SetState(5403)

				var _m = p.Match(DorisParserParserCURRENT_TIMESTAMP)

				localctx.(*ColumnDefContext).defaultTimestamp = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(5408)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == DorisParserParserLEFT_PAREN {
				{
					p.SetState(5404)
					p.Match(DorisParserParserLEFT_PAREN)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(5405)

					var _x = p.Number()

					localctx.(*ColumnDefContext).defaultValuePrecision = _x
				}
				{
					p.SetState(5406)
					p.Match(DorisParserParserRIGHT_PAREN)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

	}
	p.SetState(5423)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserParserON {
		{
			p.SetState(5414)
			p.Match(DorisParserParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5415)
			p.Match(DorisParserParserUPDATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5416)
			p.Match(DorisParserParserCURRENT_TIMESTAMP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5421)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserLEFT_PAREN {
			{
				p.SetState(5417)
				p.Match(DorisParserParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5418)

				var _x = p.Number()

				localctx.(*ColumnDefContext).onUpdateValuePrecision = _x
			}
			{
				p.SetState(5419)
				p.Match(DorisParserParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	}
	p.SetState(5427)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserParserCOMMENT {
		{
			p.SetState(5425)
			p.Match(DorisParserParserCOMMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5426)

			var _m = p.Match(DorisParserParserSTRING_LITERAL)

			localctx.(*ColumnDefContext).comment = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIndexDefsContext is an interface to support dynamic dispatch.
type IIndexDefsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_indexDef returns the _indexDef rule contexts.
	Get_indexDef() IIndexDefContext

	// Set_indexDef sets the _indexDef rule contexts.
	Set_indexDef(IIndexDefContext)

	// GetIndexes returns the indexes rule context list.
	GetIndexes() []IIndexDefContext

	// SetIndexes sets the indexes rule context list.
	SetIndexes([]IIndexDefContext)

	// Getter signatures
	AllIndexDef() []IIndexDefContext
	IndexDef(i int) IIndexDefContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsIndexDefsContext differentiates from other interfaces.
	IsIndexDefsContext()
}

type IndexDefsContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	_indexDef IIndexDefContext
	indexes   []IIndexDefContext
}

func NewEmptyIndexDefsContext() *IndexDefsContext {
	var p = new(IndexDefsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_indexDefs
	return p
}

func InitEmptyIndexDefsContext(p *IndexDefsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_indexDefs
}

func (*IndexDefsContext) IsIndexDefsContext() {}

func NewIndexDefsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexDefsContext {
	var p = new(IndexDefsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_indexDefs

	return p
}

func (s *IndexDefsContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexDefsContext) Get_indexDef() IIndexDefContext { return s._indexDef }

func (s *IndexDefsContext) Set_indexDef(v IIndexDefContext) { s._indexDef = v }

func (s *IndexDefsContext) GetIndexes() []IIndexDefContext { return s.indexes }

func (s *IndexDefsContext) SetIndexes(v []IIndexDefContext) { s.indexes = v }

func (s *IndexDefsContext) AllIndexDef() []IIndexDefContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIndexDefContext); ok {
			len++
		}
	}

	tst := make([]IIndexDefContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIndexDefContext); ok {
			tst[i] = t.(IIndexDefContext)
			i++
		}
	}

	return tst
}

func (s *IndexDefsContext) IndexDef(i int) IIndexDefContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexDefContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexDefContext)
}

func (s *IndexDefsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserCOMMA)
}

func (s *IndexDefsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOMMA, i)
}

func (s *IndexDefsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexDefsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexDefsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitIndexDefs(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) IndexDefs() (localctx IIndexDefsContext) {
	localctx = NewIndexDefsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 338, DorisParserParserRULE_indexDefs)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5429)

		var _x = p.IndexDef()

		localctx.(*IndexDefsContext)._indexDef = _x
	}
	localctx.(*IndexDefsContext).indexes = append(localctx.(*IndexDefsContext).indexes, localctx.(*IndexDefsContext)._indexDef)
	p.SetState(5434)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 783, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(5430)
				p.Match(DorisParserParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5431)

				var _x = p.IndexDef()

				localctx.(*IndexDefsContext)._indexDef = _x
			}
			localctx.(*IndexDefsContext).indexes = append(localctx.(*IndexDefsContext).indexes, localctx.(*IndexDefsContext)._indexDef)

		}
		p.SetState(5436)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 783, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIndexDefContext is an interface to support dynamic dispatch.
type IIndexDefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetIfNotExists returns the ifNotExists token.
	GetIfNotExists() antlr.Token

	// GetIndexType returns the indexType token.
	GetIndexType() antlr.Token

	// GetComment returns the comment token.
	GetComment() antlr.Token

	// SetIfNotExists sets the ifNotExists token.
	SetIfNotExists(antlr.Token)

	// SetIndexType sets the indexType token.
	SetIndexType(antlr.Token)

	// SetComment sets the comment token.
	SetComment(antlr.Token)

	// GetIndexName returns the indexName rule contexts.
	GetIndexName() IIdentifierContext

	// GetCols returns the cols rule contexts.
	GetCols() IIdentifierListContext

	// GetProperties returns the properties rule contexts.
	GetProperties() IPropertyItemListContext

	// SetIndexName sets the indexName rule contexts.
	SetIndexName(IIdentifierContext)

	// SetCols sets the cols rule contexts.
	SetCols(IIdentifierListContext)

	// SetProperties sets the properties rule contexts.
	SetProperties(IPropertyItemListContext)

	// Getter signatures
	INDEX() antlr.TerminalNode
	Identifier() IIdentifierContext
	IdentifierList() IIdentifierListContext
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	USING() antlr.TerminalNode
	PROPERTIES() antlr.TerminalNode
	LEFT_PAREN() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode
	COMMENT() antlr.TerminalNode
	IF() antlr.TerminalNode
	PropertyItemList() IPropertyItemListContext
	STRING_LITERAL() antlr.TerminalNode
	BITMAP() antlr.TerminalNode
	INVERTED() antlr.TerminalNode
	NGRAM_BF() antlr.TerminalNode

	// IsIndexDefContext differentiates from other interfaces.
	IsIndexDefContext()
}

type IndexDefContext struct {
	antlr.BaseParserRuleContext
	parser      antlr.Parser
	ifNotExists antlr.Token
	indexName   IIdentifierContext
	cols        IIdentifierListContext
	indexType   antlr.Token
	properties  IPropertyItemListContext
	comment     antlr.Token
}

func NewEmptyIndexDefContext() *IndexDefContext {
	var p = new(IndexDefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_indexDef
	return p
}

func InitEmptyIndexDefContext(p *IndexDefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_indexDef
}

func (*IndexDefContext) IsIndexDefContext() {}

func NewIndexDefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexDefContext {
	var p = new(IndexDefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_indexDef

	return p
}

func (s *IndexDefContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexDefContext) GetIfNotExists() antlr.Token { return s.ifNotExists }

func (s *IndexDefContext) GetIndexType() antlr.Token { return s.indexType }

func (s *IndexDefContext) GetComment() antlr.Token { return s.comment }

func (s *IndexDefContext) SetIfNotExists(v antlr.Token) { s.ifNotExists = v }

func (s *IndexDefContext) SetIndexType(v antlr.Token) { s.indexType = v }

func (s *IndexDefContext) SetComment(v antlr.Token) { s.comment = v }

func (s *IndexDefContext) GetIndexName() IIdentifierContext { return s.indexName }

func (s *IndexDefContext) GetCols() IIdentifierListContext { return s.cols }

func (s *IndexDefContext) GetProperties() IPropertyItemListContext { return s.properties }

func (s *IndexDefContext) SetIndexName(v IIdentifierContext) { s.indexName = v }

func (s *IndexDefContext) SetCols(v IIdentifierListContext) { s.cols = v }

func (s *IndexDefContext) SetProperties(v IPropertyItemListContext) { s.properties = v }

func (s *IndexDefContext) INDEX() antlr.TerminalNode {
	return s.GetToken(DorisParserParserINDEX, 0)
}

func (s *IndexDefContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *IndexDefContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *IndexDefContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserNOT, 0)
}

func (s *IndexDefContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserEXISTS, 0)
}

func (s *IndexDefContext) USING() antlr.TerminalNode {
	return s.GetToken(DorisParserParserUSING, 0)
}

func (s *IndexDefContext) PROPERTIES() antlr.TerminalNode {
	return s.GetToken(DorisParserParserPROPERTIES, 0)
}

func (s *IndexDefContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLEFT_PAREN, 0)
}

func (s *IndexDefContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRIGHT_PAREN, 0)
}

func (s *IndexDefContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOMMENT, 0)
}

func (s *IndexDefContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserParserIF, 0)
}

func (s *IndexDefContext) PropertyItemList() IPropertyItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyItemListContext)
}

func (s *IndexDefContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTRING_LITERAL, 0)
}

func (s *IndexDefContext) BITMAP() antlr.TerminalNode {
	return s.GetToken(DorisParserParserBITMAP, 0)
}

func (s *IndexDefContext) INVERTED() antlr.TerminalNode {
	return s.GetToken(DorisParserParserINVERTED, 0)
}

func (s *IndexDefContext) NGRAM_BF() antlr.TerminalNode {
	return s.GetToken(DorisParserParserNGRAM_BF, 0)
}

func (s *IndexDefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexDefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexDefContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitIndexDef(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) IndexDef() (localctx IIndexDefContext) {
	localctx = NewIndexDefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 340, DorisParserParserRULE_indexDef)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5437)
		p.Match(DorisParserParserINDEX)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5441)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserParserIF {
		{
			p.SetState(5438)

			var _m = p.Match(DorisParserParserIF)

			localctx.(*IndexDefContext).ifNotExists = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5439)
			p.Match(DorisParserParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5440)
			p.Match(DorisParserParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(5443)

		var _x = p.Identifier()

		localctx.(*IndexDefContext).indexName = _x
	}
	{
		p.SetState(5444)

		var _x = p.IdentifierList()

		localctx.(*IndexDefContext).cols = _x
	}
	p.SetState(5447)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserParserUSING {
		{
			p.SetState(5445)
			p.Match(DorisParserParserUSING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5446)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*IndexDefContext).indexType = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserParserBITMAP || _la == DorisParserParserINVERTED || _la == DorisParserParserNGRAM_BF) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*IndexDefContext).indexType = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(5454)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserParserPROPERTIES {
		{
			p.SetState(5449)
			p.Match(DorisParserParserPROPERTIES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5450)
			p.Match(DorisParserParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5451)

			var _x = p.PropertyItemList()

			localctx.(*IndexDefContext).properties = _x
		}
		{
			p.SetState(5452)
			p.Match(DorisParserParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(5458)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserParserCOMMENT {
		{
			p.SetState(5456)
			p.Match(DorisParserParserCOMMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5457)

			var _m = p.Match(DorisParserParserSTRING_LITERAL)

			localctx.(*IndexDefContext).comment = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionsDefContext is an interface to support dynamic dispatch.
type IPartitionsDefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_partitionDef returns the _partitionDef rule contexts.
	Get_partitionDef() IPartitionDefContext

	// Set_partitionDef sets the _partitionDef rule contexts.
	Set_partitionDef(IPartitionDefContext)

	// GetPartitions returns the partitions rule context list.
	GetPartitions() []IPartitionDefContext

	// SetPartitions sets the partitions rule context list.
	SetPartitions([]IPartitionDefContext)

	// Getter signatures
	AllPartitionDef() []IPartitionDefContext
	PartitionDef(i int) IPartitionDefContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsPartitionsDefContext differentiates from other interfaces.
	IsPartitionsDefContext()
}

type PartitionsDefContext struct {
	antlr.BaseParserRuleContext
	parser        antlr.Parser
	_partitionDef IPartitionDefContext
	partitions    []IPartitionDefContext
}

func NewEmptyPartitionsDefContext() *PartitionsDefContext {
	var p = new(PartitionsDefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_partitionsDef
	return p
}

func InitEmptyPartitionsDefContext(p *PartitionsDefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_partitionsDef
}

func (*PartitionsDefContext) IsPartitionsDefContext() {}

func NewPartitionsDefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionsDefContext {
	var p = new(PartitionsDefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_partitionsDef

	return p
}

func (s *PartitionsDefContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionsDefContext) Get_partitionDef() IPartitionDefContext { return s._partitionDef }

func (s *PartitionsDefContext) Set_partitionDef(v IPartitionDefContext) { s._partitionDef = v }

func (s *PartitionsDefContext) GetPartitions() []IPartitionDefContext { return s.partitions }

func (s *PartitionsDefContext) SetPartitions(v []IPartitionDefContext) { s.partitions = v }

func (s *PartitionsDefContext) AllPartitionDef() []IPartitionDefContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionDefContext); ok {
			len++
		}
	}

	tst := make([]IPartitionDefContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionDefContext); ok {
			tst[i] = t.(IPartitionDefContext)
			i++
		}
	}

	return tst
}

func (s *PartitionsDefContext) PartitionDef(i int) IPartitionDefContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionDefContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionDefContext)
}

func (s *PartitionsDefContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserCOMMA)
}

func (s *PartitionsDefContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOMMA, i)
}

func (s *PartitionsDefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionsDefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionsDefContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitPartitionsDef(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) PartitionsDef() (localctx IPartitionsDefContext) {
	localctx = NewPartitionsDefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 342, DorisParserParserRULE_partitionsDef)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5460)

		var _x = p.PartitionDef()

		localctx.(*PartitionsDefContext)._partitionDef = _x
	}
	localctx.(*PartitionsDefContext).partitions = append(localctx.(*PartitionsDefContext).partitions, localctx.(*PartitionsDefContext)._partitionDef)
	p.SetState(5465)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisParserParserCOMMA {
		{
			p.SetState(5461)
			p.Match(DorisParserParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5462)

			var _x = p.PartitionDef()

			localctx.(*PartitionsDefContext)._partitionDef = _x
		}
		localctx.(*PartitionsDefContext).partitions = append(localctx.(*PartitionsDefContext).partitions, localctx.(*PartitionsDefContext)._partitionDef)

		p.SetState(5467)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionDefContext is an interface to support dynamic dispatch.
type IPartitionDefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPartitionProperties returns the partitionProperties rule contexts.
	GetPartitionProperties() IPropertyItemListContext

	// SetPartitionProperties sets the partitionProperties rule contexts.
	SetPartitionProperties(IPropertyItemListContext)

	// Getter signatures
	LessThanPartitionDef() ILessThanPartitionDefContext
	FixedPartitionDef() IFixedPartitionDefContext
	StepPartitionDef() IStepPartitionDefContext
	InPartitionDef() IInPartitionDefContext
	LEFT_PAREN() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode
	PropertyItemList() IPropertyItemListContext

	// IsPartitionDefContext differentiates from other interfaces.
	IsPartitionDefContext()
}

type PartitionDefContext struct {
	antlr.BaseParserRuleContext
	parser              antlr.Parser
	partitionProperties IPropertyItemListContext
}

func NewEmptyPartitionDefContext() *PartitionDefContext {
	var p = new(PartitionDefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_partitionDef
	return p
}

func InitEmptyPartitionDefContext(p *PartitionDefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_partitionDef
}

func (*PartitionDefContext) IsPartitionDefContext() {}

func NewPartitionDefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionDefContext {
	var p = new(PartitionDefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_partitionDef

	return p
}

func (s *PartitionDefContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionDefContext) GetPartitionProperties() IPropertyItemListContext {
	return s.partitionProperties
}

func (s *PartitionDefContext) SetPartitionProperties(v IPropertyItemListContext) {
	s.partitionProperties = v
}

func (s *PartitionDefContext) LessThanPartitionDef() ILessThanPartitionDefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILessThanPartitionDefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILessThanPartitionDefContext)
}

func (s *PartitionDefContext) FixedPartitionDef() IFixedPartitionDefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFixedPartitionDefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFixedPartitionDefContext)
}

func (s *PartitionDefContext) StepPartitionDef() IStepPartitionDefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStepPartitionDefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStepPartitionDefContext)
}

func (s *PartitionDefContext) InPartitionDef() IInPartitionDefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInPartitionDefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInPartitionDefContext)
}

func (s *PartitionDefContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLEFT_PAREN, 0)
}

func (s *PartitionDefContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRIGHT_PAREN, 0)
}

func (s *PartitionDefContext) PropertyItemList() IPropertyItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyItemListContext)
}

func (s *PartitionDefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionDefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionDefContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitPartitionDef(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) PartitionDef() (localctx IPartitionDefContext) {
	localctx = NewPartitionDefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 344, DorisParserParserRULE_partitionDef)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5472)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 789, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(5468)
			p.LessThanPartitionDef()
		}

	case 2:
		{
			p.SetState(5469)
			p.FixedPartitionDef()
		}

	case 3:
		{
			p.SetState(5470)
			p.StepPartitionDef()
		}

	case 4:
		{
			p.SetState(5471)
			p.InPartitionDef()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.SetState(5478)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserParserLEFT_PAREN {
		{
			p.SetState(5474)
			p.Match(DorisParserParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5475)

			var _x = p.PropertyItemList()

			localctx.(*PartitionDefContext).partitionProperties = _x
		}
		{
			p.SetState(5476)
			p.Match(DorisParserParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILessThanPartitionDefContext is an interface to support dynamic dispatch.
type ILessThanPartitionDefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPartitionName returns the partitionName rule contexts.
	GetPartitionName() IIdentifierContext

	// SetPartitionName sets the partitionName rule contexts.
	SetPartitionName(IIdentifierContext)

	// Getter signatures
	PARTITION() antlr.TerminalNode
	VALUES() antlr.TerminalNode
	LESS() antlr.TerminalNode
	THAN() antlr.TerminalNode
	Identifier() IIdentifierContext
	MAXVALUE() antlr.TerminalNode
	PartitionValueList() IPartitionValueListContext
	IF() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode

	// IsLessThanPartitionDefContext differentiates from other interfaces.
	IsLessThanPartitionDefContext()
}

type LessThanPartitionDefContext struct {
	antlr.BaseParserRuleContext
	parser        antlr.Parser
	partitionName IIdentifierContext
}

func NewEmptyLessThanPartitionDefContext() *LessThanPartitionDefContext {
	var p = new(LessThanPartitionDefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_lessThanPartitionDef
	return p
}

func InitEmptyLessThanPartitionDefContext(p *LessThanPartitionDefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_lessThanPartitionDef
}

func (*LessThanPartitionDefContext) IsLessThanPartitionDefContext() {}

func NewLessThanPartitionDefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LessThanPartitionDefContext {
	var p = new(LessThanPartitionDefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_lessThanPartitionDef

	return p
}

func (s *LessThanPartitionDefContext) GetParser() antlr.Parser { return s.parser }

func (s *LessThanPartitionDefContext) GetPartitionName() IIdentifierContext { return s.partitionName }

func (s *LessThanPartitionDefContext) SetPartitionName(v IIdentifierContext) { s.partitionName = v }

func (s *LessThanPartitionDefContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(DorisParserParserPARTITION, 0)
}

func (s *LessThanPartitionDefContext) VALUES() antlr.TerminalNode {
	return s.GetToken(DorisParserParserVALUES, 0)
}

func (s *LessThanPartitionDefContext) LESS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLESS, 0)
}

func (s *LessThanPartitionDefContext) THAN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserTHAN, 0)
}

func (s *LessThanPartitionDefContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *LessThanPartitionDefContext) MAXVALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserMAXVALUE, 0)
}

func (s *LessThanPartitionDefContext) PartitionValueList() IPartitionValueListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionValueListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionValueListContext)
}

func (s *LessThanPartitionDefContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserParserIF, 0)
}

func (s *LessThanPartitionDefContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserNOT, 0)
}

func (s *LessThanPartitionDefContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserEXISTS, 0)
}

func (s *LessThanPartitionDefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LessThanPartitionDefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LessThanPartitionDefContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitLessThanPartitionDef(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) LessThanPartitionDef() (localctx ILessThanPartitionDefContext) {
	localctx = NewLessThanPartitionDefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 346, DorisParserParserRULE_lessThanPartitionDef)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5480)
		p.Match(DorisParserParserPARTITION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5484)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserParserIF {
		{
			p.SetState(5481)
			p.Match(DorisParserParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5482)
			p.Match(DorisParserParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5483)
			p.Match(DorisParserParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(5486)

		var _x = p.Identifier()

		localctx.(*LessThanPartitionDefContext).partitionName = _x
	}
	{
		p.SetState(5487)
		p.Match(DorisParserParserVALUES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5488)
		p.Match(DorisParserParserLESS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5489)
		p.Match(DorisParserParserTHAN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5492)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserParserMAXVALUE:
		{
			p.SetState(5490)
			p.Match(DorisParserParserMAXVALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserParserLEFT_PAREN:
		{
			p.SetState(5491)
			p.PartitionValueList()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFixedPartitionDefContext is an interface to support dynamic dispatch.
type IFixedPartitionDefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPartitionName returns the partitionName rule contexts.
	GetPartitionName() IIdentifierContext

	// GetLower returns the lower rule contexts.
	GetLower() IPartitionValueListContext

	// GetUpper returns the upper rule contexts.
	GetUpper() IPartitionValueListContext

	// SetPartitionName sets the partitionName rule contexts.
	SetPartitionName(IIdentifierContext)

	// SetLower sets the lower rule contexts.
	SetLower(IPartitionValueListContext)

	// SetUpper sets the upper rule contexts.
	SetUpper(IPartitionValueListContext)

	// Getter signatures
	PARTITION() antlr.TerminalNode
	VALUES() antlr.TerminalNode
	LEFT_BRACKET() antlr.TerminalNode
	COMMA() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode
	Identifier() IIdentifierContext
	AllPartitionValueList() []IPartitionValueListContext
	PartitionValueList(i int) IPartitionValueListContext
	IF() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode

	// IsFixedPartitionDefContext differentiates from other interfaces.
	IsFixedPartitionDefContext()
}

type FixedPartitionDefContext struct {
	antlr.BaseParserRuleContext
	parser        antlr.Parser
	partitionName IIdentifierContext
	lower         IPartitionValueListContext
	upper         IPartitionValueListContext
}

func NewEmptyFixedPartitionDefContext() *FixedPartitionDefContext {
	var p = new(FixedPartitionDefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_fixedPartitionDef
	return p
}

func InitEmptyFixedPartitionDefContext(p *FixedPartitionDefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_fixedPartitionDef
}

func (*FixedPartitionDefContext) IsFixedPartitionDefContext() {}

func NewFixedPartitionDefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FixedPartitionDefContext {
	var p = new(FixedPartitionDefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_fixedPartitionDef

	return p
}

func (s *FixedPartitionDefContext) GetParser() antlr.Parser { return s.parser }

func (s *FixedPartitionDefContext) GetPartitionName() IIdentifierContext { return s.partitionName }

func (s *FixedPartitionDefContext) GetLower() IPartitionValueListContext { return s.lower }

func (s *FixedPartitionDefContext) GetUpper() IPartitionValueListContext { return s.upper }

func (s *FixedPartitionDefContext) SetPartitionName(v IIdentifierContext) { s.partitionName = v }

func (s *FixedPartitionDefContext) SetLower(v IPartitionValueListContext) { s.lower = v }

func (s *FixedPartitionDefContext) SetUpper(v IPartitionValueListContext) { s.upper = v }

func (s *FixedPartitionDefContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(DorisParserParserPARTITION, 0)
}

func (s *FixedPartitionDefContext) VALUES() antlr.TerminalNode {
	return s.GetToken(DorisParserParserVALUES, 0)
}

func (s *FixedPartitionDefContext) LEFT_BRACKET() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLEFT_BRACKET, 0)
}

func (s *FixedPartitionDefContext) COMMA() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOMMA, 0)
}

func (s *FixedPartitionDefContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRIGHT_PAREN, 0)
}

func (s *FixedPartitionDefContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *FixedPartitionDefContext) AllPartitionValueList() []IPartitionValueListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionValueListContext); ok {
			len++
		}
	}

	tst := make([]IPartitionValueListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionValueListContext); ok {
			tst[i] = t.(IPartitionValueListContext)
			i++
		}
	}

	return tst
}

func (s *FixedPartitionDefContext) PartitionValueList(i int) IPartitionValueListContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionValueListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionValueListContext)
}

func (s *FixedPartitionDefContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserParserIF, 0)
}

func (s *FixedPartitionDefContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserNOT, 0)
}

func (s *FixedPartitionDefContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserEXISTS, 0)
}

func (s *FixedPartitionDefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FixedPartitionDefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FixedPartitionDefContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitFixedPartitionDef(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) FixedPartitionDef() (localctx IFixedPartitionDefContext) {
	localctx = NewFixedPartitionDefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 348, DorisParserParserRULE_fixedPartitionDef)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5494)
		p.Match(DorisParserParserPARTITION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5498)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserParserIF {
		{
			p.SetState(5495)
			p.Match(DorisParserParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5496)
			p.Match(DorisParserParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5497)
			p.Match(DorisParserParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(5500)

		var _x = p.Identifier()

		localctx.(*FixedPartitionDefContext).partitionName = _x
	}
	{
		p.SetState(5501)
		p.Match(DorisParserParserVALUES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5502)
		p.Match(DorisParserParserLEFT_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5503)

		var _x = p.PartitionValueList()

		localctx.(*FixedPartitionDefContext).lower = _x
	}
	{
		p.SetState(5504)
		p.Match(DorisParserParserCOMMA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5505)

		var _x = p.PartitionValueList()

		localctx.(*FixedPartitionDefContext).upper = _x
	}
	{
		p.SetState(5506)
		p.Match(DorisParserParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStepPartitionDefContext is an interface to support dynamic dispatch.
type IStepPartitionDefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetUnitsAmount returns the unitsAmount token.
	GetUnitsAmount() antlr.Token

	// SetUnitsAmount sets the unitsAmount token.
	SetUnitsAmount(antlr.Token)

	// GetFrom returns the from rule contexts.
	GetFrom() IPartitionValueListContext

	// GetTo returns the to rule contexts.
	GetTo() IPartitionValueListContext

	// GetUnit returns the unit rule contexts.
	GetUnit() IUnitIdentifierContext

	// SetFrom sets the from rule contexts.
	SetFrom(IPartitionValueListContext)

	// SetTo sets the to rule contexts.
	SetTo(IPartitionValueListContext)

	// SetUnit sets the unit rule contexts.
	SetUnit(IUnitIdentifierContext)

	// Getter signatures
	FROM() antlr.TerminalNode
	TO() antlr.TerminalNode
	INTERVAL() antlr.TerminalNode
	AllPartitionValueList() []IPartitionValueListContext
	PartitionValueList(i int) IPartitionValueListContext
	INTEGER_VALUE() antlr.TerminalNode
	UnitIdentifier() IUnitIdentifierContext

	// IsStepPartitionDefContext differentiates from other interfaces.
	IsStepPartitionDefContext()
}

type StepPartitionDefContext struct {
	antlr.BaseParserRuleContext
	parser      antlr.Parser
	from        IPartitionValueListContext
	to          IPartitionValueListContext
	unitsAmount antlr.Token
	unit        IUnitIdentifierContext
}

func NewEmptyStepPartitionDefContext() *StepPartitionDefContext {
	var p = new(StepPartitionDefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_stepPartitionDef
	return p
}

func InitEmptyStepPartitionDefContext(p *StepPartitionDefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_stepPartitionDef
}

func (*StepPartitionDefContext) IsStepPartitionDefContext() {}

func NewStepPartitionDefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StepPartitionDefContext {
	var p = new(StepPartitionDefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_stepPartitionDef

	return p
}

func (s *StepPartitionDefContext) GetParser() antlr.Parser { return s.parser }

func (s *StepPartitionDefContext) GetUnitsAmount() antlr.Token { return s.unitsAmount }

func (s *StepPartitionDefContext) SetUnitsAmount(v antlr.Token) { s.unitsAmount = v }

func (s *StepPartitionDefContext) GetFrom() IPartitionValueListContext { return s.from }

func (s *StepPartitionDefContext) GetTo() IPartitionValueListContext { return s.to }

func (s *StepPartitionDefContext) GetUnit() IUnitIdentifierContext { return s.unit }

func (s *StepPartitionDefContext) SetFrom(v IPartitionValueListContext) { s.from = v }

func (s *StepPartitionDefContext) SetTo(v IPartitionValueListContext) { s.to = v }

func (s *StepPartitionDefContext) SetUnit(v IUnitIdentifierContext) { s.unit = v }

func (s *StepPartitionDefContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFROM, 0)
}

func (s *StepPartitionDefContext) TO() antlr.TerminalNode {
	return s.GetToken(DorisParserParserTO, 0)
}

func (s *StepPartitionDefContext) INTERVAL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserINTERVAL, 0)
}

func (s *StepPartitionDefContext) AllPartitionValueList() []IPartitionValueListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionValueListContext); ok {
			len++
		}
	}

	tst := make([]IPartitionValueListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionValueListContext); ok {
			tst[i] = t.(IPartitionValueListContext)
			i++
		}
	}

	return tst
}

func (s *StepPartitionDefContext) PartitionValueList(i int) IPartitionValueListContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionValueListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionValueListContext)
}

func (s *StepPartitionDefContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserINTEGER_VALUE, 0)
}

func (s *StepPartitionDefContext) UnitIdentifier() IUnitIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnitIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnitIdentifierContext)
}

func (s *StepPartitionDefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StepPartitionDefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StepPartitionDefContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitStepPartitionDef(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) StepPartitionDef() (localctx IStepPartitionDefContext) {
	localctx = NewStepPartitionDefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 350, DorisParserParserRULE_stepPartitionDef)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5508)
		p.Match(DorisParserParserFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5509)

		var _x = p.PartitionValueList()

		localctx.(*StepPartitionDefContext).from = _x
	}
	{
		p.SetState(5510)
		p.Match(DorisParserParserTO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5511)

		var _x = p.PartitionValueList()

		localctx.(*StepPartitionDefContext).to = _x
	}
	{
		p.SetState(5512)
		p.Match(DorisParserParserINTERVAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5513)

		var _m = p.Match(DorisParserParserINTEGER_VALUE)

		localctx.(*StepPartitionDefContext).unitsAmount = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5515)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserParserDAY || _la == DorisParserParserHOUR || _la == DorisParserParserMINUTE || _la == DorisParserParserMONTH || _la == DorisParserParserQUARTER || _la == DorisParserParserSECOND || _la == DorisParserParserWEEK || _la == DorisParserParserYEAR {
		{
			p.SetState(5514)

			var _x = p.UnitIdentifier()

			localctx.(*StepPartitionDefContext).unit = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInPartitionDefContext is an interface to support dynamic dispatch.
type IInPartitionDefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPartitionName returns the partitionName rule contexts.
	GetPartitionName() IIdentifierContext

	// Get_partitionValueList returns the _partitionValueList rule contexts.
	Get_partitionValueList() IPartitionValueListContext

	// GetConstants returns the constants rule contexts.
	GetConstants() IPartitionValueListContext

	// SetPartitionName sets the partitionName rule contexts.
	SetPartitionName(IIdentifierContext)

	// Set_partitionValueList sets the _partitionValueList rule contexts.
	Set_partitionValueList(IPartitionValueListContext)

	// SetConstants sets the constants rule contexts.
	SetConstants(IPartitionValueListContext)

	// GetPartitionValueLists returns the partitionValueLists rule context list.
	GetPartitionValueLists() []IPartitionValueListContext

	// SetPartitionValueLists sets the partitionValueLists rule context list.
	SetPartitionValueLists([]IPartitionValueListContext)

	// Getter signatures
	PARTITION() antlr.TerminalNode
	Identifier() IIdentifierContext
	IF() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	VALUES() antlr.TerminalNode
	IN() antlr.TerminalNode
	AllPartitionValueList() []IPartitionValueListContext
	PartitionValueList(i int) IPartitionValueListContext
	LEFT_PAREN() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsInPartitionDefContext differentiates from other interfaces.
	IsInPartitionDefContext()
}

type InPartitionDefContext struct {
	antlr.BaseParserRuleContext
	parser              antlr.Parser
	partitionName       IIdentifierContext
	_partitionValueList IPartitionValueListContext
	partitionValueLists []IPartitionValueListContext
	constants           IPartitionValueListContext
}

func NewEmptyInPartitionDefContext() *InPartitionDefContext {
	var p = new(InPartitionDefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_inPartitionDef
	return p
}

func InitEmptyInPartitionDefContext(p *InPartitionDefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_inPartitionDef
}

func (*InPartitionDefContext) IsInPartitionDefContext() {}

func NewInPartitionDefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InPartitionDefContext {
	var p = new(InPartitionDefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_inPartitionDef

	return p
}

func (s *InPartitionDefContext) GetParser() antlr.Parser { return s.parser }

func (s *InPartitionDefContext) GetPartitionName() IIdentifierContext { return s.partitionName }

func (s *InPartitionDefContext) Get_partitionValueList() IPartitionValueListContext {
	return s._partitionValueList
}

func (s *InPartitionDefContext) GetConstants() IPartitionValueListContext { return s.constants }

func (s *InPartitionDefContext) SetPartitionName(v IIdentifierContext) { s.partitionName = v }

func (s *InPartitionDefContext) Set_partitionValueList(v IPartitionValueListContext) {
	s._partitionValueList = v
}

func (s *InPartitionDefContext) SetConstants(v IPartitionValueListContext) { s.constants = v }

func (s *InPartitionDefContext) GetPartitionValueLists() []IPartitionValueListContext {
	return s.partitionValueLists
}

func (s *InPartitionDefContext) SetPartitionValueLists(v []IPartitionValueListContext) {
	s.partitionValueLists = v
}

func (s *InPartitionDefContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(DorisParserParserPARTITION, 0)
}

func (s *InPartitionDefContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *InPartitionDefContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserParserIF, 0)
}

func (s *InPartitionDefContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserNOT, 0)
}

func (s *InPartitionDefContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserEXISTS, 0)
}

func (s *InPartitionDefContext) VALUES() antlr.TerminalNode {
	return s.GetToken(DorisParserParserVALUES, 0)
}

func (s *InPartitionDefContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserIN, 0)
}

func (s *InPartitionDefContext) AllPartitionValueList() []IPartitionValueListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionValueListContext); ok {
			len++
		}
	}

	tst := make([]IPartitionValueListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionValueListContext); ok {
			tst[i] = t.(IPartitionValueListContext)
			i++
		}
	}

	return tst
}

func (s *InPartitionDefContext) PartitionValueList(i int) IPartitionValueListContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionValueListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionValueListContext)
}

func (s *InPartitionDefContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLEFT_PAREN, 0)
}

func (s *InPartitionDefContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRIGHT_PAREN, 0)
}

func (s *InPartitionDefContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserCOMMA)
}

func (s *InPartitionDefContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOMMA, i)
}

func (s *InPartitionDefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InPartitionDefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InPartitionDefContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitInPartitionDef(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) InPartitionDef() (localctx IInPartitionDefContext) {
	localctx = NewInPartitionDefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 352, DorisParserParserRULE_inPartitionDef)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5517)
		p.Match(DorisParserParserPARTITION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5521)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserParserIF {
		{
			p.SetState(5518)
			p.Match(DorisParserParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5519)
			p.Match(DorisParserParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5520)
			p.Match(DorisParserParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(5523)

		var _x = p.Identifier()

		localctx.(*InPartitionDefContext).partitionName = _x
	}
	p.SetState(5540)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserParserVALUES {
		{
			p.SetState(5524)
			p.Match(DorisParserParserVALUES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5525)
			p.Match(DorisParserParserIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5538)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 797, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(5526)
				p.Match(DorisParserParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5527)

				var _x = p.PartitionValueList()

				localctx.(*InPartitionDefContext)._partitionValueList = _x
			}
			localctx.(*InPartitionDefContext).partitionValueLists = append(localctx.(*InPartitionDefContext).partitionValueLists, localctx.(*InPartitionDefContext)._partitionValueList)
			p.SetState(5532)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == DorisParserParserCOMMA {
				{
					p.SetState(5528)
					p.Match(DorisParserParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(5529)

					var _x = p.PartitionValueList()

					localctx.(*InPartitionDefContext)._partitionValueList = _x
				}
				localctx.(*InPartitionDefContext).partitionValueLists = append(localctx.(*InPartitionDefContext).partitionValueLists, localctx.(*InPartitionDefContext)._partitionValueList)

				p.SetState(5534)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(5535)
				p.Match(DorisParserParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 2:
			{
				p.SetState(5537)

				var _x = p.PartitionValueList()

				localctx.(*InPartitionDefContext).constants = _x
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionValueListContext is an interface to support dynamic dispatch.
type IPartitionValueListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_partitionValueDef returns the _partitionValueDef rule contexts.
	Get_partitionValueDef() IPartitionValueDefContext

	// Set_partitionValueDef sets the _partitionValueDef rule contexts.
	Set_partitionValueDef(IPartitionValueDefContext)

	// GetValues returns the values rule context list.
	GetValues() []IPartitionValueDefContext

	// SetValues sets the values rule context list.
	SetValues([]IPartitionValueDefContext)

	// Getter signatures
	LEFT_PAREN() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode
	AllPartitionValueDef() []IPartitionValueDefContext
	PartitionValueDef(i int) IPartitionValueDefContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsPartitionValueListContext differentiates from other interfaces.
	IsPartitionValueListContext()
}

type PartitionValueListContext struct {
	antlr.BaseParserRuleContext
	parser             antlr.Parser
	_partitionValueDef IPartitionValueDefContext
	values             []IPartitionValueDefContext
}

func NewEmptyPartitionValueListContext() *PartitionValueListContext {
	var p = new(PartitionValueListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_partitionValueList
	return p
}

func InitEmptyPartitionValueListContext(p *PartitionValueListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_partitionValueList
}

func (*PartitionValueListContext) IsPartitionValueListContext() {}

func NewPartitionValueListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionValueListContext {
	var p = new(PartitionValueListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_partitionValueList

	return p
}

func (s *PartitionValueListContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionValueListContext) Get_partitionValueDef() IPartitionValueDefContext {
	return s._partitionValueDef
}

func (s *PartitionValueListContext) Set_partitionValueDef(v IPartitionValueDefContext) {
	s._partitionValueDef = v
}

func (s *PartitionValueListContext) GetValues() []IPartitionValueDefContext { return s.values }

func (s *PartitionValueListContext) SetValues(v []IPartitionValueDefContext) { s.values = v }

func (s *PartitionValueListContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLEFT_PAREN, 0)
}

func (s *PartitionValueListContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRIGHT_PAREN, 0)
}

func (s *PartitionValueListContext) AllPartitionValueDef() []IPartitionValueDefContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionValueDefContext); ok {
			len++
		}
	}

	tst := make([]IPartitionValueDefContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionValueDefContext); ok {
			tst[i] = t.(IPartitionValueDefContext)
			i++
		}
	}

	return tst
}

func (s *PartitionValueListContext) PartitionValueDef(i int) IPartitionValueDefContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionValueDefContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionValueDefContext)
}

func (s *PartitionValueListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserCOMMA)
}

func (s *PartitionValueListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOMMA, i)
}

func (s *PartitionValueListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionValueListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionValueListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitPartitionValueList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) PartitionValueList() (localctx IPartitionValueListContext) {
	localctx = NewPartitionValueListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 354, DorisParserParserRULE_partitionValueList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5542)
		p.Match(DorisParserParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5543)

		var _x = p.PartitionValueDef()

		localctx.(*PartitionValueListContext)._partitionValueDef = _x
	}
	localctx.(*PartitionValueListContext).values = append(localctx.(*PartitionValueListContext).values, localctx.(*PartitionValueListContext)._partitionValueDef)
	p.SetState(5548)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisParserParserCOMMA {
		{
			p.SetState(5544)
			p.Match(DorisParserParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5545)

			var _x = p.PartitionValueDef()

			localctx.(*PartitionValueListContext)._partitionValueDef = _x
		}
		localctx.(*PartitionValueListContext).values = append(localctx.(*PartitionValueListContext).values, localctx.(*PartitionValueListContext)._partitionValueDef)

		p.SetState(5550)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(5551)
		p.Match(DorisParserParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionValueDefContext is an interface to support dynamic dispatch.
type IPartitionValueDefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INTEGER_VALUE() antlr.TerminalNode
	SUBTRACT() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode
	MAXVALUE() antlr.TerminalNode
	NULL() antlr.TerminalNode

	// IsPartitionValueDefContext differentiates from other interfaces.
	IsPartitionValueDefContext()
}

type PartitionValueDefContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionValueDefContext() *PartitionValueDefContext {
	var p = new(PartitionValueDefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_partitionValueDef
	return p
}

func InitEmptyPartitionValueDefContext(p *PartitionValueDefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_partitionValueDef
}

func (*PartitionValueDefContext) IsPartitionValueDefContext() {}

func NewPartitionValueDefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionValueDefContext {
	var p = new(PartitionValueDefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_partitionValueDef

	return p
}

func (s *PartitionValueDefContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionValueDefContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserINTEGER_VALUE, 0)
}

func (s *PartitionValueDefContext) SUBTRACT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSUBTRACT, 0)
}

func (s *PartitionValueDefContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTRING_LITERAL, 0)
}

func (s *PartitionValueDefContext) MAXVALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserMAXVALUE, 0)
}

func (s *PartitionValueDefContext) NULL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserNULL, 0)
}

func (s *PartitionValueDefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionValueDefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionValueDefContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitPartitionValueDef(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) PartitionValueDef() (localctx IPartitionValueDefContext) {
	localctx = NewPartitionValueDefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 356, DorisParserParserRULE_partitionValueDef)
	var _la int

	p.SetState(5560)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserParserSUBTRACT, DorisParserParserINTEGER_VALUE:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(5554)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserSUBTRACT {
			{
				p.SetState(5553)
				p.Match(DorisParserParserSUBTRACT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(5556)
			p.Match(DorisParserParserINTEGER_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserParserSTRING_LITERAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5557)
			p.Match(DorisParserParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserParserMAXVALUE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5558)
			p.Match(DorisParserParserMAXVALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserParserNULL:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5559)
			p.Match(DorisParserParserNULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRollupDefsContext is an interface to support dynamic dispatch.
type IRollupDefsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_rollupDef returns the _rollupDef rule contexts.
	Get_rollupDef() IRollupDefContext

	// Set_rollupDef sets the _rollupDef rule contexts.
	Set_rollupDef(IRollupDefContext)

	// GetRollups returns the rollups rule context list.
	GetRollups() []IRollupDefContext

	// SetRollups sets the rollups rule context list.
	SetRollups([]IRollupDefContext)

	// Getter signatures
	AllRollupDef() []IRollupDefContext
	RollupDef(i int) IRollupDefContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsRollupDefsContext differentiates from other interfaces.
	IsRollupDefsContext()
}

type RollupDefsContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	_rollupDef IRollupDefContext
	rollups    []IRollupDefContext
}

func NewEmptyRollupDefsContext() *RollupDefsContext {
	var p = new(RollupDefsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_rollupDefs
	return p
}

func InitEmptyRollupDefsContext(p *RollupDefsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_rollupDefs
}

func (*RollupDefsContext) IsRollupDefsContext() {}

func NewRollupDefsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RollupDefsContext {
	var p = new(RollupDefsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_rollupDefs

	return p
}

func (s *RollupDefsContext) GetParser() antlr.Parser { return s.parser }

func (s *RollupDefsContext) Get_rollupDef() IRollupDefContext { return s._rollupDef }

func (s *RollupDefsContext) Set_rollupDef(v IRollupDefContext) { s._rollupDef = v }

func (s *RollupDefsContext) GetRollups() []IRollupDefContext { return s.rollups }

func (s *RollupDefsContext) SetRollups(v []IRollupDefContext) { s.rollups = v }

func (s *RollupDefsContext) AllRollupDef() []IRollupDefContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRollupDefContext); ok {
			len++
		}
	}

	tst := make([]IRollupDefContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRollupDefContext); ok {
			tst[i] = t.(IRollupDefContext)
			i++
		}
	}

	return tst
}

func (s *RollupDefsContext) RollupDef(i int) IRollupDefContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRollupDefContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRollupDefContext)
}

func (s *RollupDefsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserCOMMA)
}

func (s *RollupDefsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOMMA, i)
}

func (s *RollupDefsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RollupDefsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RollupDefsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitRollupDefs(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) RollupDefs() (localctx IRollupDefsContext) {
	localctx = NewRollupDefsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 358, DorisParserParserRULE_rollupDefs)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5562)

		var _x = p.RollupDef()

		localctx.(*RollupDefsContext)._rollupDef = _x
	}
	localctx.(*RollupDefsContext).rollups = append(localctx.(*RollupDefsContext).rollups, localctx.(*RollupDefsContext)._rollupDef)
	p.SetState(5567)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisParserParserCOMMA {
		{
			p.SetState(5563)
			p.Match(DorisParserParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5564)

			var _x = p.RollupDef()

			localctx.(*RollupDefsContext)._rollupDef = _x
		}
		localctx.(*RollupDefsContext).rollups = append(localctx.(*RollupDefsContext).rollups, localctx.(*RollupDefsContext)._rollupDef)

		p.SetState(5569)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRollupDefContext is an interface to support dynamic dispatch.
type IRollupDefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetRollupName returns the rollupName rule contexts.
	GetRollupName() IIdentifierContext

	// GetRollupCols returns the rollupCols rule contexts.
	GetRollupCols() IIdentifierListContext

	// GetDupKeys returns the dupKeys rule contexts.
	GetDupKeys() IIdentifierListContext

	// GetProperties returns the properties rule contexts.
	GetProperties() IPropertyClauseContext

	// SetRollupName sets the rollupName rule contexts.
	SetRollupName(IIdentifierContext)

	// SetRollupCols sets the rollupCols rule contexts.
	SetRollupCols(IIdentifierListContext)

	// SetDupKeys sets the dupKeys rule contexts.
	SetDupKeys(IIdentifierListContext)

	// SetProperties sets the properties rule contexts.
	SetProperties(IPropertyClauseContext)

	// Getter signatures
	Identifier() IIdentifierContext
	AllIdentifierList() []IIdentifierListContext
	IdentifierList(i int) IIdentifierListContext
	DUPLICATE() antlr.TerminalNode
	KEY() antlr.TerminalNode
	PropertyClause() IPropertyClauseContext

	// IsRollupDefContext differentiates from other interfaces.
	IsRollupDefContext()
}

type RollupDefContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	rollupName IIdentifierContext
	rollupCols IIdentifierListContext
	dupKeys    IIdentifierListContext
	properties IPropertyClauseContext
}

func NewEmptyRollupDefContext() *RollupDefContext {
	var p = new(RollupDefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_rollupDef
	return p
}

func InitEmptyRollupDefContext(p *RollupDefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_rollupDef
}

func (*RollupDefContext) IsRollupDefContext() {}

func NewRollupDefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RollupDefContext {
	var p = new(RollupDefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_rollupDef

	return p
}

func (s *RollupDefContext) GetParser() antlr.Parser { return s.parser }

func (s *RollupDefContext) GetRollupName() IIdentifierContext { return s.rollupName }

func (s *RollupDefContext) GetRollupCols() IIdentifierListContext { return s.rollupCols }

func (s *RollupDefContext) GetDupKeys() IIdentifierListContext { return s.dupKeys }

func (s *RollupDefContext) GetProperties() IPropertyClauseContext { return s.properties }

func (s *RollupDefContext) SetRollupName(v IIdentifierContext) { s.rollupName = v }

func (s *RollupDefContext) SetRollupCols(v IIdentifierListContext) { s.rollupCols = v }

func (s *RollupDefContext) SetDupKeys(v IIdentifierListContext) { s.dupKeys = v }

func (s *RollupDefContext) SetProperties(v IPropertyClauseContext) { s.properties = v }

func (s *RollupDefContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *RollupDefContext) AllIdentifierList() []IIdentifierListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierListContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierListContext); ok {
			tst[i] = t.(IIdentifierListContext)
			i++
		}
	}

	return tst
}

func (s *RollupDefContext) IdentifierList(i int) IIdentifierListContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *RollupDefContext) DUPLICATE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDUPLICATE, 0)
}

func (s *RollupDefContext) KEY() antlr.TerminalNode {
	return s.GetToken(DorisParserParserKEY, 0)
}

func (s *RollupDefContext) PropertyClause() IPropertyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyClauseContext)
}

func (s *RollupDefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RollupDefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RollupDefContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitRollupDef(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) RollupDef() (localctx IRollupDefContext) {
	localctx = NewRollupDefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 360, DorisParserParserRULE_rollupDef)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5570)

		var _x = p.Identifier()

		localctx.(*RollupDefContext).rollupName = _x
	}
	{
		p.SetState(5571)

		var _x = p.IdentifierList()

		localctx.(*RollupDefContext).rollupCols = _x
	}
	p.SetState(5575)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserParserDUPLICATE {
		{
			p.SetState(5572)
			p.Match(DorisParserParserDUPLICATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5573)
			p.Match(DorisParserParserKEY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5574)

			var _x = p.IdentifierList()

			localctx.(*RollupDefContext).dupKeys = _x
		}

	}
	p.SetState(5578)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserParserPROPERTIES {
		{
			p.SetState(5577)

			var _x = p.PropertyClause()

			localctx.(*RollupDefContext).properties = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAggTypeDefContext is an interface to support dynamic dispatch.
type IAggTypeDefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MAX() antlr.TerminalNode
	MIN() antlr.TerminalNode
	SUM() antlr.TerminalNode
	REPLACE() antlr.TerminalNode
	REPLACE_IF_NOT_NULL() antlr.TerminalNode
	HLL_UNION() antlr.TerminalNode
	BITMAP_UNION() antlr.TerminalNode
	QUANTILE_UNION() antlr.TerminalNode
	GENERIC() antlr.TerminalNode

	// IsAggTypeDefContext differentiates from other interfaces.
	IsAggTypeDefContext()
}

type AggTypeDefContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAggTypeDefContext() *AggTypeDefContext {
	var p = new(AggTypeDefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_aggTypeDef
	return p
}

func InitEmptyAggTypeDefContext(p *AggTypeDefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_aggTypeDef
}

func (*AggTypeDefContext) IsAggTypeDefContext() {}

func NewAggTypeDefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AggTypeDefContext {
	var p = new(AggTypeDefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_aggTypeDef

	return p
}

func (s *AggTypeDefContext) GetParser() antlr.Parser { return s.parser }

func (s *AggTypeDefContext) MAX() antlr.TerminalNode {
	return s.GetToken(DorisParserParserMAX, 0)
}

func (s *AggTypeDefContext) MIN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserMIN, 0)
}

func (s *AggTypeDefContext) SUM() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSUM, 0)
}

func (s *AggTypeDefContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserREPLACE, 0)
}

func (s *AggTypeDefContext) REPLACE_IF_NOT_NULL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserREPLACE_IF_NOT_NULL, 0)
}

func (s *AggTypeDefContext) HLL_UNION() antlr.TerminalNode {
	return s.GetToken(DorisParserParserHLL_UNION, 0)
}

func (s *AggTypeDefContext) BITMAP_UNION() antlr.TerminalNode {
	return s.GetToken(DorisParserParserBITMAP_UNION, 0)
}

func (s *AggTypeDefContext) QUANTILE_UNION() antlr.TerminalNode {
	return s.GetToken(DorisParserParserQUANTILE_UNION, 0)
}

func (s *AggTypeDefContext) GENERIC() antlr.TerminalNode {
	return s.GetToken(DorisParserParserGENERIC, 0)
}

func (s *AggTypeDefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AggTypeDefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AggTypeDefContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitAggTypeDef(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) AggTypeDef() (localctx IAggTypeDefContext) {
	localctx = NewAggTypeDefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 362, DorisParserParserRULE_aggTypeDef)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5580)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisParserParserBITMAP_UNION || _la == DorisParserParserGENERIC || _la == DorisParserParserHLL_UNION || _la == DorisParserParserMAX || _la == DorisParserParserMIN || ((int64((_la-362)) & ^0x3f) == 0 && ((int64(1)<<(_la-362))&6291457) != 0) || _la == DorisParserParserSUM) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITabletListContext is an interface to support dynamic dispatch.
type ITabletListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_INTEGER_VALUE returns the _INTEGER_VALUE token.
	Get_INTEGER_VALUE() antlr.Token

	// Set_INTEGER_VALUE sets the _INTEGER_VALUE token.
	Set_INTEGER_VALUE(antlr.Token)

	// GetTabletIdList returns the tabletIdList token list.
	GetTabletIdList() []antlr.Token

	// SetTabletIdList sets the tabletIdList token list.
	SetTabletIdList([]antlr.Token)

	// Getter signatures
	TABLET() antlr.TerminalNode
	LEFT_PAREN() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode
	AllINTEGER_VALUE() []antlr.TerminalNode
	INTEGER_VALUE(i int) antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsTabletListContext differentiates from other interfaces.
	IsTabletListContext()
}

type TabletListContext struct {
	antlr.BaseParserRuleContext
	parser         antlr.Parser
	_INTEGER_VALUE antlr.Token
	tabletIdList   []antlr.Token
}

func NewEmptyTabletListContext() *TabletListContext {
	var p = new(TabletListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_tabletList
	return p
}

func InitEmptyTabletListContext(p *TabletListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_tabletList
}

func (*TabletListContext) IsTabletListContext() {}

func NewTabletListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TabletListContext {
	var p = new(TabletListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_tabletList

	return p
}

func (s *TabletListContext) GetParser() antlr.Parser { return s.parser }

func (s *TabletListContext) Get_INTEGER_VALUE() antlr.Token { return s._INTEGER_VALUE }

func (s *TabletListContext) Set_INTEGER_VALUE(v antlr.Token) { s._INTEGER_VALUE = v }

func (s *TabletListContext) GetTabletIdList() []antlr.Token { return s.tabletIdList }

func (s *TabletListContext) SetTabletIdList(v []antlr.Token) { s.tabletIdList = v }

func (s *TabletListContext) TABLET() antlr.TerminalNode {
	return s.GetToken(DorisParserParserTABLET, 0)
}

func (s *TabletListContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLEFT_PAREN, 0)
}

func (s *TabletListContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRIGHT_PAREN, 0)
}

func (s *TabletListContext) AllINTEGER_VALUE() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserINTEGER_VALUE)
}

func (s *TabletListContext) INTEGER_VALUE(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserINTEGER_VALUE, i)
}

func (s *TabletListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserCOMMA)
}

func (s *TabletListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOMMA, i)
}

func (s *TabletListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TabletListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TabletListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitTabletList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) TabletList() (localctx ITabletListContext) {
	localctx = NewTabletListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 364, DorisParserParserRULE_tabletList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5582)
		p.Match(DorisParserParserTABLET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5583)
		p.Match(DorisParserParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5584)

		var _m = p.Match(DorisParserParserINTEGER_VALUE)

		localctx.(*TabletListContext)._INTEGER_VALUE = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	localctx.(*TabletListContext).tabletIdList = append(localctx.(*TabletListContext).tabletIdList, localctx.(*TabletListContext)._INTEGER_VALUE)
	p.SetState(5589)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisParserParserCOMMA {
		{
			p.SetState(5585)
			p.Match(DorisParserParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5586)

			var _m = p.Match(DorisParserParserINTEGER_VALUE)

			localctx.(*TabletListContext)._INTEGER_VALUE = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*TabletListContext).tabletIdList = append(localctx.(*TabletListContext).tabletIdList, localctx.(*TabletListContext)._INTEGER_VALUE)

		p.SetState(5591)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(5592)
		p.Match(DorisParserParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInlineTableContext is an interface to support dynamic dispatch.
type IInlineTableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VALUES() antlr.TerminalNode
	AllRowConstructor() []IRowConstructorContext
	RowConstructor(i int) IRowConstructorContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsInlineTableContext differentiates from other interfaces.
	IsInlineTableContext()
}

type InlineTableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInlineTableContext() *InlineTableContext {
	var p = new(InlineTableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_inlineTable
	return p
}

func InitEmptyInlineTableContext(p *InlineTableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_inlineTable
}

func (*InlineTableContext) IsInlineTableContext() {}

func NewInlineTableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InlineTableContext {
	var p = new(InlineTableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_inlineTable

	return p
}

func (s *InlineTableContext) GetParser() antlr.Parser { return s.parser }

func (s *InlineTableContext) VALUES() antlr.TerminalNode {
	return s.GetToken(DorisParserParserVALUES, 0)
}

func (s *InlineTableContext) AllRowConstructor() []IRowConstructorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRowConstructorContext); ok {
			len++
		}
	}

	tst := make([]IRowConstructorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRowConstructorContext); ok {
			tst[i] = t.(IRowConstructorContext)
			i++
		}
	}

	return tst
}

func (s *InlineTableContext) RowConstructor(i int) IRowConstructorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRowConstructorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRowConstructorContext)
}

func (s *InlineTableContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserCOMMA)
}

func (s *InlineTableContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOMMA, i)
}

func (s *InlineTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InlineTableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InlineTableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitInlineTable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) InlineTable() (localctx IInlineTableContext) {
	localctx = NewInlineTableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 366, DorisParserParserRULE_inlineTable)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5594)
		p.Match(DorisParserParserVALUES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5595)
		p.RowConstructor()
	}
	p.SetState(5600)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 806, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(5596)
				p.Match(DorisParserParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5597)
				p.RowConstructor()
			}

		}
		p.SetState(5602)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 806, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INamedExpressionContext is an interface to support dynamic dispatch.
type INamedExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext
	IdentifierOrText() IIdentifierOrTextContext
	AS() antlr.TerminalNode

	// IsNamedExpressionContext differentiates from other interfaces.
	IsNamedExpressionContext()
}

type NamedExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamedExpressionContext() *NamedExpressionContext {
	var p = new(NamedExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_namedExpression
	return p
}

func InitEmptyNamedExpressionContext(p *NamedExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_namedExpression
}

func (*NamedExpressionContext) IsNamedExpressionContext() {}

func NewNamedExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamedExpressionContext {
	var p = new(NamedExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_namedExpression

	return p
}

func (s *NamedExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *NamedExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *NamedExpressionContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *NamedExpressionContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserAS, 0)
}

func (s *NamedExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamedExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NamedExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitNamedExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) NamedExpression() (localctx INamedExpressionContext) {
	localctx = NewNamedExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 368, DorisParserParserRULE_namedExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5603)
		p.Expression()
	}
	p.SetState(5608)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 808, p.GetParserRuleContext()) == 1 {
		p.SetState(5605)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserAS {
			{
				p.SetState(5604)
				p.Match(DorisParserParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

		{
			p.SetState(5607)
			p.IdentifierOrText()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INamedExpressionSeqContext is an interface to support dynamic dispatch.
type INamedExpressionSeqContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllNamedExpression() []INamedExpressionContext
	NamedExpression(i int) INamedExpressionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsNamedExpressionSeqContext differentiates from other interfaces.
	IsNamedExpressionSeqContext()
}

type NamedExpressionSeqContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamedExpressionSeqContext() *NamedExpressionSeqContext {
	var p = new(NamedExpressionSeqContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_namedExpressionSeq
	return p
}

func InitEmptyNamedExpressionSeqContext(p *NamedExpressionSeqContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_namedExpressionSeq
}

func (*NamedExpressionSeqContext) IsNamedExpressionSeqContext() {}

func NewNamedExpressionSeqContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamedExpressionSeqContext {
	var p = new(NamedExpressionSeqContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_namedExpressionSeq

	return p
}

func (s *NamedExpressionSeqContext) GetParser() antlr.Parser { return s.parser }

func (s *NamedExpressionSeqContext) AllNamedExpression() []INamedExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INamedExpressionContext); ok {
			len++
		}
	}

	tst := make([]INamedExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INamedExpressionContext); ok {
			tst[i] = t.(INamedExpressionContext)
			i++
		}
	}

	return tst
}

func (s *NamedExpressionSeqContext) NamedExpression(i int) INamedExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamedExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamedExpressionContext)
}

func (s *NamedExpressionSeqContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserCOMMA)
}

func (s *NamedExpressionSeqContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOMMA, i)
}

func (s *NamedExpressionSeqContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamedExpressionSeqContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NamedExpressionSeqContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitNamedExpressionSeq(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) NamedExpressionSeq() (localctx INamedExpressionSeqContext) {
	localctx = NewNamedExpressionSeqContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 370, DorisParserParserRULE_namedExpressionSeq)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5610)
		p.NamedExpression()
	}
	p.SetState(5615)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 809, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(5611)
				p.Match(DorisParserParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5612)
				p.NamedExpression()
			}

		}
		p.SetState(5617)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 809, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpressionContext is an interface to support dynamic dispatch.
type IExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BooleanExpression() IBooleanExpressionContext
	LambdaExpression() ILambdaExpressionContext

	// IsExpressionContext differentiates from other interfaces.
	IsExpressionContext()
}

type ExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionContext() *ExpressionContext {
	var p = new(ExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_expression
	return p
}

func InitEmptyExpressionContext(p *ExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_expression
}

func (*ExpressionContext) IsExpressionContext() {}

func NewExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionContext {
	var p = new(ExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_expression

	return p
}

func (s *ExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionContext) BooleanExpression() IBooleanExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *ExpressionContext) LambdaExpression() ILambdaExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILambdaExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILambdaExpressionContext)
}

func (s *ExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) Expression() (localctx IExpressionContext) {
	localctx = NewExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 372, DorisParserParserRULE_expression)
	p.SetState(5620)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 810, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5618)
			p.booleanExpression(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5619)
			p.LambdaExpression()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILambdaExpressionContext is an interface to support dynamic dispatch.
type ILambdaExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_errorCapturingIdentifier returns the _errorCapturingIdentifier rule contexts.
	Get_errorCapturingIdentifier() IErrorCapturingIdentifierContext

	// GetBody returns the body rule contexts.
	GetBody() IBooleanExpressionContext

	// Set_errorCapturingIdentifier sets the _errorCapturingIdentifier rule contexts.
	Set_errorCapturingIdentifier(IErrorCapturingIdentifierContext)

	// SetBody sets the body rule contexts.
	SetBody(IBooleanExpressionContext)

	// GetArgs returns the args rule context list.
	GetArgs() []IErrorCapturingIdentifierContext

	// SetArgs sets the args rule context list.
	SetArgs([]IErrorCapturingIdentifierContext)

	// Getter signatures
	ARROW() antlr.TerminalNode
	AllErrorCapturingIdentifier() []IErrorCapturingIdentifierContext
	ErrorCapturingIdentifier(i int) IErrorCapturingIdentifierContext
	BooleanExpression() IBooleanExpressionContext
	LEFT_PAREN() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsLambdaExpressionContext differentiates from other interfaces.
	IsLambdaExpressionContext()
}

type LambdaExpressionContext struct {
	antlr.BaseParserRuleContext
	parser                    antlr.Parser
	_errorCapturingIdentifier IErrorCapturingIdentifierContext
	args                      []IErrorCapturingIdentifierContext
	body                      IBooleanExpressionContext
}

func NewEmptyLambdaExpressionContext() *LambdaExpressionContext {
	var p = new(LambdaExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_lambdaExpression
	return p
}

func InitEmptyLambdaExpressionContext(p *LambdaExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_lambdaExpression
}

func (*LambdaExpressionContext) IsLambdaExpressionContext() {}

func NewLambdaExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LambdaExpressionContext {
	var p = new(LambdaExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_lambdaExpression

	return p
}

func (s *LambdaExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *LambdaExpressionContext) Get_errorCapturingIdentifier() IErrorCapturingIdentifierContext {
	return s._errorCapturingIdentifier
}

func (s *LambdaExpressionContext) GetBody() IBooleanExpressionContext { return s.body }

func (s *LambdaExpressionContext) Set_errorCapturingIdentifier(v IErrorCapturingIdentifierContext) {
	s._errorCapturingIdentifier = v
}

func (s *LambdaExpressionContext) SetBody(v IBooleanExpressionContext) { s.body = v }

func (s *LambdaExpressionContext) GetArgs() []IErrorCapturingIdentifierContext { return s.args }

func (s *LambdaExpressionContext) SetArgs(v []IErrorCapturingIdentifierContext) { s.args = v }

func (s *LambdaExpressionContext) ARROW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserARROW, 0)
}

func (s *LambdaExpressionContext) AllErrorCapturingIdentifier() []IErrorCapturingIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IErrorCapturingIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IErrorCapturingIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IErrorCapturingIdentifierContext); ok {
			tst[i] = t.(IErrorCapturingIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *LambdaExpressionContext) ErrorCapturingIdentifier(i int) IErrorCapturingIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IErrorCapturingIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IErrorCapturingIdentifierContext)
}

func (s *LambdaExpressionContext) BooleanExpression() IBooleanExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *LambdaExpressionContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLEFT_PAREN, 0)
}

func (s *LambdaExpressionContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRIGHT_PAREN, 0)
}

func (s *LambdaExpressionContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserCOMMA)
}

func (s *LambdaExpressionContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOMMA, i)
}

func (s *LambdaExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LambdaExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LambdaExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitLambdaExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) LambdaExpression() (localctx ILambdaExpressionContext) {
	localctx = NewLambdaExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 374, DorisParserParserRULE_lambdaExpression)
	var _la int

	p.SetState(5638)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserParserLEFT_BRACE, DorisParserParserRIGHT_BRACE, DorisParserParserACTIONS, DorisParserParserAFTER, DorisParserParserAGG_STATE, DorisParserParserAGGREGATE, DorisParserParserALIAS, DorisParserParserANALYZED, DorisParserParserARRAY, DorisParserParserAT, DorisParserParserAUTHORS, DorisParserParserAUTO_INCREMENT, DorisParserParserALWAYS, DorisParserParserBACKENDS, DorisParserParserBACKUP, DorisParserParserBEGIN, DorisParserParserBELONG, DorisParserParserBIN, DorisParserParserBITAND, DorisParserParserBITMAP, DorisParserParserBITMAP_EMPTY, DorisParserParserBITMAP_UNION, DorisParserParserBITOR, DorisParserParserBITXOR, DorisParserParserBLOB, DorisParserParserBOOLEAN, DorisParserParserBRANCH, DorisParserParserBRIEF, DorisParserParserBROKER, DorisParserParserBUCKETS, DorisParserParserBUILD, DorisParserParserBUILTIN, DorisParserParserBULK, DorisParserParserCACHE, DorisParserParserCACHED, DorisParserParserCALL, DorisParserParserCATALOG, DorisParserParserCATALOGS, DorisParserParserCHAIN, DorisParserParserCHAR, DorisParserParserCHARSET, DorisParserParserCHECK, DorisParserParserCLUSTER, DorisParserParserCLUSTERS, DorisParserParserCOLLATION, DorisParserParserCOLLECT, DorisParserParserCOLOCATE, DorisParserParserCOLUMNS, DorisParserParserCOMMENT, DorisParserParserCOMMIT, DorisParserParserCOMMITTED, DorisParserParserCOMPACT, DorisParserParserCOMPLETE, DorisParserParserCOMPRESS_TYPE, DorisParserParserCOMPUTE, DorisParserParserCONDITIONS, DorisParserParserCONFIG, DorisParserParserCONNECTION, DorisParserParserCONNECTION_ID, DorisParserParserCONSISTENT, DorisParserParserCONSTRAINTS, DorisParserParserCONVERT, DorisParserParserCONVERT_LSC, DorisParserParserCOPY, DorisParserParserCOUNT, DorisParserParserCREATION, DorisParserParserCRON, DorisParserParserCURRENT_CATALOG, DorisParserParserCURRENT_DATE, DorisParserParserCURRENT_TIME, DorisParserParserCURRENT_TIMESTAMP, DorisParserParserCURRENT_USER, DorisParserParserDATA, DorisParserParserDATE, DorisParserParserDATETIME, DorisParserParserDATETIMEV2, DorisParserParserDATEV2, DorisParserParserDATETIMEV1, DorisParserParserDATEV1, DorisParserParserDAY, DorisParserParserDAYS, DorisParserParserDECIMAL, DorisParserParserDECIMALV2, DorisParserParserDECIMALV3, DorisParserParserDEFERRED, DorisParserParserDEMAND, DorisParserParserDIAGNOSE, DorisParserParserDIAGNOSIS, DorisParserParserDICTIONARIES, DorisParserParserDICTIONARY, DorisParserParserDISTINCTPC, DorisParserParserDISTINCTPCSA, DorisParserParserDO, DorisParserParserDORIS_INTERNAL_TABLE_ID, DorisParserParserDUAL, DorisParserParserDYNAMIC, DorisParserParserE, DorisParserParserENABLE, DorisParserParserENCRYPTKEY, DorisParserParserENCRYPTKEYS, DorisParserParserEND, DorisParserParserENDS, DorisParserParserENGINE, DorisParserParserENGINES, DorisParserParserERRORS, DorisParserParserESCAPE, DorisParserParserEVENTS, DorisParserParserEVERY, DorisParserParserEXCLUDE, DorisParserParserEXPIRED, DorisParserParserEXTERNAL, DorisParserParserFAILED_LOGIN_ATTEMPTS, DorisParserParserFAST, DorisParserParserFEATURE, DorisParserParserFIELDS, DorisParserParserFILE, DorisParserParserFILTER, DorisParserParserFIRST, DorisParserParserFORMAT, DorisParserParserFREE, DorisParserParserFRONTENDS, DorisParserParserFUNCTION, DorisParserParserGENERATED, DorisParserParserGENERIC, DorisParserParserGLOBAL, DorisParserParserGRAPH, DorisParserParserGROUPING, DorisParserParserGROUPS, DorisParserParserHASH, DorisParserParserHASH_MAP, DorisParserParserHDFS, DorisParserParserHELP, DorisParserParserHISTOGRAM, DorisParserParserHLL_UNION, DorisParserParserHOSTNAME, DorisParserParserHOTSPOT, DorisParserParserHOUR, DorisParserParserHOURS, DorisParserParserHUB, DorisParserParserIDENTIFIED, DorisParserParserIGNORE, DorisParserParserIMMEDIATE, DorisParserParserINCREMENTAL, DorisParserParserINDEXES, DorisParserParserINVERTED, DorisParserParserIP_TRIE, DorisParserParserIPV4, DorisParserParserIPV6, DorisParserParserIS_NOT_NULL_PRED, DorisParserParserIS_NULL_PRED, DorisParserParserISNULL, DorisParserParserISOLATION, DorisParserParserJOB, DorisParserParserJOBS, DorisParserParserJSON, DorisParserParserJSONB, DorisParserParserLABEL, DorisParserParserLAST, DorisParserParserLDAP, DorisParserParserLDAP_ADMIN_PASSWORD, DorisParserParserLESS, DorisParserParserLEVEL, DorisParserParserLINES, DorisParserParserLINK, DorisParserParserLOCAL, DorisParserParserLOCALTIME, DorisParserParserLOCALTIMESTAMP, DorisParserParserLOCATION, DorisParserParserLOCK, DorisParserParserLOGICAL, DorisParserParserMANUAL, DorisParserParserMAP, DorisParserParserMATCH_ALL, DorisParserParserMATCH_ANY, DorisParserParserMATCH_PHRASE, DorisParserParserMATCH_PHRASE_EDGE, DorisParserParserMATCH_PHRASE_PREFIX, DorisParserParserMATCH_REGEXP, DorisParserParserMATERIALIZED, DorisParserParserMAX, DorisParserParserMEMO, DorisParserParserMERGE, DorisParserParserMIGRATE, DorisParserParserMIGRATIONS, DorisParserParserMIN, DorisParserParserMINUTE, DorisParserParserMINUTES, DorisParserParserMODIFY, DorisParserParserMONTH, DorisParserParserMTMV, DorisParserParserNAME, DorisParserParserNAMES, DorisParserParserNEGATIVE, DorisParserParserNEVER, DorisParserParserNEXT, DorisParserParserNGRAM_BF, DorisParserParserNO, DorisParserParserNON_NULLABLE, DorisParserParserNULLS, DorisParserParserOF, DorisParserParserOFFSET, DorisParserParserONLY, DorisParserParserOPEN, DorisParserParserOPTIMIZED, DorisParserParserPARAMETER, DorisParserParserPARSED, DorisParserParserPARTITIONS, DorisParserParserPASSWORD, DorisParserParserPASSWORD_EXPIRE, DorisParserParserPASSWORD_HISTORY, DorisParserParserPASSWORD_LOCK_TIME, DorisParserParserPASSWORD_REUSE, DorisParserParserPATH, DorisParserParserPAUSE, DorisParserParserPERCENT, DorisParserParserPERIOD, DorisParserParserPERMISSIVE, DorisParserParserPHYSICAL, DorisParserParserPI, DorisParserParserPLAN, DorisParserParserPRIVILEGES, DorisParserParserPROCESS, DorisParserParserPLUGIN, DorisParserParserPLUGINS, DorisParserParserPOLICY, DorisParserParserPROC, DorisParserParserPROCESSLIST, DorisParserParserPROFILE, DorisParserParserPROPERTIES, DorisParserParserPROPERTY, DorisParserParserQUANTILE_STATE, DorisParserParserQUANTILE_UNION, DorisParserParserQUERY, DorisParserParserQUEUED, DorisParserParserQUOTA, DorisParserParserQUALIFY, DorisParserParserQUARTER, DorisParserParserRANDOM, DorisParserParserRECENT, DorisParserParserRECOVER, DorisParserParserRECYCLE, DorisParserParserREFRESH, DorisParserParserREPEATABLE, DorisParserParserREPLACE, DorisParserParserREPLACE_IF_NOT_NULL, DorisParserParserREPLAYER, DorisParserParserREPOSITORIES, DorisParserParserREPOSITORY, DorisParserParserRESOURCE, DorisParserParserRESOURCES, DorisParserParserRESTORE, DorisParserParserRESTRICTIVE, DorisParserParserRESUME, DorisParserParserRETAIN, DorisParserParserRETENTION, DorisParserParserRETURNS, DorisParserParserREWRITTEN, DorisParserParserRLIKE, DorisParserParserROLLBACK, DorisParserParserROLLUP, DorisParserParserROUTINE, DorisParserParserS3, DorisParserParserSAMPLE, DorisParserParserSCHEDULE, DorisParserParserSCHEDULER, DorisParserParserSCHEMA, DorisParserParserSECOND, DorisParserParserSERIALIZABLE, DorisParserParserSESSION, DorisParserParserSESSION_USER, DorisParserParserSET_SESSION_VARIABLE, DorisParserParserSHAPE, DorisParserParserSKEW, DorisParserParserSNAPSHOT, DorisParserParserSNAPSHOTS, DorisParserParserSONAME, DorisParserParserSPLIT, DorisParserParserSQL, DorisParserParserSTAGE, DorisParserParserSTAGES, DorisParserParserSTART, DorisParserParserSTARTS, DorisParserParserSTATS, DorisParserParserSTATUS, DorisParserParserSTOP, DorisParserParserSTORAGE, DorisParserParserSTREAM, DorisParserParserSTREAMING, DorisParserParserSTRING, DorisParserParserSTRUCT, DorisParserParserSUM, DorisParserParserTABLES, DorisParserParserTAG, DorisParserParserTASK, DorisParserParserTASKS, DorisParserParserTEMPORARY, DorisParserParserTEXT, DorisParserParserTHAN, DorisParserParserTIME, DorisParserParserTIMESTAMP, DorisParserParserTRANSACTION, DorisParserParserTREE, DorisParserParserTRIGGERS, DorisParserParserTRUNCATE, DorisParserParserTYPE, DorisParserParserTYPES, DorisParserParserUNCOMMITTED, DorisParserParserUNLOCK, DorisParserParserUNSET, DorisParserParserUP, DorisParserParserUSER, DorisParserParserVALUE, DorisParserParserVARCHAR, DorisParserParserVARIABLE, DorisParserParserVARIABLES, DorisParserParserVARIANT, DorisParserParserVAULT, DorisParserParserVAULTS, DorisParserParserVERBOSE, DorisParserParserVERSION, DorisParserParserVIEW, DorisParserParserVIEWS, DorisParserParserWARM, DorisParserParserWARNINGS, DorisParserParserWEEK, DorisParserParserWORK, DorisParserParserYEAR, DorisParserParserHINT_START, DorisParserParserHINT_END, DorisParserParserCOMMENT_START, DorisParserParserIDENTIFIER, DorisParserParserBACKQUOTED_IDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5622)

			var _x = p.ErrorCapturingIdentifier()

			localctx.(*LambdaExpressionContext)._errorCapturingIdentifier = _x
		}
		localctx.(*LambdaExpressionContext).args = append(localctx.(*LambdaExpressionContext).args, localctx.(*LambdaExpressionContext)._errorCapturingIdentifier)
		{
			p.SetState(5623)
			p.Match(DorisParserParserARROW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5624)

			var _x = p.booleanExpression(0)

			localctx.(*LambdaExpressionContext).body = _x
		}

	case DorisParserParserLEFT_PAREN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5626)
			p.Match(DorisParserParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5627)

			var _x = p.ErrorCapturingIdentifier()

			localctx.(*LambdaExpressionContext)._errorCapturingIdentifier = _x
		}
		localctx.(*LambdaExpressionContext).args = append(localctx.(*LambdaExpressionContext).args, localctx.(*LambdaExpressionContext)._errorCapturingIdentifier)
		p.SetState(5630)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == DorisParserParserCOMMA {
			{
				p.SetState(5628)
				p.Match(DorisParserParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5629)

				var _x = p.ErrorCapturingIdentifier()

				localctx.(*LambdaExpressionContext)._errorCapturingIdentifier = _x
			}
			localctx.(*LambdaExpressionContext).args = append(localctx.(*LambdaExpressionContext).args, localctx.(*LambdaExpressionContext)._errorCapturingIdentifier)

			p.SetState(5632)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(5634)
			p.Match(DorisParserParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5635)
			p.Match(DorisParserParserARROW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5636)

			var _x = p.booleanExpression(0)

			localctx.(*LambdaExpressionContext).body = _x
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBooleanExpressionContext is an interface to support dynamic dispatch.
type IBooleanExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsBooleanExpressionContext differentiates from other interfaces.
	IsBooleanExpressionContext()
}

type BooleanExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBooleanExpressionContext() *BooleanExpressionContext {
	var p = new(BooleanExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_booleanExpression
	return p
}

func InitEmptyBooleanExpressionContext(p *BooleanExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_booleanExpression
}

func (*BooleanExpressionContext) IsBooleanExpressionContext() {}

func NewBooleanExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BooleanExpressionContext {
	var p = new(BooleanExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_booleanExpression

	return p
}

func (s *BooleanExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *BooleanExpressionContext) CopyAll(ctx *BooleanExpressionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *BooleanExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ExistContext struct {
	BooleanExpressionContext
}

func NewExistContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExistContext {
	var p = new(ExistContext)

	InitEmptyBooleanExpressionContext(&p.BooleanExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*BooleanExpressionContext))

	return p
}

func (s *ExistContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExistContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserEXISTS, 0)
}

func (s *ExistContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLEFT_PAREN, 0)
}

func (s *ExistContext) Query() IQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *ExistContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRIGHT_PAREN, 0)
}

func (s *ExistContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitExist(s)

	default:
		return t.VisitChildren(s)
	}
}

type LogicalNotContext struct {
	BooleanExpressionContext
}

func NewLogicalNotContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LogicalNotContext {
	var p = new(LogicalNotContext)

	InitEmptyBooleanExpressionContext(&p.BooleanExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*BooleanExpressionContext))

	return p
}

func (s *LogicalNotContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogicalNotContext) LOGICALNOT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLOGICALNOT, 0)
}

func (s *LogicalNotContext) BooleanExpression() IBooleanExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *LogicalNotContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserNOT, 0)
}

func (s *LogicalNotContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitLogicalNot(s)

	default:
		return t.VisitChildren(s)
	}
}

type PredicatedContext struct {
	BooleanExpressionContext
}

func NewPredicatedContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PredicatedContext {
	var p = new(PredicatedContext)

	InitEmptyBooleanExpressionContext(&p.BooleanExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*BooleanExpressionContext))

	return p
}

func (s *PredicatedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PredicatedContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *PredicatedContext) Predicate() IPredicateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredicateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *PredicatedContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitPredicated(s)

	default:
		return t.VisitChildren(s)
	}
}

type IsnullContext struct {
	BooleanExpressionContext
}

func NewIsnullContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IsnullContext {
	var p = new(IsnullContext)

	InitEmptyBooleanExpressionContext(&p.BooleanExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*BooleanExpressionContext))

	return p
}

func (s *IsnullContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IsnullContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLEFT_PAREN, 0)
}

func (s *IsnullContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *IsnullContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRIGHT_PAREN, 0)
}

func (s *IsnullContext) ISNULL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserISNULL, 0)
}

func (s *IsnullContext) IS_NULL_PRED() antlr.TerminalNode {
	return s.GetToken(DorisParserParserIS_NULL_PRED, 0)
}

func (s *IsnullContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitIsnull(s)

	default:
		return t.VisitChildren(s)
	}
}

type Is_not_null_predContext struct {
	BooleanExpressionContext
}

func NewIs_not_null_predContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *Is_not_null_predContext {
	var p = new(Is_not_null_predContext)

	InitEmptyBooleanExpressionContext(&p.BooleanExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*BooleanExpressionContext))

	return p
}

func (s *Is_not_null_predContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Is_not_null_predContext) IS_NOT_NULL_PRED() antlr.TerminalNode {
	return s.GetToken(DorisParserParserIS_NOT_NULL_PRED, 0)
}

func (s *Is_not_null_predContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLEFT_PAREN, 0)
}

func (s *Is_not_null_predContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *Is_not_null_predContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRIGHT_PAREN, 0)
}

func (s *Is_not_null_predContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitIs_not_null_pred(s)

	default:
		return t.VisitChildren(s)
	}
}

type LogicalBinaryContext struct {
	BooleanExpressionContext
	left     IBooleanExpressionContext
	operator antlr.Token
	right    IBooleanExpressionContext
}

func NewLogicalBinaryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LogicalBinaryContext {
	var p = new(LogicalBinaryContext)

	InitEmptyBooleanExpressionContext(&p.BooleanExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*BooleanExpressionContext))

	return p
}

func (s *LogicalBinaryContext) GetOperator() antlr.Token { return s.operator }

func (s *LogicalBinaryContext) SetOperator(v antlr.Token) { s.operator = v }

func (s *LogicalBinaryContext) GetLeft() IBooleanExpressionContext { return s.left }

func (s *LogicalBinaryContext) GetRight() IBooleanExpressionContext { return s.right }

func (s *LogicalBinaryContext) SetLeft(v IBooleanExpressionContext) { s.left = v }

func (s *LogicalBinaryContext) SetRight(v IBooleanExpressionContext) { s.right = v }

func (s *LogicalBinaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogicalBinaryContext) AllBooleanExpression() []IBooleanExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			len++
		}
	}

	tst := make([]IBooleanExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IBooleanExpressionContext); ok {
			tst[i] = t.(IBooleanExpressionContext)
			i++
		}
	}

	return tst
}

func (s *LogicalBinaryContext) BooleanExpression(i int) IBooleanExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *LogicalBinaryContext) AND() antlr.TerminalNode {
	return s.GetToken(DorisParserParserAND, 0)
}

func (s *LogicalBinaryContext) LOGICALAND() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLOGICALAND, 0)
}

func (s *LogicalBinaryContext) XOR() antlr.TerminalNode {
	return s.GetToken(DorisParserParserXOR, 0)
}

func (s *LogicalBinaryContext) OR() antlr.TerminalNode {
	return s.GetToken(DorisParserParserOR, 0)
}

func (s *LogicalBinaryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitLogicalBinary(s)

	default:
		return t.VisitChildren(s)
	}
}

type DoublePipesContext struct {
	BooleanExpressionContext
	left     IBooleanExpressionContext
	operator antlr.Token
	right    IBooleanExpressionContext
}

func NewDoublePipesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DoublePipesContext {
	var p = new(DoublePipesContext)

	InitEmptyBooleanExpressionContext(&p.BooleanExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*BooleanExpressionContext))

	return p
}

func (s *DoublePipesContext) GetOperator() antlr.Token { return s.operator }

func (s *DoublePipesContext) SetOperator(v antlr.Token) { s.operator = v }

func (s *DoublePipesContext) GetLeft() IBooleanExpressionContext { return s.left }

func (s *DoublePipesContext) GetRight() IBooleanExpressionContext { return s.right }

func (s *DoublePipesContext) SetLeft(v IBooleanExpressionContext) { s.left = v }

func (s *DoublePipesContext) SetRight(v IBooleanExpressionContext) { s.right = v }

func (s *DoublePipesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DoublePipesContext) AllBooleanExpression() []IBooleanExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			len++
		}
	}

	tst := make([]IBooleanExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IBooleanExpressionContext); ok {
			tst[i] = t.(IBooleanExpressionContext)
			i++
		}
	}

	return tst
}

func (s *DoublePipesContext) BooleanExpression(i int) IBooleanExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *DoublePipesContext) DOUBLEPIPES() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDOUBLEPIPES, 0)
}

func (s *DoublePipesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitDoublePipes(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) BooleanExpression() (localctx IBooleanExpressionContext) {
	return p.booleanExpression(0)
}

func (p *DorisParserParser) booleanExpression(_p int) (localctx IBooleanExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewBooleanExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IBooleanExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 376
	p.EnterRecursionRule(localctx, 376, DorisParserParserRULE_booleanExpression, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5664)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 814, p.GetParserRuleContext()) {
	case 1:
		localctx = NewLogicalNotContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(5641)
			p.Match(DorisParserParserLOGICALNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5642)
			p.booleanExpression(10)
		}

	case 2:
		localctx = NewExistContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(5643)
			p.Match(DorisParserParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5644)
			p.Match(DorisParserParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5645)
			p.Query()
		}
		{
			p.SetState(5646)
			p.Match(DorisParserParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		localctx = NewIsnullContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(5648)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserParserIS_NULL_PRED || _la == DorisParserParserISNULL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(5649)
			p.Match(DorisParserParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5650)
			p.valueExpression(0)
		}
		{
			p.SetState(5651)
			p.Match(DorisParserParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		localctx = NewIs_not_null_predContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(5653)
			p.Match(DorisParserParserIS_NOT_NULL_PRED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5654)
			p.Match(DorisParserParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5655)
			p.valueExpression(0)
		}
		{
			p.SetState(5656)
			p.Match(DorisParserParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		localctx = NewPredicatedContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(5658)
			p.valueExpression(0)
		}
		p.SetState(5660)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 813, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5659)
				p.Predicate()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 6:
		localctx = NewLogicalNotContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(5662)
			p.Match(DorisParserParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5663)
			p.booleanExpression(5)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(5680)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 816, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(5678)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 815, p.GetParserRuleContext()) {
			case 1:
				localctx = NewLogicalBinaryContext(p, NewBooleanExpressionContext(p, _parentctx, _parentState))
				localctx.(*LogicalBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, DorisParserParserRULE_booleanExpression)
				p.SetState(5666)

				if !(p.Precpred(p.GetParserRuleContext(), 4)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 4)", ""))
					goto errorExit
				}
				{
					p.SetState(5667)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*LogicalBinaryContext).operator = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == DorisParserParserAND || _la == DorisParserParserLOGICALAND) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*LogicalBinaryContext).operator = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(5668)

					var _x = p.booleanExpression(5)

					localctx.(*LogicalBinaryContext).right = _x
				}

			case 2:
				localctx = NewLogicalBinaryContext(p, NewBooleanExpressionContext(p, _parentctx, _parentState))
				localctx.(*LogicalBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, DorisParserParserRULE_booleanExpression)
				p.SetState(5669)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
					goto errorExit
				}
				{
					p.SetState(5670)

					var _m = p.Match(DorisParserParserXOR)

					localctx.(*LogicalBinaryContext).operator = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(5671)

					var _x = p.booleanExpression(4)

					localctx.(*LogicalBinaryContext).right = _x
				}

			case 3:
				localctx = NewLogicalBinaryContext(p, NewBooleanExpressionContext(p, _parentctx, _parentState))
				localctx.(*LogicalBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, DorisParserParserRULE_booleanExpression)
				p.SetState(5672)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
					goto errorExit
				}
				{
					p.SetState(5673)

					var _m = p.Match(DorisParserParserOR)

					localctx.(*LogicalBinaryContext).operator = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(5674)

					var _x = p.booleanExpression(3)

					localctx.(*LogicalBinaryContext).right = _x
				}

			case 4:
				localctx = NewDoublePipesContext(p, NewBooleanExpressionContext(p, _parentctx, _parentState))
				localctx.(*DoublePipesContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, DorisParserParserRULE_booleanExpression)
				p.SetState(5675)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
					goto errorExit
				}
				{
					p.SetState(5676)

					var _m = p.Match(DorisParserParserDOUBLEPIPES)

					localctx.(*DoublePipesContext).operator = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(5677)

					var _x = p.booleanExpression(2)

					localctx.(*DoublePipesContext).right = _x
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(5682)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 816, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRowConstructorContext is an interface to support dynamic dispatch.
type IRowConstructorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LEFT_PAREN() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode
	AllRowConstructorItem() []IRowConstructorItemContext
	RowConstructorItem(i int) IRowConstructorItemContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsRowConstructorContext differentiates from other interfaces.
	IsRowConstructorContext()
}

type RowConstructorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRowConstructorContext() *RowConstructorContext {
	var p = new(RowConstructorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_rowConstructor
	return p
}

func InitEmptyRowConstructorContext(p *RowConstructorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_rowConstructor
}

func (*RowConstructorContext) IsRowConstructorContext() {}

func NewRowConstructorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RowConstructorContext {
	var p = new(RowConstructorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_rowConstructor

	return p
}

func (s *RowConstructorContext) GetParser() antlr.Parser { return s.parser }

func (s *RowConstructorContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLEFT_PAREN, 0)
}

func (s *RowConstructorContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRIGHT_PAREN, 0)
}

func (s *RowConstructorContext) AllRowConstructorItem() []IRowConstructorItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRowConstructorItemContext); ok {
			len++
		}
	}

	tst := make([]IRowConstructorItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRowConstructorItemContext); ok {
			tst[i] = t.(IRowConstructorItemContext)
			i++
		}
	}

	return tst
}

func (s *RowConstructorContext) RowConstructorItem(i int) IRowConstructorItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRowConstructorItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRowConstructorItemContext)
}

func (s *RowConstructorContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserCOMMA)
}

func (s *RowConstructorContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOMMA, i)
}

func (s *RowConstructorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RowConstructorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RowConstructorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitRowConstructor(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) RowConstructor() (localctx IRowConstructorContext) {
	localctx = NewRowConstructorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 378, DorisParserParserRULE_rowConstructor)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5683)
		p.Match(DorisParserParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5692)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-2305884869834611068) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-4612819754502202371) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-9079382760121755163) != 0) || ((int64((_la-192)) & ^0x3f) == 0 && ((int64(1)<<(_la-192))&4321098383830537129) != 0) || ((int64((_la-256)) & ^0x3f) == 0 && ((int64(1)<<(_la-256))&-5206443760946300951) != 0) || ((int64((_la-320)) & ^0x3f) == 0 && ((int64(1)<<(_la-320))&-4187784802352497917) != 0) || ((int64((_la-384)) & ^0x3f) == 0 && ((int64(1)<<(_la-384))&9222796779122712571) != 0) || ((int64((_la-452)) & ^0x3f) == 0 && ((int64(1)<<(_la-452))&2449945648132536049) != 0) || ((int64((_la-517)) & ^0x3f) == 0 && ((int64(1)<<(_la-517))&236487517953) != 0) {
		{
			p.SetState(5684)
			p.RowConstructorItem()
		}
		p.SetState(5689)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserParserCOMMA {
			{
				p.SetState(5685)
				p.Match(DorisParserParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5686)
				p.RowConstructorItem()
			}

			p.SetState(5691)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(5694)
		p.Match(DorisParserParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRowConstructorItemContext is an interface to support dynamic dispatch.
type IRowConstructorItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Constant() IConstantContext
	DEFAULT() antlr.TerminalNode
	NamedExpression() INamedExpressionContext

	// IsRowConstructorItemContext differentiates from other interfaces.
	IsRowConstructorItemContext()
}

type RowConstructorItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRowConstructorItemContext() *RowConstructorItemContext {
	var p = new(RowConstructorItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_rowConstructorItem
	return p
}

func InitEmptyRowConstructorItemContext(p *RowConstructorItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_rowConstructorItem
}

func (*RowConstructorItemContext) IsRowConstructorItemContext() {}

func NewRowConstructorItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RowConstructorItemContext {
	var p = new(RowConstructorItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_rowConstructorItem

	return p
}

func (s *RowConstructorItemContext) GetParser() antlr.Parser { return s.parser }

func (s *RowConstructorItemContext) Constant() IConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *RowConstructorItemContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDEFAULT, 0)
}

func (s *RowConstructorItemContext) NamedExpression() INamedExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamedExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamedExpressionContext)
}

func (s *RowConstructorItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RowConstructorItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RowConstructorItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitRowConstructorItem(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) RowConstructorItem() (localctx IRowConstructorItemContext) {
	localctx = NewRowConstructorItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 380, DorisParserParserRULE_rowConstructorItem)
	p.SetState(5699)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 819, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5696)
			p.Constant()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5697)
			p.Match(DorisParserParserDEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5698)
			p.NamedExpression()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPredicateContext is an interface to support dynamic dispatch.
type IPredicateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetKind returns the kind token.
	GetKind() antlr.Token

	// SetKind sets the kind token.
	SetKind(antlr.Token)

	// GetLower returns the lower rule contexts.
	GetLower() IValueExpressionContext

	// GetUpper returns the upper rule contexts.
	GetUpper() IValueExpressionContext

	// GetPattern returns the pattern rule contexts.
	GetPattern() IValueExpressionContext

	// GetEscape returns the escape rule contexts.
	GetEscape() IValueExpressionContext

	// SetLower sets the lower rule contexts.
	SetLower(IValueExpressionContext)

	// SetUpper sets the upper rule contexts.
	SetUpper(IValueExpressionContext)

	// SetPattern sets the pattern rule contexts.
	SetPattern(IValueExpressionContext)

	// SetEscape sets the escape rule contexts.
	SetEscape(IValueExpressionContext)

	// Getter signatures
	AND() antlr.TerminalNode
	BETWEEN() antlr.TerminalNode
	AllValueExpression() []IValueExpressionContext
	ValueExpression(i int) IValueExpressionContext
	NOT() antlr.TerminalNode
	REGEXP() antlr.TerminalNode
	RLIKE() antlr.TerminalNode
	LIKE() antlr.TerminalNode
	ESCAPE() antlr.TerminalNode
	MATCH() antlr.TerminalNode
	MATCH_ANY() antlr.TerminalNode
	MATCH_ALL() antlr.TerminalNode
	MATCH_PHRASE() antlr.TerminalNode
	MATCH_PHRASE_PREFIX() antlr.TerminalNode
	MATCH_REGEXP() antlr.TerminalNode
	MATCH_PHRASE_EDGE() antlr.TerminalNode
	LEFT_PAREN() antlr.TerminalNode
	Query() IQueryContext
	RIGHT_PAREN() antlr.TerminalNode
	IN() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	IS() antlr.TerminalNode
	NULL() antlr.TerminalNode
	TRUE() antlr.TerminalNode
	FALSE() antlr.TerminalNode

	// IsPredicateContext differentiates from other interfaces.
	IsPredicateContext()
}

type PredicateContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	kind    antlr.Token
	lower   IValueExpressionContext
	upper   IValueExpressionContext
	pattern IValueExpressionContext
	escape  IValueExpressionContext
}

func NewEmptyPredicateContext() *PredicateContext {
	var p = new(PredicateContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_predicate
	return p
}

func InitEmptyPredicateContext(p *PredicateContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_predicate
}

func (*PredicateContext) IsPredicateContext() {}

func NewPredicateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PredicateContext {
	var p = new(PredicateContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_predicate

	return p
}

func (s *PredicateContext) GetParser() antlr.Parser { return s.parser }

func (s *PredicateContext) GetKind() antlr.Token { return s.kind }

func (s *PredicateContext) SetKind(v antlr.Token) { s.kind = v }

func (s *PredicateContext) GetLower() IValueExpressionContext { return s.lower }

func (s *PredicateContext) GetUpper() IValueExpressionContext { return s.upper }

func (s *PredicateContext) GetPattern() IValueExpressionContext { return s.pattern }

func (s *PredicateContext) GetEscape() IValueExpressionContext { return s.escape }

func (s *PredicateContext) SetLower(v IValueExpressionContext) { s.lower = v }

func (s *PredicateContext) SetUpper(v IValueExpressionContext) { s.upper = v }

func (s *PredicateContext) SetPattern(v IValueExpressionContext) { s.pattern = v }

func (s *PredicateContext) SetEscape(v IValueExpressionContext) { s.escape = v }

func (s *PredicateContext) AND() antlr.TerminalNode {
	return s.GetToken(DorisParserParserAND, 0)
}

func (s *PredicateContext) BETWEEN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserBETWEEN, 0)
}

func (s *PredicateContext) AllValueExpression() []IValueExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IValueExpressionContext); ok {
			len++
		}
	}

	tst := make([]IValueExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IValueExpressionContext); ok {
			tst[i] = t.(IValueExpressionContext)
			i++
		}
	}

	return tst
}

func (s *PredicateContext) ValueExpression(i int) IValueExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *PredicateContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserNOT, 0)
}

func (s *PredicateContext) REGEXP() antlr.TerminalNode {
	return s.GetToken(DorisParserParserREGEXP, 0)
}

func (s *PredicateContext) RLIKE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRLIKE, 0)
}

func (s *PredicateContext) LIKE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLIKE, 0)
}

func (s *PredicateContext) ESCAPE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserESCAPE, 0)
}

func (s *PredicateContext) MATCH() antlr.TerminalNode {
	return s.GetToken(DorisParserParserMATCH, 0)
}

func (s *PredicateContext) MATCH_ANY() antlr.TerminalNode {
	return s.GetToken(DorisParserParserMATCH_ANY, 0)
}

func (s *PredicateContext) MATCH_ALL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserMATCH_ALL, 0)
}

func (s *PredicateContext) MATCH_PHRASE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserMATCH_PHRASE, 0)
}

func (s *PredicateContext) MATCH_PHRASE_PREFIX() antlr.TerminalNode {
	return s.GetToken(DorisParserParserMATCH_PHRASE_PREFIX, 0)
}

func (s *PredicateContext) MATCH_REGEXP() antlr.TerminalNode {
	return s.GetToken(DorisParserParserMATCH_REGEXP, 0)
}

func (s *PredicateContext) MATCH_PHRASE_EDGE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserMATCH_PHRASE_EDGE, 0)
}

func (s *PredicateContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLEFT_PAREN, 0)
}

func (s *PredicateContext) Query() IQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *PredicateContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRIGHT_PAREN, 0)
}

func (s *PredicateContext) IN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserIN, 0)
}

func (s *PredicateContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *PredicateContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PredicateContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserCOMMA)
}

func (s *PredicateContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOMMA, i)
}

func (s *PredicateContext) IS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserIS, 0)
}

func (s *PredicateContext) NULL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserNULL, 0)
}

func (s *PredicateContext) TRUE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserTRUE, 0)
}

func (s *PredicateContext) FALSE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFALSE, 0)
}

func (s *PredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PredicateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PredicateContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitPredicate(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) Predicate() (localctx IPredicateContext) {
	localctx = NewPredicateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 382, DorisParserParserRULE_predicate)
	var _la int

	p.SetState(5761)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 830, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(5702)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserNOT {
			{
				p.SetState(5701)
				p.Match(DorisParserParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(5704)

			var _m = p.Match(DorisParserParserBETWEEN)

			localctx.(*PredicateContext).kind = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5705)

			var _x = p.valueExpression(0)

			localctx.(*PredicateContext).lower = _x
		}
		{
			p.SetState(5706)
			p.Match(DorisParserParserAND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5707)

			var _x = p.valueExpression(0)

			localctx.(*PredicateContext).upper = _x
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(5710)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserNOT {
			{
				p.SetState(5709)
				p.Match(DorisParserParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(5712)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*PredicateContext).kind = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserParserREGEXP || _la == DorisParserParserRLIKE) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*PredicateContext).kind = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(5713)

			var _x = p.valueExpression(0)

			localctx.(*PredicateContext).pattern = _x
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(5715)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserNOT {
			{
				p.SetState(5714)
				p.Match(DorisParserParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(5717)

			var _m = p.Match(DorisParserParserLIKE)

			localctx.(*PredicateContext).kind = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5718)

			var _x = p.valueExpression(0)

			localctx.(*PredicateContext).pattern = _x
		}
		p.SetState(5721)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 823, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5719)
				p.Match(DorisParserParserESCAPE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5720)

				var _x = p.valueExpression(0)

				localctx.(*PredicateContext).escape = _x
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		p.SetState(5724)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserNOT {
			{
				p.SetState(5723)
				p.Match(DorisParserParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(5726)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*PredicateContext).kind = _lt

			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-281)) & ^0x3f) == 0 && ((int64(1)<<(_la-281))&127) != 0) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*PredicateContext).kind = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(5727)

			var _x = p.valueExpression(0)

			localctx.(*PredicateContext).pattern = _x
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		p.SetState(5729)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserNOT {
			{
				p.SetState(5728)
				p.Match(DorisParserParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(5731)

			var _m = p.Match(DorisParserParserIN)

			localctx.(*PredicateContext).kind = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5732)
			p.Match(DorisParserParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5733)
			p.Query()
		}
		{
			p.SetState(5734)
			p.Match(DorisParserParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		p.SetState(5737)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserNOT {
			{
				p.SetState(5736)
				p.Match(DorisParserParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(5739)

			var _m = p.Match(DorisParserParserIN)

			localctx.(*PredicateContext).kind = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5740)
			p.Match(DorisParserParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5741)
			p.Expression()
		}
		p.SetState(5746)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserParserCOMMA {
			{
				p.SetState(5742)
				p.Match(DorisParserParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5743)
				p.Expression()
			}

			p.SetState(5748)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(5749)
			p.Match(DorisParserParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(5751)
			p.Match(DorisParserParserIS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5753)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserNOT {
			{
				p.SetState(5752)
				p.Match(DorisParserParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(5755)

			var _m = p.Match(DorisParserParserNULL)

			localctx.(*PredicateContext).kind = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(5756)
			p.Match(DorisParserParserIS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5758)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserNOT {
			{
				p.SetState(5757)
				p.Match(DorisParserParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(5760)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*PredicateContext).kind = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserParserFALSE || _la == DorisParserParserTRUE) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*PredicateContext).kind = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IValueExpressionContext is an interface to support dynamic dispatch.
type IValueExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsValueExpressionContext differentiates from other interfaces.
	IsValueExpressionContext()
}

type ValueExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValueExpressionContext() *ValueExpressionContext {
	var p = new(ValueExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_valueExpression
	return p
}

func InitEmptyValueExpressionContext(p *ValueExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_valueExpression
}

func (*ValueExpressionContext) IsValueExpressionContext() {}

func NewValueExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValueExpressionContext {
	var p = new(ValueExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_valueExpression

	return p
}

func (s *ValueExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ValueExpressionContext) CopyAll(ctx *ValueExpressionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ValueExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ValueExpressionDefaultContext struct {
	ValueExpressionContext
}

func NewValueExpressionDefaultContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ValueExpressionDefaultContext {
	var p = new(ValueExpressionDefaultContext)

	InitEmptyValueExpressionContext(&p.ValueExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ValueExpressionContext))

	return p
}

func (s *ValueExpressionDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueExpressionDefaultContext) PrimaryExpression() IPrimaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *ValueExpressionDefaultContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitValueExpressionDefault(s)

	default:
		return t.VisitChildren(s)
	}
}

type ComparisonContext struct {
	ValueExpressionContext
	left  IValueExpressionContext
	right IValueExpressionContext
}

func NewComparisonContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ComparisonContext {
	var p = new(ComparisonContext)

	InitEmptyValueExpressionContext(&p.ValueExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ValueExpressionContext))

	return p
}

func (s *ComparisonContext) GetLeft() IValueExpressionContext { return s.left }

func (s *ComparisonContext) GetRight() IValueExpressionContext { return s.right }

func (s *ComparisonContext) SetLeft(v IValueExpressionContext) { s.left = v }

func (s *ComparisonContext) SetRight(v IValueExpressionContext) { s.right = v }

func (s *ComparisonContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparisonContext) ComparisonOperator() IComparisonOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComparisonOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComparisonOperatorContext)
}

func (s *ComparisonContext) AllValueExpression() []IValueExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IValueExpressionContext); ok {
			len++
		}
	}

	tst := make([]IValueExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IValueExpressionContext); ok {
			tst[i] = t.(IValueExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ComparisonContext) ValueExpression(i int) IValueExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ComparisonContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitComparison(s)

	default:
		return t.VisitChildren(s)
	}
}

type ArithmeticBinaryContext struct {
	ValueExpressionContext
	left     IValueExpressionContext
	operator antlr.Token
	right    IValueExpressionContext
}

func NewArithmeticBinaryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ArithmeticBinaryContext {
	var p = new(ArithmeticBinaryContext)

	InitEmptyValueExpressionContext(&p.ValueExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ValueExpressionContext))

	return p
}

func (s *ArithmeticBinaryContext) GetOperator() antlr.Token { return s.operator }

func (s *ArithmeticBinaryContext) SetOperator(v antlr.Token) { s.operator = v }

func (s *ArithmeticBinaryContext) GetLeft() IValueExpressionContext { return s.left }

func (s *ArithmeticBinaryContext) GetRight() IValueExpressionContext { return s.right }

func (s *ArithmeticBinaryContext) SetLeft(v IValueExpressionContext) { s.left = v }

func (s *ArithmeticBinaryContext) SetRight(v IValueExpressionContext) { s.right = v }

func (s *ArithmeticBinaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArithmeticBinaryContext) AllValueExpression() []IValueExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IValueExpressionContext); ok {
			len++
		}
	}

	tst := make([]IValueExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IValueExpressionContext); ok {
			tst[i] = t.(IValueExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ArithmeticBinaryContext) ValueExpression(i int) IValueExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ArithmeticBinaryContext) HAT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserHAT, 0)
}

func (s *ArithmeticBinaryContext) ASTERISK() antlr.TerminalNode {
	return s.GetToken(DorisParserParserASTERISK, 0)
}

func (s *ArithmeticBinaryContext) SLASH() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSLASH, 0)
}

func (s *ArithmeticBinaryContext) MOD() antlr.TerminalNode {
	return s.GetToken(DorisParserParserMOD, 0)
}

func (s *ArithmeticBinaryContext) DIV() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDIV, 0)
}

func (s *ArithmeticBinaryContext) PLUS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserPLUS, 0)
}

func (s *ArithmeticBinaryContext) SUBTRACT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSUBTRACT, 0)
}

func (s *ArithmeticBinaryContext) AMPERSAND() antlr.TerminalNode {
	return s.GetToken(DorisParserParserAMPERSAND, 0)
}

func (s *ArithmeticBinaryContext) PIPE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserPIPE, 0)
}

func (s *ArithmeticBinaryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitArithmeticBinary(s)

	default:
		return t.VisitChildren(s)
	}
}

type ArithmeticUnaryContext struct {
	ValueExpressionContext
	operator antlr.Token
}

func NewArithmeticUnaryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ArithmeticUnaryContext {
	var p = new(ArithmeticUnaryContext)

	InitEmptyValueExpressionContext(&p.ValueExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ValueExpressionContext))

	return p
}

func (s *ArithmeticUnaryContext) GetOperator() antlr.Token { return s.operator }

func (s *ArithmeticUnaryContext) SetOperator(v antlr.Token) { s.operator = v }

func (s *ArithmeticUnaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArithmeticUnaryContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ArithmeticUnaryContext) SUBTRACT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSUBTRACT, 0)
}

func (s *ArithmeticUnaryContext) PLUS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserPLUS, 0)
}

func (s *ArithmeticUnaryContext) TILDE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserTILDE, 0)
}

func (s *ArithmeticUnaryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitArithmeticUnary(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) ValueExpression() (localctx IValueExpressionContext) {
	return p.valueExpression(0)
}

func (p *DorisParserParser) valueExpression(_p int) (localctx IValueExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewValueExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IValueExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 384
	p.EnterRecursionRule(localctx, 384, DorisParserParserRULE_valueExpression, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5767)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 831, p.GetParserRuleContext()) {
	case 1:
		localctx = NewValueExpressionDefaultContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(5764)
			p.primaryExpression(0)
		}

	case 2:
		localctx = NewArithmeticUnaryContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(5765)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ArithmeticUnaryContext).operator = _lt

			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-525)) & ^0x3f) == 0 && ((int64(1)<<(_la-525))&35) != 0) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ArithmeticUnaryContext).operator = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(5766)
			p.valueExpression(7)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(5790)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 833, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(5788)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 832, p.GetParserRuleContext()) {
			case 1:
				localctx = NewArithmeticBinaryContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				localctx.(*ArithmeticBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, DorisParserParserRULE_valueExpression)
				p.SetState(5769)

				if !(p.Precpred(p.GetParserRuleContext(), 6)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 6)", ""))
					goto errorExit
				}
				{
					p.SetState(5770)

					var _m = p.Match(DorisParserParserHAT)

					localctx.(*ArithmeticBinaryContext).operator = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(5771)

					var _x = p.valueExpression(7)

					localctx.(*ArithmeticBinaryContext).right = _x
				}

			case 2:
				localctx = NewArithmeticBinaryContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				localctx.(*ArithmeticBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, DorisParserParserRULE_valueExpression)
				p.SetState(5772)

				if !(p.Precpred(p.GetParserRuleContext(), 5)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 5)", ""))
					goto errorExit
				}
				{
					p.SetState(5773)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*ArithmeticBinaryContext).operator = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == DorisParserParserDIV || ((int64((_la-527)) & ^0x3f) == 0 && ((int64(1)<<(_la-527))&7) != 0)) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*ArithmeticBinaryContext).operator = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(5774)

					var _x = p.valueExpression(6)

					localctx.(*ArithmeticBinaryContext).right = _x
				}

			case 3:
				localctx = NewArithmeticBinaryContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				localctx.(*ArithmeticBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, DorisParserParserRULE_valueExpression)
				p.SetState(5775)

				if !(p.Precpred(p.GetParserRuleContext(), 4)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 4)", ""))
					goto errorExit
				}
				{
					p.SetState(5776)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*ArithmeticBinaryContext).operator = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == DorisParserParserPLUS || _la == DorisParserParserSUBTRACT) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*ArithmeticBinaryContext).operator = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(5777)

					var _x = p.valueExpression(5)

					localctx.(*ArithmeticBinaryContext).right = _x
				}

			case 4:
				localctx = NewArithmeticBinaryContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				localctx.(*ArithmeticBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, DorisParserParserRULE_valueExpression)
				p.SetState(5778)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
					goto errorExit
				}
				{
					p.SetState(5779)

					var _m = p.Match(DorisParserParserAMPERSAND)

					localctx.(*ArithmeticBinaryContext).operator = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(5780)

					var _x = p.valueExpression(4)

					localctx.(*ArithmeticBinaryContext).right = _x
				}

			case 5:
				localctx = NewArithmeticBinaryContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				localctx.(*ArithmeticBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, DorisParserParserRULE_valueExpression)
				p.SetState(5781)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
					goto errorExit
				}
				{
					p.SetState(5782)

					var _m = p.Match(DorisParserParserPIPE)

					localctx.(*ArithmeticBinaryContext).operator = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(5783)

					var _x = p.valueExpression(3)

					localctx.(*ArithmeticBinaryContext).right = _x
				}

			case 6:
				localctx = NewComparisonContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				localctx.(*ComparisonContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, DorisParserParserRULE_valueExpression)
				p.SetState(5784)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
					goto errorExit
				}
				{
					p.SetState(5785)
					p.ComparisonOperator()
				}
				{
					p.SetState(5786)

					var _x = p.valueExpression(2)

					localctx.(*ComparisonContext).right = _x
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(5792)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 833, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrimaryExpressionContext is an interface to support dynamic dispatch.
type IPrimaryExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsPrimaryExpressionContext differentiates from other interfaces.
	IsPrimaryExpressionContext()
}

type PrimaryExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimaryExpressionContext() *PrimaryExpressionContext {
	var p = new(PrimaryExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_primaryExpression
	return p
}

func InitEmptyPrimaryExpressionContext(p *PrimaryExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_primaryExpression
}

func (*PrimaryExpressionContext) IsPrimaryExpressionContext() {}

func NewPrimaryExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimaryExpressionContext {
	var p = new(PrimaryExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_primaryExpression

	return p
}

func (s *PrimaryExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimaryExpressionContext) CopyAll(ctx *PrimaryExpressionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *PrimaryExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type DereferenceContext struct {
	PrimaryExpressionContext
	base      IPrimaryExpressionContext
	fieldName IIdentifierContext
}

func NewDereferenceContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DereferenceContext {
	var p = new(DereferenceContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *DereferenceContext) GetBase() IPrimaryExpressionContext { return s.base }

func (s *DereferenceContext) GetFieldName() IIdentifierContext { return s.fieldName }

func (s *DereferenceContext) SetBase(v IPrimaryExpressionContext) { s.base = v }

func (s *DereferenceContext) SetFieldName(v IIdentifierContext) { s.fieldName = v }

func (s *DereferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DereferenceContext) DOT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDOT, 0)
}

func (s *DereferenceContext) PrimaryExpression() IPrimaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *DereferenceContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DereferenceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitDereference(s)

	default:
		return t.VisitChildren(s)
	}
}

type CurrentDateContext struct {
	PrimaryExpressionContext
	name antlr.Token
}

func NewCurrentDateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CurrentDateContext {
	var p = new(CurrentDateContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *CurrentDateContext) GetName() antlr.Token { return s.name }

func (s *CurrentDateContext) SetName(v antlr.Token) { s.name = v }

func (s *CurrentDateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CurrentDateContext) CURRENT_DATE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCURRENT_DATE, 0)
}

func (s *CurrentDateContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitCurrentDate(s)

	default:
		return t.VisitChildren(s)
	}
}

type CastContext struct {
	PrimaryExpressionContext
	name antlr.Token
}

func NewCastContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CastContext {
	var p = new(CastContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *CastContext) GetName() antlr.Token { return s.name }

func (s *CastContext) SetName(v antlr.Token) { s.name = v }

func (s *CastContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CastContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLEFT_PAREN, 0)
}

func (s *CastContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CastContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserAS, 0)
}

func (s *CastContext) CastDataType() ICastDataTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICastDataTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICastDataTypeContext)
}

func (s *CastContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRIGHT_PAREN, 0)
}

func (s *CastContext) CAST() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCAST, 0)
}

func (s *CastContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitCast(s)

	default:
		return t.VisitChildren(s)
	}
}

type ParenthesizedExpressionContext struct {
	PrimaryExpressionContext
}

func NewParenthesizedExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ParenthesizedExpressionContext {
	var p = new(ParenthesizedExpressionContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ParenthesizedExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParenthesizedExpressionContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLEFT_PAREN, 0)
}

func (s *ParenthesizedExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ParenthesizedExpressionContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRIGHT_PAREN, 0)
}

func (s *ParenthesizedExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitParenthesizedExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type UserVariableContext struct {
	PrimaryExpressionContext
}

func NewUserVariableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UserVariableContext {
	var p = new(UserVariableContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *UserVariableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UserVariableContext) ATSIGN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserATSIGN, 0)
}

func (s *UserVariableContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *UserVariableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitUserVariable(s)

	default:
		return t.VisitChildren(s)
	}
}

type ElementAtContext struct {
	PrimaryExpressionContext
	value IPrimaryExpressionContext
	index IValueExpressionContext
}

func NewElementAtContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ElementAtContext {
	var p = new(ElementAtContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ElementAtContext) GetValue() IPrimaryExpressionContext { return s.value }

func (s *ElementAtContext) GetIndex() IValueExpressionContext { return s.index }

func (s *ElementAtContext) SetValue(v IPrimaryExpressionContext) { s.value = v }

func (s *ElementAtContext) SetIndex(v IValueExpressionContext) { s.index = v }

func (s *ElementAtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementAtContext) LEFT_BRACKET() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLEFT_BRACKET, 0)
}

func (s *ElementAtContext) RIGHT_BRACKET() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRIGHT_BRACKET, 0)
}

func (s *ElementAtContext) PrimaryExpression() IPrimaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *ElementAtContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ElementAtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitElementAt(s)

	default:
		return t.VisitChildren(s)
	}
}

type LocalTimestampContext struct {
	PrimaryExpressionContext
	name antlr.Token
}

func NewLocalTimestampContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LocalTimestampContext {
	var p = new(LocalTimestampContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *LocalTimestampContext) GetName() antlr.Token { return s.name }

func (s *LocalTimestampContext) SetName(v antlr.Token) { s.name = v }

func (s *LocalTimestampContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LocalTimestampContext) LOCALTIMESTAMP() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLOCALTIMESTAMP, 0)
}

func (s *LocalTimestampContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitLocalTimestamp(s)

	default:
		return t.VisitChildren(s)
	}
}

type CharFunctionContext struct {
	PrimaryExpressionContext
	_expression IExpressionContext
	arguments   []IExpressionContext
	charSet     IIdentifierOrTextContext
}

func NewCharFunctionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CharFunctionContext {
	var p = new(CharFunctionContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *CharFunctionContext) Get_expression() IExpressionContext { return s._expression }

func (s *CharFunctionContext) GetCharSet() IIdentifierOrTextContext { return s.charSet }

func (s *CharFunctionContext) Set_expression(v IExpressionContext) { s._expression = v }

func (s *CharFunctionContext) SetCharSet(v IIdentifierOrTextContext) { s.charSet = v }

func (s *CharFunctionContext) GetArguments() []IExpressionContext { return s.arguments }

func (s *CharFunctionContext) SetArguments(v []IExpressionContext) { s.arguments = v }

func (s *CharFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CharFunctionContext) CHAR() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCHAR, 0)
}

func (s *CharFunctionContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLEFT_PAREN, 0)
}

func (s *CharFunctionContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRIGHT_PAREN, 0)
}

func (s *CharFunctionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *CharFunctionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CharFunctionContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserCOMMA)
}

func (s *CharFunctionContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOMMA, i)
}

func (s *CharFunctionContext) USING() antlr.TerminalNode {
	return s.GetToken(DorisParserParserUSING, 0)
}

func (s *CharFunctionContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *CharFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitCharFunction(s)

	default:
		return t.VisitChildren(s)
	}
}

type IntervalLiteralContext struct {
	PrimaryExpressionContext
}

func NewIntervalLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IntervalLiteralContext {
	var p = new(IntervalLiteralContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *IntervalLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntervalLiteralContext) Interval() IIntervalContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntervalContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntervalContext)
}

func (s *IntervalLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitIntervalLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

type SimpleCaseContext struct {
	PrimaryExpressionContext
	value          IExpressionContext
	elseExpression IExpressionContext
}

func NewSimpleCaseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimpleCaseContext {
	var p = new(SimpleCaseContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *SimpleCaseContext) GetValue() IExpressionContext { return s.value }

func (s *SimpleCaseContext) GetElseExpression() IExpressionContext { return s.elseExpression }

func (s *SimpleCaseContext) SetValue(v IExpressionContext) { s.value = v }

func (s *SimpleCaseContext) SetElseExpression(v IExpressionContext) { s.elseExpression = v }

func (s *SimpleCaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleCaseContext) CASE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCASE, 0)
}

func (s *SimpleCaseContext) END() antlr.TerminalNode {
	return s.GetToken(DorisParserParserEND, 0)
}

func (s *SimpleCaseContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *SimpleCaseContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SimpleCaseContext) AllWhenClause() []IWhenClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IWhenClauseContext); ok {
			len++
		}
	}

	tst := make([]IWhenClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IWhenClauseContext); ok {
			tst[i] = t.(IWhenClauseContext)
			i++
		}
	}

	return tst
}

func (s *SimpleCaseContext) WhenClause(i int) IWhenClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhenClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhenClauseContext)
}

func (s *SimpleCaseContext) ELSE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserELSE, 0)
}

func (s *SimpleCaseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitSimpleCase(s)

	default:
		return t.VisitChildren(s)
	}
}

type ColumnReferenceContext struct {
	PrimaryExpressionContext
}

func NewColumnReferenceContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnReferenceContext {
	var p = new(ColumnReferenceContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ColumnReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnReferenceContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ColumnReferenceContext) BINARY() antlr.TerminalNode {
	return s.GetToken(DorisParserParserBINARY, 0)
}

func (s *ColumnReferenceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitColumnReference(s)

	default:
		return t.VisitChildren(s)
	}
}

type StarContext struct {
	PrimaryExpressionContext
}

func NewStarContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StarContext {
	var p = new(StarContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *StarContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StarContext) ASTERISK() antlr.TerminalNode {
	return s.GetToken(DorisParserParserASTERISK, 0)
}

func (s *StarContext) AllExceptOrReplace() []IExceptOrReplaceContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExceptOrReplaceContext); ok {
			len++
		}
	}

	tst := make([]IExceptOrReplaceContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExceptOrReplaceContext); ok {
			tst[i] = t.(IExceptOrReplaceContext)
			i++
		}
	}

	return tst
}

func (s *StarContext) ExceptOrReplace(i int) IExceptOrReplaceContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExceptOrReplaceContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExceptOrReplaceContext)
}

func (s *StarContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *StarContext) DOT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDOT, 0)
}

func (s *StarContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitStar(s)

	default:
		return t.VisitChildren(s)
	}
}

type SessionUserContext struct {
	PrimaryExpressionContext
	name antlr.Token
}

func NewSessionUserContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SessionUserContext {
	var p = new(SessionUserContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *SessionUserContext) GetName() antlr.Token { return s.name }

func (s *SessionUserContext) SetName(v antlr.Token) { s.name = v }

func (s *SessionUserContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SessionUserContext) SESSION_USER() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSESSION_USER, 0)
}

func (s *SessionUserContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitSessionUser(s)

	default:
		return t.VisitChildren(s)
	}
}

type ConvertTypeContext struct {
	PrimaryExpressionContext
	argument IExpressionContext
}

func NewConvertTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ConvertTypeContext {
	var p = new(ConvertTypeContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ConvertTypeContext) GetArgument() IExpressionContext { return s.argument }

func (s *ConvertTypeContext) SetArgument(v IExpressionContext) { s.argument = v }

func (s *ConvertTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConvertTypeContext) CONVERT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCONVERT, 0)
}

func (s *ConvertTypeContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLEFT_PAREN, 0)
}

func (s *ConvertTypeContext) COMMA() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOMMA, 0)
}

func (s *ConvertTypeContext) CastDataType() ICastDataTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICastDataTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICastDataTypeContext)
}

func (s *ConvertTypeContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRIGHT_PAREN, 0)
}

func (s *ConvertTypeContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ConvertTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitConvertType(s)

	default:
		return t.VisitChildren(s)
	}
}

type ConvertCharSetContext struct {
	PrimaryExpressionContext
	argument IExpressionContext
	charSet  IIdentifierOrTextContext
}

func NewConvertCharSetContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ConvertCharSetContext {
	var p = new(ConvertCharSetContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ConvertCharSetContext) GetArgument() IExpressionContext { return s.argument }

func (s *ConvertCharSetContext) GetCharSet() IIdentifierOrTextContext { return s.charSet }

func (s *ConvertCharSetContext) SetArgument(v IExpressionContext) { s.argument = v }

func (s *ConvertCharSetContext) SetCharSet(v IIdentifierOrTextContext) { s.charSet = v }

func (s *ConvertCharSetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConvertCharSetContext) CONVERT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCONVERT, 0)
}

func (s *ConvertCharSetContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLEFT_PAREN, 0)
}

func (s *ConvertCharSetContext) USING() antlr.TerminalNode {
	return s.GetToken(DorisParserParserUSING, 0)
}

func (s *ConvertCharSetContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRIGHT_PAREN, 0)
}

func (s *ConvertCharSetContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ConvertCharSetContext) IdentifierOrText() IIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrTextContext)
}

func (s *ConvertCharSetContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitConvertCharSet(s)

	default:
		return t.VisitChildren(s)
	}
}

type SubqueryExpressionContext struct {
	PrimaryExpressionContext
}

func NewSubqueryExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SubqueryExpressionContext {
	var p = new(SubqueryExpressionContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *SubqueryExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubqueryExpressionContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLEFT_PAREN, 0)
}

func (s *SubqueryExpressionContext) Query() IQueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *SubqueryExpressionContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRIGHT_PAREN, 0)
}

func (s *SubqueryExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitSubqueryExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type EncryptKeyContext struct {
	PrimaryExpressionContext
	dbName  IIdentifierContext
	keyName IIdentifierContext
}

func NewEncryptKeyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *EncryptKeyContext {
	var p = new(EncryptKeyContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *EncryptKeyContext) GetDbName() IIdentifierContext { return s.dbName }

func (s *EncryptKeyContext) GetKeyName() IIdentifierContext { return s.keyName }

func (s *EncryptKeyContext) SetDbName(v IIdentifierContext) { s.dbName = v }

func (s *EncryptKeyContext) SetKeyName(v IIdentifierContext) { s.keyName = v }

func (s *EncryptKeyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EncryptKeyContext) KEY() antlr.TerminalNode {
	return s.GetToken(DorisParserParserKEY, 0)
}

func (s *EncryptKeyContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *EncryptKeyContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *EncryptKeyContext) DOT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDOT, 0)
}

func (s *EncryptKeyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitEncryptKey(s)

	default:
		return t.VisitChildren(s)
	}
}

type CurrentTimeContext struct {
	PrimaryExpressionContext
	name antlr.Token
}

func NewCurrentTimeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CurrentTimeContext {
	var p = new(CurrentTimeContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *CurrentTimeContext) GetName() antlr.Token { return s.name }

func (s *CurrentTimeContext) SetName(v antlr.Token) { s.name = v }

func (s *CurrentTimeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CurrentTimeContext) CURRENT_TIME() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCURRENT_TIME, 0)
}

func (s *CurrentTimeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitCurrentTime(s)

	default:
		return t.VisitChildren(s)
	}
}

type LocalTimeContext struct {
	PrimaryExpressionContext
	name antlr.Token
}

func NewLocalTimeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LocalTimeContext {
	var p = new(LocalTimeContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *LocalTimeContext) GetName() antlr.Token { return s.name }

func (s *LocalTimeContext) SetName(v antlr.Token) { s.name = v }

func (s *LocalTimeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LocalTimeContext) LOCALTIME() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLOCALTIME, 0)
}

func (s *LocalTimeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitLocalTime(s)

	default:
		return t.VisitChildren(s)
	}
}

type SystemVariableContext struct {
	PrimaryExpressionContext
	kind antlr.Token
}

func NewSystemVariableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SystemVariableContext {
	var p = new(SystemVariableContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *SystemVariableContext) GetKind() antlr.Token { return s.kind }

func (s *SystemVariableContext) SetKind(v antlr.Token) { s.kind = v }

func (s *SystemVariableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SystemVariableContext) DOUBLEATSIGN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDOUBLEATSIGN, 0)
}

func (s *SystemVariableContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SystemVariableContext) DOT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDOT, 0)
}

func (s *SystemVariableContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserGLOBAL, 0)
}

func (s *SystemVariableContext) SESSION() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSESSION, 0)
}

func (s *SystemVariableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitSystemVariable(s)

	default:
		return t.VisitChildren(s)
	}
}

type CollateContext struct {
	PrimaryExpressionContext
}

func NewCollateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CollateContext {
	var p = new(CollateContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *CollateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CollateContext) PrimaryExpression() IPrimaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *CollateContext) COLLATE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOLLATE, 0)
}

func (s *CollateContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CollateContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTRING_LITERAL, 0)
}

func (s *CollateContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDEFAULT, 0)
}

func (s *CollateContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitCollate(s)

	default:
		return t.VisitChildren(s)
	}
}

type CurrentUserContext struct {
	PrimaryExpressionContext
	name antlr.Token
}

func NewCurrentUserContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CurrentUserContext {
	var p = new(CurrentUserContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *CurrentUserContext) GetName() antlr.Token { return s.name }

func (s *CurrentUserContext) SetName(v antlr.Token) { s.name = v }

func (s *CurrentUserContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CurrentUserContext) CURRENT_USER() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCURRENT_USER, 0)
}

func (s *CurrentUserContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitCurrentUser(s)

	default:
		return t.VisitChildren(s)
	}
}

type ConstantDefaultContext struct {
	PrimaryExpressionContext
}

func NewConstantDefaultContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ConstantDefaultContext {
	var p = new(ConstantDefaultContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ConstantDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstantDefaultContext) Constant() IConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *ConstantDefaultContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitConstantDefault(s)

	default:
		return t.VisitChildren(s)
	}
}

type ExtractContext struct {
	PrimaryExpressionContext
	field  IIdentifierContext
	source IValueExpressionContext
}

func NewExtractContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExtractContext {
	var p = new(ExtractContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ExtractContext) GetField() IIdentifierContext { return s.field }

func (s *ExtractContext) GetSource() IValueExpressionContext { return s.source }

func (s *ExtractContext) SetField(v IIdentifierContext) { s.field = v }

func (s *ExtractContext) SetSource(v IValueExpressionContext) { s.source = v }

func (s *ExtractContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExtractContext) EXTRACT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserEXTRACT, 0)
}

func (s *ExtractContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLEFT_PAREN, 0)
}

func (s *ExtractContext) FROM() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFROM, 0)
}

func (s *ExtractContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRIGHT_PAREN, 0)
}

func (s *ExtractContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ExtractContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ExtractContext) DATE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDATE, 0)
}

func (s *ExtractContext) TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(DorisParserParserTIMESTAMP, 0)
}

func (s *ExtractContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitExtract(s)

	default:
		return t.VisitChildren(s)
	}
}

type CurrentTimestampContext struct {
	PrimaryExpressionContext
	name antlr.Token
}

func NewCurrentTimestampContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CurrentTimestampContext {
	var p = new(CurrentTimestampContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *CurrentTimestampContext) GetName() antlr.Token { return s.name }

func (s *CurrentTimestampContext) SetName(v antlr.Token) { s.name = v }

func (s *CurrentTimestampContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CurrentTimestampContext) CURRENT_TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCURRENT_TIMESTAMP, 0)
}

func (s *CurrentTimestampContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitCurrentTimestamp(s)

	default:
		return t.VisitChildren(s)
	}
}

type FunctionCallContext struct {
	PrimaryExpressionContext
}

func NewFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *FunctionCallContext {
	var p = new(FunctionCallContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *FunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionCallContext) FunctionCallExpression() IFunctionCallExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionCallExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionCallExpressionContext)
}

func (s *FunctionCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitFunctionCall(s)

	default:
		return t.VisitChildren(s)
	}
}

type ArraySliceContext struct {
	PrimaryExpressionContext
	value IPrimaryExpressionContext
	begin IValueExpressionContext
	end   IValueExpressionContext
}

func NewArraySliceContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ArraySliceContext {
	var p = new(ArraySliceContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ArraySliceContext) GetValue() IPrimaryExpressionContext { return s.value }

func (s *ArraySliceContext) GetBegin() IValueExpressionContext { return s.begin }

func (s *ArraySliceContext) GetEnd() IValueExpressionContext { return s.end }

func (s *ArraySliceContext) SetValue(v IPrimaryExpressionContext) { s.value = v }

func (s *ArraySliceContext) SetBegin(v IValueExpressionContext) { s.begin = v }

func (s *ArraySliceContext) SetEnd(v IValueExpressionContext) { s.end = v }

func (s *ArraySliceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArraySliceContext) LEFT_BRACKET() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLEFT_BRACKET, 0)
}

func (s *ArraySliceContext) COLON() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOLON, 0)
}

func (s *ArraySliceContext) RIGHT_BRACKET() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRIGHT_BRACKET, 0)
}

func (s *ArraySliceContext) PrimaryExpression() IPrimaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *ArraySliceContext) AllValueExpression() []IValueExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IValueExpressionContext); ok {
			len++
		}
	}

	tst := make([]IValueExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IValueExpressionContext); ok {
			tst[i] = t.(IValueExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ArraySliceContext) ValueExpression(i int) IValueExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ArraySliceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitArraySlice(s)

	default:
		return t.VisitChildren(s)
	}
}

type SearchedCaseContext struct {
	PrimaryExpressionContext
	elseExpression IExpressionContext
}

func NewSearchedCaseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SearchedCaseContext {
	var p = new(SearchedCaseContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *SearchedCaseContext) GetElseExpression() IExpressionContext { return s.elseExpression }

func (s *SearchedCaseContext) SetElseExpression(v IExpressionContext) { s.elseExpression = v }

func (s *SearchedCaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SearchedCaseContext) CASE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCASE, 0)
}

func (s *SearchedCaseContext) END() antlr.TerminalNode {
	return s.GetToken(DorisParserParserEND, 0)
}

func (s *SearchedCaseContext) AllWhenClause() []IWhenClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IWhenClauseContext); ok {
			len++
		}
	}

	tst := make([]IWhenClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IWhenClauseContext); ok {
			tst[i] = t.(IWhenClauseContext)
			i++
		}
	}

	return tst
}

func (s *SearchedCaseContext) WhenClause(i int) IWhenClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhenClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhenClauseContext)
}

func (s *SearchedCaseContext) ELSE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserELSE, 0)
}

func (s *SearchedCaseContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SearchedCaseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitSearchedCase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) PrimaryExpression() (localctx IPrimaryExpressionContext) {
	return p.primaryExpression(0)
}

func (p *DorisParserParser) primaryExpression(_p int) (localctx IPrimaryExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewPrimaryExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IPrimaryExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 386
	p.EnterRecursionRule(localctx, 386, DorisParserParserRULE_primaryExpression, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5919)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 846, p.GetParserRuleContext()) {
	case 1:
		localctx = NewCurrentDateContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(5794)

			var _m = p.Match(DorisParserParserCURRENT_DATE)

			localctx.(*CurrentDateContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewCurrentTimeContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(5795)

			var _m = p.Match(DorisParserParserCURRENT_TIME)

			localctx.(*CurrentTimeContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		localctx = NewCurrentTimestampContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(5796)

			var _m = p.Match(DorisParserParserCURRENT_TIMESTAMP)

			localctx.(*CurrentTimestampContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		localctx = NewLocalTimeContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(5797)

			var _m = p.Match(DorisParserParserLOCALTIME)

			localctx.(*LocalTimeContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		localctx = NewLocalTimestampContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(5798)

			var _m = p.Match(DorisParserParserLOCALTIMESTAMP)

			localctx.(*LocalTimestampContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		localctx = NewCurrentUserContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(5799)

			var _m = p.Match(DorisParserParserCURRENT_USER)

			localctx.(*CurrentUserContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		localctx = NewSessionUserContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(5800)

			var _m = p.Match(DorisParserParserSESSION_USER)

			localctx.(*SessionUserContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 8:
		localctx = NewSearchedCaseContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(5801)
			p.Match(DorisParserParserCASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5803)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == DorisParserParserWHEN {
			{
				p.SetState(5802)
				p.WhenClause()
			}

			p.SetState(5805)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(5809)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserELSE {
			{
				p.SetState(5807)
				p.Match(DorisParserParserELSE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5808)

				var _x = p.Expression()

				localctx.(*SearchedCaseContext).elseExpression = _x
			}

		}
		{
			p.SetState(5811)
			p.Match(DorisParserParserEND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 9:
		localctx = NewSimpleCaseContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(5813)
			p.Match(DorisParserParserCASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5814)

			var _x = p.Expression()

			localctx.(*SimpleCaseContext).value = _x
		}
		p.SetState(5816)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == DorisParserParserWHEN {
			{
				p.SetState(5815)
				p.WhenClause()
			}

			p.SetState(5818)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(5822)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserELSE {
			{
				p.SetState(5820)
				p.Match(DorisParserParserELSE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5821)

				var _x = p.Expression()

				localctx.(*SimpleCaseContext).elseExpression = _x
			}

		}
		{
			p.SetState(5824)
			p.Match(DorisParserParserEND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 10:
		localctx = NewCastContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(5826)

			var _m = p.Match(DorisParserParserCAST)

			localctx.(*CastContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5827)
			p.Match(DorisParserParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5828)
			p.Expression()
		}
		{
			p.SetState(5829)
			p.Match(DorisParserParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5830)
			p.CastDataType()
		}
		{
			p.SetState(5831)
			p.Match(DorisParserParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 11:
		localctx = NewConstantDefaultContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(5833)
			p.Constant()
		}

	case 12:
		localctx = NewIntervalLiteralContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(5834)
			p.Interval()
		}

	case 13:
		localctx = NewStarContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(5835)
			p.Match(DorisParserParserASTERISK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5839)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 838, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(5836)
					p.ExceptOrReplace()
				}

			}
			p.SetState(5841)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 838, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case 14:
		localctx = NewStarContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(5842)
			p.QualifiedName()
		}
		{
			p.SetState(5843)
			p.Match(DorisParserParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5844)
			p.Match(DorisParserParserASTERISK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5848)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 839, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(5845)
					p.ExceptOrReplace()
				}

			}
			p.SetState(5850)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 839, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case 15:
		localctx = NewCharFunctionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(5851)
			p.Match(DorisParserParserCHAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5852)
			p.Match(DorisParserParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5853)

			var _x = p.Expression()

			localctx.(*CharFunctionContext)._expression = _x
		}
		localctx.(*CharFunctionContext).arguments = append(localctx.(*CharFunctionContext).arguments, localctx.(*CharFunctionContext)._expression)
		p.SetState(5858)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserParserCOMMA {
			{
				p.SetState(5854)
				p.Match(DorisParserParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5855)

				var _x = p.Expression()

				localctx.(*CharFunctionContext)._expression = _x
			}
			localctx.(*CharFunctionContext).arguments = append(localctx.(*CharFunctionContext).arguments, localctx.(*CharFunctionContext)._expression)

			p.SetState(5860)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(5863)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserUSING {
			{
				p.SetState(5861)
				p.Match(DorisParserParserUSING)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5862)

				var _x = p.IdentifierOrText()

				localctx.(*CharFunctionContext).charSet = _x
			}

		}
		{
			p.SetState(5865)
			p.Match(DorisParserParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 16:
		localctx = NewConvertCharSetContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(5867)
			p.Match(DorisParserParserCONVERT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5868)
			p.Match(DorisParserParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5869)

			var _x = p.Expression()

			localctx.(*ConvertCharSetContext).argument = _x
		}
		{
			p.SetState(5870)
			p.Match(DorisParserParserUSING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5871)

			var _x = p.IdentifierOrText()

			localctx.(*ConvertCharSetContext).charSet = _x
		}
		{
			p.SetState(5872)
			p.Match(DorisParserParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 17:
		localctx = NewConvertTypeContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(5874)
			p.Match(DorisParserParserCONVERT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5875)
			p.Match(DorisParserParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5876)

			var _x = p.Expression()

			localctx.(*ConvertTypeContext).argument = _x
		}
		{
			p.SetState(5877)
			p.Match(DorisParserParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5878)
			p.CastDataType()
		}
		{
			p.SetState(5879)
			p.Match(DorisParserParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 18:
		localctx = NewFunctionCallContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(5881)
			p.FunctionCallExpression()
		}

	case 19:
		localctx = NewSubqueryExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(5882)
			p.Match(DorisParserParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5883)
			p.Query()
		}
		{
			p.SetState(5884)
			p.Match(DorisParserParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 20:
		localctx = NewUserVariableContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(5886)
			p.Match(DorisParserParserATSIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5887)
			p.IdentifierOrText()
		}

	case 21:
		localctx = NewSystemVariableContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(5888)
			p.Match(DorisParserParserDOUBLEATSIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5891)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 842, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5889)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*SystemVariableContext).kind = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserParserGLOBAL || _la == DorisParserParserSESSION) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*SystemVariableContext).kind = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(5890)
				p.Match(DorisParserParserDOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(5893)
			p.Identifier()
		}

	case 22:
		localctx = NewColumnReferenceContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		p.SetState(5895)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserBINARY {
			{
				p.SetState(5894)
				p.Match(DorisParserParserBINARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(5897)
			p.Identifier()
		}

	case 23:
		localctx = NewParenthesizedExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(5898)
			p.Match(DorisParserParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5899)
			p.Expression()
		}
		{
			p.SetState(5900)
			p.Match(DorisParserParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 24:
		localctx = NewEncryptKeyContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(5902)
			p.Match(DorisParserParserKEY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5906)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 844, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5903)

				var _x = p.Identifier()

				localctx.(*EncryptKeyContext).dbName = _x
			}
			{
				p.SetState(5904)
				p.Match(DorisParserParserDOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(5908)

			var _x = p.Identifier()

			localctx.(*EncryptKeyContext).keyName = _x
		}

	case 25:
		localctx = NewExtractContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(5909)
			p.Match(DorisParserParserEXTRACT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5910)
			p.Match(DorisParserParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5911)

			var _x = p.Identifier()

			localctx.(*ExtractContext).field = _x
		}
		{
			p.SetState(5912)
			p.Match(DorisParserParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5914)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 845, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5913)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserParserDATE || _la == DorisParserParserTIMESTAMP) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(5916)

			var _x = p.valueExpression(0)

			localctx.(*ExtractContext).source = _x
		}
		{
			p.SetState(5917)
			p.Match(DorisParserParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(5947)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 850, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(5945)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 849, p.GetParserRuleContext()) {
			case 1:
				localctx = NewElementAtContext(p, NewPrimaryExpressionContext(p, _parentctx, _parentState))
				localctx.(*ElementAtContext).value = _prevctx

				p.PushNewRecursionContext(localctx, _startState, DorisParserParserRULE_primaryExpression)
				p.SetState(5921)

				if !(p.Precpred(p.GetParserRuleContext(), 11)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 11)", ""))
					goto errorExit
				}
				{
					p.SetState(5922)
					p.Match(DorisParserParserLEFT_BRACKET)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(5923)

					var _x = p.valueExpression(0)

					localctx.(*ElementAtContext).index = _x
				}
				{
					p.SetState(5924)
					p.Match(DorisParserParserRIGHT_BRACKET)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case 2:
				localctx = NewArraySliceContext(p, NewPrimaryExpressionContext(p, _parentctx, _parentState))
				localctx.(*ArraySliceContext).value = _prevctx

				p.PushNewRecursionContext(localctx, _startState, DorisParserParserRULE_primaryExpression)
				p.SetState(5926)

				if !(p.Precpred(p.GetParserRuleContext(), 10)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 10)", ""))
					goto errorExit
				}
				{
					p.SetState(5927)
					p.Match(DorisParserParserLEFT_BRACKET)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(5928)

					var _x = p.valueExpression(0)

					localctx.(*ArraySliceContext).begin = _x
				}
				{
					p.SetState(5929)
					p.Match(DorisParserParserCOLON)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(5931)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-2305884869834611068) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&4610552282352573437) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-9079387158168266267) != 0) || ((int64((_la-192)) & ^0x3f) == 0 && ((int64(1)<<(_la-192))&4321098383830537129) != 0) || ((int64((_la-256)) & ^0x3f) == 0 && ((int64(1)<<(_la-256))&-5278501354984228887) != 0) || ((int64((_la-320)) & ^0x3f) == 0 && ((int64(1)<<(_la-320))&-4187784802352497917) != 0) || ((int64((_la-384)) & ^0x3f) == 0 && ((int64(1)<<(_la-384))&9222796779122712571) != 0) || ((int64((_la-452)) & ^0x3f) == 0 && ((int64(1)<<(_la-452))&2449945648132536049) != 0) || ((int64((_la-517)) & ^0x3f) == 0 && ((int64(1)<<(_la-517))&236487452417) != 0) {
					{
						p.SetState(5930)

						var _x = p.valueExpression(0)

						localctx.(*ArraySliceContext).end = _x
					}

				}
				{
					p.SetState(5933)
					p.Match(DorisParserParserRIGHT_BRACKET)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case 3:
				localctx = NewDereferenceContext(p, NewPrimaryExpressionContext(p, _parentctx, _parentState))
				localctx.(*DereferenceContext).base = _prevctx

				p.PushNewRecursionContext(localctx, _startState, DorisParserParserRULE_primaryExpression)
				p.SetState(5935)

				if !(p.Precpred(p.GetParserRuleContext(), 5)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 5)", ""))
					goto errorExit
				}
				{
					p.SetState(5936)
					p.Match(DorisParserParserDOT)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(5937)

					var _x = p.Identifier()

					localctx.(*DereferenceContext).fieldName = _x
				}

			case 4:
				localctx = NewCollateContext(p, NewPrimaryExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, DorisParserParserRULE_primaryExpression)
				p.SetState(5938)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
					goto errorExit
				}
				{
					p.SetState(5939)
					p.Match(DorisParserParserCOLLATE)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(5943)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}

				switch p.GetTokenStream().LA(1) {
				case DorisParserParserLEFT_BRACE, DorisParserParserRIGHT_BRACE, DorisParserParserACTIONS, DorisParserParserAFTER, DorisParserParserAGG_STATE, DorisParserParserAGGREGATE, DorisParserParserALIAS, DorisParserParserANALYZED, DorisParserParserARRAY, DorisParserParserAT, DorisParserParserAUTHORS, DorisParserParserAUTO_INCREMENT, DorisParserParserALWAYS, DorisParserParserBACKENDS, DorisParserParserBACKUP, DorisParserParserBEGIN, DorisParserParserBELONG, DorisParserParserBIN, DorisParserParserBITAND, DorisParserParserBITMAP, DorisParserParserBITMAP_EMPTY, DorisParserParserBITMAP_UNION, DorisParserParserBITOR, DorisParserParserBITXOR, DorisParserParserBLOB, DorisParserParserBOOLEAN, DorisParserParserBRANCH, DorisParserParserBRIEF, DorisParserParserBROKER, DorisParserParserBUCKETS, DorisParserParserBUILD, DorisParserParserBUILTIN, DorisParserParserBULK, DorisParserParserCACHE, DorisParserParserCACHED, DorisParserParserCALL, DorisParserParserCATALOG, DorisParserParserCATALOGS, DorisParserParserCHAIN, DorisParserParserCHAR, DorisParserParserCHARSET, DorisParserParserCHECK, DorisParserParserCLUSTER, DorisParserParserCLUSTERS, DorisParserParserCOLLATION, DorisParserParserCOLLECT, DorisParserParserCOLOCATE, DorisParserParserCOLUMNS, DorisParserParserCOMMENT, DorisParserParserCOMMIT, DorisParserParserCOMMITTED, DorisParserParserCOMPACT, DorisParserParserCOMPLETE, DorisParserParserCOMPRESS_TYPE, DorisParserParserCOMPUTE, DorisParserParserCONDITIONS, DorisParserParserCONFIG, DorisParserParserCONNECTION, DorisParserParserCONNECTION_ID, DorisParserParserCONSISTENT, DorisParserParserCONSTRAINTS, DorisParserParserCONVERT, DorisParserParserCONVERT_LSC, DorisParserParserCOPY, DorisParserParserCOUNT, DorisParserParserCREATION, DorisParserParserCRON, DorisParserParserCURRENT_CATALOG, DorisParserParserCURRENT_DATE, DorisParserParserCURRENT_TIME, DorisParserParserCURRENT_TIMESTAMP, DorisParserParserCURRENT_USER, DorisParserParserDATA, DorisParserParserDATE, DorisParserParserDATETIME, DorisParserParserDATETIMEV2, DorisParserParserDATEV2, DorisParserParserDATETIMEV1, DorisParserParserDATEV1, DorisParserParserDAY, DorisParserParserDAYS, DorisParserParserDECIMAL, DorisParserParserDECIMALV2, DorisParserParserDECIMALV3, DorisParserParserDEFERRED, DorisParserParserDEMAND, DorisParserParserDIAGNOSE, DorisParserParserDIAGNOSIS, DorisParserParserDICTIONARIES, DorisParserParserDICTIONARY, DorisParserParserDISTINCTPC, DorisParserParserDISTINCTPCSA, DorisParserParserDO, DorisParserParserDORIS_INTERNAL_TABLE_ID, DorisParserParserDUAL, DorisParserParserDYNAMIC, DorisParserParserE, DorisParserParserENABLE, DorisParserParserENCRYPTKEY, DorisParserParserENCRYPTKEYS, DorisParserParserEND, DorisParserParserENDS, DorisParserParserENGINE, DorisParserParserENGINES, DorisParserParserERRORS, DorisParserParserESCAPE, DorisParserParserEVENTS, DorisParserParserEVERY, DorisParserParserEXCLUDE, DorisParserParserEXPIRED, DorisParserParserEXTERNAL, DorisParserParserFAILED_LOGIN_ATTEMPTS, DorisParserParserFAST, DorisParserParserFEATURE, DorisParserParserFIELDS, DorisParserParserFILE, DorisParserParserFILTER, DorisParserParserFIRST, DorisParserParserFORMAT, DorisParserParserFREE, DorisParserParserFRONTENDS, DorisParserParserFUNCTION, DorisParserParserGENERATED, DorisParserParserGENERIC, DorisParserParserGLOBAL, DorisParserParserGRAPH, DorisParserParserGROUPING, DorisParserParserGROUPS, DorisParserParserHASH, DorisParserParserHASH_MAP, DorisParserParserHDFS, DorisParserParserHELP, DorisParserParserHISTOGRAM, DorisParserParserHLL_UNION, DorisParserParserHOSTNAME, DorisParserParserHOTSPOT, DorisParserParserHOUR, DorisParserParserHOURS, DorisParserParserHUB, DorisParserParserIDENTIFIED, DorisParserParserIGNORE, DorisParserParserIMMEDIATE, DorisParserParserINCREMENTAL, DorisParserParserINDEXES, DorisParserParserINVERTED, DorisParserParserIP_TRIE, DorisParserParserIPV4, DorisParserParserIPV6, DorisParserParserIS_NOT_NULL_PRED, DorisParserParserIS_NULL_PRED, DorisParserParserISNULL, DorisParserParserISOLATION, DorisParserParserJOB, DorisParserParserJOBS, DorisParserParserJSON, DorisParserParserJSONB, DorisParserParserLABEL, DorisParserParserLAST, DorisParserParserLDAP, DorisParserParserLDAP_ADMIN_PASSWORD, DorisParserParserLESS, DorisParserParserLEVEL, DorisParserParserLINES, DorisParserParserLINK, DorisParserParserLOCAL, DorisParserParserLOCALTIME, DorisParserParserLOCALTIMESTAMP, DorisParserParserLOCATION, DorisParserParserLOCK, DorisParserParserLOGICAL, DorisParserParserMANUAL, DorisParserParserMAP, DorisParserParserMATCH_ALL, DorisParserParserMATCH_ANY, DorisParserParserMATCH_PHRASE, DorisParserParserMATCH_PHRASE_EDGE, DorisParserParserMATCH_PHRASE_PREFIX, DorisParserParserMATCH_REGEXP, DorisParserParserMATERIALIZED, DorisParserParserMAX, DorisParserParserMEMO, DorisParserParserMERGE, DorisParserParserMIGRATE, DorisParserParserMIGRATIONS, DorisParserParserMIN, DorisParserParserMINUTE, DorisParserParserMINUTES, DorisParserParserMODIFY, DorisParserParserMONTH, DorisParserParserMTMV, DorisParserParserNAME, DorisParserParserNAMES, DorisParserParserNEGATIVE, DorisParserParserNEVER, DorisParserParserNEXT, DorisParserParserNGRAM_BF, DorisParserParserNO, DorisParserParserNON_NULLABLE, DorisParserParserNULLS, DorisParserParserOF, DorisParserParserOFFSET, DorisParserParserONLY, DorisParserParserOPEN, DorisParserParserOPTIMIZED, DorisParserParserPARAMETER, DorisParserParserPARSED, DorisParserParserPARTITIONS, DorisParserParserPASSWORD, DorisParserParserPASSWORD_EXPIRE, DorisParserParserPASSWORD_HISTORY, DorisParserParserPASSWORD_LOCK_TIME, DorisParserParserPASSWORD_REUSE, DorisParserParserPATH, DorisParserParserPAUSE, DorisParserParserPERCENT, DorisParserParserPERIOD, DorisParserParserPERMISSIVE, DorisParserParserPHYSICAL, DorisParserParserPI, DorisParserParserPLAN, DorisParserParserPRIVILEGES, DorisParserParserPROCESS, DorisParserParserPLUGIN, DorisParserParserPLUGINS, DorisParserParserPOLICY, DorisParserParserPROC, DorisParserParserPROCESSLIST, DorisParserParserPROFILE, DorisParserParserPROPERTIES, DorisParserParserPROPERTY, DorisParserParserQUANTILE_STATE, DorisParserParserQUANTILE_UNION, DorisParserParserQUERY, DorisParserParserQUEUED, DorisParserParserQUOTA, DorisParserParserQUALIFY, DorisParserParserQUARTER, DorisParserParserRANDOM, DorisParserParserRECENT, DorisParserParserRECOVER, DorisParserParserRECYCLE, DorisParserParserREFRESH, DorisParserParserREPEATABLE, DorisParserParserREPLACE, DorisParserParserREPLACE_IF_NOT_NULL, DorisParserParserREPLAYER, DorisParserParserREPOSITORIES, DorisParserParserREPOSITORY, DorisParserParserRESOURCE, DorisParserParserRESOURCES, DorisParserParserRESTORE, DorisParserParserRESTRICTIVE, DorisParserParserRESUME, DorisParserParserRETAIN, DorisParserParserRETENTION, DorisParserParserRETURNS, DorisParserParserREWRITTEN, DorisParserParserRLIKE, DorisParserParserROLLBACK, DorisParserParserROLLUP, DorisParserParserROUTINE, DorisParserParserS3, DorisParserParserSAMPLE, DorisParserParserSCHEDULE, DorisParserParserSCHEDULER, DorisParserParserSCHEMA, DorisParserParserSECOND, DorisParserParserSERIALIZABLE, DorisParserParserSESSION, DorisParserParserSESSION_USER, DorisParserParserSET_SESSION_VARIABLE, DorisParserParserSHAPE, DorisParserParserSKEW, DorisParserParserSNAPSHOT, DorisParserParserSNAPSHOTS, DorisParserParserSONAME, DorisParserParserSPLIT, DorisParserParserSQL, DorisParserParserSTAGE, DorisParserParserSTAGES, DorisParserParserSTART, DorisParserParserSTARTS, DorisParserParserSTATS, DorisParserParserSTATUS, DorisParserParserSTOP, DorisParserParserSTORAGE, DorisParserParserSTREAM, DorisParserParserSTREAMING, DorisParserParserSTRING, DorisParserParserSTRUCT, DorisParserParserSUM, DorisParserParserTABLES, DorisParserParserTAG, DorisParserParserTASK, DorisParserParserTASKS, DorisParserParserTEMPORARY, DorisParserParserTEXT, DorisParserParserTHAN, DorisParserParserTIME, DorisParserParserTIMESTAMP, DorisParserParserTRANSACTION, DorisParserParserTREE, DorisParserParserTRIGGERS, DorisParserParserTRUNCATE, DorisParserParserTYPE, DorisParserParserTYPES, DorisParserParserUNCOMMITTED, DorisParserParserUNLOCK, DorisParserParserUNSET, DorisParserParserUP, DorisParserParserUSER, DorisParserParserVALUE, DorisParserParserVARCHAR, DorisParserParserVARIABLE, DorisParserParserVARIABLES, DorisParserParserVARIANT, DorisParserParserVAULT, DorisParserParserVAULTS, DorisParserParserVERBOSE, DorisParserParserVERSION, DorisParserParserVIEW, DorisParserParserVIEWS, DorisParserParserWARM, DorisParserParserWARNINGS, DorisParserParserWEEK, DorisParserParserWORK, DorisParserParserYEAR, DorisParserParserHINT_START, DorisParserParserHINT_END, DorisParserParserCOMMENT_START, DorisParserParserIDENTIFIER, DorisParserParserBACKQUOTED_IDENTIFIER:
					{
						p.SetState(5940)
						p.Identifier()
					}

				case DorisParserParserSTRING_LITERAL:
					{
						p.SetState(5941)
						p.Match(DorisParserParserSTRING_LITERAL)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				case DorisParserParserDEFAULT:
					{
						p.SetState(5942)
						p.Match(DorisParserParserDEFAULT)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				default:
					p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
					goto errorExit
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(5949)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 850, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExceptOrReplaceContext is an interface to support dynamic dispatch.
type IExceptOrReplaceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsExceptOrReplaceContext differentiates from other interfaces.
	IsExceptOrReplaceContext()
}

type ExceptOrReplaceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExceptOrReplaceContext() *ExceptOrReplaceContext {
	var p = new(ExceptOrReplaceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_exceptOrReplace
	return p
}

func InitEmptyExceptOrReplaceContext(p *ExceptOrReplaceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_exceptOrReplace
}

func (*ExceptOrReplaceContext) IsExceptOrReplaceContext() {}

func NewExceptOrReplaceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExceptOrReplaceContext {
	var p = new(ExceptOrReplaceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_exceptOrReplace

	return p
}

func (s *ExceptOrReplaceContext) GetParser() antlr.Parser { return s.parser }

func (s *ExceptOrReplaceContext) CopyAll(ctx *ExceptOrReplaceContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ExceptOrReplaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExceptOrReplaceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ReplaceContext struct {
	ExceptOrReplaceContext
}

func NewReplaceContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ReplaceContext {
	var p = new(ReplaceContext)

	InitEmptyExceptOrReplaceContext(&p.ExceptOrReplaceContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExceptOrReplaceContext))

	return p
}

func (s *ReplaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReplaceContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserREPLACE, 0)
}

func (s *ReplaceContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLEFT_PAREN, 0)
}

func (s *ReplaceContext) NamedExpressionSeq() INamedExpressionSeqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamedExpressionSeqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamedExpressionSeqContext)
}

func (s *ReplaceContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRIGHT_PAREN, 0)
}

func (s *ReplaceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitReplace(s)

	default:
		return t.VisitChildren(s)
	}
}

type ExceptContext struct {
	ExceptOrReplaceContext
}

func NewExceptContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExceptContext {
	var p = new(ExceptContext)

	InitEmptyExceptOrReplaceContext(&p.ExceptOrReplaceContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExceptOrReplaceContext))

	return p
}

func (s *ExceptContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExceptContext) EXCEPT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserEXCEPT, 0)
}

func (s *ExceptContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLEFT_PAREN, 0)
}

func (s *ExceptContext) NamedExpressionSeq() INamedExpressionSeqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamedExpressionSeqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamedExpressionSeqContext)
}

func (s *ExceptContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRIGHT_PAREN, 0)
}

func (s *ExceptContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitExcept(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) ExceptOrReplace() (localctx IExceptOrReplaceContext) {
	localctx = NewExceptOrReplaceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 388, DorisParserParserRULE_exceptOrReplace)
	p.SetState(5960)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserParserEXCEPT:
		localctx = NewExceptContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5950)
			p.Match(DorisParserParserEXCEPT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5951)
			p.Match(DorisParserParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5952)
			p.NamedExpressionSeq()
		}
		{
			p.SetState(5953)
			p.Match(DorisParserParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserParserREPLACE:
		localctx = NewReplaceContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5955)
			p.Match(DorisParserParserREPLACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5956)
			p.Match(DorisParserParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5957)
			p.NamedExpressionSeq()
		}
		{
			p.SetState(5958)
			p.Match(DorisParserParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICastDataTypeContext is an interface to support dynamic dispatch.
type ICastDataTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DataType() IDataTypeContext
	SIGNED() antlr.TerminalNode
	UNSIGNED() antlr.TerminalNode
	INT() antlr.TerminalNode
	INTEGER() antlr.TerminalNode

	// IsCastDataTypeContext differentiates from other interfaces.
	IsCastDataTypeContext()
}

type CastDataTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCastDataTypeContext() *CastDataTypeContext {
	var p = new(CastDataTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_castDataType
	return p
}

func InitEmptyCastDataTypeContext(p *CastDataTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_castDataType
}

func (*CastDataTypeContext) IsCastDataTypeContext() {}

func NewCastDataTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CastDataTypeContext {
	var p = new(CastDataTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_castDataType

	return p
}

func (s *CastDataTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *CastDataTypeContext) DataType() IDataTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *CastDataTypeContext) SIGNED() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSIGNED, 0)
}

func (s *CastDataTypeContext) UNSIGNED() antlr.TerminalNode {
	return s.GetToken(DorisParserParserUNSIGNED, 0)
}

func (s *CastDataTypeContext) INT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserINT, 0)
}

func (s *CastDataTypeContext) INTEGER() antlr.TerminalNode {
	return s.GetToken(DorisParserParserINTEGER, 0)
}

func (s *CastDataTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CastDataTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CastDataTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitCastDataType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) CastDataType() (localctx ICastDataTypeContext) {
	localctx = NewCastDataTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 390, DorisParserParserRULE_castDataType)
	var _la int

	p.SetState(5967)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserParserAGG_STATE, DorisParserParserALL, DorisParserParserARRAY, DorisParserParserBIGINT, DorisParserParserBITMAP, DorisParserParserBOOLEAN, DorisParserParserCHAR, DorisParserParserDATE, DorisParserParserDATETIME, DorisParserParserDATETIMEV2, DorisParserParserDATEV2, DorisParserParserDATETIMEV1, DorisParserParserDATEV1, DorisParserParserDECIMAL, DorisParserParserDECIMALV2, DorisParserParserDECIMALV3, DorisParserParserDOUBLE, DorisParserParserFLOAT, DorisParserParserHLL, DorisParserParserINT, DorisParserParserINTEGER, DorisParserParserIPV4, DorisParserParserIPV6, DorisParserParserJSON, DorisParserParserJSONB, DorisParserParserLARGEINT, DorisParserParserMAP, DorisParserParserQUANTILE_STATE, DorisParserParserSMALLINT, DorisParserParserSTRING, DorisParserParserSTRUCT, DorisParserParserTEXT, DorisParserParserTIME, DorisParserParserTINYINT, DorisParserParserVARCHAR, DorisParserParserVARIANT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5962)
			p.DataType()
		}

	case DorisParserParserSIGNED, DorisParserParserUNSIGNED:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5963)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserParserSIGNED || _la == DorisParserParserUNSIGNED) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(5965)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserINT || _la == DorisParserParserINTEGER {
			{
				p.SetState(5964)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserParserINT || _la == DorisParserParserINTEGER) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionCallExpressionContext is an interface to support dynamic dispatch.
type IFunctionCallExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_expression returns the _expression rule contexts.
	Get_expression() IExpressionContext

	// Set_expression sets the _expression rule contexts.
	Set_expression(IExpressionContext)

	// GetArguments returns the arguments rule context list.
	GetArguments() []IExpressionContext

	// SetArguments sets the arguments rule context list.
	SetArguments([]IExpressionContext)

	// Getter signatures
	FunctionIdentifier() IFunctionIdentifierContext
	LEFT_PAREN() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode
	OVER() antlr.TerminalNode
	WindowSpec() IWindowSpecContext
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	ORDER() antlr.TerminalNode
	BY() antlr.TerminalNode
	AllSortItem() []ISortItemContext
	SortItem(i int) ISortItemContext
	DISTINCT() antlr.TerminalNode
	ALL() antlr.TerminalNode

	// IsFunctionCallExpressionContext differentiates from other interfaces.
	IsFunctionCallExpressionContext()
}

type FunctionCallExpressionContext struct {
	antlr.BaseParserRuleContext
	parser      antlr.Parser
	_expression IExpressionContext
	arguments   []IExpressionContext
}

func NewEmptyFunctionCallExpressionContext() *FunctionCallExpressionContext {
	var p = new(FunctionCallExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_functionCallExpression
	return p
}

func InitEmptyFunctionCallExpressionContext(p *FunctionCallExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_functionCallExpression
}

func (*FunctionCallExpressionContext) IsFunctionCallExpressionContext() {}

func NewFunctionCallExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionCallExpressionContext {
	var p = new(FunctionCallExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_functionCallExpression

	return p
}

func (s *FunctionCallExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionCallExpressionContext) Get_expression() IExpressionContext { return s._expression }

func (s *FunctionCallExpressionContext) Set_expression(v IExpressionContext) { s._expression = v }

func (s *FunctionCallExpressionContext) GetArguments() []IExpressionContext { return s.arguments }

func (s *FunctionCallExpressionContext) SetArguments(v []IExpressionContext) { s.arguments = v }

func (s *FunctionCallExpressionContext) FunctionIdentifier() IFunctionIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionIdentifierContext)
}

func (s *FunctionCallExpressionContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLEFT_PAREN, 0)
}

func (s *FunctionCallExpressionContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRIGHT_PAREN, 0)
}

func (s *FunctionCallExpressionContext) OVER() antlr.TerminalNode {
	return s.GetToken(DorisParserParserOVER, 0)
}

func (s *FunctionCallExpressionContext) WindowSpec() IWindowSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowSpecContext)
}

func (s *FunctionCallExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *FunctionCallExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *FunctionCallExpressionContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserCOMMA)
}

func (s *FunctionCallExpressionContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOMMA, i)
}

func (s *FunctionCallExpressionContext) ORDER() antlr.TerminalNode {
	return s.GetToken(DorisParserParserORDER, 0)
}

func (s *FunctionCallExpressionContext) BY() antlr.TerminalNode {
	return s.GetToken(DorisParserParserBY, 0)
}

func (s *FunctionCallExpressionContext) AllSortItem() []ISortItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISortItemContext); ok {
			len++
		}
	}

	tst := make([]ISortItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISortItemContext); ok {
			tst[i] = t.(ISortItemContext)
			i++
		}
	}

	return tst
}

func (s *FunctionCallExpressionContext) SortItem(i int) ISortItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortItemContext)
}

func (s *FunctionCallExpressionContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDISTINCT, 0)
}

func (s *FunctionCallExpressionContext) ALL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserALL, 0)
}

func (s *FunctionCallExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionCallExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionCallExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitFunctionCallExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) FunctionCallExpression() (localctx IFunctionCallExpressionContext) {
	localctx = NewFunctionCallExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 392, DorisParserParserRULE_functionCallExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5969)
		p.FunctionIdentifier()
	}
	{
		p.SetState(5970)
		p.Match(DorisParserParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5994)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-2305884869833562492) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&4610552282352573437) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-9079382760121754139) != 0) || ((int64((_la-192)) & ^0x3f) == 0 && ((int64(1)<<(_la-192))&4321098383830537129) != 0) || ((int64((_la-256)) & ^0x3f) == 0 && ((int64(1)<<(_la-256))&-5206443760946300951) != 0) || ((int64((_la-320)) & ^0x3f) == 0 && ((int64(1)<<(_la-320))&-4187784802352497917) != 0) || ((int64((_la-384)) & ^0x3f) == 0 && ((int64(1)<<(_la-384))&9222796779122712571) != 0) || ((int64((_la-452)) & ^0x3f) == 0 && ((int64(1)<<(_la-452))&2449945648132536049) != 0) || ((int64((_la-517)) & ^0x3f) == 0 && ((int64(1)<<(_la-517))&236487517953) != 0) {
		p.SetState(5972)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserALL || _la == DorisParserParserDISTINCT {
			{
				p.SetState(5971)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserParserALL || _la == DorisParserParserDISTINCT) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(5974)

			var _x = p.Expression()

			localctx.(*FunctionCallExpressionContext)._expression = _x
		}
		localctx.(*FunctionCallExpressionContext).arguments = append(localctx.(*FunctionCallExpressionContext).arguments, localctx.(*FunctionCallExpressionContext)._expression)
		p.SetState(5979)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserParserCOMMA {
			{
				p.SetState(5975)
				p.Match(DorisParserParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5976)

				var _x = p.Expression()

				localctx.(*FunctionCallExpressionContext)._expression = _x
			}
			localctx.(*FunctionCallExpressionContext).arguments = append(localctx.(*FunctionCallExpressionContext).arguments, localctx.(*FunctionCallExpressionContext)._expression)

			p.SetState(5981)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(5992)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserORDER {
			{
				p.SetState(5982)
				p.Match(DorisParserParserORDER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5983)
				p.Match(DorisParserParserBY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5984)
				p.SortItem()
			}
			p.SetState(5989)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == DorisParserParserCOMMA {
				{
					p.SetState(5985)
					p.Match(DorisParserParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(5986)
					p.SortItem()
				}

				p.SetState(5991)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}

	}
	{
		p.SetState(5996)
		p.Match(DorisParserParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5999)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 859, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5997)
			p.Match(DorisParserParserOVER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5998)
			p.WindowSpec()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionIdentifierContext is an interface to support dynamic dispatch.
type IFunctionIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDbName returns the dbName rule contexts.
	GetDbName() IIdentifierContext

	// SetDbName sets the dbName rule contexts.
	SetDbName(IIdentifierContext)

	// Getter signatures
	FunctionNameIdentifier() IFunctionNameIdentifierContext
	DOT() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsFunctionIdentifierContext differentiates from other interfaces.
	IsFunctionIdentifierContext()
}

type FunctionIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	dbName IIdentifierContext
}

func NewEmptyFunctionIdentifierContext() *FunctionIdentifierContext {
	var p = new(FunctionIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_functionIdentifier
	return p
}

func InitEmptyFunctionIdentifierContext(p *FunctionIdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_functionIdentifier
}

func (*FunctionIdentifierContext) IsFunctionIdentifierContext() {}

func NewFunctionIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionIdentifierContext {
	var p = new(FunctionIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_functionIdentifier

	return p
}

func (s *FunctionIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionIdentifierContext) GetDbName() IIdentifierContext { return s.dbName }

func (s *FunctionIdentifierContext) SetDbName(v IIdentifierContext) { s.dbName = v }

func (s *FunctionIdentifierContext) FunctionNameIdentifier() IFunctionNameIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionNameIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionNameIdentifierContext)
}

func (s *FunctionIdentifierContext) DOT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDOT, 0)
}

func (s *FunctionIdentifierContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *FunctionIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitFunctionIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) FunctionIdentifier() (localctx IFunctionIdentifierContext) {
	localctx = NewFunctionIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 394, DorisParserParserRULE_functionIdentifier)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(6004)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 860, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(6001)

			var _x = p.Identifier()

			localctx.(*FunctionIdentifierContext).dbName = _x
		}
		{
			p.SetState(6002)
			p.Match(DorisParserParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(6006)
		p.FunctionNameIdentifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionNameIdentifierContext is an interface to support dynamic dispatch.
type IFunctionNameIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	ADD() antlr.TerminalNode
	CONNECTION_ID() antlr.TerminalNode
	CURRENT_CATALOG() antlr.TerminalNode
	CURRENT_USER() antlr.TerminalNode
	DATABASE() antlr.TerminalNode
	IF() antlr.TerminalNode
	LEFT() antlr.TerminalNode
	LIKE() antlr.TerminalNode
	PASSWORD() antlr.TerminalNode
	REGEXP() antlr.TerminalNode
	RIGHT() antlr.TerminalNode
	SCHEMA() antlr.TerminalNode
	SESSION_USER() antlr.TerminalNode
	TRIM() antlr.TerminalNode
	USER() antlr.TerminalNode

	// IsFunctionNameIdentifierContext differentiates from other interfaces.
	IsFunctionNameIdentifierContext()
}

type FunctionNameIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionNameIdentifierContext() *FunctionNameIdentifierContext {
	var p = new(FunctionNameIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_functionNameIdentifier
	return p
}

func InitEmptyFunctionNameIdentifierContext(p *FunctionNameIdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_functionNameIdentifier
}

func (*FunctionNameIdentifierContext) IsFunctionNameIdentifierContext() {}

func NewFunctionNameIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionNameIdentifierContext {
	var p = new(FunctionNameIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_functionNameIdentifier

	return p
}

func (s *FunctionNameIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionNameIdentifierContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *FunctionNameIdentifierContext) ADD() antlr.TerminalNode {
	return s.GetToken(DorisParserParserADD, 0)
}

func (s *FunctionNameIdentifierContext) CONNECTION_ID() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCONNECTION_ID, 0)
}

func (s *FunctionNameIdentifierContext) CURRENT_CATALOG() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCURRENT_CATALOG, 0)
}

func (s *FunctionNameIdentifierContext) CURRENT_USER() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCURRENT_USER, 0)
}

func (s *FunctionNameIdentifierContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDATABASE, 0)
}

func (s *FunctionNameIdentifierContext) IF() antlr.TerminalNode {
	return s.GetToken(DorisParserParserIF, 0)
}

func (s *FunctionNameIdentifierContext) LEFT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLEFT, 0)
}

func (s *FunctionNameIdentifierContext) LIKE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLIKE, 0)
}

func (s *FunctionNameIdentifierContext) PASSWORD() antlr.TerminalNode {
	return s.GetToken(DorisParserParserPASSWORD, 0)
}

func (s *FunctionNameIdentifierContext) REGEXP() antlr.TerminalNode {
	return s.GetToken(DorisParserParserREGEXP, 0)
}

func (s *FunctionNameIdentifierContext) RIGHT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRIGHT, 0)
}

func (s *FunctionNameIdentifierContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSCHEMA, 0)
}

func (s *FunctionNameIdentifierContext) SESSION_USER() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSESSION_USER, 0)
}

func (s *FunctionNameIdentifierContext) TRIM() antlr.TerminalNode {
	return s.GetToken(DorisParserParserTRIM, 0)
}

func (s *FunctionNameIdentifierContext) USER() antlr.TerminalNode {
	return s.GetToken(DorisParserParserUSER, 0)
}

func (s *FunctionNameIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionNameIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionNameIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitFunctionNameIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) FunctionNameIdentifier() (localctx IFunctionNameIdentifierContext) {
	localctx = NewFunctionNameIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 396, DorisParserParserRULE_functionNameIdentifier)
	p.SetState(6024)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 861, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6008)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6009)
			p.Match(DorisParserParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6010)
			p.Match(DorisParserParserCONNECTION_ID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(6011)
			p.Match(DorisParserParserCURRENT_CATALOG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(6012)
			p.Match(DorisParserParserCURRENT_USER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(6013)
			p.Match(DorisParserParserDATABASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(6014)
			p.Match(DorisParserParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(6015)
			p.Match(DorisParserParserLEFT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(6016)
			p.Match(DorisParserParserLIKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(6017)
			p.Match(DorisParserParserPASSWORD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(6018)
			p.Match(DorisParserParserREGEXP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(6019)
			p.Match(DorisParserParserRIGHT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(6020)
			p.Match(DorisParserParserSCHEMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(6021)
			p.Match(DorisParserParserSESSION_USER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(6022)
			p.Match(DorisParserParserTRIM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(6023)
			p.Match(DorisParserParserUSER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWindowSpecContext is an interface to support dynamic dispatch.
type IWindowSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LEFT_PAREN() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode
	PartitionClause() IPartitionClauseContext
	SortClause() ISortClauseContext
	WindowFrame() IWindowFrameContext

	// IsWindowSpecContext differentiates from other interfaces.
	IsWindowSpecContext()
}

type WindowSpecContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindowSpecContext() *WindowSpecContext {
	var p = new(WindowSpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_windowSpec
	return p
}

func InitEmptyWindowSpecContext(p *WindowSpecContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_windowSpec
}

func (*WindowSpecContext) IsWindowSpecContext() {}

func NewWindowSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WindowSpecContext {
	var p = new(WindowSpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_windowSpec

	return p
}

func (s *WindowSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *WindowSpecContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLEFT_PAREN, 0)
}

func (s *WindowSpecContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRIGHT_PAREN, 0)
}

func (s *WindowSpecContext) PartitionClause() IPartitionClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionClauseContext)
}

func (s *WindowSpecContext) SortClause() ISortClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortClauseContext)
}

func (s *WindowSpecContext) WindowFrame() IWindowFrameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowFrameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowFrameContext)
}

func (s *WindowSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WindowSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WindowSpecContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitWindowSpec(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) WindowSpec() (localctx IWindowSpecContext) {
	localctx = NewWindowSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 398, DorisParserParserRULE_windowSpec)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6026)
		p.Match(DorisParserParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(6028)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserParserPARTITION {
		{
			p.SetState(6027)
			p.PartitionClause()
		}

	}
	p.SetState(6031)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserParserORDER {
		{
			p.SetState(6030)
			p.SortClause()
		}

	}
	p.SetState(6034)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserParserRANGE || _la == DorisParserParserROWS {
		{
			p.SetState(6033)
			p.WindowFrame()
		}

	}
	{
		p.SetState(6036)
		p.Match(DorisParserParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWindowFrameContext is an interface to support dynamic dispatch.
type IWindowFrameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetStart_ returns the start_ rule contexts.
	GetStart_() IFrameBoundaryContext

	// GetEnd returns the end rule contexts.
	GetEnd() IFrameBoundaryContext

	// SetStart_ sets the start_ rule contexts.
	SetStart_(IFrameBoundaryContext)

	// SetEnd sets the end rule contexts.
	SetEnd(IFrameBoundaryContext)

	// Getter signatures
	FrameUnits() IFrameUnitsContext
	AllFrameBoundary() []IFrameBoundaryContext
	FrameBoundary(i int) IFrameBoundaryContext
	BETWEEN() antlr.TerminalNode
	AND() antlr.TerminalNode

	// IsWindowFrameContext differentiates from other interfaces.
	IsWindowFrameContext()
}

type WindowFrameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	start_ IFrameBoundaryContext
	end    IFrameBoundaryContext
}

func NewEmptyWindowFrameContext() *WindowFrameContext {
	var p = new(WindowFrameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_windowFrame
	return p
}

func InitEmptyWindowFrameContext(p *WindowFrameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_windowFrame
}

func (*WindowFrameContext) IsWindowFrameContext() {}

func NewWindowFrameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WindowFrameContext {
	var p = new(WindowFrameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_windowFrame

	return p
}

func (s *WindowFrameContext) GetParser() antlr.Parser { return s.parser }

func (s *WindowFrameContext) GetStart_() IFrameBoundaryContext { return s.start_ }

func (s *WindowFrameContext) GetEnd() IFrameBoundaryContext { return s.end }

func (s *WindowFrameContext) SetStart_(v IFrameBoundaryContext) { s.start_ = v }

func (s *WindowFrameContext) SetEnd(v IFrameBoundaryContext) { s.end = v }

func (s *WindowFrameContext) FrameUnits() IFrameUnitsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFrameUnitsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFrameUnitsContext)
}

func (s *WindowFrameContext) AllFrameBoundary() []IFrameBoundaryContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFrameBoundaryContext); ok {
			len++
		}
	}

	tst := make([]IFrameBoundaryContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFrameBoundaryContext); ok {
			tst[i] = t.(IFrameBoundaryContext)
			i++
		}
	}

	return tst
}

func (s *WindowFrameContext) FrameBoundary(i int) IFrameBoundaryContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFrameBoundaryContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFrameBoundaryContext)
}

func (s *WindowFrameContext) BETWEEN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserBETWEEN, 0)
}

func (s *WindowFrameContext) AND() antlr.TerminalNode {
	return s.GetToken(DorisParserParserAND, 0)
}

func (s *WindowFrameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WindowFrameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WindowFrameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitWindowFrame(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) WindowFrame() (localctx IWindowFrameContext) {
	localctx = NewWindowFrameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 400, DorisParserParserRULE_windowFrame)
	p.SetState(6047)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 865, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6038)
			p.FrameUnits()
		}
		{
			p.SetState(6039)

			var _x = p.FrameBoundary()

			localctx.(*WindowFrameContext).start_ = _x
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6041)
			p.FrameUnits()
		}
		{
			p.SetState(6042)
			p.Match(DorisParserParserBETWEEN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6043)

			var _x = p.FrameBoundary()

			localctx.(*WindowFrameContext).start_ = _x
		}
		{
			p.SetState(6044)
			p.Match(DorisParserParserAND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6045)

			var _x = p.FrameBoundary()

			localctx.(*WindowFrameContext).end = _x
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFrameUnitsContext is an interface to support dynamic dispatch.
type IFrameUnitsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ROWS() antlr.TerminalNode
	RANGE() antlr.TerminalNode

	// IsFrameUnitsContext differentiates from other interfaces.
	IsFrameUnitsContext()
}

type FrameUnitsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFrameUnitsContext() *FrameUnitsContext {
	var p = new(FrameUnitsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_frameUnits
	return p
}

func InitEmptyFrameUnitsContext(p *FrameUnitsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_frameUnits
}

func (*FrameUnitsContext) IsFrameUnitsContext() {}

func NewFrameUnitsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FrameUnitsContext {
	var p = new(FrameUnitsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_frameUnits

	return p
}

func (s *FrameUnitsContext) GetParser() antlr.Parser { return s.parser }

func (s *FrameUnitsContext) ROWS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserROWS, 0)
}

func (s *FrameUnitsContext) RANGE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRANGE, 0)
}

func (s *FrameUnitsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FrameUnitsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FrameUnitsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitFrameUnits(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) FrameUnits() (localctx IFrameUnitsContext) {
	localctx = NewFrameUnitsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 402, DorisParserParserRULE_frameUnits)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6049)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisParserParserRANGE || _la == DorisParserParserROWS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFrameBoundaryContext is an interface to support dynamic dispatch.
type IFrameBoundaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetBoundType returns the boundType token.
	GetBoundType() antlr.Token

	// SetBoundType sets the boundType token.
	SetBoundType(antlr.Token)

	// Getter signatures
	UNBOUNDED() antlr.TerminalNode
	PRECEDING() antlr.TerminalNode
	FOLLOWING() antlr.TerminalNode
	ROW() antlr.TerminalNode
	CURRENT() antlr.TerminalNode
	Expression() IExpressionContext

	// IsFrameBoundaryContext differentiates from other interfaces.
	IsFrameBoundaryContext()
}

type FrameBoundaryContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	boundType antlr.Token
}

func NewEmptyFrameBoundaryContext() *FrameBoundaryContext {
	var p = new(FrameBoundaryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_frameBoundary
	return p
}

func InitEmptyFrameBoundaryContext(p *FrameBoundaryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_frameBoundary
}

func (*FrameBoundaryContext) IsFrameBoundaryContext() {}

func NewFrameBoundaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FrameBoundaryContext {
	var p = new(FrameBoundaryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_frameBoundary

	return p
}

func (s *FrameBoundaryContext) GetParser() antlr.Parser { return s.parser }

func (s *FrameBoundaryContext) GetBoundType() antlr.Token { return s.boundType }

func (s *FrameBoundaryContext) SetBoundType(v antlr.Token) { s.boundType = v }

func (s *FrameBoundaryContext) UNBOUNDED() antlr.TerminalNode {
	return s.GetToken(DorisParserParserUNBOUNDED, 0)
}

func (s *FrameBoundaryContext) PRECEDING() antlr.TerminalNode {
	return s.GetToken(DorisParserParserPRECEDING, 0)
}

func (s *FrameBoundaryContext) FOLLOWING() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFOLLOWING, 0)
}

func (s *FrameBoundaryContext) ROW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserROW, 0)
}

func (s *FrameBoundaryContext) CURRENT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCURRENT, 0)
}

func (s *FrameBoundaryContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *FrameBoundaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FrameBoundaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FrameBoundaryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitFrameBoundary(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) FrameBoundary() (localctx IFrameBoundaryContext) {
	localctx = NewFrameBoundaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 404, DorisParserParserRULE_frameBoundary)
	var _la int

	p.SetState(6058)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserParserUNBOUNDED:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6051)
			p.Match(DorisParserParserUNBOUNDED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6052)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*FrameBoundaryContext).boundType = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserParserFOLLOWING || _la == DorisParserParserPRECEDING) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*FrameBoundaryContext).boundType = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case DorisParserParserCURRENT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6053)

			var _m = p.Match(DorisParserParserCURRENT)

			localctx.(*FrameBoundaryContext).boundType = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6054)
			p.Match(DorisParserParserROW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserParserLEFT_PAREN, DorisParserParserLEFT_BRACKET, DorisParserParserLEFT_BRACE, DorisParserParserRIGHT_BRACE, DorisParserParserACTIONS, DorisParserParserADD, DorisParserParserAFTER, DorisParserParserAGG_STATE, DorisParserParserAGGREGATE, DorisParserParserALIAS, DorisParserParserANALYZED, DorisParserParserARRAY, DorisParserParserAT, DorisParserParserAUTHORS, DorisParserParserAUTO_INCREMENT, DorisParserParserALWAYS, DorisParserParserBACKENDS, DorisParserParserBACKUP, DorisParserParserBEGIN, DorisParserParserBELONG, DorisParserParserBIN, DorisParserParserBINARY, DorisParserParserBITAND, DorisParserParserBITMAP, DorisParserParserBITMAP_EMPTY, DorisParserParserBITMAP_UNION, DorisParserParserBITOR, DorisParserParserBITXOR, DorisParserParserBLOB, DorisParserParserBOOLEAN, DorisParserParserBRANCH, DorisParserParserBRIEF, DorisParserParserBROKER, DorisParserParserBUCKETS, DorisParserParserBUILD, DorisParserParserBUILTIN, DorisParserParserBULK, DorisParserParserCACHE, DorisParserParserCACHED, DorisParserParserCALL, DorisParserParserCASE, DorisParserParserCAST, DorisParserParserCATALOG, DorisParserParserCATALOGS, DorisParserParserCHAIN, DorisParserParserCHAR, DorisParserParserCHARSET, DorisParserParserCHECK, DorisParserParserCLUSTER, DorisParserParserCLUSTERS, DorisParserParserCOLLATION, DorisParserParserCOLLECT, DorisParserParserCOLOCATE, DorisParserParserCOLUMNS, DorisParserParserCOMMENT, DorisParserParserCOMMIT, DorisParserParserCOMMITTED, DorisParserParserCOMPACT, DorisParserParserCOMPLETE, DorisParserParserCOMPRESS_TYPE, DorisParserParserCOMPUTE, DorisParserParserCONDITIONS, DorisParserParserCONFIG, DorisParserParserCONNECTION, DorisParserParserCONNECTION_ID, DorisParserParserCONSISTENT, DorisParserParserCONSTRAINTS, DorisParserParserCONVERT, DorisParserParserCONVERT_LSC, DorisParserParserCOPY, DorisParserParserCOUNT, DorisParserParserCREATION, DorisParserParserCRON, DorisParserParserCURRENT_CATALOG, DorisParserParserCURRENT_DATE, DorisParserParserCURRENT_TIME, DorisParserParserCURRENT_TIMESTAMP, DorisParserParserCURRENT_USER, DorisParserParserDATA, DorisParserParserDATABASE, DorisParserParserDATE, DorisParserParserDATETIME, DorisParserParserDATETIMEV2, DorisParserParserDATEV2, DorisParserParserDATETIMEV1, DorisParserParserDATEV1, DorisParserParserDAY, DorisParserParserDAYS, DorisParserParserDECIMAL, DorisParserParserDECIMALV2, DorisParserParserDECIMALV3, DorisParserParserDEFERRED, DorisParserParserDEMAND, DorisParserParserDIAGNOSE, DorisParserParserDIAGNOSIS, DorisParserParserDICTIONARIES, DorisParserParserDICTIONARY, DorisParserParserDISTINCTPC, DorisParserParserDISTINCTPCSA, DorisParserParserDO, DorisParserParserDORIS_INTERNAL_TABLE_ID, DorisParserParserDUAL, DorisParserParserDYNAMIC, DorisParserParserE, DorisParserParserENABLE, DorisParserParserENCRYPTKEY, DorisParserParserENCRYPTKEYS, DorisParserParserEND, DorisParserParserENDS, DorisParserParserENGINE, DorisParserParserENGINES, DorisParserParserERRORS, DorisParserParserESCAPE, DorisParserParserEVENTS, DorisParserParserEVERY, DorisParserParserEXCLUDE, DorisParserParserEXISTS, DorisParserParserEXPIRED, DorisParserParserEXTERNAL, DorisParserParserEXTRACT, DorisParserParserFAILED_LOGIN_ATTEMPTS, DorisParserParserFALSE, DorisParserParserFAST, DorisParserParserFEATURE, DorisParserParserFIELDS, DorisParserParserFILE, DorisParserParserFILTER, DorisParserParserFIRST, DorisParserParserFORMAT, DorisParserParserFREE, DorisParserParserFRONTENDS, DorisParserParserFUNCTION, DorisParserParserGENERATED, DorisParserParserGENERIC, DorisParserParserGLOBAL, DorisParserParserGRAPH, DorisParserParserGROUPING, DorisParserParserGROUPS, DorisParserParserHASH, DorisParserParserHASH_MAP, DorisParserParserHDFS, DorisParserParserHELP, DorisParserParserHISTOGRAM, DorisParserParserHLL_UNION, DorisParserParserHOSTNAME, DorisParserParserHOTSPOT, DorisParserParserHOUR, DorisParserParserHOURS, DorisParserParserHUB, DorisParserParserIDENTIFIED, DorisParserParserIF, DorisParserParserIGNORE, DorisParserParserIMMEDIATE, DorisParserParserINCREMENTAL, DorisParserParserINDEXES, DorisParserParserINTERVAL, DorisParserParserINVERTED, DorisParserParserIP_TRIE, DorisParserParserIPV4, DorisParserParserIPV6, DorisParserParserIS_NOT_NULL_PRED, DorisParserParserIS_NULL_PRED, DorisParserParserISNULL, DorisParserParserISOLATION, DorisParserParserJOB, DorisParserParserJOBS, DorisParserParserJSON, DorisParserParserJSONB, DorisParserParserKEY, DorisParserParserLABEL, DorisParserParserLAST, DorisParserParserLDAP, DorisParserParserLDAP_ADMIN_PASSWORD, DorisParserParserLEFT, DorisParserParserLESS, DorisParserParserLEVEL, DorisParserParserLIKE, DorisParserParserLINES, DorisParserParserLINK, DorisParserParserLOCAL, DorisParserParserLOCALTIME, DorisParserParserLOCALTIMESTAMP, DorisParserParserLOCATION, DorisParserParserLOCK, DorisParserParserLOGICAL, DorisParserParserMANUAL, DorisParserParserMAP, DorisParserParserMATCH_ALL, DorisParserParserMATCH_ANY, DorisParserParserMATCH_PHRASE, DorisParserParserMATCH_PHRASE_EDGE, DorisParserParserMATCH_PHRASE_PREFIX, DorisParserParserMATCH_REGEXP, DorisParserParserMATERIALIZED, DorisParserParserMAX, DorisParserParserMEMO, DorisParserParserMERGE, DorisParserParserMIGRATE, DorisParserParserMIGRATIONS, DorisParserParserMIN, DorisParserParserMINUTE, DorisParserParserMINUTES, DorisParserParserMODIFY, DorisParserParserMONTH, DorisParserParserMTMV, DorisParserParserNAME, DorisParserParserNAMES, DorisParserParserNEGATIVE, DorisParserParserNEVER, DorisParserParserNEXT, DorisParserParserNGRAM_BF, DorisParserParserNO, DorisParserParserNON_NULLABLE, DorisParserParserNOT, DorisParserParserNULL, DorisParserParserNULLS, DorisParserParserOF, DorisParserParserOFFSET, DorisParserParserONLY, DorisParserParserOPEN, DorisParserParserOPTIMIZED, DorisParserParserPARAMETER, DorisParserParserPARSED, DorisParserParserPARTITIONS, DorisParserParserPASSWORD, DorisParserParserPASSWORD_EXPIRE, DorisParserParserPASSWORD_HISTORY, DorisParserParserPASSWORD_LOCK_TIME, DorisParserParserPASSWORD_REUSE, DorisParserParserPATH, DorisParserParserPAUSE, DorisParserParserPERCENT, DorisParserParserPERIOD, DorisParserParserPERMISSIVE, DorisParserParserPHYSICAL, DorisParserParserPI, DorisParserParserPLACEHOLDER, DorisParserParserPLAN, DorisParserParserPRIVILEGES, DorisParserParserPROCESS, DorisParserParserPLUGIN, DorisParserParserPLUGINS, DorisParserParserPOLICY, DorisParserParserPROC, DorisParserParserPROCESSLIST, DorisParserParserPROFILE, DorisParserParserPROPERTIES, DorisParserParserPROPERTY, DorisParserParserQUANTILE_STATE, DorisParserParserQUANTILE_UNION, DorisParserParserQUERY, DorisParserParserQUEUED, DorisParserParserQUOTA, DorisParserParserQUALIFY, DorisParserParserQUARTER, DorisParserParserRANDOM, DorisParserParserRECENT, DorisParserParserRECOVER, DorisParserParserRECYCLE, DorisParserParserREFRESH, DorisParserParserREGEXP, DorisParserParserREPEATABLE, DorisParserParserREPLACE, DorisParserParserREPLACE_IF_NOT_NULL, DorisParserParserREPLAYER, DorisParserParserREPOSITORIES, DorisParserParserREPOSITORY, DorisParserParserRESOURCE, DorisParserParserRESOURCES, DorisParserParserRESTORE, DorisParserParserRESTRICTIVE, DorisParserParserRESUME, DorisParserParserRETAIN, DorisParserParserRETENTION, DorisParserParserRETURNS, DorisParserParserREWRITTEN, DorisParserParserRIGHT, DorisParserParserRLIKE, DorisParserParserROLLBACK, DorisParserParserROLLUP, DorisParserParserROUTINE, DorisParserParserS3, DorisParserParserSAMPLE, DorisParserParserSCHEDULE, DorisParserParserSCHEDULER, DorisParserParserSCHEMA, DorisParserParserSECOND, DorisParserParserSERIALIZABLE, DorisParserParserSESSION, DorisParserParserSESSION_USER, DorisParserParserSET_SESSION_VARIABLE, DorisParserParserSHAPE, DorisParserParserSKEW, DorisParserParserSNAPSHOT, DorisParserParserSNAPSHOTS, DorisParserParserSONAME, DorisParserParserSPLIT, DorisParserParserSQL, DorisParserParserSTAGE, DorisParserParserSTAGES, DorisParserParserSTART, DorisParserParserSTARTS, DorisParserParserSTATS, DorisParserParserSTATUS, DorisParserParserSTOP, DorisParserParserSTORAGE, DorisParserParserSTREAM, DorisParserParserSTREAMING, DorisParserParserSTRING, DorisParserParserSTRUCT, DorisParserParserSUM, DorisParserParserTABLES, DorisParserParserTAG, DorisParserParserTASK, DorisParserParserTASKS, DorisParserParserTEMPORARY, DorisParserParserTEXT, DorisParserParserTHAN, DorisParserParserTIME, DorisParserParserTIMESTAMP, DorisParserParserTRANSACTION, DorisParserParserTREE, DorisParserParserTRIGGERS, DorisParserParserTRIM, DorisParserParserTRUE, DorisParserParserTRUNCATE, DorisParserParserTYPE, DorisParserParserTYPES, DorisParserParserUNCOMMITTED, DorisParserParserUNLOCK, DorisParserParserUNSET, DorisParserParserUP, DorisParserParserUSER, DorisParserParserVALUE, DorisParserParserVARCHAR, DorisParserParserVARIABLE, DorisParserParserVARIABLES, DorisParserParserVARIANT, DorisParserParserVAULT, DorisParserParserVAULTS, DorisParserParserVERBOSE, DorisParserParserVERSION, DorisParserParserVIEW, DorisParserParserVIEWS, DorisParserParserWARM, DorisParserParserWARNINGS, DorisParserParserWEEK, DorisParserParserWORK, DorisParserParserYEAR, DorisParserParserPLUS, DorisParserParserSUBTRACT, DorisParserParserASTERISK, DorisParserParserTILDE, DorisParserParserLOGICALNOT, DorisParserParserHINT_START, DorisParserParserHINT_END, DorisParserParserCOMMENT_START, DorisParserParserATSIGN, DorisParserParserDOUBLEATSIGN, DorisParserParserSTRING_LITERAL, DorisParserParserINTEGER_VALUE, DorisParserParserEXPONENT_VALUE, DorisParserParserDECIMAL_VALUE, DorisParserParserIDENTIFIER, DorisParserParserBACKQUOTED_IDENTIFIER:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6055)
			p.Expression()
		}
		{
			p.SetState(6056)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*FrameBoundaryContext).boundType = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserParserFOLLOWING || _la == DorisParserParserPRECEDING) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*FrameBoundaryContext).boundType = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQualifiedNameContext is an interface to support dynamic dispatch.
type IQualifiedNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode

	// IsQualifiedNameContext differentiates from other interfaces.
	IsQualifiedNameContext()
}

type QualifiedNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQualifiedNameContext() *QualifiedNameContext {
	var p = new(QualifiedNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_qualifiedName
	return p
}

func InitEmptyQualifiedNameContext(p *QualifiedNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_qualifiedName
}

func (*QualifiedNameContext) IsQualifiedNameContext() {}

func NewQualifiedNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QualifiedNameContext {
	var p = new(QualifiedNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_qualifiedName

	return p
}

func (s *QualifiedNameContext) GetParser() antlr.Parser { return s.parser }

func (s *QualifiedNameContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *QualifiedNameContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *QualifiedNameContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserDOT)
}

func (s *QualifiedNameContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserDOT, i)
}

func (s *QualifiedNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QualifiedNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QualifiedNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitQualifiedName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) QualifiedName() (localctx IQualifiedNameContext) {
	localctx = NewQualifiedNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 406, DorisParserParserRULE_qualifiedName)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6060)
		p.Identifier()
	}
	p.SetState(6065)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 867, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(6061)
				p.Match(DorisParserParserDOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6062)
				p.Identifier()
			}

		}
		p.SetState(6067)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 867, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISpecifiedPartitionContext is an interface to support dynamic dispatch.
type ISpecifiedPartitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PARTITION() antlr.TerminalNode
	Identifier() IIdentifierContext
	IdentifierList() IIdentifierListContext
	TEMPORARY() antlr.TerminalNode
	PARTITIONS() antlr.TerminalNode

	// IsSpecifiedPartitionContext differentiates from other interfaces.
	IsSpecifiedPartitionContext()
}

type SpecifiedPartitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySpecifiedPartitionContext() *SpecifiedPartitionContext {
	var p = new(SpecifiedPartitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_specifiedPartition
	return p
}

func InitEmptySpecifiedPartitionContext(p *SpecifiedPartitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_specifiedPartition
}

func (*SpecifiedPartitionContext) IsSpecifiedPartitionContext() {}

func NewSpecifiedPartitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SpecifiedPartitionContext {
	var p = new(SpecifiedPartitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_specifiedPartition

	return p
}

func (s *SpecifiedPartitionContext) GetParser() antlr.Parser { return s.parser }

func (s *SpecifiedPartitionContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(DorisParserParserPARTITION, 0)
}

func (s *SpecifiedPartitionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SpecifiedPartitionContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *SpecifiedPartitionContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(DorisParserParserTEMPORARY, 0)
}

func (s *SpecifiedPartitionContext) PARTITIONS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserPARTITIONS, 0)
}

func (s *SpecifiedPartitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SpecifiedPartitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SpecifiedPartitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitSpecifiedPartition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) SpecifiedPartition() (localctx ISpecifiedPartitionContext) {
	localctx = NewSpecifiedPartitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 408, DorisParserParserRULE_specifiedPartition)
	var _la int

	p.SetState(6081)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 871, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(6069)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserTEMPORARY {
			{
				p.SetState(6068)
				p.Match(DorisParserParserTEMPORARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(6071)
			p.Match(DorisParserParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6074)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case DorisParserParserLEFT_BRACE, DorisParserParserRIGHT_BRACE, DorisParserParserACTIONS, DorisParserParserAFTER, DorisParserParserAGG_STATE, DorisParserParserAGGREGATE, DorisParserParserALIAS, DorisParserParserANALYZED, DorisParserParserARRAY, DorisParserParserAT, DorisParserParserAUTHORS, DorisParserParserAUTO_INCREMENT, DorisParserParserALWAYS, DorisParserParserBACKENDS, DorisParserParserBACKUP, DorisParserParserBEGIN, DorisParserParserBELONG, DorisParserParserBIN, DorisParserParserBITAND, DorisParserParserBITMAP, DorisParserParserBITMAP_EMPTY, DorisParserParserBITMAP_UNION, DorisParserParserBITOR, DorisParserParserBITXOR, DorisParserParserBLOB, DorisParserParserBOOLEAN, DorisParserParserBRANCH, DorisParserParserBRIEF, DorisParserParserBROKER, DorisParserParserBUCKETS, DorisParserParserBUILD, DorisParserParserBUILTIN, DorisParserParserBULK, DorisParserParserCACHE, DorisParserParserCACHED, DorisParserParserCALL, DorisParserParserCATALOG, DorisParserParserCATALOGS, DorisParserParserCHAIN, DorisParserParserCHAR, DorisParserParserCHARSET, DorisParserParserCHECK, DorisParserParserCLUSTER, DorisParserParserCLUSTERS, DorisParserParserCOLLATION, DorisParserParserCOLLECT, DorisParserParserCOLOCATE, DorisParserParserCOLUMNS, DorisParserParserCOMMENT, DorisParserParserCOMMIT, DorisParserParserCOMMITTED, DorisParserParserCOMPACT, DorisParserParserCOMPLETE, DorisParserParserCOMPRESS_TYPE, DorisParserParserCOMPUTE, DorisParserParserCONDITIONS, DorisParserParserCONFIG, DorisParserParserCONNECTION, DorisParserParserCONNECTION_ID, DorisParserParserCONSISTENT, DorisParserParserCONSTRAINTS, DorisParserParserCONVERT, DorisParserParserCONVERT_LSC, DorisParserParserCOPY, DorisParserParserCOUNT, DorisParserParserCREATION, DorisParserParserCRON, DorisParserParserCURRENT_CATALOG, DorisParserParserCURRENT_DATE, DorisParserParserCURRENT_TIME, DorisParserParserCURRENT_TIMESTAMP, DorisParserParserCURRENT_USER, DorisParserParserDATA, DorisParserParserDATE, DorisParserParserDATETIME, DorisParserParserDATETIMEV2, DorisParserParserDATEV2, DorisParserParserDATETIMEV1, DorisParserParserDATEV1, DorisParserParserDAY, DorisParserParserDAYS, DorisParserParserDECIMAL, DorisParserParserDECIMALV2, DorisParserParserDECIMALV3, DorisParserParserDEFERRED, DorisParserParserDEMAND, DorisParserParserDIAGNOSE, DorisParserParserDIAGNOSIS, DorisParserParserDICTIONARIES, DorisParserParserDICTIONARY, DorisParserParserDISTINCTPC, DorisParserParserDISTINCTPCSA, DorisParserParserDO, DorisParserParserDORIS_INTERNAL_TABLE_ID, DorisParserParserDUAL, DorisParserParserDYNAMIC, DorisParserParserE, DorisParserParserENABLE, DorisParserParserENCRYPTKEY, DorisParserParserENCRYPTKEYS, DorisParserParserEND, DorisParserParserENDS, DorisParserParserENGINE, DorisParserParserENGINES, DorisParserParserERRORS, DorisParserParserESCAPE, DorisParserParserEVENTS, DorisParserParserEVERY, DorisParserParserEXCLUDE, DorisParserParserEXPIRED, DorisParserParserEXTERNAL, DorisParserParserFAILED_LOGIN_ATTEMPTS, DorisParserParserFAST, DorisParserParserFEATURE, DorisParserParserFIELDS, DorisParserParserFILE, DorisParserParserFILTER, DorisParserParserFIRST, DorisParserParserFORMAT, DorisParserParserFREE, DorisParserParserFRONTENDS, DorisParserParserFUNCTION, DorisParserParserGENERATED, DorisParserParserGENERIC, DorisParserParserGLOBAL, DorisParserParserGRAPH, DorisParserParserGROUPING, DorisParserParserGROUPS, DorisParserParserHASH, DorisParserParserHASH_MAP, DorisParserParserHDFS, DorisParserParserHELP, DorisParserParserHISTOGRAM, DorisParserParserHLL_UNION, DorisParserParserHOSTNAME, DorisParserParserHOTSPOT, DorisParserParserHOUR, DorisParserParserHOURS, DorisParserParserHUB, DorisParserParserIDENTIFIED, DorisParserParserIGNORE, DorisParserParserIMMEDIATE, DorisParserParserINCREMENTAL, DorisParserParserINDEXES, DorisParserParserINVERTED, DorisParserParserIP_TRIE, DorisParserParserIPV4, DorisParserParserIPV6, DorisParserParserIS_NOT_NULL_PRED, DorisParserParserIS_NULL_PRED, DorisParserParserISNULL, DorisParserParserISOLATION, DorisParserParserJOB, DorisParserParserJOBS, DorisParserParserJSON, DorisParserParserJSONB, DorisParserParserLABEL, DorisParserParserLAST, DorisParserParserLDAP, DorisParserParserLDAP_ADMIN_PASSWORD, DorisParserParserLESS, DorisParserParserLEVEL, DorisParserParserLINES, DorisParserParserLINK, DorisParserParserLOCAL, DorisParserParserLOCALTIME, DorisParserParserLOCALTIMESTAMP, DorisParserParserLOCATION, DorisParserParserLOCK, DorisParserParserLOGICAL, DorisParserParserMANUAL, DorisParserParserMAP, DorisParserParserMATCH_ALL, DorisParserParserMATCH_ANY, DorisParserParserMATCH_PHRASE, DorisParserParserMATCH_PHRASE_EDGE, DorisParserParserMATCH_PHRASE_PREFIX, DorisParserParserMATCH_REGEXP, DorisParserParserMATERIALIZED, DorisParserParserMAX, DorisParserParserMEMO, DorisParserParserMERGE, DorisParserParserMIGRATE, DorisParserParserMIGRATIONS, DorisParserParserMIN, DorisParserParserMINUTE, DorisParserParserMINUTES, DorisParserParserMODIFY, DorisParserParserMONTH, DorisParserParserMTMV, DorisParserParserNAME, DorisParserParserNAMES, DorisParserParserNEGATIVE, DorisParserParserNEVER, DorisParserParserNEXT, DorisParserParserNGRAM_BF, DorisParserParserNO, DorisParserParserNON_NULLABLE, DorisParserParserNULLS, DorisParserParserOF, DorisParserParserOFFSET, DorisParserParserONLY, DorisParserParserOPEN, DorisParserParserOPTIMIZED, DorisParserParserPARAMETER, DorisParserParserPARSED, DorisParserParserPARTITIONS, DorisParserParserPASSWORD, DorisParserParserPASSWORD_EXPIRE, DorisParserParserPASSWORD_HISTORY, DorisParserParserPASSWORD_LOCK_TIME, DorisParserParserPASSWORD_REUSE, DorisParserParserPATH, DorisParserParserPAUSE, DorisParserParserPERCENT, DorisParserParserPERIOD, DorisParserParserPERMISSIVE, DorisParserParserPHYSICAL, DorisParserParserPI, DorisParserParserPLAN, DorisParserParserPRIVILEGES, DorisParserParserPROCESS, DorisParserParserPLUGIN, DorisParserParserPLUGINS, DorisParserParserPOLICY, DorisParserParserPROC, DorisParserParserPROCESSLIST, DorisParserParserPROFILE, DorisParserParserPROPERTIES, DorisParserParserPROPERTY, DorisParserParserQUANTILE_STATE, DorisParserParserQUANTILE_UNION, DorisParserParserQUERY, DorisParserParserQUEUED, DorisParserParserQUOTA, DorisParserParserQUALIFY, DorisParserParserQUARTER, DorisParserParserRANDOM, DorisParserParserRECENT, DorisParserParserRECOVER, DorisParserParserRECYCLE, DorisParserParserREFRESH, DorisParserParserREPEATABLE, DorisParserParserREPLACE, DorisParserParserREPLACE_IF_NOT_NULL, DorisParserParserREPLAYER, DorisParserParserREPOSITORIES, DorisParserParserREPOSITORY, DorisParserParserRESOURCE, DorisParserParserRESOURCES, DorisParserParserRESTORE, DorisParserParserRESTRICTIVE, DorisParserParserRESUME, DorisParserParserRETAIN, DorisParserParserRETENTION, DorisParserParserRETURNS, DorisParserParserREWRITTEN, DorisParserParserRLIKE, DorisParserParserROLLBACK, DorisParserParserROLLUP, DorisParserParserROUTINE, DorisParserParserS3, DorisParserParserSAMPLE, DorisParserParserSCHEDULE, DorisParserParserSCHEDULER, DorisParserParserSCHEMA, DorisParserParserSECOND, DorisParserParserSERIALIZABLE, DorisParserParserSESSION, DorisParserParserSESSION_USER, DorisParserParserSET_SESSION_VARIABLE, DorisParserParserSHAPE, DorisParserParserSKEW, DorisParserParserSNAPSHOT, DorisParserParserSNAPSHOTS, DorisParserParserSONAME, DorisParserParserSPLIT, DorisParserParserSQL, DorisParserParserSTAGE, DorisParserParserSTAGES, DorisParserParserSTART, DorisParserParserSTARTS, DorisParserParserSTATS, DorisParserParserSTATUS, DorisParserParserSTOP, DorisParserParserSTORAGE, DorisParserParserSTREAM, DorisParserParserSTREAMING, DorisParserParserSTRING, DorisParserParserSTRUCT, DorisParserParserSUM, DorisParserParserTABLES, DorisParserParserTAG, DorisParserParserTASK, DorisParserParserTASKS, DorisParserParserTEMPORARY, DorisParserParserTEXT, DorisParserParserTHAN, DorisParserParserTIME, DorisParserParserTIMESTAMP, DorisParserParserTRANSACTION, DorisParserParserTREE, DorisParserParserTRIGGERS, DorisParserParserTRUNCATE, DorisParserParserTYPE, DorisParserParserTYPES, DorisParserParserUNCOMMITTED, DorisParserParserUNLOCK, DorisParserParserUNSET, DorisParserParserUP, DorisParserParserUSER, DorisParserParserVALUE, DorisParserParserVARCHAR, DorisParserParserVARIABLE, DorisParserParserVARIABLES, DorisParserParserVARIANT, DorisParserParserVAULT, DorisParserParserVAULTS, DorisParserParserVERBOSE, DorisParserParserVERSION, DorisParserParserVIEW, DorisParserParserVIEWS, DorisParserParserWARM, DorisParserParserWARNINGS, DorisParserParserWEEK, DorisParserParserWORK, DorisParserParserYEAR, DorisParserParserHINT_START, DorisParserParserHINT_END, DorisParserParserCOMMENT_START, DorisParserParserIDENTIFIER, DorisParserParserBACKQUOTED_IDENTIFIER:
			{
				p.SetState(6072)
				p.Identifier()
			}

		case DorisParserParserLEFT_PAREN:
			{
				p.SetState(6073)
				p.IdentifierList()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(6077)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserTEMPORARY {
			{
				p.SetState(6076)
				p.Match(DorisParserParserTEMPORARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(6079)
			p.Match(DorisParserParserPARTITIONS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6080)
			p.IdentifierList()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConstantContext is an interface to support dynamic dispatch.
type IConstantContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsConstantContext differentiates from other interfaces.
	IsConstantContext()
}

type ConstantContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstantContext() *ConstantContext {
	var p = new(ConstantContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_constant
	return p
}

func InitEmptyConstantContext(p *ConstantContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_constant
}

func (*ConstantContext) IsConstantContext() {}

func NewConstantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstantContext {
	var p = new(ConstantContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_constant

	return p
}

func (s *ConstantContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstantContext) CopyAll(ctx *ConstantContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ConstantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type StructLiteralContext struct {
	ConstantContext
	_constant IConstantContext
	items     []IConstantContext
}

func NewStructLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StructLiteralContext {
	var p = new(StructLiteralContext)

	InitEmptyConstantContext(&p.ConstantContext)
	p.parser = parser
	p.CopyAll(ctx.(*ConstantContext))

	return p
}

func (s *StructLiteralContext) Get_constant() IConstantContext { return s._constant }

func (s *StructLiteralContext) Set_constant(v IConstantContext) { s._constant = v }

func (s *StructLiteralContext) GetItems() []IConstantContext { return s.items }

func (s *StructLiteralContext) SetItems(v []IConstantContext) { s.items = v }

func (s *StructLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StructLiteralContext) LEFT_BRACE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLEFT_BRACE, 0)
}

func (s *StructLiteralContext) RIGHT_BRACE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRIGHT_BRACE, 0)
}

func (s *StructLiteralContext) AllConstant() []IConstantContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IConstantContext); ok {
			len++
		}
	}

	tst := make([]IConstantContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IConstantContext); ok {
			tst[i] = t.(IConstantContext)
			i++
		}
	}

	return tst
}

func (s *StructLiteralContext) Constant(i int) IConstantContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *StructLiteralContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserCOMMA)
}

func (s *StructLiteralContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOMMA, i)
}

func (s *StructLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitStructLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

type NullLiteralContext struct {
	ConstantContext
}

func NewNullLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NullLiteralContext {
	var p = new(NullLiteralContext)

	InitEmptyConstantContext(&p.ConstantContext)
	p.parser = parser
	p.CopyAll(ctx.(*ConstantContext))

	return p
}

func (s *NullLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NullLiteralContext) NULL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserNULL, 0)
}

func (s *NullLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitNullLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

type StringLiteralContext struct {
	ConstantContext
}

func NewStringLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StringLiteralContext {
	var p = new(StringLiteralContext)

	InitEmptyConstantContext(&p.ConstantContext)
	p.parser = parser
	p.CopyAll(ctx.(*ConstantContext))

	return p
}

func (s *StringLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringLiteralContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTRING_LITERAL, 0)
}

func (s *StringLiteralContext) BINARY() antlr.TerminalNode {
	return s.GetToken(DorisParserParserBINARY, 0)
}

func (s *StringLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitStringLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

type TypeConstructorContext struct {
	ConstantContext
	type_ antlr.Token
}

func NewTypeConstructorContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TypeConstructorContext {
	var p = new(TypeConstructorContext)

	InitEmptyConstantContext(&p.ConstantContext)
	p.parser = parser
	p.CopyAll(ctx.(*ConstantContext))

	return p
}

func (s *TypeConstructorContext) GetType_() antlr.Token { return s.type_ }

func (s *TypeConstructorContext) SetType_(v antlr.Token) { s.type_ = v }

func (s *TypeConstructorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeConstructorContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTRING_LITERAL, 0)
}

func (s *TypeConstructorContext) DATE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDATE, 0)
}

func (s *TypeConstructorContext) DATEV1() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDATEV1, 0)
}

func (s *TypeConstructorContext) DATEV2() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDATEV2, 0)
}

func (s *TypeConstructorContext) TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(DorisParserParserTIMESTAMP, 0)
}

func (s *TypeConstructorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitTypeConstructor(s)

	default:
		return t.VisitChildren(s)
	}
}

type ArrayLiteralContext struct {
	ConstantContext
	_constant IConstantContext
	items     []IConstantContext
}

func NewArrayLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ArrayLiteralContext {
	var p = new(ArrayLiteralContext)

	InitEmptyConstantContext(&p.ConstantContext)
	p.parser = parser
	p.CopyAll(ctx.(*ConstantContext))

	return p
}

func (s *ArrayLiteralContext) Get_constant() IConstantContext { return s._constant }

func (s *ArrayLiteralContext) Set_constant(v IConstantContext) { s._constant = v }

func (s *ArrayLiteralContext) GetItems() []IConstantContext { return s.items }

func (s *ArrayLiteralContext) SetItems(v []IConstantContext) { s.items = v }

func (s *ArrayLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayLiteralContext) LEFT_BRACKET() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLEFT_BRACKET, 0)
}

func (s *ArrayLiteralContext) RIGHT_BRACKET() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRIGHT_BRACKET, 0)
}

func (s *ArrayLiteralContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserCOMMA)
}

func (s *ArrayLiteralContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOMMA, i)
}

func (s *ArrayLiteralContext) AllConstant() []IConstantContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IConstantContext); ok {
			len++
		}
	}

	tst := make([]IConstantContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IConstantContext); ok {
			tst[i] = t.(IConstantContext)
			i++
		}
	}

	return tst
}

func (s *ArrayLiteralContext) Constant(i int) IConstantContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *ArrayLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitArrayLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

type PlaceholderContext struct {
	ConstantContext
}

func NewPlaceholderContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PlaceholderContext {
	var p = new(PlaceholderContext)

	InitEmptyConstantContext(&p.ConstantContext)
	p.parser = parser
	p.CopyAll(ctx.(*ConstantContext))

	return p
}

func (s *PlaceholderContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PlaceholderContext) PLACEHOLDER() antlr.TerminalNode {
	return s.GetToken(DorisParserParserPLACEHOLDER, 0)
}

func (s *PlaceholderContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitPlaceholder(s)

	default:
		return t.VisitChildren(s)
	}
}

type MapLiteralContext struct {
	ConstantContext
	_constant IConstantContext
	items     []IConstantContext
}

func NewMapLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MapLiteralContext {
	var p = new(MapLiteralContext)

	InitEmptyConstantContext(&p.ConstantContext)
	p.parser = parser
	p.CopyAll(ctx.(*ConstantContext))

	return p
}

func (s *MapLiteralContext) Get_constant() IConstantContext { return s._constant }

func (s *MapLiteralContext) Set_constant(v IConstantContext) { s._constant = v }

func (s *MapLiteralContext) GetItems() []IConstantContext { return s.items }

func (s *MapLiteralContext) SetItems(v []IConstantContext) { s.items = v }

func (s *MapLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MapLiteralContext) LEFT_BRACE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLEFT_BRACE, 0)
}

func (s *MapLiteralContext) RIGHT_BRACE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRIGHT_BRACE, 0)
}

func (s *MapLiteralContext) AllCOLON() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserCOLON)
}

func (s *MapLiteralContext) COLON(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOLON, i)
}

func (s *MapLiteralContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserCOMMA)
}

func (s *MapLiteralContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOMMA, i)
}

func (s *MapLiteralContext) AllConstant() []IConstantContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IConstantContext); ok {
			len++
		}
	}

	tst := make([]IConstantContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IConstantContext); ok {
			tst[i] = t.(IConstantContext)
			i++
		}
	}

	return tst
}

func (s *MapLiteralContext) Constant(i int) IConstantContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *MapLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitMapLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

type NumericLiteralContext struct {
	ConstantContext
}

func NewNumericLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NumericLiteralContext {
	var p = new(NumericLiteralContext)

	InitEmptyConstantContext(&p.ConstantContext)
	p.parser = parser
	p.CopyAll(ctx.(*ConstantContext))

	return p
}

func (s *NumericLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumericLiteralContext) Number() INumberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *NumericLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitNumericLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

type BooleanLiteralContext struct {
	ConstantContext
}

func NewBooleanLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BooleanLiteralContext {
	var p = new(BooleanLiteralContext)

	InitEmptyConstantContext(&p.ConstantContext)
	p.parser = parser
	p.CopyAll(ctx.(*ConstantContext))

	return p
}

func (s *BooleanLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanLiteralContext) BooleanValue() IBooleanValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanValueContext)
}

func (s *BooleanLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitBooleanLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) Constant() (localctx IConstantContext) {
	localctx = NewConstantContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 410, DorisParserParserRULE_constant)
	var _la int

	p.SetState(6134)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 878, p.GetParserRuleContext()) {
	case 1:
		localctx = NewNullLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6083)
			p.Match(DorisParserParserNULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewTypeConstructorContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6084)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*TypeConstructorContext).type_ = _lt

			_la = p.GetTokenStream().LA(1)

			if !(((int64((_la-115)) & ^0x3f) == 0 && ((int64(1)<<(_la-115))&41) != 0) || _la == DorisParserParserTIMESTAMP) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*TypeConstructorContext).type_ = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(6085)
			p.Match(DorisParserParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		localctx = NewNumericLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6086)
			p.Number()
		}

	case 4:
		localctx = NewBooleanLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(6087)
			p.BooleanValue()
		}

	case 5:
		localctx = NewStringLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		p.SetState(6089)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserBINARY {
			{
				p.SetState(6088)
				p.Match(DorisParserParserBINARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(6091)
			p.Match(DorisParserParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		localctx = NewArrayLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(6092)
			p.Match(DorisParserParserLEFT_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6094)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&17592186045056) != 0) || ((int64((_la-115)) & ^0x3f) == 0 && ((int64(1)<<(_la-115))&-9223372036854775767) != 0) || _la == DorisParserParserNULL || _la == DorisParserParserPLACEHOLDER || ((int64((_la-465)) & ^0x3f) == 0 && ((int64(1)<<(_la-465))&2305843009213694977) != 0) || ((int64((_la-544)) & ^0x3f) == 0 && ((int64(1)<<(_la-544))&225) != 0) {
			{
				p.SetState(6093)

				var _x = p.Constant()

				localctx.(*ArrayLiteralContext)._constant = _x
			}
			localctx.(*ArrayLiteralContext).items = append(localctx.(*ArrayLiteralContext).items, localctx.(*ArrayLiteralContext)._constant)

		}
		p.SetState(6100)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserParserCOMMA {
			{
				p.SetState(6096)
				p.Match(DorisParserParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6097)

				var _x = p.Constant()

				localctx.(*ArrayLiteralContext)._constant = _x
			}
			localctx.(*ArrayLiteralContext).items = append(localctx.(*ArrayLiteralContext).items, localctx.(*ArrayLiteralContext)._constant)

			p.SetState(6102)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(6103)
			p.Match(DorisParserParserRIGHT_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		localctx = NewMapLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(6104)
			p.Match(DorisParserParserLEFT_BRACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6109)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&17592186045056) != 0) || ((int64((_la-115)) & ^0x3f) == 0 && ((int64(1)<<(_la-115))&-9223372036854775767) != 0) || _la == DorisParserParserNULL || _la == DorisParserParserPLACEHOLDER || ((int64((_la-465)) & ^0x3f) == 0 && ((int64(1)<<(_la-465))&2305843009213694977) != 0) || ((int64((_la-544)) & ^0x3f) == 0 && ((int64(1)<<(_la-544))&225) != 0) {
			{
				p.SetState(6105)

				var _x = p.Constant()

				localctx.(*MapLiteralContext)._constant = _x
			}
			localctx.(*MapLiteralContext).items = append(localctx.(*MapLiteralContext).items, localctx.(*MapLiteralContext)._constant)
			{
				p.SetState(6106)
				p.Match(DorisParserParserCOLON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6107)

				var _x = p.Constant()

				localctx.(*MapLiteralContext)._constant = _x
			}
			localctx.(*MapLiteralContext).items = append(localctx.(*MapLiteralContext).items, localctx.(*MapLiteralContext)._constant)

		}
		p.SetState(6118)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserParserCOMMA {
			{
				p.SetState(6111)
				p.Match(DorisParserParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6112)

				var _x = p.Constant()

				localctx.(*MapLiteralContext)._constant = _x
			}
			localctx.(*MapLiteralContext).items = append(localctx.(*MapLiteralContext).items, localctx.(*MapLiteralContext)._constant)
			{
				p.SetState(6113)
				p.Match(DorisParserParserCOLON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6114)

				var _x = p.Constant()

				localctx.(*MapLiteralContext)._constant = _x
			}
			localctx.(*MapLiteralContext).items = append(localctx.(*MapLiteralContext).items, localctx.(*MapLiteralContext)._constant)

			p.SetState(6120)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(6121)
			p.Match(DorisParserParserRIGHT_BRACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 8:
		localctx = NewStructLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(6122)
			p.Match(DorisParserParserLEFT_BRACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6123)

			var _x = p.Constant()

			localctx.(*StructLiteralContext)._constant = _x
		}
		localctx.(*StructLiteralContext).items = append(localctx.(*StructLiteralContext).items, localctx.(*StructLiteralContext)._constant)
		p.SetState(6128)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserParserCOMMA {
			{
				p.SetState(6124)
				p.Match(DorisParserParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6125)

				var _x = p.Constant()

				localctx.(*StructLiteralContext)._constant = _x
			}
			localctx.(*StructLiteralContext).items = append(localctx.(*StructLiteralContext).items, localctx.(*StructLiteralContext)._constant)

			p.SetState(6130)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(6131)
			p.Match(DorisParserParserRIGHT_BRACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 9:
		localctx = NewPlaceholderContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(6133)
			p.Match(DorisParserParserPLACEHOLDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IComparisonOperatorContext is an interface to support dynamic dispatch.
type IComparisonOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EQ() antlr.TerminalNode
	NEQ() antlr.TerminalNode
	LT() antlr.TerminalNode
	LTE() antlr.TerminalNode
	GT() antlr.TerminalNode
	GTE() antlr.TerminalNode
	NSEQ() antlr.TerminalNode

	// IsComparisonOperatorContext differentiates from other interfaces.
	IsComparisonOperatorContext()
}

type ComparisonOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComparisonOperatorContext() *ComparisonOperatorContext {
	var p = new(ComparisonOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_comparisonOperator
	return p
}

func InitEmptyComparisonOperatorContext(p *ComparisonOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_comparisonOperator
}

func (*ComparisonOperatorContext) IsComparisonOperatorContext() {}

func NewComparisonOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComparisonOperatorContext {
	var p = new(ComparisonOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_comparisonOperator

	return p
}

func (s *ComparisonOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *ComparisonOperatorContext) EQ() antlr.TerminalNode {
	return s.GetToken(DorisParserParserEQ, 0)
}

func (s *ComparisonOperatorContext) NEQ() antlr.TerminalNode {
	return s.GetToken(DorisParserParserNEQ, 0)
}

func (s *ComparisonOperatorContext) LT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLT, 0)
}

func (s *ComparisonOperatorContext) LTE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLTE, 0)
}

func (s *ComparisonOperatorContext) GT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserGT, 0)
}

func (s *ComparisonOperatorContext) GTE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserGTE, 0)
}

func (s *ComparisonOperatorContext) NSEQ() antlr.TerminalNode {
	return s.GetToken(DorisParserParserNSEQ, 0)
}

func (s *ComparisonOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparisonOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComparisonOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitComparisonOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) ComparisonOperator() (localctx IComparisonOperatorContext) {
	localctx = NewComparisonOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 412, DorisParserParserRULE_comparisonOperator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6136)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-518)) & ^0x3f) == 0 && ((int64(1)<<(_la-518))&127) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBooleanValueContext is an interface to support dynamic dispatch.
type IBooleanValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TRUE() antlr.TerminalNode
	FALSE() antlr.TerminalNode

	// IsBooleanValueContext differentiates from other interfaces.
	IsBooleanValueContext()
}

type BooleanValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBooleanValueContext() *BooleanValueContext {
	var p = new(BooleanValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_booleanValue
	return p
}

func InitEmptyBooleanValueContext(p *BooleanValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_booleanValue
}

func (*BooleanValueContext) IsBooleanValueContext() {}

func NewBooleanValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BooleanValueContext {
	var p = new(BooleanValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_booleanValue

	return p
}

func (s *BooleanValueContext) GetParser() antlr.Parser { return s.parser }

func (s *BooleanValueContext) TRUE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserTRUE, 0)
}

func (s *BooleanValueContext) FALSE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFALSE, 0)
}

func (s *BooleanValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BooleanValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitBooleanValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) BooleanValue() (localctx IBooleanValueContext) {
	localctx = NewBooleanValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 414, DorisParserParserRULE_booleanValue)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6138)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisParserParserFALSE || _la == DorisParserParserTRUE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWhenClauseContext is an interface to support dynamic dispatch.
type IWhenClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCondition returns the condition rule contexts.
	GetCondition() IExpressionContext

	// GetResult returns the result rule contexts.
	GetResult() IExpressionContext

	// SetCondition sets the condition rule contexts.
	SetCondition(IExpressionContext)

	// SetResult sets the result rule contexts.
	SetResult(IExpressionContext)

	// Getter signatures
	WHEN() antlr.TerminalNode
	THEN() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext

	// IsWhenClauseContext differentiates from other interfaces.
	IsWhenClauseContext()
}

type WhenClauseContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	condition IExpressionContext
	result    IExpressionContext
}

func NewEmptyWhenClauseContext() *WhenClauseContext {
	var p = new(WhenClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_whenClause
	return p
}

func InitEmptyWhenClauseContext(p *WhenClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_whenClause
}

func (*WhenClauseContext) IsWhenClauseContext() {}

func NewWhenClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhenClauseContext {
	var p = new(WhenClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_whenClause

	return p
}

func (s *WhenClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *WhenClauseContext) GetCondition() IExpressionContext { return s.condition }

func (s *WhenClauseContext) GetResult() IExpressionContext { return s.result }

func (s *WhenClauseContext) SetCondition(v IExpressionContext) { s.condition = v }

func (s *WhenClauseContext) SetResult(v IExpressionContext) { s.result = v }

func (s *WhenClauseContext) WHEN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserWHEN, 0)
}

func (s *WhenClauseContext) THEN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserTHEN, 0)
}

func (s *WhenClauseContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *WhenClauseContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *WhenClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhenClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhenClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitWhenClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) WhenClause() (localctx IWhenClauseContext) {
	localctx = NewWhenClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 416, DorisParserParserRULE_whenClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6140)
		p.Match(DorisParserParserWHEN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6141)

		var _x = p.Expression()

		localctx.(*WhenClauseContext).condition = _x
	}
	{
		p.SetState(6142)
		p.Match(DorisParserParserTHEN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6143)

		var _x = p.Expression()

		localctx.(*WhenClauseContext).result = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIntervalContext is an interface to support dynamic dispatch.
type IIntervalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetValue returns the value rule contexts.
	GetValue() IExpressionContext

	// GetUnit returns the unit rule contexts.
	GetUnit() IUnitIdentifierContext

	// SetValue sets the value rule contexts.
	SetValue(IExpressionContext)

	// SetUnit sets the unit rule contexts.
	SetUnit(IUnitIdentifierContext)

	// Getter signatures
	INTERVAL() antlr.TerminalNode
	Expression() IExpressionContext
	UnitIdentifier() IUnitIdentifierContext

	// IsIntervalContext differentiates from other interfaces.
	IsIntervalContext()
}

type IntervalContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	value  IExpressionContext
	unit   IUnitIdentifierContext
}

func NewEmptyIntervalContext() *IntervalContext {
	var p = new(IntervalContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_interval
	return p
}

func InitEmptyIntervalContext(p *IntervalContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_interval
}

func (*IntervalContext) IsIntervalContext() {}

func NewIntervalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntervalContext {
	var p = new(IntervalContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_interval

	return p
}

func (s *IntervalContext) GetParser() antlr.Parser { return s.parser }

func (s *IntervalContext) GetValue() IExpressionContext { return s.value }

func (s *IntervalContext) GetUnit() IUnitIdentifierContext { return s.unit }

func (s *IntervalContext) SetValue(v IExpressionContext) { s.value = v }

func (s *IntervalContext) SetUnit(v IUnitIdentifierContext) { s.unit = v }

func (s *IntervalContext) INTERVAL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserINTERVAL, 0)
}

func (s *IntervalContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *IntervalContext) UnitIdentifier() IUnitIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnitIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnitIdentifierContext)
}

func (s *IntervalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntervalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IntervalContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitInterval(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) Interval() (localctx IIntervalContext) {
	localctx = NewIntervalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 418, DorisParserParserRULE_interval)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6145)
		p.Match(DorisParserParserINTERVAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6146)

		var _x = p.Expression()

		localctx.(*IntervalContext).value = _x
	}
	{
		p.SetState(6147)

		var _x = p.UnitIdentifier()

		localctx.(*IntervalContext).unit = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnitIdentifierContext is an interface to support dynamic dispatch.
type IUnitIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	YEAR() antlr.TerminalNode
	QUARTER() antlr.TerminalNode
	MONTH() antlr.TerminalNode
	WEEK() antlr.TerminalNode
	DAY() antlr.TerminalNode
	HOUR() antlr.TerminalNode
	MINUTE() antlr.TerminalNode
	SECOND() antlr.TerminalNode

	// IsUnitIdentifierContext differentiates from other interfaces.
	IsUnitIdentifierContext()
}

type UnitIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnitIdentifierContext() *UnitIdentifierContext {
	var p = new(UnitIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_unitIdentifier
	return p
}

func InitEmptyUnitIdentifierContext(p *UnitIdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_unitIdentifier
}

func (*UnitIdentifierContext) IsUnitIdentifierContext() {}

func NewUnitIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnitIdentifierContext {
	var p = new(UnitIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_unitIdentifier

	return p
}

func (s *UnitIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *UnitIdentifierContext) YEAR() antlr.TerminalNode {
	return s.GetToken(DorisParserParserYEAR, 0)
}

func (s *UnitIdentifierContext) QUARTER() antlr.TerminalNode {
	return s.GetToken(DorisParserParserQUARTER, 0)
}

func (s *UnitIdentifierContext) MONTH() antlr.TerminalNode {
	return s.GetToken(DorisParserParserMONTH, 0)
}

func (s *UnitIdentifierContext) WEEK() antlr.TerminalNode {
	return s.GetToken(DorisParserParserWEEK, 0)
}

func (s *UnitIdentifierContext) DAY() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDAY, 0)
}

func (s *UnitIdentifierContext) HOUR() antlr.TerminalNode {
	return s.GetToken(DorisParserParserHOUR, 0)
}

func (s *UnitIdentifierContext) MINUTE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserMINUTE, 0)
}

func (s *UnitIdentifierContext) SECOND() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSECOND, 0)
}

func (s *UnitIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnitIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnitIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitUnitIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) UnitIdentifier() (localctx IUnitIdentifierContext) {
	localctx = NewUnitIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 420, DorisParserParserRULE_unitIdentifier)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6149)
		_la = p.GetTokenStream().LA(1)

		if !(_la == DorisParserParserDAY || _la == DorisParserParserHOUR || _la == DorisParserParserMINUTE || _la == DorisParserParserMONTH || _la == DorisParserParserQUARTER || _la == DorisParserParserSECOND || _la == DorisParserParserWEEK || _la == DorisParserParserYEAR) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDataTypeWithNullableContext is an interface to support dynamic dispatch.
type IDataTypeWithNullableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DataType() IDataTypeContext
	NULL() antlr.TerminalNode
	NOT() antlr.TerminalNode

	// IsDataTypeWithNullableContext differentiates from other interfaces.
	IsDataTypeWithNullableContext()
}

type DataTypeWithNullableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataTypeWithNullableContext() *DataTypeWithNullableContext {
	var p = new(DataTypeWithNullableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_dataTypeWithNullable
	return p
}

func InitEmptyDataTypeWithNullableContext(p *DataTypeWithNullableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_dataTypeWithNullable
}

func (*DataTypeWithNullableContext) IsDataTypeWithNullableContext() {}

func NewDataTypeWithNullableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataTypeWithNullableContext {
	var p = new(DataTypeWithNullableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_dataTypeWithNullable

	return p
}

func (s *DataTypeWithNullableContext) GetParser() antlr.Parser { return s.parser }

func (s *DataTypeWithNullableContext) DataType() IDataTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *DataTypeWithNullableContext) NULL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserNULL, 0)
}

func (s *DataTypeWithNullableContext) NOT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserNOT, 0)
}

func (s *DataTypeWithNullableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataTypeWithNullableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataTypeWithNullableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitDataTypeWithNullable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) DataTypeWithNullable() (localctx IDataTypeWithNullableContext) {
	localctx = NewDataTypeWithNullableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 422, DorisParserParserRULE_dataTypeWithNullable)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6151)
		p.DataType()
	}
	p.SetState(6156)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserParserNOT || _la == DorisParserParserNULL {
		p.SetState(6153)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserNOT {
			{
				p.SetState(6152)
				p.Match(DorisParserParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(6155)
			p.Match(DorisParserParserNULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDataTypeContext is an interface to support dynamic dispatch.
type IDataTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsDataTypeContext differentiates from other interfaces.
	IsDataTypeContext()
}

type DataTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataTypeContext() *DataTypeContext {
	var p = new(DataTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_dataType
	return p
}

func InitEmptyDataTypeContext(p *DataTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_dataType
}

func (*DataTypeContext) IsDataTypeContext() {}

func NewDataTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataTypeContext {
	var p = new(DataTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_dataType

	return p
}

func (s *DataTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *DataTypeContext) CopyAll(ctx *DataTypeContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *DataTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ComplexDataTypeContext struct {
	DataTypeContext
	complex_ antlr.Token
}

func NewComplexDataTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ComplexDataTypeContext {
	var p = new(ComplexDataTypeContext)

	InitEmptyDataTypeContext(&p.DataTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*DataTypeContext))

	return p
}

func (s *ComplexDataTypeContext) GetComplex_() antlr.Token { return s.complex_ }

func (s *ComplexDataTypeContext) SetComplex_(v antlr.Token) { s.complex_ = v }

func (s *ComplexDataTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComplexDataTypeContext) LT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLT, 0)
}

func (s *ComplexDataTypeContext) AllDataType() []IDataTypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDataTypeContext); ok {
			len++
		}
	}

	tst := make([]IDataTypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDataTypeContext); ok {
			tst[i] = t.(IDataTypeContext)
			i++
		}
	}

	return tst
}

func (s *ComplexDataTypeContext) DataType(i int) IDataTypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *ComplexDataTypeContext) GT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserGT, 0)
}

func (s *ComplexDataTypeContext) ARRAY() antlr.TerminalNode {
	return s.GetToken(DorisParserParserARRAY, 0)
}

func (s *ComplexDataTypeContext) COMMA() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOMMA, 0)
}

func (s *ComplexDataTypeContext) MAP() antlr.TerminalNode {
	return s.GetToken(DorisParserParserMAP, 0)
}

func (s *ComplexDataTypeContext) ComplexColTypeList() IComplexColTypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComplexColTypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComplexColTypeListContext)
}

func (s *ComplexDataTypeContext) STRUCT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTRUCT, 0)
}

func (s *ComplexDataTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitComplexDataType(s)

	default:
		return t.VisitChildren(s)
	}
}

type AggStateDataTypeContext struct {
	DataTypeContext
	_dataTypeWithNullable IDataTypeWithNullableContext
	dataTypes             []IDataTypeWithNullableContext
}

func NewAggStateDataTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AggStateDataTypeContext {
	var p = new(AggStateDataTypeContext)

	InitEmptyDataTypeContext(&p.DataTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*DataTypeContext))

	return p
}

func (s *AggStateDataTypeContext) Get_dataTypeWithNullable() IDataTypeWithNullableContext {
	return s._dataTypeWithNullable
}

func (s *AggStateDataTypeContext) Set_dataTypeWithNullable(v IDataTypeWithNullableContext) {
	s._dataTypeWithNullable = v
}

func (s *AggStateDataTypeContext) GetDataTypes() []IDataTypeWithNullableContext { return s.dataTypes }

func (s *AggStateDataTypeContext) SetDataTypes(v []IDataTypeWithNullableContext) { s.dataTypes = v }

func (s *AggStateDataTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AggStateDataTypeContext) AGG_STATE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserAGG_STATE, 0)
}

func (s *AggStateDataTypeContext) LT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLT, 0)
}

func (s *AggStateDataTypeContext) FunctionNameIdentifier() IFunctionNameIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionNameIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionNameIdentifierContext)
}

func (s *AggStateDataTypeContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLEFT_PAREN, 0)
}

func (s *AggStateDataTypeContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRIGHT_PAREN, 0)
}

func (s *AggStateDataTypeContext) GT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserGT, 0)
}

func (s *AggStateDataTypeContext) AllDataTypeWithNullable() []IDataTypeWithNullableContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDataTypeWithNullableContext); ok {
			len++
		}
	}

	tst := make([]IDataTypeWithNullableContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDataTypeWithNullableContext); ok {
			tst[i] = t.(IDataTypeWithNullableContext)
			i++
		}
	}

	return tst
}

func (s *AggStateDataTypeContext) DataTypeWithNullable(i int) IDataTypeWithNullableContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeWithNullableContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeWithNullableContext)
}

func (s *AggStateDataTypeContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserCOMMA)
}

func (s *AggStateDataTypeContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOMMA, i)
}

func (s *AggStateDataTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitAggStateDataType(s)

	default:
		return t.VisitChildren(s)
	}
}

type PrimitiveDataTypeContext struct {
	DataTypeContext
}

func NewPrimitiveDataTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PrimitiveDataTypeContext {
	var p = new(PrimitiveDataTypeContext)

	InitEmptyDataTypeContext(&p.DataTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*DataTypeContext))

	return p
}

func (s *PrimitiveDataTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimitiveDataTypeContext) PrimitiveColType() IPrimitiveColTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimitiveColTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimitiveColTypeContext)
}

func (s *PrimitiveDataTypeContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLEFT_PAREN, 0)
}

func (s *PrimitiveDataTypeContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRIGHT_PAREN, 0)
}

func (s *PrimitiveDataTypeContext) AllINTEGER_VALUE() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserINTEGER_VALUE)
}

func (s *PrimitiveDataTypeContext) INTEGER_VALUE(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserINTEGER_VALUE, i)
}

func (s *PrimitiveDataTypeContext) ASTERISK() antlr.TerminalNode {
	return s.GetToken(DorisParserParserASTERISK, 0)
}

func (s *PrimitiveDataTypeContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserCOMMA)
}

func (s *PrimitiveDataTypeContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOMMA, i)
}

func (s *PrimitiveDataTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitPrimitiveDataType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) DataType() (localctx IDataTypeContext) {
	localctx = NewDataTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 424, DorisParserParserRULE_dataType)
	var _la int

	p.SetState(6203)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 884, p.GetParserRuleContext()) {
	case 1:
		localctx = NewComplexDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6158)

			var _m = p.Match(DorisParserParserARRAY)

			localctx.(*ComplexDataTypeContext).complex_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6159)
			p.Match(DorisParserParserLT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6160)
			p.DataType()
		}
		{
			p.SetState(6161)
			p.Match(DorisParserParserGT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewComplexDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6163)

			var _m = p.Match(DorisParserParserMAP)

			localctx.(*ComplexDataTypeContext).complex_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6164)
			p.Match(DorisParserParserLT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6165)
			p.DataType()
		}
		{
			p.SetState(6166)
			p.Match(DorisParserParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6167)
			p.DataType()
		}
		{
			p.SetState(6168)
			p.Match(DorisParserParserGT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		localctx = NewComplexDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6170)

			var _m = p.Match(DorisParserParserSTRUCT)

			localctx.(*ComplexDataTypeContext).complex_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6171)
			p.Match(DorisParserParserLT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6172)
			p.ComplexColTypeList()
		}
		{
			p.SetState(6173)
			p.Match(DorisParserParserGT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		localctx = NewAggStateDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(6175)
			p.Match(DorisParserParserAGG_STATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6176)
			p.Match(DorisParserParserLT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6177)
			p.FunctionNameIdentifier()
		}
		{
			p.SetState(6178)
			p.Match(DorisParserParserLEFT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6179)

			var _x = p.DataTypeWithNullable()

			localctx.(*AggStateDataTypeContext)._dataTypeWithNullable = _x
		}
		localctx.(*AggStateDataTypeContext).dataTypes = append(localctx.(*AggStateDataTypeContext).dataTypes, localctx.(*AggStateDataTypeContext)._dataTypeWithNullable)
		p.SetState(6184)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == DorisParserParserCOMMA {
			{
				p.SetState(6180)
				p.Match(DorisParserParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6181)

				var _x = p.DataTypeWithNullable()

				localctx.(*AggStateDataTypeContext)._dataTypeWithNullable = _x
			}
			localctx.(*AggStateDataTypeContext).dataTypes = append(localctx.(*AggStateDataTypeContext).dataTypes, localctx.(*AggStateDataTypeContext)._dataTypeWithNullable)

			p.SetState(6186)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(6187)
			p.Match(DorisParserParserRIGHT_PAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6188)
			p.Match(DorisParserParserGT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		localctx = NewPrimitiveDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(6190)
			p.PrimitiveColType()
		}
		p.SetState(6201)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserLEFT_PAREN {
			{
				p.SetState(6191)
				p.Match(DorisParserParserLEFT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6192)
				_la = p.GetTokenStream().LA(1)

				if !(_la == DorisParserParserASTERISK || _la == DorisParserParserINTEGER_VALUE) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			p.SetState(6197)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == DorisParserParserCOMMA {
				{
					p.SetState(6193)
					p.Match(DorisParserParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(6194)
					p.Match(DorisParserParserINTEGER_VALUE)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

				p.SetState(6199)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(6200)
				p.Match(DorisParserParserRIGHT_PAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrimitiveColTypeContext is an interface to support dynamic dispatch.
type IPrimitiveColTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetType_ returns the type_ token.
	GetType_() antlr.Token

	// SetType_ sets the type_ token.
	SetType_(antlr.Token)

	// Getter signatures
	TINYINT() antlr.TerminalNode
	SMALLINT() antlr.TerminalNode
	INT() antlr.TerminalNode
	INTEGER() antlr.TerminalNode
	BIGINT() antlr.TerminalNode
	LARGEINT() antlr.TerminalNode
	BOOLEAN() antlr.TerminalNode
	FLOAT() antlr.TerminalNode
	DOUBLE() antlr.TerminalNode
	DATE() antlr.TerminalNode
	DATETIME() antlr.TerminalNode
	TIME() antlr.TerminalNode
	DATEV2() antlr.TerminalNode
	DATETIMEV2() antlr.TerminalNode
	DATEV1() antlr.TerminalNode
	DATETIMEV1() antlr.TerminalNode
	BITMAP() antlr.TerminalNode
	QUANTILE_STATE() antlr.TerminalNode
	HLL() antlr.TerminalNode
	AGG_STATE() antlr.TerminalNode
	STRING() antlr.TerminalNode
	JSON() antlr.TerminalNode
	JSONB() antlr.TerminalNode
	TEXT() antlr.TerminalNode
	VARCHAR() antlr.TerminalNode
	CHAR() antlr.TerminalNode
	DECIMAL() antlr.TerminalNode
	DECIMALV2() antlr.TerminalNode
	DECIMALV3() antlr.TerminalNode
	IPV4() antlr.TerminalNode
	IPV6() antlr.TerminalNode
	VARIANT() antlr.TerminalNode
	ALL() antlr.TerminalNode

	// IsPrimitiveColTypeContext differentiates from other interfaces.
	IsPrimitiveColTypeContext()
}

type PrimitiveColTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	type_  antlr.Token
}

func NewEmptyPrimitiveColTypeContext() *PrimitiveColTypeContext {
	var p = new(PrimitiveColTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_primitiveColType
	return p
}

func InitEmptyPrimitiveColTypeContext(p *PrimitiveColTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_primitiveColType
}

func (*PrimitiveColTypeContext) IsPrimitiveColTypeContext() {}

func NewPrimitiveColTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimitiveColTypeContext {
	var p = new(PrimitiveColTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_primitiveColType

	return p
}

func (s *PrimitiveColTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimitiveColTypeContext) GetType_() antlr.Token { return s.type_ }

func (s *PrimitiveColTypeContext) SetType_(v antlr.Token) { s.type_ = v }

func (s *PrimitiveColTypeContext) TINYINT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserTINYINT, 0)
}

func (s *PrimitiveColTypeContext) SMALLINT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSMALLINT, 0)
}

func (s *PrimitiveColTypeContext) INT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserINT, 0)
}

func (s *PrimitiveColTypeContext) INTEGER() antlr.TerminalNode {
	return s.GetToken(DorisParserParserINTEGER, 0)
}

func (s *PrimitiveColTypeContext) BIGINT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserBIGINT, 0)
}

func (s *PrimitiveColTypeContext) LARGEINT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLARGEINT, 0)
}

func (s *PrimitiveColTypeContext) BOOLEAN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserBOOLEAN, 0)
}

func (s *PrimitiveColTypeContext) FLOAT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFLOAT, 0)
}

func (s *PrimitiveColTypeContext) DOUBLE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDOUBLE, 0)
}

func (s *PrimitiveColTypeContext) DATE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDATE, 0)
}

func (s *PrimitiveColTypeContext) DATETIME() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDATETIME, 0)
}

func (s *PrimitiveColTypeContext) TIME() antlr.TerminalNode {
	return s.GetToken(DorisParserParserTIME, 0)
}

func (s *PrimitiveColTypeContext) DATEV2() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDATEV2, 0)
}

func (s *PrimitiveColTypeContext) DATETIMEV2() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDATETIMEV2, 0)
}

func (s *PrimitiveColTypeContext) DATEV1() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDATEV1, 0)
}

func (s *PrimitiveColTypeContext) DATETIMEV1() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDATETIMEV1, 0)
}

func (s *PrimitiveColTypeContext) BITMAP() antlr.TerminalNode {
	return s.GetToken(DorisParserParserBITMAP, 0)
}

func (s *PrimitiveColTypeContext) QUANTILE_STATE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserQUANTILE_STATE, 0)
}

func (s *PrimitiveColTypeContext) HLL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserHLL, 0)
}

func (s *PrimitiveColTypeContext) AGG_STATE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserAGG_STATE, 0)
}

func (s *PrimitiveColTypeContext) STRING() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTRING, 0)
}

func (s *PrimitiveColTypeContext) JSON() antlr.TerminalNode {
	return s.GetToken(DorisParserParserJSON, 0)
}

func (s *PrimitiveColTypeContext) JSONB() antlr.TerminalNode {
	return s.GetToken(DorisParserParserJSONB, 0)
}

func (s *PrimitiveColTypeContext) TEXT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserTEXT, 0)
}

func (s *PrimitiveColTypeContext) VARCHAR() antlr.TerminalNode {
	return s.GetToken(DorisParserParserVARCHAR, 0)
}

func (s *PrimitiveColTypeContext) CHAR() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCHAR, 0)
}

func (s *PrimitiveColTypeContext) DECIMAL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDECIMAL, 0)
}

func (s *PrimitiveColTypeContext) DECIMALV2() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDECIMALV2, 0)
}

func (s *PrimitiveColTypeContext) DECIMALV3() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDECIMALV3, 0)
}

func (s *PrimitiveColTypeContext) IPV4() antlr.TerminalNode {
	return s.GetToken(DorisParserParserIPV4, 0)
}

func (s *PrimitiveColTypeContext) IPV6() antlr.TerminalNode {
	return s.GetToken(DorisParserParserIPV6, 0)
}

func (s *PrimitiveColTypeContext) VARIANT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserVARIANT, 0)
}

func (s *PrimitiveColTypeContext) ALL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserALL, 0)
}

func (s *PrimitiveColTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimitiveColTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrimitiveColTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitPrimitiveColType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) PrimitiveColType() (localctx IPrimitiveColTypeContext) {
	localctx = NewPrimitiveColTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 426, DorisParserParserRULE_primitiveColType)
	var _la int

	p.SetState(6237)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserParserTINYINT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6205)

			var _m = p.Match(DorisParserParserTINYINT)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserParserSMALLINT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6206)

			var _m = p.Match(DorisParserParserSMALLINT)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserParserINT, DorisParserParserINTEGER:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6207)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*PrimitiveColTypeContext).type_ = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserParserINT || _la == DorisParserParserINTEGER) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*PrimitiveColTypeContext).type_ = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case DorisParserParserBIGINT:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(6208)

			var _m = p.Match(DorisParserParserBIGINT)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserParserLARGEINT:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(6209)

			var _m = p.Match(DorisParserParserLARGEINT)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserParserBOOLEAN:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(6210)

			var _m = p.Match(DorisParserParserBOOLEAN)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserParserFLOAT:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(6211)

			var _m = p.Match(DorisParserParserFLOAT)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserParserDOUBLE:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(6212)

			var _m = p.Match(DorisParserParserDOUBLE)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserParserDATE:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(6213)

			var _m = p.Match(DorisParserParserDATE)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserParserDATETIME:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(6214)

			var _m = p.Match(DorisParserParserDATETIME)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserParserTIME:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(6215)

			var _m = p.Match(DorisParserParserTIME)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserParserDATEV2:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(6216)

			var _m = p.Match(DorisParserParserDATEV2)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserParserDATETIMEV2:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(6217)

			var _m = p.Match(DorisParserParserDATETIMEV2)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserParserDATEV1:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(6218)

			var _m = p.Match(DorisParserParserDATEV1)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserParserDATETIMEV1:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(6219)

			var _m = p.Match(DorisParserParserDATETIMEV1)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserParserBITMAP:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(6220)

			var _m = p.Match(DorisParserParserBITMAP)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserParserQUANTILE_STATE:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(6221)

			var _m = p.Match(DorisParserParserQUANTILE_STATE)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserParserHLL:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(6222)

			var _m = p.Match(DorisParserParserHLL)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserParserAGG_STATE:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(6223)

			var _m = p.Match(DorisParserParserAGG_STATE)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserParserSTRING:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(6224)

			var _m = p.Match(DorisParserParserSTRING)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserParserJSON:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(6225)

			var _m = p.Match(DorisParserParserJSON)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserParserJSONB:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(6226)

			var _m = p.Match(DorisParserParserJSONB)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserParserTEXT:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(6227)

			var _m = p.Match(DorisParserParserTEXT)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserParserVARCHAR:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(6228)

			var _m = p.Match(DorisParserParserVARCHAR)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserParserCHAR:
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(6229)

			var _m = p.Match(DorisParserParserCHAR)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserParserDECIMAL:
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(6230)

			var _m = p.Match(DorisParserParserDECIMAL)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserParserDECIMALV2:
		p.EnterOuterAlt(localctx, 27)
		{
			p.SetState(6231)

			var _m = p.Match(DorisParserParserDECIMALV2)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserParserDECIMALV3:
		p.EnterOuterAlt(localctx, 28)
		{
			p.SetState(6232)

			var _m = p.Match(DorisParserParserDECIMALV3)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserParserIPV4:
		p.EnterOuterAlt(localctx, 29)
		{
			p.SetState(6233)

			var _m = p.Match(DorisParserParserIPV4)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserParserIPV6:
		p.EnterOuterAlt(localctx, 30)
		{
			p.SetState(6234)

			var _m = p.Match(DorisParserParserIPV6)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserParserVARIANT:
		p.EnterOuterAlt(localctx, 31)
		{
			p.SetState(6235)

			var _m = p.Match(DorisParserParserVARIANT)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserParserALL:
		p.EnterOuterAlt(localctx, 32)
		{
			p.SetState(6236)

			var _m = p.Match(DorisParserParserALL)

			localctx.(*PrimitiveColTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IComplexColTypeListContext is an interface to support dynamic dispatch.
type IComplexColTypeListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllComplexColType() []IComplexColTypeContext
	ComplexColType(i int) IComplexColTypeContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsComplexColTypeListContext differentiates from other interfaces.
	IsComplexColTypeListContext()
}

type ComplexColTypeListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComplexColTypeListContext() *ComplexColTypeListContext {
	var p = new(ComplexColTypeListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_complexColTypeList
	return p
}

func InitEmptyComplexColTypeListContext(p *ComplexColTypeListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_complexColTypeList
}

func (*ComplexColTypeListContext) IsComplexColTypeListContext() {}

func NewComplexColTypeListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComplexColTypeListContext {
	var p = new(ComplexColTypeListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_complexColTypeList

	return p
}

func (s *ComplexColTypeListContext) GetParser() antlr.Parser { return s.parser }

func (s *ComplexColTypeListContext) AllComplexColType() []IComplexColTypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IComplexColTypeContext); ok {
			len++
		}
	}

	tst := make([]IComplexColTypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IComplexColTypeContext); ok {
			tst[i] = t.(IComplexColTypeContext)
			i++
		}
	}

	return tst
}

func (s *ComplexColTypeListContext) ComplexColType(i int) IComplexColTypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComplexColTypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComplexColTypeContext)
}

func (s *ComplexColTypeListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserCOMMA)
}

func (s *ComplexColTypeListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOMMA, i)
}

func (s *ComplexColTypeListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComplexColTypeListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComplexColTypeListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitComplexColTypeList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) ComplexColTypeList() (localctx IComplexColTypeListContext) {
	localctx = NewComplexColTypeListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 428, DorisParserParserRULE_complexColTypeList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6239)
		p.ComplexColType()
	}
	p.SetState(6244)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == DorisParserParserCOMMA {
		{
			p.SetState(6240)
			p.Match(DorisParserParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6241)
			p.ComplexColType()
		}

		p.SetState(6246)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IComplexColTypeContext is an interface to support dynamic dispatch.
type IComplexColTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	COLON() antlr.TerminalNode
	DataType() IDataTypeContext
	CommentSpec() ICommentSpecContext

	// IsComplexColTypeContext differentiates from other interfaces.
	IsComplexColTypeContext()
}

type ComplexColTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComplexColTypeContext() *ComplexColTypeContext {
	var p = new(ComplexColTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_complexColType
	return p
}

func InitEmptyComplexColTypeContext(p *ComplexColTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_complexColType
}

func (*ComplexColTypeContext) IsComplexColTypeContext() {}

func NewComplexColTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComplexColTypeContext {
	var p = new(ComplexColTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_complexColType

	return p
}

func (s *ComplexColTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ComplexColTypeContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ComplexColTypeContext) COLON() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOLON, 0)
}

func (s *ComplexColTypeContext) DataType() IDataTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *ComplexColTypeContext) CommentSpec() ICommentSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentSpecContext)
}

func (s *ComplexColTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComplexColTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComplexColTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitComplexColType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) ComplexColType() (localctx IComplexColTypeContext) {
	localctx = NewComplexColTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 430, DorisParserParserRULE_complexColType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6247)
		p.Identifier()
	}
	{
		p.SetState(6248)
		p.Match(DorisParserParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6249)
		p.DataType()
	}
	p.SetState(6251)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserParserCOMMENT {
		{
			p.SetState(6250)
			p.CommentSpec()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICommentSpecContext is an interface to support dynamic dispatch.
type ICommentSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COMMENT() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode

	// IsCommentSpecContext differentiates from other interfaces.
	IsCommentSpecContext()
}

type CommentSpecContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCommentSpecContext() *CommentSpecContext {
	var p = new(CommentSpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_commentSpec
	return p
}

func InitEmptyCommentSpecContext(p *CommentSpecContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_commentSpec
}

func (*CommentSpecContext) IsCommentSpecContext() {}

func NewCommentSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CommentSpecContext {
	var p = new(CommentSpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_commentSpec

	return p
}

func (s *CommentSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *CommentSpecContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOMMENT, 0)
}

func (s *CommentSpecContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTRING_LITERAL, 0)
}

func (s *CommentSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommentSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CommentSpecContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitCommentSpec(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) CommentSpec() (localctx ICommentSpecContext) {
	localctx = NewCommentSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 432, DorisParserParserRULE_commentSpec)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6253)
		p.Match(DorisParserParserCOMMENT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6254)
		p.Match(DorisParserParserSTRING_LITERAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISampleContext is an interface to support dynamic dispatch.
type ISampleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetSeed returns the seed token.
	GetSeed() antlr.Token

	// SetSeed sets the seed token.
	SetSeed(antlr.Token)

	// Getter signatures
	TABLESAMPLE() antlr.TerminalNode
	LEFT_PAREN() antlr.TerminalNode
	RIGHT_PAREN() antlr.TerminalNode
	SampleMethod() ISampleMethodContext
	REPEATABLE() antlr.TerminalNode
	INTEGER_VALUE() antlr.TerminalNode

	// IsSampleContext differentiates from other interfaces.
	IsSampleContext()
}

type SampleContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	seed   antlr.Token
}

func NewEmptySampleContext() *SampleContext {
	var p = new(SampleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_sample
	return p
}

func InitEmptySampleContext(p *SampleContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_sample
}

func (*SampleContext) IsSampleContext() {}

func NewSampleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SampleContext {
	var p = new(SampleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_sample

	return p
}

func (s *SampleContext) GetParser() antlr.Parser { return s.parser }

func (s *SampleContext) GetSeed() antlr.Token { return s.seed }

func (s *SampleContext) SetSeed(v antlr.Token) { s.seed = v }

func (s *SampleContext) TABLESAMPLE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserTABLESAMPLE, 0)
}

func (s *SampleContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLEFT_PAREN, 0)
}

func (s *SampleContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRIGHT_PAREN, 0)
}

func (s *SampleContext) SampleMethod() ISampleMethodContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISampleMethodContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISampleMethodContext)
}

func (s *SampleContext) REPEATABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserREPEATABLE, 0)
}

func (s *SampleContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserINTEGER_VALUE, 0)
}

func (s *SampleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SampleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SampleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitSample(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) Sample() (localctx ISampleContext) {
	localctx = NewSampleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 434, DorisParserParserRULE_sample)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6256)
		p.Match(DorisParserParserTABLESAMPLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6257)
		p.Match(DorisParserParserLEFT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(6259)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == DorisParserParserINTEGER_VALUE {
		{
			p.SetState(6258)
			p.SampleMethod()
		}

	}
	{
		p.SetState(6261)
		p.Match(DorisParserParserRIGHT_PAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(6264)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 889, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(6262)
			p.Match(DorisParserParserREPEATABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6263)

			var _m = p.Match(DorisParserParserINTEGER_VALUE)

			localctx.(*SampleContext).seed = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISampleMethodContext is an interface to support dynamic dispatch.
type ISampleMethodContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSampleMethodContext differentiates from other interfaces.
	IsSampleMethodContext()
}

type SampleMethodContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySampleMethodContext() *SampleMethodContext {
	var p = new(SampleMethodContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_sampleMethod
	return p
}

func InitEmptySampleMethodContext(p *SampleMethodContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_sampleMethod
}

func (*SampleMethodContext) IsSampleMethodContext() {}

func NewSampleMethodContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SampleMethodContext {
	var p = new(SampleMethodContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_sampleMethod

	return p
}

func (s *SampleMethodContext) GetParser() antlr.Parser { return s.parser }

func (s *SampleMethodContext) CopyAll(ctx *SampleMethodContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *SampleMethodContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SampleMethodContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SampleByRowsContext struct {
	SampleMethodContext
}

func NewSampleByRowsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SampleByRowsContext {
	var p = new(SampleByRowsContext)

	InitEmptySampleMethodContext(&p.SampleMethodContext)
	p.parser = parser
	p.CopyAll(ctx.(*SampleMethodContext))

	return p
}

func (s *SampleByRowsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SampleByRowsContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserINTEGER_VALUE, 0)
}

func (s *SampleByRowsContext) ROWS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserROWS, 0)
}

func (s *SampleByRowsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitSampleByRows(s)

	default:
		return t.VisitChildren(s)
	}
}

type SampleByPercentileContext struct {
	SampleMethodContext
	percentage antlr.Token
}

func NewSampleByPercentileContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SampleByPercentileContext {
	var p = new(SampleByPercentileContext)

	InitEmptySampleMethodContext(&p.SampleMethodContext)
	p.parser = parser
	p.CopyAll(ctx.(*SampleMethodContext))

	return p
}

func (s *SampleByPercentileContext) GetPercentage() antlr.Token { return s.percentage }

func (s *SampleByPercentileContext) SetPercentage(v antlr.Token) { s.percentage = v }

func (s *SampleByPercentileContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SampleByPercentileContext) PERCENT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserPERCENT, 0)
}

func (s *SampleByPercentileContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserINTEGER_VALUE, 0)
}

func (s *SampleByPercentileContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitSampleByPercentile(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) SampleMethod() (localctx ISampleMethodContext) {
	localctx = NewSampleMethodContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 436, DorisParserParserRULE_sampleMethod)
	p.SetState(6270)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 890, p.GetParserRuleContext()) {
	case 1:
		localctx = NewSampleByPercentileContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6266)

			var _m = p.Match(DorisParserParserINTEGER_VALUE)

			localctx.(*SampleByPercentileContext).percentage = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6267)
			p.Match(DorisParserParserPERCENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewSampleByRowsContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6268)
			p.Match(DorisParserParserINTEGER_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6269)
			p.Match(DorisParserParserROWS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableSnapshotContext is an interface to support dynamic dispatch.
type ITableSnapshotContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetVersion returns the version token.
	GetVersion() antlr.Token

	// GetTime returns the time token.
	GetTime() antlr.Token

	// SetVersion sets the version token.
	SetVersion(antlr.Token)

	// SetTime sets the time token.
	SetTime(antlr.Token)

	// Getter signatures
	FOR() antlr.TerminalNode
	VERSION() antlr.TerminalNode
	AS() antlr.TerminalNode
	OF() antlr.TerminalNode
	INTEGER_VALUE() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode
	TIME() antlr.TerminalNode

	// IsTableSnapshotContext differentiates from other interfaces.
	IsTableSnapshotContext()
}

type TableSnapshotContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	version antlr.Token
	time    antlr.Token
}

func NewEmptyTableSnapshotContext() *TableSnapshotContext {
	var p = new(TableSnapshotContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_tableSnapshot
	return p
}

func InitEmptyTableSnapshotContext(p *TableSnapshotContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_tableSnapshot
}

func (*TableSnapshotContext) IsTableSnapshotContext() {}

func NewTableSnapshotContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableSnapshotContext {
	var p = new(TableSnapshotContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_tableSnapshot

	return p
}

func (s *TableSnapshotContext) GetParser() antlr.Parser { return s.parser }

func (s *TableSnapshotContext) GetVersion() antlr.Token { return s.version }

func (s *TableSnapshotContext) GetTime() antlr.Token { return s.time }

func (s *TableSnapshotContext) SetVersion(v antlr.Token) { s.version = v }

func (s *TableSnapshotContext) SetTime(v antlr.Token) { s.time = v }

func (s *TableSnapshotContext) FOR() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFOR, 0)
}

func (s *TableSnapshotContext) VERSION() antlr.TerminalNode {
	return s.GetToken(DorisParserParserVERSION, 0)
}

func (s *TableSnapshotContext) AS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserAS, 0)
}

func (s *TableSnapshotContext) OF() antlr.TerminalNode {
	return s.GetToken(DorisParserParserOF, 0)
}

func (s *TableSnapshotContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserINTEGER_VALUE, 0)
}

func (s *TableSnapshotContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTRING_LITERAL, 0)
}

func (s *TableSnapshotContext) TIME() antlr.TerminalNode {
	return s.GetToken(DorisParserParserTIME, 0)
}

func (s *TableSnapshotContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableSnapshotContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableSnapshotContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitTableSnapshot(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) TableSnapshot() (localctx ITableSnapshotContext) {
	localctx = NewTableSnapshotContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 438, DorisParserParserRULE_tableSnapshot)
	var _la int

	p.SetState(6282)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 891, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6272)
			p.Match(DorisParserParserFOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6273)
			p.Match(DorisParserParserVERSION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6274)
			p.Match(DorisParserParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6275)
			p.Match(DorisParserParserOF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6276)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*TableSnapshotContext).version = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserParserSTRING_LITERAL || _la == DorisParserParserINTEGER_VALUE) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*TableSnapshotContext).version = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6277)
			p.Match(DorisParserParserFOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6278)
			p.Match(DorisParserParserTIME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6279)
			p.Match(DorisParserParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6280)
			p.Match(DorisParserParserOF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6281)

			var _m = p.Match(DorisParserParserSTRING_LITERAL)

			localctx.(*TableSnapshotContext).time = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IErrorCapturingIdentifierContext is an interface to support dynamic dispatch.
type IErrorCapturingIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	ErrorCapturingIdentifierExtra() IErrorCapturingIdentifierExtraContext

	// IsErrorCapturingIdentifierContext differentiates from other interfaces.
	IsErrorCapturingIdentifierContext()
}

type ErrorCapturingIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyErrorCapturingIdentifierContext() *ErrorCapturingIdentifierContext {
	var p = new(ErrorCapturingIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_errorCapturingIdentifier
	return p
}

func InitEmptyErrorCapturingIdentifierContext(p *ErrorCapturingIdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_errorCapturingIdentifier
}

func (*ErrorCapturingIdentifierContext) IsErrorCapturingIdentifierContext() {}

func NewErrorCapturingIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ErrorCapturingIdentifierContext {
	var p = new(ErrorCapturingIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_errorCapturingIdentifier

	return p
}

func (s *ErrorCapturingIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *ErrorCapturingIdentifierContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ErrorCapturingIdentifierContext) ErrorCapturingIdentifierExtra() IErrorCapturingIdentifierExtraContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IErrorCapturingIdentifierExtraContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IErrorCapturingIdentifierExtraContext)
}

func (s *ErrorCapturingIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ErrorCapturingIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ErrorCapturingIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitErrorCapturingIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) ErrorCapturingIdentifier() (localctx IErrorCapturingIdentifierContext) {
	localctx = NewErrorCapturingIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 440, DorisParserParserRULE_errorCapturingIdentifier)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6284)
		p.Identifier()
	}
	{
		p.SetState(6285)
		p.ErrorCapturingIdentifierExtra()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IErrorCapturingIdentifierExtraContext is an interface to support dynamic dispatch.
type IErrorCapturingIdentifierExtraContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsErrorCapturingIdentifierExtraContext differentiates from other interfaces.
	IsErrorCapturingIdentifierExtraContext()
}

type ErrorCapturingIdentifierExtraContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyErrorCapturingIdentifierExtraContext() *ErrorCapturingIdentifierExtraContext {
	var p = new(ErrorCapturingIdentifierExtraContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_errorCapturingIdentifierExtra
	return p
}

func InitEmptyErrorCapturingIdentifierExtraContext(p *ErrorCapturingIdentifierExtraContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_errorCapturingIdentifierExtra
}

func (*ErrorCapturingIdentifierExtraContext) IsErrorCapturingIdentifierExtraContext() {}

func NewErrorCapturingIdentifierExtraContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ErrorCapturingIdentifierExtraContext {
	var p = new(ErrorCapturingIdentifierExtraContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_errorCapturingIdentifierExtra

	return p
}

func (s *ErrorCapturingIdentifierExtraContext) GetParser() antlr.Parser { return s.parser }

func (s *ErrorCapturingIdentifierExtraContext) CopyAll(ctx *ErrorCapturingIdentifierExtraContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ErrorCapturingIdentifierExtraContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ErrorCapturingIdentifierExtraContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ErrorIdentContext struct {
	ErrorCapturingIdentifierExtraContext
}

func NewErrorIdentContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ErrorIdentContext {
	var p = new(ErrorIdentContext)

	InitEmptyErrorCapturingIdentifierExtraContext(&p.ErrorCapturingIdentifierExtraContext)
	p.parser = parser
	p.CopyAll(ctx.(*ErrorCapturingIdentifierExtraContext))

	return p
}

func (s *ErrorIdentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ErrorIdentContext) AllSUBTRACT() []antlr.TerminalNode {
	return s.GetTokens(DorisParserParserSUBTRACT)
}

func (s *ErrorIdentContext) SUBTRACT(i int) antlr.TerminalNode {
	return s.GetToken(DorisParserParserSUBTRACT, i)
}

func (s *ErrorIdentContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *ErrorIdentContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ErrorIdentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitErrorIdent(s)

	default:
		return t.VisitChildren(s)
	}
}

type RealIdentContext struct {
	ErrorCapturingIdentifierExtraContext
}

func NewRealIdentContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RealIdentContext {
	var p = new(RealIdentContext)

	InitEmptyErrorCapturingIdentifierExtraContext(&p.ErrorCapturingIdentifierExtraContext)
	p.parser = parser
	p.CopyAll(ctx.(*ErrorCapturingIdentifierExtraContext))

	return p
}

func (s *RealIdentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RealIdentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitRealIdent(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) ErrorCapturingIdentifierExtra() (localctx IErrorCapturingIdentifierExtraContext) {
	localctx = NewErrorCapturingIdentifierExtraContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 442, DorisParserParserRULE_errorCapturingIdentifierExtra)
	var _alt int

	p.SetState(6294)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 893, p.GetParserRuleContext()) {
	case 1:
		localctx = NewErrorIdentContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		p.SetState(6289)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(6287)
					p.Match(DorisParserParserSUBTRACT)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(6288)
					p.Identifier()
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

			p.SetState(6291)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 892, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case 2:
		localctx = NewRealIdentContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierContext is an interface to support dynamic dispatch.
type IIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	StrictIdentifier() IStrictIdentifierContext

	// IsIdentifierContext differentiates from other interfaces.
	IsIdentifierContext()
}

type IdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierContext() *IdentifierContext {
	var p = new(IdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_identifier
	return p
}

func InitEmptyIdentifierContext(p *IdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_identifier
}

func (*IdentifierContext) IsIdentifierContext() {}

func NewIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierContext {
	var p = new(IdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_identifier

	return p
}

func (s *IdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierContext) StrictIdentifier() IStrictIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStrictIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStrictIdentifierContext)
}

func (s *IdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) Identifier() (localctx IIdentifierContext) {
	localctx = NewIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 444, DorisParserParserRULE_identifier)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6296)
		p.StrictIdentifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStrictIdentifierContext is an interface to support dynamic dispatch.
type IStrictIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsStrictIdentifierContext differentiates from other interfaces.
	IsStrictIdentifierContext()
}

type StrictIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStrictIdentifierContext() *StrictIdentifierContext {
	var p = new(StrictIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_strictIdentifier
	return p
}

func InitEmptyStrictIdentifierContext(p *StrictIdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_strictIdentifier
}

func (*StrictIdentifierContext) IsStrictIdentifierContext() {}

func NewStrictIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StrictIdentifierContext {
	var p = new(StrictIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_strictIdentifier

	return p
}

func (s *StrictIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *StrictIdentifierContext) CopyAll(ctx *StrictIdentifierContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *StrictIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StrictIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type QuotedIdentifierAlternativeContext struct {
	StrictIdentifierContext
}

func NewQuotedIdentifierAlternativeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *QuotedIdentifierAlternativeContext {
	var p = new(QuotedIdentifierAlternativeContext)

	InitEmptyStrictIdentifierContext(&p.StrictIdentifierContext)
	p.parser = parser
	p.CopyAll(ctx.(*StrictIdentifierContext))

	return p
}

func (s *QuotedIdentifierAlternativeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QuotedIdentifierAlternativeContext) QuotedIdentifier() IQuotedIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuotedIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuotedIdentifierContext)
}

func (s *QuotedIdentifierAlternativeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitQuotedIdentifierAlternative(s)

	default:
		return t.VisitChildren(s)
	}
}

type UnquotedIdentifierContext struct {
	StrictIdentifierContext
}

func NewUnquotedIdentifierContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnquotedIdentifierContext {
	var p = new(UnquotedIdentifierContext)

	InitEmptyStrictIdentifierContext(&p.StrictIdentifierContext)
	p.parser = parser
	p.CopyAll(ctx.(*StrictIdentifierContext))

	return p
}

func (s *UnquotedIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnquotedIdentifierContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(DorisParserParserIDENTIFIER, 0)
}

func (s *UnquotedIdentifierContext) NonReserved() INonReservedContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INonReservedContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INonReservedContext)
}

func (s *UnquotedIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitUnquotedIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) StrictIdentifier() (localctx IStrictIdentifierContext) {
	localctx = NewStrictIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 446, DorisParserParserRULE_strictIdentifier)
	p.SetState(6301)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case DorisParserParserIDENTIFIER:
		localctx = NewUnquotedIdentifierContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6298)
			p.Match(DorisParserParserIDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case DorisParserParserBACKQUOTED_IDENTIFIER:
		localctx = NewQuotedIdentifierAlternativeContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6299)
			p.QuotedIdentifier()
		}

	case DorisParserParserLEFT_BRACE, DorisParserParserRIGHT_BRACE, DorisParserParserACTIONS, DorisParserParserAFTER, DorisParserParserAGG_STATE, DorisParserParserAGGREGATE, DorisParserParserALIAS, DorisParserParserANALYZED, DorisParserParserARRAY, DorisParserParserAT, DorisParserParserAUTHORS, DorisParserParserAUTO_INCREMENT, DorisParserParserALWAYS, DorisParserParserBACKENDS, DorisParserParserBACKUP, DorisParserParserBEGIN, DorisParserParserBELONG, DorisParserParserBIN, DorisParserParserBITAND, DorisParserParserBITMAP, DorisParserParserBITMAP_EMPTY, DorisParserParserBITMAP_UNION, DorisParserParserBITOR, DorisParserParserBITXOR, DorisParserParserBLOB, DorisParserParserBOOLEAN, DorisParserParserBRANCH, DorisParserParserBRIEF, DorisParserParserBROKER, DorisParserParserBUCKETS, DorisParserParserBUILD, DorisParserParserBUILTIN, DorisParserParserBULK, DorisParserParserCACHE, DorisParserParserCACHED, DorisParserParserCALL, DorisParserParserCATALOG, DorisParserParserCATALOGS, DorisParserParserCHAIN, DorisParserParserCHAR, DorisParserParserCHARSET, DorisParserParserCHECK, DorisParserParserCLUSTER, DorisParserParserCLUSTERS, DorisParserParserCOLLATION, DorisParserParserCOLLECT, DorisParserParserCOLOCATE, DorisParserParserCOLUMNS, DorisParserParserCOMMENT, DorisParserParserCOMMIT, DorisParserParserCOMMITTED, DorisParserParserCOMPACT, DorisParserParserCOMPLETE, DorisParserParserCOMPRESS_TYPE, DorisParserParserCOMPUTE, DorisParserParserCONDITIONS, DorisParserParserCONFIG, DorisParserParserCONNECTION, DorisParserParserCONNECTION_ID, DorisParserParserCONSISTENT, DorisParserParserCONSTRAINTS, DorisParserParserCONVERT, DorisParserParserCONVERT_LSC, DorisParserParserCOPY, DorisParserParserCOUNT, DorisParserParserCREATION, DorisParserParserCRON, DorisParserParserCURRENT_CATALOG, DorisParserParserCURRENT_DATE, DorisParserParserCURRENT_TIME, DorisParserParserCURRENT_TIMESTAMP, DorisParserParserCURRENT_USER, DorisParserParserDATA, DorisParserParserDATE, DorisParserParserDATETIME, DorisParserParserDATETIMEV2, DorisParserParserDATEV2, DorisParserParserDATETIMEV1, DorisParserParserDATEV1, DorisParserParserDAY, DorisParserParserDAYS, DorisParserParserDECIMAL, DorisParserParserDECIMALV2, DorisParserParserDECIMALV3, DorisParserParserDEFERRED, DorisParserParserDEMAND, DorisParserParserDIAGNOSE, DorisParserParserDIAGNOSIS, DorisParserParserDICTIONARIES, DorisParserParserDICTIONARY, DorisParserParserDISTINCTPC, DorisParserParserDISTINCTPCSA, DorisParserParserDO, DorisParserParserDORIS_INTERNAL_TABLE_ID, DorisParserParserDUAL, DorisParserParserDYNAMIC, DorisParserParserE, DorisParserParserENABLE, DorisParserParserENCRYPTKEY, DorisParserParserENCRYPTKEYS, DorisParserParserEND, DorisParserParserENDS, DorisParserParserENGINE, DorisParserParserENGINES, DorisParserParserERRORS, DorisParserParserESCAPE, DorisParserParserEVENTS, DorisParserParserEVERY, DorisParserParserEXCLUDE, DorisParserParserEXPIRED, DorisParserParserEXTERNAL, DorisParserParserFAILED_LOGIN_ATTEMPTS, DorisParserParserFAST, DorisParserParserFEATURE, DorisParserParserFIELDS, DorisParserParserFILE, DorisParserParserFILTER, DorisParserParserFIRST, DorisParserParserFORMAT, DorisParserParserFREE, DorisParserParserFRONTENDS, DorisParserParserFUNCTION, DorisParserParserGENERATED, DorisParserParserGENERIC, DorisParserParserGLOBAL, DorisParserParserGRAPH, DorisParserParserGROUPING, DorisParserParserGROUPS, DorisParserParserHASH, DorisParserParserHASH_MAP, DorisParserParserHDFS, DorisParserParserHELP, DorisParserParserHISTOGRAM, DorisParserParserHLL_UNION, DorisParserParserHOSTNAME, DorisParserParserHOTSPOT, DorisParserParserHOUR, DorisParserParserHOURS, DorisParserParserHUB, DorisParserParserIDENTIFIED, DorisParserParserIGNORE, DorisParserParserIMMEDIATE, DorisParserParserINCREMENTAL, DorisParserParserINDEXES, DorisParserParserINVERTED, DorisParserParserIP_TRIE, DorisParserParserIPV4, DorisParserParserIPV6, DorisParserParserIS_NOT_NULL_PRED, DorisParserParserIS_NULL_PRED, DorisParserParserISNULL, DorisParserParserISOLATION, DorisParserParserJOB, DorisParserParserJOBS, DorisParserParserJSON, DorisParserParserJSONB, DorisParserParserLABEL, DorisParserParserLAST, DorisParserParserLDAP, DorisParserParserLDAP_ADMIN_PASSWORD, DorisParserParserLESS, DorisParserParserLEVEL, DorisParserParserLINES, DorisParserParserLINK, DorisParserParserLOCAL, DorisParserParserLOCALTIME, DorisParserParserLOCALTIMESTAMP, DorisParserParserLOCATION, DorisParserParserLOCK, DorisParserParserLOGICAL, DorisParserParserMANUAL, DorisParserParserMAP, DorisParserParserMATCH_ALL, DorisParserParserMATCH_ANY, DorisParserParserMATCH_PHRASE, DorisParserParserMATCH_PHRASE_EDGE, DorisParserParserMATCH_PHRASE_PREFIX, DorisParserParserMATCH_REGEXP, DorisParserParserMATERIALIZED, DorisParserParserMAX, DorisParserParserMEMO, DorisParserParserMERGE, DorisParserParserMIGRATE, DorisParserParserMIGRATIONS, DorisParserParserMIN, DorisParserParserMINUTE, DorisParserParserMINUTES, DorisParserParserMODIFY, DorisParserParserMONTH, DorisParserParserMTMV, DorisParserParserNAME, DorisParserParserNAMES, DorisParserParserNEGATIVE, DorisParserParserNEVER, DorisParserParserNEXT, DorisParserParserNGRAM_BF, DorisParserParserNO, DorisParserParserNON_NULLABLE, DorisParserParserNULLS, DorisParserParserOF, DorisParserParserOFFSET, DorisParserParserONLY, DorisParserParserOPEN, DorisParserParserOPTIMIZED, DorisParserParserPARAMETER, DorisParserParserPARSED, DorisParserParserPARTITIONS, DorisParserParserPASSWORD, DorisParserParserPASSWORD_EXPIRE, DorisParserParserPASSWORD_HISTORY, DorisParserParserPASSWORD_LOCK_TIME, DorisParserParserPASSWORD_REUSE, DorisParserParserPATH, DorisParserParserPAUSE, DorisParserParserPERCENT, DorisParserParserPERIOD, DorisParserParserPERMISSIVE, DorisParserParserPHYSICAL, DorisParserParserPI, DorisParserParserPLAN, DorisParserParserPRIVILEGES, DorisParserParserPROCESS, DorisParserParserPLUGIN, DorisParserParserPLUGINS, DorisParserParserPOLICY, DorisParserParserPROC, DorisParserParserPROCESSLIST, DorisParserParserPROFILE, DorisParserParserPROPERTIES, DorisParserParserPROPERTY, DorisParserParserQUANTILE_STATE, DorisParserParserQUANTILE_UNION, DorisParserParserQUERY, DorisParserParserQUEUED, DorisParserParserQUOTA, DorisParserParserQUALIFY, DorisParserParserQUARTER, DorisParserParserRANDOM, DorisParserParserRECENT, DorisParserParserRECOVER, DorisParserParserRECYCLE, DorisParserParserREFRESH, DorisParserParserREPEATABLE, DorisParserParserREPLACE, DorisParserParserREPLACE_IF_NOT_NULL, DorisParserParserREPLAYER, DorisParserParserREPOSITORIES, DorisParserParserREPOSITORY, DorisParserParserRESOURCE, DorisParserParserRESOURCES, DorisParserParserRESTORE, DorisParserParserRESTRICTIVE, DorisParserParserRESUME, DorisParserParserRETAIN, DorisParserParserRETENTION, DorisParserParserRETURNS, DorisParserParserREWRITTEN, DorisParserParserRLIKE, DorisParserParserROLLBACK, DorisParserParserROLLUP, DorisParserParserROUTINE, DorisParserParserS3, DorisParserParserSAMPLE, DorisParserParserSCHEDULE, DorisParserParserSCHEDULER, DorisParserParserSCHEMA, DorisParserParserSECOND, DorisParserParserSERIALIZABLE, DorisParserParserSESSION, DorisParserParserSESSION_USER, DorisParserParserSET_SESSION_VARIABLE, DorisParserParserSHAPE, DorisParserParserSKEW, DorisParserParserSNAPSHOT, DorisParserParserSNAPSHOTS, DorisParserParserSONAME, DorisParserParserSPLIT, DorisParserParserSQL, DorisParserParserSTAGE, DorisParserParserSTAGES, DorisParserParserSTART, DorisParserParserSTARTS, DorisParserParserSTATS, DorisParserParserSTATUS, DorisParserParserSTOP, DorisParserParserSTORAGE, DorisParserParserSTREAM, DorisParserParserSTREAMING, DorisParserParserSTRING, DorisParserParserSTRUCT, DorisParserParserSUM, DorisParserParserTABLES, DorisParserParserTAG, DorisParserParserTASK, DorisParserParserTASKS, DorisParserParserTEMPORARY, DorisParserParserTEXT, DorisParserParserTHAN, DorisParserParserTIME, DorisParserParserTIMESTAMP, DorisParserParserTRANSACTION, DorisParserParserTREE, DorisParserParserTRIGGERS, DorisParserParserTRUNCATE, DorisParserParserTYPE, DorisParserParserTYPES, DorisParserParserUNCOMMITTED, DorisParserParserUNLOCK, DorisParserParserUNSET, DorisParserParserUP, DorisParserParserUSER, DorisParserParserVALUE, DorisParserParserVARCHAR, DorisParserParserVARIABLE, DorisParserParserVARIABLES, DorisParserParserVARIANT, DorisParserParserVAULT, DorisParserParserVAULTS, DorisParserParserVERBOSE, DorisParserParserVERSION, DorisParserParserVIEW, DorisParserParserVIEWS, DorisParserParserWARM, DorisParserParserWARNINGS, DorisParserParserWEEK, DorisParserParserWORK, DorisParserParserYEAR, DorisParserParserHINT_START, DorisParserParserHINT_END, DorisParserParserCOMMENT_START:
		localctx = NewUnquotedIdentifierContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6300)
			p.NonReserved()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQuotedIdentifierContext is an interface to support dynamic dispatch.
type IQuotedIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BACKQUOTED_IDENTIFIER() antlr.TerminalNode

	// IsQuotedIdentifierContext differentiates from other interfaces.
	IsQuotedIdentifierContext()
}

type QuotedIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQuotedIdentifierContext() *QuotedIdentifierContext {
	var p = new(QuotedIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_quotedIdentifier
	return p
}

func InitEmptyQuotedIdentifierContext(p *QuotedIdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_quotedIdentifier
}

func (*QuotedIdentifierContext) IsQuotedIdentifierContext() {}

func NewQuotedIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QuotedIdentifierContext {
	var p = new(QuotedIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_quotedIdentifier

	return p
}

func (s *QuotedIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *QuotedIdentifierContext) BACKQUOTED_IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(DorisParserParserBACKQUOTED_IDENTIFIER, 0)
}

func (s *QuotedIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QuotedIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QuotedIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitQuotedIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) QuotedIdentifier() (localctx IQuotedIdentifierContext) {
	localctx = NewQuotedIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 448, DorisParserParserRULE_quotedIdentifier)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6303)
		p.Match(DorisParserParserBACKQUOTED_IDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INumberContext is an interface to support dynamic dispatch.
type INumberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsNumberContext differentiates from other interfaces.
	IsNumberContext()
}

type NumberContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNumberContext() *NumberContext {
	var p = new(NumberContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_number
	return p
}

func InitEmptyNumberContext(p *NumberContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_number
}

func (*NumberContext) IsNumberContext() {}

func NewNumberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NumberContext {
	var p = new(NumberContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_number

	return p
}

func (s *NumberContext) GetParser() antlr.Parser { return s.parser }

func (s *NumberContext) CopyAll(ctx *NumberContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *NumberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type DecimalLiteralContext struct {
	NumberContext
}

func NewDecimalLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DecimalLiteralContext {
	var p = new(DecimalLiteralContext)

	InitEmptyNumberContext(&p.NumberContext)
	p.parser = parser
	p.CopyAll(ctx.(*NumberContext))

	return p
}

func (s *DecimalLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DecimalLiteralContext) EXPONENT_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserEXPONENT_VALUE, 0)
}

func (s *DecimalLiteralContext) DECIMAL_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDECIMAL_VALUE, 0)
}

func (s *DecimalLiteralContext) SUBTRACT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSUBTRACT, 0)
}

func (s *DecimalLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitDecimalLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

type IntegerLiteralContext struct {
	NumberContext
}

func NewIntegerLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IntegerLiteralContext {
	var p = new(IntegerLiteralContext)

	InitEmptyNumberContext(&p.NumberContext)
	p.parser = parser
	p.CopyAll(ctx.(*NumberContext))

	return p
}

func (s *IntegerLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntegerLiteralContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserINTEGER_VALUE, 0)
}

func (s *IntegerLiteralContext) SUBTRACT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSUBTRACT, 0)
}

func (s *IntegerLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitIntegerLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) Number() (localctx INumberContext) {
	localctx = NewNumberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 450, DorisParserParserRULE_number)
	var _la int

	p.SetState(6313)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 897, p.GetParserRuleContext()) {
	case 1:
		localctx = NewIntegerLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		p.SetState(6306)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserSUBTRACT {
			{
				p.SetState(6305)
				p.Match(DorisParserParserSUBTRACT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(6308)
			p.Match(DorisParserParserINTEGER_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewDecimalLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		p.SetState(6310)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == DorisParserParserSUBTRACT {
			{
				p.SetState(6309)
				p.Match(DorisParserParserSUBTRACT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(6312)
			_la = p.GetTokenStream().LA(1)

			if !(_la == DorisParserParserEXPONENT_VALUE || _la == DorisParserParserDECIMAL_VALUE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INonReservedContext is an interface to support dynamic dispatch.
type INonReservedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ACTIONS() antlr.TerminalNode
	AFTER() antlr.TerminalNode
	AGG_STATE() antlr.TerminalNode
	AGGREGATE() antlr.TerminalNode
	ALIAS() antlr.TerminalNode
	ALWAYS() antlr.TerminalNode
	ANALYZED() antlr.TerminalNode
	ARRAY() antlr.TerminalNode
	AT() antlr.TerminalNode
	AUTHORS() antlr.TerminalNode
	AUTO_INCREMENT() antlr.TerminalNode
	BACKENDS() antlr.TerminalNode
	BACKUP() antlr.TerminalNode
	BEGIN() antlr.TerminalNode
	BELONG() antlr.TerminalNode
	BIN() antlr.TerminalNode
	BITAND() antlr.TerminalNode
	BITMAP() antlr.TerminalNode
	BITMAP_EMPTY() antlr.TerminalNode
	BITMAP_UNION() antlr.TerminalNode
	BITOR() antlr.TerminalNode
	BITXOR() antlr.TerminalNode
	BLOB() antlr.TerminalNode
	BOOLEAN() antlr.TerminalNode
	BRANCH() antlr.TerminalNode
	BRIEF() antlr.TerminalNode
	BROKER() antlr.TerminalNode
	BUCKETS() antlr.TerminalNode
	BUILD() antlr.TerminalNode
	BUILTIN() antlr.TerminalNode
	BULK() antlr.TerminalNode
	CACHE() antlr.TerminalNode
	CACHED() antlr.TerminalNode
	CALL() antlr.TerminalNode
	CATALOG() antlr.TerminalNode
	CATALOGS() antlr.TerminalNode
	CHAIN() antlr.TerminalNode
	CHAR() antlr.TerminalNode
	CHARSET() antlr.TerminalNode
	CHECK() antlr.TerminalNode
	CLUSTER() antlr.TerminalNode
	CLUSTERS() antlr.TerminalNode
	COLLATION() antlr.TerminalNode
	COLLECT() antlr.TerminalNode
	COLOCATE() antlr.TerminalNode
	COLUMNS() antlr.TerminalNode
	COMMENT() antlr.TerminalNode
	COMMENT_START() antlr.TerminalNode
	COMMIT() antlr.TerminalNode
	COMMITTED() antlr.TerminalNode
	COMPACT() antlr.TerminalNode
	COMPLETE() antlr.TerminalNode
	COMPRESS_TYPE() antlr.TerminalNode
	COMPUTE() antlr.TerminalNode
	CONDITIONS() antlr.TerminalNode
	CONFIG() antlr.TerminalNode
	CONNECTION() antlr.TerminalNode
	CONNECTION_ID() antlr.TerminalNode
	CONSISTENT() antlr.TerminalNode
	CONSTRAINTS() antlr.TerminalNode
	CONVERT() antlr.TerminalNode
	CONVERT_LSC() antlr.TerminalNode
	COPY() antlr.TerminalNode
	COUNT() antlr.TerminalNode
	CREATION() antlr.TerminalNode
	CRON() antlr.TerminalNode
	CURRENT_CATALOG() antlr.TerminalNode
	CURRENT_DATE() antlr.TerminalNode
	CURRENT_TIME() antlr.TerminalNode
	CURRENT_TIMESTAMP() antlr.TerminalNode
	CURRENT_USER() antlr.TerminalNode
	DATA() antlr.TerminalNode
	DATE() antlr.TerminalNode
	DATETIME() antlr.TerminalNode
	DATETIMEV1() antlr.TerminalNode
	DATETIMEV2() antlr.TerminalNode
	DATEV1() antlr.TerminalNode
	DATEV2() antlr.TerminalNode
	DAY() antlr.TerminalNode
	DAYS() antlr.TerminalNode
	DECIMAL() antlr.TerminalNode
	DECIMALV2() antlr.TerminalNode
	DECIMALV3() antlr.TerminalNode
	DEFERRED() antlr.TerminalNode
	DEMAND() antlr.TerminalNode
	DIAGNOSE() antlr.TerminalNode
	DIAGNOSIS() antlr.TerminalNode
	DICTIONARIES() antlr.TerminalNode
	DICTIONARY() antlr.TerminalNode
	DISTINCTPC() antlr.TerminalNode
	DISTINCTPCSA() antlr.TerminalNode
	DO() antlr.TerminalNode
	DORIS_INTERNAL_TABLE_ID() antlr.TerminalNode
	DUAL() antlr.TerminalNode
	DYNAMIC() antlr.TerminalNode
	E() antlr.TerminalNode
	ENABLE() antlr.TerminalNode
	ENCRYPTKEY() antlr.TerminalNode
	ENCRYPTKEYS() antlr.TerminalNode
	END() antlr.TerminalNode
	ENDS() antlr.TerminalNode
	ENGINE() antlr.TerminalNode
	ENGINES() antlr.TerminalNode
	ERRORS() antlr.TerminalNode
	ESCAPE() antlr.TerminalNode
	EVENTS() antlr.TerminalNode
	EVERY() antlr.TerminalNode
	EXCLUDE() antlr.TerminalNode
	EXPIRED() antlr.TerminalNode
	EXTERNAL() antlr.TerminalNode
	FAILED_LOGIN_ATTEMPTS() antlr.TerminalNode
	FAST() antlr.TerminalNode
	FEATURE() antlr.TerminalNode
	FIELDS() antlr.TerminalNode
	FILE() antlr.TerminalNode
	FILTER() antlr.TerminalNode
	FIRST() antlr.TerminalNode
	FORMAT() antlr.TerminalNode
	FREE() antlr.TerminalNode
	FRONTENDS() antlr.TerminalNode
	FUNCTION() antlr.TerminalNode
	GENERATED() antlr.TerminalNode
	GENERIC() antlr.TerminalNode
	GLOBAL() antlr.TerminalNode
	GRAPH() antlr.TerminalNode
	GROUPING() antlr.TerminalNode
	GROUPS() antlr.TerminalNode
	HASH() antlr.TerminalNode
	HASH_MAP() antlr.TerminalNode
	HDFS() antlr.TerminalNode
	HELP() antlr.TerminalNode
	HINT_END() antlr.TerminalNode
	HINT_START() antlr.TerminalNode
	HISTOGRAM() antlr.TerminalNode
	HLL_UNION() antlr.TerminalNode
	HOSTNAME() antlr.TerminalNode
	HOTSPOT() antlr.TerminalNode
	HOUR() antlr.TerminalNode
	HOURS() antlr.TerminalNode
	HUB() antlr.TerminalNode
	IDENTIFIED() antlr.TerminalNode
	IGNORE() antlr.TerminalNode
	IMMEDIATE() antlr.TerminalNode
	INCREMENTAL() antlr.TerminalNode
	INDEXES() antlr.TerminalNode
	INVERTED() antlr.TerminalNode
	IP_TRIE() antlr.TerminalNode
	IPV4() antlr.TerminalNode
	IPV6() antlr.TerminalNode
	IS_NOT_NULL_PRED() antlr.TerminalNode
	IS_NULL_PRED() antlr.TerminalNode
	ISNULL() antlr.TerminalNode
	ISOLATION() antlr.TerminalNode
	JOB() antlr.TerminalNode
	JOBS() antlr.TerminalNode
	JSON() antlr.TerminalNode
	JSONB() antlr.TerminalNode
	LABEL() antlr.TerminalNode
	LAST() antlr.TerminalNode
	LDAP() antlr.TerminalNode
	LDAP_ADMIN_PASSWORD() antlr.TerminalNode
	LEFT_BRACE() antlr.TerminalNode
	LESS() antlr.TerminalNode
	LEVEL() antlr.TerminalNode
	LINES() antlr.TerminalNode
	LINK() antlr.TerminalNode
	LOCAL() antlr.TerminalNode
	LOCALTIME() antlr.TerminalNode
	LOCALTIMESTAMP() antlr.TerminalNode
	LOCATION() antlr.TerminalNode
	LOCK() antlr.TerminalNode
	LOGICAL() antlr.TerminalNode
	MANUAL() antlr.TerminalNode
	MAP() antlr.TerminalNode
	MATCH_ALL() antlr.TerminalNode
	MATCH_ANY() antlr.TerminalNode
	MATCH_PHRASE() antlr.TerminalNode
	MATCH_PHRASE_EDGE() antlr.TerminalNode
	MATCH_PHRASE_PREFIX() antlr.TerminalNode
	MATCH_REGEXP() antlr.TerminalNode
	MATERIALIZED() antlr.TerminalNode
	MAX() antlr.TerminalNode
	MEMO() antlr.TerminalNode
	MERGE() antlr.TerminalNode
	MIGRATE() antlr.TerminalNode
	MIGRATIONS() antlr.TerminalNode
	MIN() antlr.TerminalNode
	MINUTE() antlr.TerminalNode
	MINUTES() antlr.TerminalNode
	MODIFY() antlr.TerminalNode
	MONTH() antlr.TerminalNode
	MTMV() antlr.TerminalNode
	NAME() antlr.TerminalNode
	NAMES() antlr.TerminalNode
	NEGATIVE() antlr.TerminalNode
	NEVER() antlr.TerminalNode
	NEXT() antlr.TerminalNode
	NGRAM_BF() antlr.TerminalNode
	NO() antlr.TerminalNode
	NON_NULLABLE() antlr.TerminalNode
	NULLS() antlr.TerminalNode
	OF() antlr.TerminalNode
	OFFSET() antlr.TerminalNode
	ONLY() antlr.TerminalNode
	OPEN() antlr.TerminalNode
	OPTIMIZED() antlr.TerminalNode
	PARAMETER() antlr.TerminalNode
	PARSED() antlr.TerminalNode
	PASSWORD() antlr.TerminalNode
	PASSWORD_EXPIRE() antlr.TerminalNode
	PASSWORD_HISTORY() antlr.TerminalNode
	PASSWORD_LOCK_TIME() antlr.TerminalNode
	PASSWORD_REUSE() antlr.TerminalNode
	PARTITIONS() antlr.TerminalNode
	PATH() antlr.TerminalNode
	PAUSE() antlr.TerminalNode
	PERCENT() antlr.TerminalNode
	PERIOD() antlr.TerminalNode
	PERMISSIVE() antlr.TerminalNode
	PHYSICAL() antlr.TerminalNode
	PI() antlr.TerminalNode
	PLAN() antlr.TerminalNode
	PLUGIN() antlr.TerminalNode
	PLUGINS() antlr.TerminalNode
	POLICY() antlr.TerminalNode
	PRIVILEGES() antlr.TerminalNode
	PROC() antlr.TerminalNode
	PROCESS() antlr.TerminalNode
	PROCESSLIST() antlr.TerminalNode
	PROFILE() antlr.TerminalNode
	PROPERTIES() antlr.TerminalNode
	PROPERTY() antlr.TerminalNode
	QUANTILE_STATE() antlr.TerminalNode
	QUANTILE_UNION() antlr.TerminalNode
	QUARTER() antlr.TerminalNode
	QUERY() antlr.TerminalNode
	QUOTA() antlr.TerminalNode
	QUALIFY() antlr.TerminalNode
	QUEUED() antlr.TerminalNode
	RANDOM() antlr.TerminalNode
	RECENT() antlr.TerminalNode
	RECOVER() antlr.TerminalNode
	RECYCLE() antlr.TerminalNode
	REFRESH() antlr.TerminalNode
	REPEATABLE() antlr.TerminalNode
	REPLACE() antlr.TerminalNode
	REPLACE_IF_NOT_NULL() antlr.TerminalNode
	REPLAYER() antlr.TerminalNode
	REPOSITORIES() antlr.TerminalNode
	REPOSITORY() antlr.TerminalNode
	RESOURCE() antlr.TerminalNode
	RESOURCES() antlr.TerminalNode
	RESTORE() antlr.TerminalNode
	RESTRICTIVE() antlr.TerminalNode
	RESUME() antlr.TerminalNode
	RETAIN() antlr.TerminalNode
	RETENTION() antlr.TerminalNode
	RETURNS() antlr.TerminalNode
	REWRITTEN() antlr.TerminalNode
	RIGHT_BRACE() antlr.TerminalNode
	RLIKE() antlr.TerminalNode
	ROLLBACK() antlr.TerminalNode
	ROLLUP() antlr.TerminalNode
	ROUTINE() antlr.TerminalNode
	S3() antlr.TerminalNode
	SAMPLE() antlr.TerminalNode
	SCHEDULE() antlr.TerminalNode
	SCHEDULER() antlr.TerminalNode
	SCHEMA() antlr.TerminalNode
	SECOND() antlr.TerminalNode
	SERIALIZABLE() antlr.TerminalNode
	SET_SESSION_VARIABLE() antlr.TerminalNode
	SESSION() antlr.TerminalNode
	SESSION_USER() antlr.TerminalNode
	SHAPE() antlr.TerminalNode
	SKEW() antlr.TerminalNode
	SNAPSHOT() antlr.TerminalNode
	SNAPSHOTS() antlr.TerminalNode
	SONAME() antlr.TerminalNode
	SPLIT() antlr.TerminalNode
	SQL() antlr.TerminalNode
	STAGE() antlr.TerminalNode
	STAGES() antlr.TerminalNode
	START() antlr.TerminalNode
	STARTS() antlr.TerminalNode
	STATS() antlr.TerminalNode
	STATUS() antlr.TerminalNode
	STOP() antlr.TerminalNode
	STORAGE() antlr.TerminalNode
	STREAM() antlr.TerminalNode
	STREAMING() antlr.TerminalNode
	STRING() antlr.TerminalNode
	STRUCT() antlr.TerminalNode
	SUM() antlr.TerminalNode
	TABLES() antlr.TerminalNode
	TAG() antlr.TerminalNode
	TASK() antlr.TerminalNode
	TASKS() antlr.TerminalNode
	TEMPORARY() antlr.TerminalNode
	TEXT() antlr.TerminalNode
	THAN() antlr.TerminalNode
	TIME() antlr.TerminalNode
	TIMESTAMP() antlr.TerminalNode
	TRANSACTION() antlr.TerminalNode
	TREE() antlr.TerminalNode
	TRIGGERS() antlr.TerminalNode
	TRUNCATE() antlr.TerminalNode
	TYPE() antlr.TerminalNode
	TYPES() antlr.TerminalNode
	UNCOMMITTED() antlr.TerminalNode
	UNLOCK() antlr.TerminalNode
	UNSET() antlr.TerminalNode
	UP() antlr.TerminalNode
	USER() antlr.TerminalNode
	VALUE() antlr.TerminalNode
	VARCHAR() antlr.TerminalNode
	VARIABLE() antlr.TerminalNode
	VARIABLES() antlr.TerminalNode
	VARIANT() antlr.TerminalNode
	VAULT() antlr.TerminalNode
	VAULTS() antlr.TerminalNode
	VERBOSE() antlr.TerminalNode
	VERSION() antlr.TerminalNode
	VIEW() antlr.TerminalNode
	VIEWS() antlr.TerminalNode
	WARM() antlr.TerminalNode
	WARNINGS() antlr.TerminalNode
	WEEK() antlr.TerminalNode
	WORK() antlr.TerminalNode
	YEAR() antlr.TerminalNode

	// IsNonReservedContext differentiates from other interfaces.
	IsNonReservedContext()
}

type NonReservedContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNonReservedContext() *NonReservedContext {
	var p = new(NonReservedContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_nonReserved
	return p
}

func InitEmptyNonReservedContext(p *NonReservedContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = DorisParserParserRULE_nonReserved
}

func (*NonReservedContext) IsNonReservedContext() {}

func NewNonReservedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NonReservedContext {
	var p = new(NonReservedContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = DorisParserParserRULE_nonReserved

	return p
}

func (s *NonReservedContext) GetParser() antlr.Parser { return s.parser }

func (s *NonReservedContext) ACTIONS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserACTIONS, 0)
}

func (s *NonReservedContext) AFTER() antlr.TerminalNode {
	return s.GetToken(DorisParserParserAFTER, 0)
}

func (s *NonReservedContext) AGG_STATE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserAGG_STATE, 0)
}

func (s *NonReservedContext) AGGREGATE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserAGGREGATE, 0)
}

func (s *NonReservedContext) ALIAS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserALIAS, 0)
}

func (s *NonReservedContext) ALWAYS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserALWAYS, 0)
}

func (s *NonReservedContext) ANALYZED() antlr.TerminalNode {
	return s.GetToken(DorisParserParserANALYZED, 0)
}

func (s *NonReservedContext) ARRAY() antlr.TerminalNode {
	return s.GetToken(DorisParserParserARRAY, 0)
}

func (s *NonReservedContext) AT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserAT, 0)
}

func (s *NonReservedContext) AUTHORS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserAUTHORS, 0)
}

func (s *NonReservedContext) AUTO_INCREMENT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserAUTO_INCREMENT, 0)
}

func (s *NonReservedContext) BACKENDS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserBACKENDS, 0)
}

func (s *NonReservedContext) BACKUP() antlr.TerminalNode {
	return s.GetToken(DorisParserParserBACKUP, 0)
}

func (s *NonReservedContext) BEGIN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserBEGIN, 0)
}

func (s *NonReservedContext) BELONG() antlr.TerminalNode {
	return s.GetToken(DorisParserParserBELONG, 0)
}

func (s *NonReservedContext) BIN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserBIN, 0)
}

func (s *NonReservedContext) BITAND() antlr.TerminalNode {
	return s.GetToken(DorisParserParserBITAND, 0)
}

func (s *NonReservedContext) BITMAP() antlr.TerminalNode {
	return s.GetToken(DorisParserParserBITMAP, 0)
}

func (s *NonReservedContext) BITMAP_EMPTY() antlr.TerminalNode {
	return s.GetToken(DorisParserParserBITMAP_EMPTY, 0)
}

func (s *NonReservedContext) BITMAP_UNION() antlr.TerminalNode {
	return s.GetToken(DorisParserParserBITMAP_UNION, 0)
}

func (s *NonReservedContext) BITOR() antlr.TerminalNode {
	return s.GetToken(DorisParserParserBITOR, 0)
}

func (s *NonReservedContext) BITXOR() antlr.TerminalNode {
	return s.GetToken(DorisParserParserBITXOR, 0)
}

func (s *NonReservedContext) BLOB() antlr.TerminalNode {
	return s.GetToken(DorisParserParserBLOB, 0)
}

func (s *NonReservedContext) BOOLEAN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserBOOLEAN, 0)
}

func (s *NonReservedContext) BRANCH() antlr.TerminalNode {
	return s.GetToken(DorisParserParserBRANCH, 0)
}

func (s *NonReservedContext) BRIEF() antlr.TerminalNode {
	return s.GetToken(DorisParserParserBRIEF, 0)
}

func (s *NonReservedContext) BROKER() antlr.TerminalNode {
	return s.GetToken(DorisParserParserBROKER, 0)
}

func (s *NonReservedContext) BUCKETS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserBUCKETS, 0)
}

func (s *NonReservedContext) BUILD() antlr.TerminalNode {
	return s.GetToken(DorisParserParserBUILD, 0)
}

func (s *NonReservedContext) BUILTIN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserBUILTIN, 0)
}

func (s *NonReservedContext) BULK() antlr.TerminalNode {
	return s.GetToken(DorisParserParserBULK, 0)
}

func (s *NonReservedContext) CACHE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCACHE, 0)
}

func (s *NonReservedContext) CACHED() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCACHED, 0)
}

func (s *NonReservedContext) CALL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCALL, 0)
}

func (s *NonReservedContext) CATALOG() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCATALOG, 0)
}

func (s *NonReservedContext) CATALOGS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCATALOGS, 0)
}

func (s *NonReservedContext) CHAIN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCHAIN, 0)
}

func (s *NonReservedContext) CHAR() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCHAR, 0)
}

func (s *NonReservedContext) CHARSET() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCHARSET, 0)
}

func (s *NonReservedContext) CHECK() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCHECK, 0)
}

func (s *NonReservedContext) CLUSTER() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCLUSTER, 0)
}

func (s *NonReservedContext) CLUSTERS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCLUSTERS, 0)
}

func (s *NonReservedContext) COLLATION() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOLLATION, 0)
}

func (s *NonReservedContext) COLLECT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOLLECT, 0)
}

func (s *NonReservedContext) COLOCATE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOLOCATE, 0)
}

func (s *NonReservedContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOLUMNS, 0)
}

func (s *NonReservedContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOMMENT, 0)
}

func (s *NonReservedContext) COMMENT_START() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOMMENT_START, 0)
}

func (s *NonReservedContext) COMMIT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOMMIT, 0)
}

func (s *NonReservedContext) COMMITTED() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOMMITTED, 0)
}

func (s *NonReservedContext) COMPACT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOMPACT, 0)
}

func (s *NonReservedContext) COMPLETE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOMPLETE, 0)
}

func (s *NonReservedContext) COMPRESS_TYPE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOMPRESS_TYPE, 0)
}

func (s *NonReservedContext) COMPUTE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOMPUTE, 0)
}

func (s *NonReservedContext) CONDITIONS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCONDITIONS, 0)
}

func (s *NonReservedContext) CONFIG() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCONFIG, 0)
}

func (s *NonReservedContext) CONNECTION() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCONNECTION, 0)
}

func (s *NonReservedContext) CONNECTION_ID() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCONNECTION_ID, 0)
}

func (s *NonReservedContext) CONSISTENT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCONSISTENT, 0)
}

func (s *NonReservedContext) CONSTRAINTS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCONSTRAINTS, 0)
}

func (s *NonReservedContext) CONVERT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCONVERT, 0)
}

func (s *NonReservedContext) CONVERT_LSC() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCONVERT_LSC, 0)
}

func (s *NonReservedContext) COPY() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOPY, 0)
}

func (s *NonReservedContext) COUNT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCOUNT, 0)
}

func (s *NonReservedContext) CREATION() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCREATION, 0)
}

func (s *NonReservedContext) CRON() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCRON, 0)
}

func (s *NonReservedContext) CURRENT_CATALOG() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCURRENT_CATALOG, 0)
}

func (s *NonReservedContext) CURRENT_DATE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCURRENT_DATE, 0)
}

func (s *NonReservedContext) CURRENT_TIME() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCURRENT_TIME, 0)
}

func (s *NonReservedContext) CURRENT_TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCURRENT_TIMESTAMP, 0)
}

func (s *NonReservedContext) CURRENT_USER() antlr.TerminalNode {
	return s.GetToken(DorisParserParserCURRENT_USER, 0)
}

func (s *NonReservedContext) DATA() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDATA, 0)
}

func (s *NonReservedContext) DATE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDATE, 0)
}

func (s *NonReservedContext) DATETIME() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDATETIME, 0)
}

func (s *NonReservedContext) DATETIMEV1() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDATETIMEV1, 0)
}

func (s *NonReservedContext) DATETIMEV2() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDATETIMEV2, 0)
}

func (s *NonReservedContext) DATEV1() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDATEV1, 0)
}

func (s *NonReservedContext) DATEV2() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDATEV2, 0)
}

func (s *NonReservedContext) DAY() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDAY, 0)
}

func (s *NonReservedContext) DAYS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDAYS, 0)
}

func (s *NonReservedContext) DECIMAL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDECIMAL, 0)
}

func (s *NonReservedContext) DECIMALV2() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDECIMALV2, 0)
}

func (s *NonReservedContext) DECIMALV3() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDECIMALV3, 0)
}

func (s *NonReservedContext) DEFERRED() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDEFERRED, 0)
}

func (s *NonReservedContext) DEMAND() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDEMAND, 0)
}

func (s *NonReservedContext) DIAGNOSE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDIAGNOSE, 0)
}

func (s *NonReservedContext) DIAGNOSIS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDIAGNOSIS, 0)
}

func (s *NonReservedContext) DICTIONARIES() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDICTIONARIES, 0)
}

func (s *NonReservedContext) DICTIONARY() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDICTIONARY, 0)
}

func (s *NonReservedContext) DISTINCTPC() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDISTINCTPC, 0)
}

func (s *NonReservedContext) DISTINCTPCSA() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDISTINCTPCSA, 0)
}

func (s *NonReservedContext) DO() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDO, 0)
}

func (s *NonReservedContext) DORIS_INTERNAL_TABLE_ID() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDORIS_INTERNAL_TABLE_ID, 0)
}

func (s *NonReservedContext) DUAL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDUAL, 0)
}

func (s *NonReservedContext) DYNAMIC() antlr.TerminalNode {
	return s.GetToken(DorisParserParserDYNAMIC, 0)
}

func (s *NonReservedContext) E() antlr.TerminalNode {
	return s.GetToken(DorisParserParserE, 0)
}

func (s *NonReservedContext) ENABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserENABLE, 0)
}

func (s *NonReservedContext) ENCRYPTKEY() antlr.TerminalNode {
	return s.GetToken(DorisParserParserENCRYPTKEY, 0)
}

func (s *NonReservedContext) ENCRYPTKEYS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserENCRYPTKEYS, 0)
}

func (s *NonReservedContext) END() antlr.TerminalNode {
	return s.GetToken(DorisParserParserEND, 0)
}

func (s *NonReservedContext) ENDS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserENDS, 0)
}

func (s *NonReservedContext) ENGINE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserENGINE, 0)
}

func (s *NonReservedContext) ENGINES() antlr.TerminalNode {
	return s.GetToken(DorisParserParserENGINES, 0)
}

func (s *NonReservedContext) ERRORS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserERRORS, 0)
}

func (s *NonReservedContext) ESCAPE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserESCAPE, 0)
}

func (s *NonReservedContext) EVENTS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserEVENTS, 0)
}

func (s *NonReservedContext) EVERY() antlr.TerminalNode {
	return s.GetToken(DorisParserParserEVERY, 0)
}

func (s *NonReservedContext) EXCLUDE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserEXCLUDE, 0)
}

func (s *NonReservedContext) EXPIRED() antlr.TerminalNode {
	return s.GetToken(DorisParserParserEXPIRED, 0)
}

func (s *NonReservedContext) EXTERNAL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserEXTERNAL, 0)
}

func (s *NonReservedContext) FAILED_LOGIN_ATTEMPTS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFAILED_LOGIN_ATTEMPTS, 0)
}

func (s *NonReservedContext) FAST() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFAST, 0)
}

func (s *NonReservedContext) FEATURE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFEATURE, 0)
}

func (s *NonReservedContext) FIELDS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFIELDS, 0)
}

func (s *NonReservedContext) FILE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFILE, 0)
}

func (s *NonReservedContext) FILTER() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFILTER, 0)
}

func (s *NonReservedContext) FIRST() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFIRST, 0)
}

func (s *NonReservedContext) FORMAT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFORMAT, 0)
}

func (s *NonReservedContext) FREE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFREE, 0)
}

func (s *NonReservedContext) FRONTENDS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFRONTENDS, 0)
}

func (s *NonReservedContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(DorisParserParserFUNCTION, 0)
}

func (s *NonReservedContext) GENERATED() antlr.TerminalNode {
	return s.GetToken(DorisParserParserGENERATED, 0)
}

func (s *NonReservedContext) GENERIC() antlr.TerminalNode {
	return s.GetToken(DorisParserParserGENERIC, 0)
}

func (s *NonReservedContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserGLOBAL, 0)
}

func (s *NonReservedContext) GRAPH() antlr.TerminalNode {
	return s.GetToken(DorisParserParserGRAPH, 0)
}

func (s *NonReservedContext) GROUPING() antlr.TerminalNode {
	return s.GetToken(DorisParserParserGROUPING, 0)
}

func (s *NonReservedContext) GROUPS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserGROUPS, 0)
}

func (s *NonReservedContext) HASH() antlr.TerminalNode {
	return s.GetToken(DorisParserParserHASH, 0)
}

func (s *NonReservedContext) HASH_MAP() antlr.TerminalNode {
	return s.GetToken(DorisParserParserHASH_MAP, 0)
}

func (s *NonReservedContext) HDFS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserHDFS, 0)
}

func (s *NonReservedContext) HELP() antlr.TerminalNode {
	return s.GetToken(DorisParserParserHELP, 0)
}

func (s *NonReservedContext) HINT_END() antlr.TerminalNode {
	return s.GetToken(DorisParserParserHINT_END, 0)
}

func (s *NonReservedContext) HINT_START() antlr.TerminalNode {
	return s.GetToken(DorisParserParserHINT_START, 0)
}

func (s *NonReservedContext) HISTOGRAM() antlr.TerminalNode {
	return s.GetToken(DorisParserParserHISTOGRAM, 0)
}

func (s *NonReservedContext) HLL_UNION() antlr.TerminalNode {
	return s.GetToken(DorisParserParserHLL_UNION, 0)
}

func (s *NonReservedContext) HOSTNAME() antlr.TerminalNode {
	return s.GetToken(DorisParserParserHOSTNAME, 0)
}

func (s *NonReservedContext) HOTSPOT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserHOTSPOT, 0)
}

func (s *NonReservedContext) HOUR() antlr.TerminalNode {
	return s.GetToken(DorisParserParserHOUR, 0)
}

func (s *NonReservedContext) HOURS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserHOURS, 0)
}

func (s *NonReservedContext) HUB() antlr.TerminalNode {
	return s.GetToken(DorisParserParserHUB, 0)
}

func (s *NonReservedContext) IDENTIFIED() antlr.TerminalNode {
	return s.GetToken(DorisParserParserIDENTIFIED, 0)
}

func (s *NonReservedContext) IGNORE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserIGNORE, 0)
}

func (s *NonReservedContext) IMMEDIATE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserIMMEDIATE, 0)
}

func (s *NonReservedContext) INCREMENTAL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserINCREMENTAL, 0)
}

func (s *NonReservedContext) INDEXES() antlr.TerminalNode {
	return s.GetToken(DorisParserParserINDEXES, 0)
}

func (s *NonReservedContext) INVERTED() antlr.TerminalNode {
	return s.GetToken(DorisParserParserINVERTED, 0)
}

func (s *NonReservedContext) IP_TRIE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserIP_TRIE, 0)
}

func (s *NonReservedContext) IPV4() antlr.TerminalNode {
	return s.GetToken(DorisParserParserIPV4, 0)
}

func (s *NonReservedContext) IPV6() antlr.TerminalNode {
	return s.GetToken(DorisParserParserIPV6, 0)
}

func (s *NonReservedContext) IS_NOT_NULL_PRED() antlr.TerminalNode {
	return s.GetToken(DorisParserParserIS_NOT_NULL_PRED, 0)
}

func (s *NonReservedContext) IS_NULL_PRED() antlr.TerminalNode {
	return s.GetToken(DorisParserParserIS_NULL_PRED, 0)
}

func (s *NonReservedContext) ISNULL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserISNULL, 0)
}

func (s *NonReservedContext) ISOLATION() antlr.TerminalNode {
	return s.GetToken(DorisParserParserISOLATION, 0)
}

func (s *NonReservedContext) JOB() antlr.TerminalNode {
	return s.GetToken(DorisParserParserJOB, 0)
}

func (s *NonReservedContext) JOBS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserJOBS, 0)
}

func (s *NonReservedContext) JSON() antlr.TerminalNode {
	return s.GetToken(DorisParserParserJSON, 0)
}

func (s *NonReservedContext) JSONB() antlr.TerminalNode {
	return s.GetToken(DorisParserParserJSONB, 0)
}

func (s *NonReservedContext) LABEL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLABEL, 0)
}

func (s *NonReservedContext) LAST() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLAST, 0)
}

func (s *NonReservedContext) LDAP() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLDAP, 0)
}

func (s *NonReservedContext) LDAP_ADMIN_PASSWORD() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLDAP_ADMIN_PASSWORD, 0)
}

func (s *NonReservedContext) LEFT_BRACE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLEFT_BRACE, 0)
}

func (s *NonReservedContext) LESS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLESS, 0)
}

func (s *NonReservedContext) LEVEL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLEVEL, 0)
}

func (s *NonReservedContext) LINES() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLINES, 0)
}

func (s *NonReservedContext) LINK() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLINK, 0)
}

func (s *NonReservedContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLOCAL, 0)
}

func (s *NonReservedContext) LOCALTIME() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLOCALTIME, 0)
}

func (s *NonReservedContext) LOCALTIMESTAMP() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLOCALTIMESTAMP, 0)
}

func (s *NonReservedContext) LOCATION() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLOCATION, 0)
}

func (s *NonReservedContext) LOCK() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLOCK, 0)
}

func (s *NonReservedContext) LOGICAL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserLOGICAL, 0)
}

func (s *NonReservedContext) MANUAL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserMANUAL, 0)
}

func (s *NonReservedContext) MAP() antlr.TerminalNode {
	return s.GetToken(DorisParserParserMAP, 0)
}

func (s *NonReservedContext) MATCH_ALL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserMATCH_ALL, 0)
}

func (s *NonReservedContext) MATCH_ANY() antlr.TerminalNode {
	return s.GetToken(DorisParserParserMATCH_ANY, 0)
}

func (s *NonReservedContext) MATCH_PHRASE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserMATCH_PHRASE, 0)
}

func (s *NonReservedContext) MATCH_PHRASE_EDGE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserMATCH_PHRASE_EDGE, 0)
}

func (s *NonReservedContext) MATCH_PHRASE_PREFIX() antlr.TerminalNode {
	return s.GetToken(DorisParserParserMATCH_PHRASE_PREFIX, 0)
}

func (s *NonReservedContext) MATCH_REGEXP() antlr.TerminalNode {
	return s.GetToken(DorisParserParserMATCH_REGEXP, 0)
}

func (s *NonReservedContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(DorisParserParserMATERIALIZED, 0)
}

func (s *NonReservedContext) MAX() antlr.TerminalNode {
	return s.GetToken(DorisParserParserMAX, 0)
}

func (s *NonReservedContext) MEMO() antlr.TerminalNode {
	return s.GetToken(DorisParserParserMEMO, 0)
}

func (s *NonReservedContext) MERGE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserMERGE, 0)
}

func (s *NonReservedContext) MIGRATE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserMIGRATE, 0)
}

func (s *NonReservedContext) MIGRATIONS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserMIGRATIONS, 0)
}

func (s *NonReservedContext) MIN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserMIN, 0)
}

func (s *NonReservedContext) MINUTE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserMINUTE, 0)
}

func (s *NonReservedContext) MINUTES() antlr.TerminalNode {
	return s.GetToken(DorisParserParserMINUTES, 0)
}

func (s *NonReservedContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(DorisParserParserMODIFY, 0)
}

func (s *NonReservedContext) MONTH() antlr.TerminalNode {
	return s.GetToken(DorisParserParserMONTH, 0)
}

func (s *NonReservedContext) MTMV() antlr.TerminalNode {
	return s.GetToken(DorisParserParserMTMV, 0)
}

func (s *NonReservedContext) NAME() antlr.TerminalNode {
	return s.GetToken(DorisParserParserNAME, 0)
}

func (s *NonReservedContext) NAMES() antlr.TerminalNode {
	return s.GetToken(DorisParserParserNAMES, 0)
}

func (s *NonReservedContext) NEGATIVE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserNEGATIVE, 0)
}

func (s *NonReservedContext) NEVER() antlr.TerminalNode {
	return s.GetToken(DorisParserParserNEVER, 0)
}

func (s *NonReservedContext) NEXT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserNEXT, 0)
}

func (s *NonReservedContext) NGRAM_BF() antlr.TerminalNode {
	return s.GetToken(DorisParserParserNGRAM_BF, 0)
}

func (s *NonReservedContext) NO() antlr.TerminalNode {
	return s.GetToken(DorisParserParserNO, 0)
}

func (s *NonReservedContext) NON_NULLABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserNON_NULLABLE, 0)
}

func (s *NonReservedContext) NULLS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserNULLS, 0)
}

func (s *NonReservedContext) OF() antlr.TerminalNode {
	return s.GetToken(DorisParserParserOF, 0)
}

func (s *NonReservedContext) OFFSET() antlr.TerminalNode {
	return s.GetToken(DorisParserParserOFFSET, 0)
}

func (s *NonReservedContext) ONLY() antlr.TerminalNode {
	return s.GetToken(DorisParserParserONLY, 0)
}

func (s *NonReservedContext) OPEN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserOPEN, 0)
}

func (s *NonReservedContext) OPTIMIZED() antlr.TerminalNode {
	return s.GetToken(DorisParserParserOPTIMIZED, 0)
}

func (s *NonReservedContext) PARAMETER() antlr.TerminalNode {
	return s.GetToken(DorisParserParserPARAMETER, 0)
}

func (s *NonReservedContext) PARSED() antlr.TerminalNode {
	return s.GetToken(DorisParserParserPARSED, 0)
}

func (s *NonReservedContext) PASSWORD() antlr.TerminalNode {
	return s.GetToken(DorisParserParserPASSWORD, 0)
}

func (s *NonReservedContext) PASSWORD_EXPIRE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserPASSWORD_EXPIRE, 0)
}

func (s *NonReservedContext) PASSWORD_HISTORY() antlr.TerminalNode {
	return s.GetToken(DorisParserParserPASSWORD_HISTORY, 0)
}

func (s *NonReservedContext) PASSWORD_LOCK_TIME() antlr.TerminalNode {
	return s.GetToken(DorisParserParserPASSWORD_LOCK_TIME, 0)
}

func (s *NonReservedContext) PASSWORD_REUSE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserPASSWORD_REUSE, 0)
}

func (s *NonReservedContext) PARTITIONS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserPARTITIONS, 0)
}

func (s *NonReservedContext) PATH() antlr.TerminalNode {
	return s.GetToken(DorisParserParserPATH, 0)
}

func (s *NonReservedContext) PAUSE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserPAUSE, 0)
}

func (s *NonReservedContext) PERCENT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserPERCENT, 0)
}

func (s *NonReservedContext) PERIOD() antlr.TerminalNode {
	return s.GetToken(DorisParserParserPERIOD, 0)
}

func (s *NonReservedContext) PERMISSIVE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserPERMISSIVE, 0)
}

func (s *NonReservedContext) PHYSICAL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserPHYSICAL, 0)
}

func (s *NonReservedContext) PI() antlr.TerminalNode {
	return s.GetToken(DorisParserParserPI, 0)
}

func (s *NonReservedContext) PLAN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserPLAN, 0)
}

func (s *NonReservedContext) PLUGIN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserPLUGIN, 0)
}

func (s *NonReservedContext) PLUGINS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserPLUGINS, 0)
}

func (s *NonReservedContext) POLICY() antlr.TerminalNode {
	return s.GetToken(DorisParserParserPOLICY, 0)
}

func (s *NonReservedContext) PRIVILEGES() antlr.TerminalNode {
	return s.GetToken(DorisParserParserPRIVILEGES, 0)
}

func (s *NonReservedContext) PROC() antlr.TerminalNode {
	return s.GetToken(DorisParserParserPROC, 0)
}

func (s *NonReservedContext) PROCESS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserPROCESS, 0)
}

func (s *NonReservedContext) PROCESSLIST() antlr.TerminalNode {
	return s.GetToken(DorisParserParserPROCESSLIST, 0)
}

func (s *NonReservedContext) PROFILE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserPROFILE, 0)
}

func (s *NonReservedContext) PROPERTIES() antlr.TerminalNode {
	return s.GetToken(DorisParserParserPROPERTIES, 0)
}

func (s *NonReservedContext) PROPERTY() antlr.TerminalNode {
	return s.GetToken(DorisParserParserPROPERTY, 0)
}

func (s *NonReservedContext) QUANTILE_STATE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserQUANTILE_STATE, 0)
}

func (s *NonReservedContext) QUANTILE_UNION() antlr.TerminalNode {
	return s.GetToken(DorisParserParserQUANTILE_UNION, 0)
}

func (s *NonReservedContext) QUARTER() antlr.TerminalNode {
	return s.GetToken(DorisParserParserQUARTER, 0)
}

func (s *NonReservedContext) QUERY() antlr.TerminalNode {
	return s.GetToken(DorisParserParserQUERY, 0)
}

func (s *NonReservedContext) QUOTA() antlr.TerminalNode {
	return s.GetToken(DorisParserParserQUOTA, 0)
}

func (s *NonReservedContext) QUALIFY() antlr.TerminalNode {
	return s.GetToken(DorisParserParserQUALIFY, 0)
}

func (s *NonReservedContext) QUEUED() antlr.TerminalNode {
	return s.GetToken(DorisParserParserQUEUED, 0)
}

func (s *NonReservedContext) RANDOM() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRANDOM, 0)
}

func (s *NonReservedContext) RECENT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRECENT, 0)
}

func (s *NonReservedContext) RECOVER() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRECOVER, 0)
}

func (s *NonReservedContext) RECYCLE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRECYCLE, 0)
}

func (s *NonReservedContext) REFRESH() antlr.TerminalNode {
	return s.GetToken(DorisParserParserREFRESH, 0)
}

func (s *NonReservedContext) REPEATABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserREPEATABLE, 0)
}

func (s *NonReservedContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserREPLACE, 0)
}

func (s *NonReservedContext) REPLACE_IF_NOT_NULL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserREPLACE_IF_NOT_NULL, 0)
}

func (s *NonReservedContext) REPLAYER() antlr.TerminalNode {
	return s.GetToken(DorisParserParserREPLAYER, 0)
}

func (s *NonReservedContext) REPOSITORIES() antlr.TerminalNode {
	return s.GetToken(DorisParserParserREPOSITORIES, 0)
}

func (s *NonReservedContext) REPOSITORY() antlr.TerminalNode {
	return s.GetToken(DorisParserParserREPOSITORY, 0)
}

func (s *NonReservedContext) RESOURCE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRESOURCE, 0)
}

func (s *NonReservedContext) RESOURCES() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRESOURCES, 0)
}

func (s *NonReservedContext) RESTORE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRESTORE, 0)
}

func (s *NonReservedContext) RESTRICTIVE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRESTRICTIVE, 0)
}

func (s *NonReservedContext) RESUME() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRESUME, 0)
}

func (s *NonReservedContext) RETAIN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRETAIN, 0)
}

func (s *NonReservedContext) RETENTION() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRETENTION, 0)
}

func (s *NonReservedContext) RETURNS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRETURNS, 0)
}

func (s *NonReservedContext) REWRITTEN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserREWRITTEN, 0)
}

func (s *NonReservedContext) RIGHT_BRACE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRIGHT_BRACE, 0)
}

func (s *NonReservedContext) RLIKE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserRLIKE, 0)
}

func (s *NonReservedContext) ROLLBACK() antlr.TerminalNode {
	return s.GetToken(DorisParserParserROLLBACK, 0)
}

func (s *NonReservedContext) ROLLUP() antlr.TerminalNode {
	return s.GetToken(DorisParserParserROLLUP, 0)
}

func (s *NonReservedContext) ROUTINE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserROUTINE, 0)
}

func (s *NonReservedContext) S3() antlr.TerminalNode {
	return s.GetToken(DorisParserParserS3, 0)
}

func (s *NonReservedContext) SAMPLE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSAMPLE, 0)
}

func (s *NonReservedContext) SCHEDULE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSCHEDULE, 0)
}

func (s *NonReservedContext) SCHEDULER() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSCHEDULER, 0)
}

func (s *NonReservedContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSCHEMA, 0)
}

func (s *NonReservedContext) SECOND() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSECOND, 0)
}

func (s *NonReservedContext) SERIALIZABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSERIALIZABLE, 0)
}

func (s *NonReservedContext) SET_SESSION_VARIABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSET_SESSION_VARIABLE, 0)
}

func (s *NonReservedContext) SESSION() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSESSION, 0)
}

func (s *NonReservedContext) SESSION_USER() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSESSION_USER, 0)
}

func (s *NonReservedContext) SHAPE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSHAPE, 0)
}

func (s *NonReservedContext) SKEW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSKEW, 0)
}

func (s *NonReservedContext) SNAPSHOT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSNAPSHOT, 0)
}

func (s *NonReservedContext) SNAPSHOTS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSNAPSHOTS, 0)
}

func (s *NonReservedContext) SONAME() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSONAME, 0)
}

func (s *NonReservedContext) SPLIT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSPLIT, 0)
}

func (s *NonReservedContext) SQL() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSQL, 0)
}

func (s *NonReservedContext) STAGE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTAGE, 0)
}

func (s *NonReservedContext) STAGES() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTAGES, 0)
}

func (s *NonReservedContext) START() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTART, 0)
}

func (s *NonReservedContext) STARTS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTARTS, 0)
}

func (s *NonReservedContext) STATS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTATS, 0)
}

func (s *NonReservedContext) STATUS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTATUS, 0)
}

func (s *NonReservedContext) STOP() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTOP, 0)
}

func (s *NonReservedContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTORAGE, 0)
}

func (s *NonReservedContext) STREAM() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTREAM, 0)
}

func (s *NonReservedContext) STREAMING() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTREAMING, 0)
}

func (s *NonReservedContext) STRING() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTRING, 0)
}

func (s *NonReservedContext) STRUCT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSTRUCT, 0)
}

func (s *NonReservedContext) SUM() antlr.TerminalNode {
	return s.GetToken(DorisParserParserSUM, 0)
}

func (s *NonReservedContext) TABLES() antlr.TerminalNode {
	return s.GetToken(DorisParserParserTABLES, 0)
}

func (s *NonReservedContext) TAG() antlr.TerminalNode {
	return s.GetToken(DorisParserParserTAG, 0)
}

func (s *NonReservedContext) TASK() antlr.TerminalNode {
	return s.GetToken(DorisParserParserTASK, 0)
}

func (s *NonReservedContext) TASKS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserTASKS, 0)
}

func (s *NonReservedContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(DorisParserParserTEMPORARY, 0)
}

func (s *NonReservedContext) TEXT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserTEXT, 0)
}

func (s *NonReservedContext) THAN() antlr.TerminalNode {
	return s.GetToken(DorisParserParserTHAN, 0)
}

func (s *NonReservedContext) TIME() antlr.TerminalNode {
	return s.GetToken(DorisParserParserTIME, 0)
}

func (s *NonReservedContext) TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(DorisParserParserTIMESTAMP, 0)
}

func (s *NonReservedContext) TRANSACTION() antlr.TerminalNode {
	return s.GetToken(DorisParserParserTRANSACTION, 0)
}

func (s *NonReservedContext) TREE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserTREE, 0)
}

func (s *NonReservedContext) TRIGGERS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserTRIGGERS, 0)
}

func (s *NonReservedContext) TRUNCATE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserTRUNCATE, 0)
}

func (s *NonReservedContext) TYPE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserTYPE, 0)
}

func (s *NonReservedContext) TYPES() antlr.TerminalNode {
	return s.GetToken(DorisParserParserTYPES, 0)
}

func (s *NonReservedContext) UNCOMMITTED() antlr.TerminalNode {
	return s.GetToken(DorisParserParserUNCOMMITTED, 0)
}

func (s *NonReservedContext) UNLOCK() antlr.TerminalNode {
	return s.GetToken(DorisParserParserUNLOCK, 0)
}

func (s *NonReservedContext) UNSET() antlr.TerminalNode {
	return s.GetToken(DorisParserParserUNSET, 0)
}

func (s *NonReservedContext) UP() antlr.TerminalNode {
	return s.GetToken(DorisParserParserUP, 0)
}

func (s *NonReservedContext) USER() antlr.TerminalNode {
	return s.GetToken(DorisParserParserUSER, 0)
}

func (s *NonReservedContext) VALUE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserVALUE, 0)
}

func (s *NonReservedContext) VARCHAR() antlr.TerminalNode {
	return s.GetToken(DorisParserParserVARCHAR, 0)
}

func (s *NonReservedContext) VARIABLE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserVARIABLE, 0)
}

func (s *NonReservedContext) VARIABLES() antlr.TerminalNode {
	return s.GetToken(DorisParserParserVARIABLES, 0)
}

func (s *NonReservedContext) VARIANT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserVARIANT, 0)
}

func (s *NonReservedContext) VAULT() antlr.TerminalNode {
	return s.GetToken(DorisParserParserVAULT, 0)
}

func (s *NonReservedContext) VAULTS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserVAULTS, 0)
}

func (s *NonReservedContext) VERBOSE() antlr.TerminalNode {
	return s.GetToken(DorisParserParserVERBOSE, 0)
}

func (s *NonReservedContext) VERSION() antlr.TerminalNode {
	return s.GetToken(DorisParserParserVERSION, 0)
}

func (s *NonReservedContext) VIEW() antlr.TerminalNode {
	return s.GetToken(DorisParserParserVIEW, 0)
}

func (s *NonReservedContext) VIEWS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserVIEWS, 0)
}

func (s *NonReservedContext) WARM() antlr.TerminalNode {
	return s.GetToken(DorisParserParserWARM, 0)
}

func (s *NonReservedContext) WARNINGS() antlr.TerminalNode {
	return s.GetToken(DorisParserParserWARNINGS, 0)
}

func (s *NonReservedContext) WEEK() antlr.TerminalNode {
	return s.GetToken(DorisParserParserWEEK, 0)
}

func (s *NonReservedContext) WORK() antlr.TerminalNode {
	return s.GetToken(DorisParserParserWORK, 0)
}

func (s *NonReservedContext) YEAR() antlr.TerminalNode {
	return s.GetToken(DorisParserParserYEAR, 0)
}

func (s *NonReservedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NonReservedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NonReservedContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case DorisParserVisitor:
		return t.VisitNonReserved(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *DorisParserParser) NonReserved() (localctx INonReservedContext) {
	localctx = NewNonReservedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 452, DorisParserParserRULE_nonReserved)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6315)
		_la = p.GetTokenStream().LA(1)

		if !(((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-2305902462020672000) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&4609989332399152113) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-9080794533051819547) != 0) || ((int64((_la-192)) & ^0x3f) == 0 && ((int64(1)<<(_la-192))&2015220189171012521) != 0) || ((int64((_la-256)) & ^0x3f) == 0 && ((int64(1)<<(_la-256))&-5422616543060085911) != 0) || ((int64((_la-320)) & ^0x3f) == 0 && ((int64(1)<<(_la-320))&-4476015178520986877) != 0) || ((int64((_la-384)) & ^0x3f) == 0 && ((int64(1)<<(_la-384))&9222796779122679803) != 0) || ((int64((_la-452)) & ^0x3f) == 0 && ((int64(1)<<(_la-452))&2449945648119953137) != 0) || ((int64((_la-517)) & ^0x3f) == 0 && ((int64(1)<<(_la-517))&29360129) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

func (p *DorisParserParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 116:
		var t *QueryTermContext = nil
		if localctx != nil {
			t = localctx.(*QueryTermContext)
		}
		return p.QueryTerm_Sempred(t, predIndex)

	case 119:
		var t *QuerySpecificationContext = nil
		if localctx != nil {
			t = localctx.(*QuerySpecificationContext)
		}
		return p.QuerySpecification_Sempred(t, predIndex)

	case 188:
		var t *BooleanExpressionContext = nil
		if localctx != nil {
			t = localctx.(*BooleanExpressionContext)
		}
		return p.BooleanExpression_Sempred(t, predIndex)

	case 192:
		var t *ValueExpressionContext = nil
		if localctx != nil {
			t = localctx.(*ValueExpressionContext)
		}
		return p.ValueExpression_Sempred(t, predIndex)

	case 193:
		var t *PrimaryExpressionContext = nil
		if localctx != nil {
			t = localctx.(*PrimaryExpressionContext)
		}
		return p.PrimaryExpression_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *DorisParserParser) QueryTerm_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 0:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 1:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *DorisParserParser) QuerySpecification_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 2:
		return !ansiSQLSyntax

	case 3:
		return ansiSQLSyntax

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *DorisParserParser) BooleanExpression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 4:
		return p.Precpred(p.GetParserRuleContext(), 4)

	case 5:
		return p.Precpred(p.GetParserRuleContext(), 3)

	case 6:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 7:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *DorisParserParser) ValueExpression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 8:
		return p.Precpred(p.GetParserRuleContext(), 6)

	case 9:
		return p.Precpred(p.GetParserRuleContext(), 5)

	case 10:
		return p.Precpred(p.GetParserRuleContext(), 4)

	case 11:
		return p.Precpred(p.GetParserRuleContext(), 3)

	case 12:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 13:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *DorisParserParser) PrimaryExpression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 14:
		return p.Precpred(p.GetParserRuleContext(), 11)

	case 15:
		return p.Precpred(p.GetParserRuleContext(), 10)

	case 16:
		return p.Precpred(p.GetParserRuleContext(), 5)

	case 17:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
